/-
Copyright (c) 2019 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen

! This file was ported from Lean 3 source module linear_algebra.matrix.adjugate
! leanprover-community/mathlib commit 4f81bc21e32048db7344b7867946e992cf5f68cc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Regular.Basic
import Mathbin.LinearAlgebra.Matrix.MvPolynomial
import Mathbin.LinearAlgebra.Matrix.Polynomial
import Mathbin.RingTheory.Polynomial.Basic

/-!
# Cramer's rule and adjugate matrices

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The adjugate matrix is the transpose of the cofactor matrix.
It is calculated with Cramer's rule, which we introduce first.
The vectors returned by Cramer's rule are given by the linear map `cramer`,
which sends a matrix `A` and vector `b` to the vector consisting of the
determinant of replacing the `i`th column of `A` with `b` at index `i`
(written as `(A.update_column i b).det`).
Using Cramer's rule, we can compute for each matrix `A` the matrix `adjugate A`.
The entries of the adjugate are the minors of `A`.
Instead of defining a minor by deleting row `i` and column `j` of `A`, we
replace the `i`th row of `A` with the `j`th basis vector; the resulting matrix
has the same determinant but more importantly equals Cramer's rule applied
to `A` and the `j`th basis vector, simplifying the subsequent proofs.
We prove the adjugate behaves like `det A • A⁻¹`.

## Main definitions

 * `matrix.cramer A b`: the vector output by Cramer's rule on `A` and `b`.
 * `matrix.adjugate A`: the adjugate (or classical adjoint) of the matrix `A`.

## References

  * https://en.wikipedia.org/wiki/Cramer's_rule#Finding_inverse_matrix

## Tags

cramer, cramer's rule, adjugate
-/


namespace Matrix

universe u v w

variable {m : Type u} {n : Type v} {α : Type w}

variable [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] [CommRing α]

open Matrix BigOperators Polynomial

open Equiv Equiv.Perm Finset

section Cramer

/-!
  ### `cramer` section

  Introduce the linear map `cramer` with values defined by `cramer_map`.
  After defining `cramer_map` and showing it is linear,
  we will restrict our proofs to using `cramer`.
-/


variable (A : Matrix n n α) (b : n → α)

#print Matrix.cramerMap /-
/-- `cramer_map A b i` is the determinant of the matrix `A` with column `i` replaced with `b`,
  and thus `cramer_map A b` is the vector output by Cramer's rule on `A` and `b`.

  If `A ⬝ x = b` has a unique solution in `x`, `cramer_map A` sends the vector `b` to `A.det • x`.
  Otherwise, the outcome of `cramer_map` is well-defined but not necessarily useful.
-/
def cramerMap (i : n) : α :=
  (A.updateColumn i b).det
#align matrix.cramer_map Matrix.cramerMap
-/

#print Matrix.cramerMap_is_linear /-
theorem cramerMap_is_linear (i : n) : IsLinearMap α fun b => cramerMap A b i :=
  { map_add := det_updateColumn_add _ _
    map_smul := det_updateColumn_smul _ _ }
#align matrix.cramer_map_is_linear Matrix.cramerMap_is_linear
-/

#print Matrix.cramer_is_linear /-
theorem cramer_is_linear : IsLinearMap α (cramerMap A) :=
  by
  constructor <;> intros <;> ext i
  · apply (cramer_map_is_linear A i).1
  · apply (cramer_map_is_linear A i).2
#align matrix.cramer_is_linear Matrix.cramer_is_linear
-/

#print Matrix.cramer /-
/-- `cramer A b i` is the determinant of the matrix `A` with column `i` replaced with `b`,
  and thus `cramer A b` is the vector output by Cramer's rule on `A` and `b`.

  If `A ⬝ x = b` has a unique solution in `x`, `cramer A` sends the vector `b` to `A.det • x`.
  Otherwise, the outcome of `cramer` is well-defined but not necessarily useful.
 -/
def cramer (A : Matrix n n α) : (n → α) →ₗ[α] n → α :=
  IsLinearMap.mk' (cramerMap A) (cramer_is_linear A)
#align matrix.cramer Matrix.cramer
-/

/- warning: matrix.cramer_apply -> Matrix.cramer_apply is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α) (i : n), Eq.{succ u2} α (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b i) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n α (fun (a : n) (b : n) => _inst_1 a b) A i b))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α) (i : n), Eq.{succ u2} α (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b i) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n α (fun (a : n) (b : n) => _inst_1 a b) A i b))
Case conversion may be inaccurate. Consider using '#align matrix.cramer_apply Matrix.cramer_applyₓ'. -/
theorem cramer_apply (i : n) : cramer A b i = (A.updateColumn i b).det :=
  rfl
#align matrix.cramer_apply Matrix.cramer_apply

/- warning: matrix.cramer_transpose_apply -> Matrix.cramer_transpose_apply is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α) (i : n), Eq.{succ u2} α (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.transpose.{u2, u1, u1} n n α A)) b i) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 (Matrix.updateRow.{u2, u1, u1} n n α (fun (a : n) (b : n) => _inst_1 a b) A i b))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α) (i : n), Eq.{succ u2} α (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.transpose.{u2, u1, u1} n n α A)) b i) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 (Matrix.updateRow.{u2, u1, u1} n n α (fun (a : n) (b : n) => _inst_1 a b) A i b))
Case conversion may be inaccurate. Consider using '#align matrix.cramer_transpose_apply Matrix.cramer_transpose_applyₓ'. -/
theorem cramer_transpose_apply (i : n) : cramer Aᵀ b i = (A.updateRow i b).det := by
  rw [cramer_apply, update_column_transpose, det_transpose]
#align matrix.cramer_transpose_apply Matrix.cramer_transpose_apply

/- warning: matrix.cramer_transpose_row_self -> Matrix.cramer_transpose_row_self is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (i : n), Eq.{max (succ u1) (succ u2)} (n -> α) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.transpose.{u2, u1, u1} n n α A)) (A i)) (Pi.single.{u1, u2} n (fun (ᾰ : n) => α) (fun (a : n) (b : n) => _inst_1 a b) (fun (i : n) => MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) i (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (i : n), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) (A i)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.transpose.{u2, u1, u1} n n α A)) (A i)) (Pi.single.{u1, u2} n (fun (ᾰ : n) => α) (fun (a : n) (b : n) => _inst_1 a b) (fun (i : n) => CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) i (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.cramer_transpose_row_self Matrix.cramer_transpose_row_selfₓ'. -/
theorem cramer_transpose_row_self (i : n) : Aᵀ.cramer (A i) = Pi.single i A.det :=
  by
  ext j
  rw [cramer_apply, Pi.single_apply]
  split_ifs with h
  · -- i = j: this entry should be `A.det`
    subst h
    simp only [update_column_transpose, det_transpose, update_row_eq_self]
  · -- i ≠ j: this entry should be 0
    rw [update_column_transpose, det_transpose]
    apply det_zero_of_row_eq h
    rw [update_row_self, update_row_ne (Ne.symm h)]
#align matrix.cramer_transpose_row_self Matrix.cramer_transpose_row_self

/- warning: matrix.cramer_row_self -> Matrix.cramer_row_self is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α) (i : n), (forall (j : n), Eq.{succ u2} α (b j) (A j i)) -> (Eq.{max (succ u1) (succ u2)} (n -> α) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b) (Pi.single.{u1, u2} n (fun (ᾰ : n) => α) (fun (a : n) (b : n) => _inst_1 a b) (fun (i : n) => MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) i (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A)))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α) (i : n), (forall (j : n), Eq.{succ u2} α (b j) (A j i)) -> (Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) b) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b) (Pi.single.{u1, u2} n (fun (ᾰ : n) => α) (fun (a : n) (b : n) => _inst_1 a b) (fun (i : n) => CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) i (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A)))
Case conversion may be inaccurate. Consider using '#align matrix.cramer_row_self Matrix.cramer_row_selfₓ'. -/
theorem cramer_row_self (i : n) (h : ∀ j, b j = A j i) : A.cramer b = Pi.single i A.det :=
  by
  rw [← transpose_transpose A, det_transpose]
  convert cramer_transpose_row_self Aᵀ i
  exact funext h
#align matrix.cramer_row_self Matrix.cramer_row_self

/- warning: matrix.cramer_one -> Matrix.cramer_one is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α], Eq.{succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_5)))))))))) (OfNat.ofNat.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) 1 (OfNat.mk.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) 1 (One.one.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (LinearMap.module.End.hasOne.{u2, max u1 u2} α (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α], Eq.{max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))))) (OfNat.ofNat.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) 1 (One.toOfNat1.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (LinearMap.instOneEnd.{u2, max u1 u2} α (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align matrix.cramer_one Matrix.cramer_oneₓ'. -/
@[simp]
theorem cramer_one : cramer (1 : Matrix n n α) = 1 :=
  by
  ext (i j)
  convert congr_fun (cramer_row_self (1 : Matrix n n α) (Pi.single i 1) i _) j
  · simp
  · intro j
    rw [Matrix.one_eq_pi_single, Pi.single_comm]
#align matrix.cramer_one Matrix.cramer_one

/- warning: matrix.cramer_smul -> Matrix.cramer_smul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (r : α) (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) r A)) (SMul.smul.{u2, max u1 u2} α (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (LinearMap.hasSmul.{u2, u2, u2, max u1 u2, max u1 u2} α α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Module.toDistribMulAction.{u2, max u1 u2} α (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Function.smulCommClass.{u1, u2, u2, u2} n α α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (smulCommClass_self.{u2, u2} α α (CommRing.toCommMonoid.{u2} α _inst_5) (Monoid.toMulAction.{u2} α (CommMonoid.toMonoid.{u2} α (CommRing.toCommMonoid.{u2} α _inst_5)))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_5)))) r (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (r : α) (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) r A)) (HSMul.hSMul.{u2, max u2 u1, max u1 u2} α (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (instHSMul.{u2, max u1 u2} α (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (ᾰ : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (LinearMap.instSMulLinearMap.{u2, u2, u2, max u1 u2, max u1 u2} α α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.distribMulAction.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.278 : n) => α) α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (fun (i : n) => (fun (i : n) => AddCommMonoid.toAddMonoid.{u2} ((fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) i) ((fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) i)) i) (fun (i : n) => Module.toDistribMulAction.{u2, u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Pi.smulCommClass.{u1, u2, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.278 : n) => α) α α (fun (i : n) => Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (fun (i : n) => Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (fun (i : n) => smulCommClass_self.{u2, u2} α α (CommRing.toCommMonoid.{u2} α _inst_5) (MulActionWithZero.toMulAction.{u2, u2} α α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (MonoidWithZero.toMulActionWithZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))) r (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.cramer_smul Matrix.cramer_smulₓ'. -/
theorem cramer_smul (r : α) (A : Matrix n n α) :
    cramer (r • A) = r ^ (Fintype.card n - 1) • cramer A :=
  LinearMap.ext fun b => funext fun _ => det_updateColumn_smul' _ _ _ _
#align matrix.cramer_smul Matrix.cramer_smul

/- warning: matrix.cramer_subsingleton_apply -> Matrix.cramer_subsingleton_apply is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] [_inst_6 : Subsingleton.{succ u1} n] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α) (i : n), Eq.{succ u2} α (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b i) (b i)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] [_inst_6 : Subsingleton.{succ u1} n] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α) (i : n), Eq.{succ u2} α (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b i) (b i)
Case conversion may be inaccurate. Consider using '#align matrix.cramer_subsingleton_apply Matrix.cramer_subsingleton_applyₓ'. -/
@[simp]
theorem cramer_subsingleton_apply [Subsingleton n] (A : Matrix n n α) (b : n → α) (i : n) :
    cramer A b i = b i := by rw [cramer_apply, det_eq_elem_of_subsingleton _ i, update_column_self]
#align matrix.cramer_subsingleton_apply Matrix.cramer_subsingleton_apply

/- warning: matrix.cramer_zero -> Matrix.cramer_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] [_inst_6 : Nontrivial.{u1} n], Eq.{succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.zero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasZero.{u2, u1, u1} n n α (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))))))))) (OfNat.ofNat.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) 0 (OfNat.mk.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) 0 (Zero.zero.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (LinearMap.hasZero.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] [_inst_6 : Nontrivial.{u1} n], Eq.{max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.toOfNat0.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.zero.{u2, u1, u1} n n α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))))) (OfNat.ofNat.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) 0 (Zero.toOfNat0.{max u1 u2} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (LinearMap.instZeroLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align matrix.cramer_zero Matrix.cramer_zeroₓ'. -/
theorem cramer_zero [Nontrivial n] : cramer (0 : Matrix n n α) = 0 :=
  by
  ext (i j)
  obtain ⟨j', hj'⟩ : ∃ j', j' ≠ j := exists_ne j
  apply det_eq_zero_of_column_eq_zero j'
  intro j''
  simp [update_column_ne hj']
#align matrix.cramer_zero Matrix.cramer_zero

/- warning: matrix.sum_cramer -> Matrix.sum_cramer is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) {β : Type.{u3}} (s : Finset.{u3} β) (f : β -> n -> α), Eq.{succ (max u1 u2)} (n -> α) (Finset.sum.{max u1 u2, u3} (n -> α) β (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) s (fun (x : β) => coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (f x))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (Finset.sum.{max u1 u2, u3} (n -> α) β (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) s (fun (x : β) => f x)))
but is expected to have type
  forall {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] [_inst_5 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) {β : Type.{u1}} (s : Finset.{u1} β) (f : β -> n -> α), Eq.{max (succ u2) (succ u3)} (n -> α) (Finset.sum.{max u2 u3, u1} (n -> α) β (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) s (fun (x : β) => FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, max u2 u3} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (Matrix.cramer.{u2, u3} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (f x))) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, max u2 u3} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (Matrix.cramer.{u2, u3} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (Finset.sum.{max u2 u3, u1} (n -> α) β (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) s (fun (x : β) => f x)))
Case conversion may be inaccurate. Consider using '#align matrix.sum_cramer Matrix.sum_cramerₓ'. -/
/-- Use linearity of `cramer` to take it out of a summation. -/
theorem sum_cramer {β} (s : Finset β) (f : β → n → α) :
    (∑ x in s, cramer A (f x)) = cramer A (∑ x in s, f x) :=
  (LinearMap.map_sum (cramer A)).symm
#align matrix.sum_cramer Matrix.sum_cramer

/- warning: matrix.sum_cramer_apply -> Matrix.sum_cramer_apply is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) {β : Type.{u3}} (s : Finset.{u3} β) (f : n -> β -> α) (i : n), Eq.{succ u2} α (Finset.sum.{u2, u3} α β (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) s (fun (x : β) => coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (fun (j : n) => f j x) i)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (fun (j : n) => Finset.sum.{u2, u3} α β (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) s (fun (x : β) => f j x)) i)
but is expected to have type
  forall {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] [_inst_5 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) {β : Type.{u1}} (s : Finset.{u1} β) (f : n -> β -> α) (i : n), Eq.{succ u3} α (Finset.sum.{u3, u1} α β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) s (fun (x : β) => FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, max u2 u3} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (Matrix.cramer.{u2, u3} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (fun (j : n) => f j x) i)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, max u2 u3} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (Matrix.cramer.{u2, u3} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (fun (j : n) => Finset.sum.{u3, u1} α β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) s (fun (x : β) => f j x)) i)
Case conversion may be inaccurate. Consider using '#align matrix.sum_cramer_apply Matrix.sum_cramer_applyₓ'. -/
/-- Use linearity of `cramer` and vector evaluation to take `cramer A _ i` out of a summation. -/
theorem sum_cramer_apply {β} (s : Finset β) (f : n → β → α) (i : n) :
    (∑ x in s, cramer A (fun j => f j x) i) = cramer A (fun j : n => ∑ x in s, f j x) i :=
  calc
    (∑ x in s, cramer A (fun j => f j x) i) = (∑ x in s, cramer A fun j => f j x) i :=
      (Finset.sum_apply i s _).symm
    _ = cramer A (fun j : n => ∑ x in s, f j x) i :=
      by
      rw [sum_cramer, cramer_apply]
      congr with j
      apply Finset.sum_apply
    
#align matrix.sum_cramer_apply Matrix.sum_cramer_apply

/- warning: matrix.cramer_submatrix_equiv -> Matrix.cramer_submatrix_equiv is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] [_inst_5 : CommRing.{u3} α] (A : Matrix.{u1, u1, u3} m m α) (e : Equiv.{succ u2, succ u1} n m) (b : n -> α), Eq.{max (succ u2) (succ u3)} (n -> α) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (_x : LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u3, u3, max u2 u3, max u2 u3} α α (n -> α) (n -> α) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Matrix.cramer.{u2, u3} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e))) b) (Function.comp.{succ u2, succ u1, succ u3} n m α (coeFn.{succ (max u1 u3), succ (max u1 u3)} (LinearMap.{u3, u3, max u1 u3, max u1 u3} α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (m -> α) (m -> α) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (_x : LinearMap.{u3, u3, max u1 u3, max u1 u3} α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (m -> α) (m -> α) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) => (m -> α) -> m -> α) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, max u1 u3} α α (m -> α) (m -> α) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Matrix.cramer.{u1, u3} m α (fun (a : m) (b : m) => _inst_3 a b) _inst_4 _inst_5 A) (Function.comp.{succ u1, succ u2, succ u3} m n α b (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} m n) (fun (_x : Equiv.{succ u1, succ u2} m n) => m -> n) (Equiv.hasCoeToFun.{succ u1, succ u2} m n) (Equiv.symm.{succ u2, succ u1} n m e)))) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e))
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] [_inst_5 : CommRing.{u3} α] (A : Matrix.{u1, u1, u3} m m α) (e : Equiv.{succ u2, succ u1} n m) (b : n -> α), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) b) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, max u2 u3} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (Matrix.cramer.{u2, u3} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e))) b) (Function.comp.{succ u2, succ u1, succ u3} n m α (FunLike.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3), max (succ u1) (succ u3)} (LinearMap.{u3, u3, max u1 u3, max u1 u3} α α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (m -> α) (m -> α) (Pi.addCommMonoid.{u1, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u1, u3, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : m) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u1, u3, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : m) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (m -> α) (fun (_x : m -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : m -> α) => m -> α) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u1 u3, max u1 u3} α α (m -> α) (m -> α) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u1, u3, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : m) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u1, u3, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : m) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (Matrix.cramer.{u1, u3} m α (fun (a : m) (b : m) => _inst_3 a b) _inst_4 _inst_5 A) (Function.comp.{succ u1, succ u2, succ u3} m n α b (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Equiv.{succ u1, succ u2} m n) m (fun (_x : m) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : m) => n) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u2} m n) (Equiv.symm.{succ u2, succ u1} n m e)))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e))
Case conversion may be inaccurate. Consider using '#align matrix.cramer_submatrix_equiv Matrix.cramer_submatrix_equivₓ'. -/
theorem cramer_submatrix_equiv (A : Matrix m m α) (e : n ≃ m) (b : n → α) :
    cramer (A.submatrix e e) b = cramer A (b ∘ e.symm) ∘ e :=
  by
  ext i
  simp_rw [Function.comp_apply, cramer_apply, update_column_submatrix_equiv,
    det_submatrix_equiv_self e]
#align matrix.cramer_submatrix_equiv Matrix.cramer_submatrix_equiv

/- warning: matrix.cramer_reindex -> Matrix.cramer_reindex is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] [_inst_5 : CommRing.{u3} α] (e : Equiv.{succ u1, succ u2} m n) (A : Matrix.{u1, u1, u3} m m α) (b : n -> α), Eq.{max (succ u2) (succ u3)} (n -> α) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (_x : LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u3, u3, max u2 u3, max u2 u3} α α (n -> α) (n -> α) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u2, u3, u3} n α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Matrix.cramer.{u2, u3} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (coeFn.{max 1 (max (succ (max u1 u3)) (succ (max u2 u3))) (succ (max u2 u3)) (succ (max u1 u3)), max (succ (max u1 u3)) (succ (max u2 u3))} (Equiv.{succ (max u1 u3), succ (max u2 u3)} (Matrix.{u1, u1, u3} m m α) (Matrix.{u2, u2, u3} n n α)) (fun (_x : Equiv.{succ (max u1 u3), succ (max u2 u3)} (Matrix.{u1, u1, u3} m m α) (Matrix.{u2, u2, u3} n n α)) => (Matrix.{u1, u1, u3} m m α) -> (Matrix.{u2, u2, u3} n n α)) (Equiv.hasCoeToFun.{succ (max u1 u3), succ (max u2 u3)} (Matrix.{u1, u1, u3} m m α) (Matrix.{u2, u2, u3} n n α)) (Matrix.reindex.{u3, u2, u1, u1, u2} n m m n α e e) A)) b) (Function.comp.{succ u2, succ u1, succ u3} n m α (coeFn.{succ (max u1 u3), succ (max u1 u3)} (LinearMap.{u3, u3, max u1 u3, max u1 u3} α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (m -> α) (m -> α) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (_x : LinearMap.{u3, u3, max u1 u3, max u1 u3} α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (m -> α) (m -> α) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) => (m -> α) -> m -> α) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, max u1 u3} α α (m -> α) (m -> α) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (Pi.Function.module.{u1, u3, u3} m α α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Semiring.toModule.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (Ring.toSemiring.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (Matrix.cramer.{u1, u3} m α (fun (a : m) (b : m) => _inst_3 a b) _inst_4 _inst_5 A) (Function.comp.{succ u1, succ u2, succ u3} m n α b (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} m n) (fun (_x : Equiv.{succ u1, succ u2} m n) => m -> n) (Equiv.hasCoeToFun.{succ u1, succ u2} m n) e))) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) (Equiv.symm.{succ u1, succ u2} m n e)))
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] [_inst_5 : CommRing.{u3} α] (e : Equiv.{succ u1, succ u2} m n) (A : Matrix.{u1, u1, u3} m m α) (b : n -> α), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) b) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u3, u3, max u2 u3, max u2 u3} α α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, max u2 u3} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u2, u3} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u2, u3, u3} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (Matrix.cramer.{u2, u3} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u1) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u2)} (Matrix.{u1, u1, u3} m m α) (Matrix.{u2, u2, u3} n n α)) (Matrix.{u1, u1, u3} m m α) (fun (_x : Matrix.{u1, u1, u3} m m α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Matrix.{u1, u1, u3} m m α) => Matrix.{u2, u2, u3} n n α) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u3), max (succ u2) (succ u3)} (Matrix.{u1, u1, u3} m m α) (Matrix.{u2, u2, u3} n n α)) (Matrix.reindex.{u3, u2, u1, u1, u2} n m m n α e e) A)) b) (Function.comp.{succ u2, succ u1, succ u3} n m α (FunLike.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3), max (succ u1) (succ u3)} (LinearMap.{u3, u3, max u1 u3, max u1 u3} α α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (m -> α) (m -> α) (Pi.addCommMonoid.{u1, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u1, u3, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : m) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u1, u3, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : m) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (m -> α) (fun (_x : m -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : m -> α) => m -> α) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u1 u3, max u1 u3} α α (m -> α) (m -> α) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.addCommMonoid.{u1, u3} m (fun (ᾰ : m) => α) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5)))))) (Pi.module.{u1, u3, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : m) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (Pi.module.{u1, u3, u3} m (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : m) => α) α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)) (fun (i : m) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_5))))) (fun (i : m) => Semiring.toModule.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5)))) (RingHom.id.{u3} α (Semiring.toNonAssocSemiring.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_5))))) (Matrix.cramer.{u1, u3} m α (fun (a : m) (b : m) => _inst_3 a b) _inst_4 _inst_5 A) (Function.comp.{succ u1, succ u2, succ u3} m n α b (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Equiv.{succ u1, succ u2} m n) m (fun (_x : m) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : m) => n) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u2} m n) e))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) (Equiv.symm.{succ u1, succ u2} m n e)))
Case conversion may be inaccurate. Consider using '#align matrix.cramer_reindex Matrix.cramer_reindexₓ'. -/
theorem cramer_reindex (e : m ≃ n) (A : Matrix m m α) (b : n → α) :
    cramer (reindex e e A) b = cramer A (b ∘ e) ∘ e.symm :=
  cramer_submatrix_equiv _ _ _
#align matrix.cramer_reindex Matrix.cramer_reindex

end Cramer

section Adjugate

/-!
### `adjugate` section

Define the `adjugate` matrix and a few equations.
These will hold for any matrix over a commutative ring.
-/


#print Matrix.adjugate /-
/-- The adjugate matrix is the transpose of the cofactor matrix.

  Typically, the cofactor matrix is defined by taking minors,
  i.e. the determinant of the matrix with a row and column removed.
  However, the proof of `mul_adjugate` becomes a lot easier if we use the
  matrix replacing a column with a basis vector, since it allows us to use
  facts about the `cramer` map.
-/
def adjugate (A : Matrix n n α) : Matrix n n α :=
  of fun i => cramer Aᵀ (Pi.single i 1)
#align matrix.adjugate Matrix.adjugate
-/

#print Matrix.adjugate_def /-
theorem adjugate_def (A : Matrix n n α) : adjugate A = of fun i => cramer Aᵀ (Pi.single i 1) :=
  rfl
#align matrix.adjugate_def Matrix.adjugate_def
-/

/- warning: matrix.adjugate_apply -> Matrix.adjugate_apply is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (i : n) (j : n), Eq.{succ u2} α (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A i j) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 (Matrix.updateRow.{u2, u1, u1} n n α (fun (a : n) (b : n) => _inst_1 a b) A j (Pi.single.{u1, u2} n (fun (ᾰ : n) => α) (fun (a : n) (b : n) => _inst_1 a b) (fun (i : n) => MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) i (OfNat.ofNat.{u2} α 1 (OfNat.mk.{u2} α 1 (One.one.{u2} α (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_5)))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (i : n) (j : n), Eq.{succ u2} α (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A i j) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 (Matrix.updateRow.{u2, u1, u1} n n α (fun (a : n) (b : n) => _inst_1 a b) A j (Pi.single.{u1, u2} n (fun (ᾰ : n) => α) (fun (a : n) (b : n) => _inst_1 a b) (fun (i : n) => CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) i (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))))))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_apply Matrix.adjugate_applyₓ'. -/
theorem adjugate_apply (A : Matrix n n α) (i j : n) :
    adjugate A i j = (A.updateRow j (Pi.single i 1)).det := by
  rw [adjugate_def, of_apply, cramer_apply, update_column_transpose, det_transpose]
#align matrix.adjugate_apply Matrix.adjugate_apply

#print Matrix.adjugate_transpose /-
theorem adjugate_transpose (A : Matrix n n α) : (adjugate A)ᵀ = adjugate Aᵀ :=
  by
  ext (i j)
  rw [transpose_apply, adjugate_apply, adjugate_apply, update_row_transpose, det_transpose]
  rw [det_apply', det_apply']
  apply Finset.sum_congr rfl
  intro σ _
  congr 1
  by_cases i = σ j
  · -- Everything except `(i , j)` (= `(σ j , j)`) is given by A, and the rest is a single `1`.
      congr <;> ext j'
    subst h
    have : σ j' = σ j ↔ j' = j := σ.injective.eq_iff
    rw [update_row_apply, update_column_apply]
    simp_rw [this]
    rw [← dite_eq_ite, ← dite_eq_ite]
    congr 1 with rfl
    rw [Pi.single_eq_same, Pi.single_eq_same]
  · -- Otherwise, we need to show that there is a `0` somewhere in the product.
    have : (∏ j' : n, update_column A j (Pi.single i 1) (σ j') j') = 0 :=
      by
      apply prod_eq_zero (mem_univ j)
      rw [update_column_self, Pi.single_eq_of_ne' h]
    rw [this]
    apply prod_eq_zero (mem_univ (σ⁻¹ i))
    erw [apply_symm_apply σ i, update_row_self]
    apply Pi.single_eq_of_ne
    intro h'
    exact h ((symm_apply_eq σ).mp h')
#align matrix.adjugate_transpose Matrix.adjugate_transpose
-/

#print Matrix.adjugate_submatrix_equiv_self /-
@[simp]
theorem adjugate_submatrix_equiv_self (e : n ≃ m) (A : Matrix m m α) :
    adjugate (A.submatrix e e) = (adjugate A).submatrix e e :=
  by
  ext (i j)
  rw [adjugate_apply, submatrix_apply, adjugate_apply, ← det_submatrix_equiv_self e,
    update_row_submatrix_equiv]
  congr
  exact Function.update_comp_equiv _ e.symm _ _
#align matrix.adjugate_submatrix_equiv_self Matrix.adjugate_submatrix_equiv_self
-/

#print Matrix.adjugate_reindex /-
theorem adjugate_reindex (e : m ≃ n) (A : Matrix m m α) :
    adjugate (reindex e e A) = reindex e e (adjugate A) :=
  adjugate_submatrix_equiv_self _ _
#align matrix.adjugate_reindex Matrix.adjugate_reindex
-/

/- warning: matrix.cramer_eq_adjugate_mul_vec -> Matrix.cramer_eq_adjugate_mulVec is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α), Eq.{max (succ u1) (succ u2)} (n -> α) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b) (Matrix.mulVec.{u2, u1, u1} n n α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) _inst_2 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) b) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b) (Matrix.mulVec.{u2, u1, u1} n n α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) _inst_2 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b)
Case conversion may be inaccurate. Consider using '#align matrix.cramer_eq_adjugate_mul_vec Matrix.cramer_eq_adjugate_mulVecₓ'. -/
/-- Since the map `b ↦ cramer A b` is linear in `b`, it must be multiplication by some matrix. This
matrix is `A.adjugate`. -/
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate.mulVec b :=
  by
  nth_rw 2 [← A.transpose_transpose]
  rw [← adjugate_transpose, adjugate_def]
  have : b = ∑ i, b i • Pi.single i 1 :=
    by
    refine' (pi_eq_sum_univ b).trans _
    congr with j
    simp [Pi.single_apply, eq_comm]
  nth_rw 1 [this]
  ext k
  simp [mul_vec, dot_product, mul_comm]
#align matrix.cramer_eq_adjugate_mul_vec Matrix.cramer_eq_adjugate_mulVec

/- warning: matrix.mul_adjugate_apply -> Matrix.mul_adjugate_apply is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (i : n) (j : n) (k : n), Eq.{succ u2} α (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (A i k) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A k j)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.transpose.{u2, u1, u1} n n α A)) (Pi.single.{u1, u2} n (fun (ᾰ : n) => α) (fun (a : n) (b : n) => _inst_1 a b) (fun (i : n) => MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) k (A i k)) j)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (i : n) (j : n) (k : n), Eq.{succ u2} α (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (A i k) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A k j)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.transpose.{u2, u1, u1} n n α A)) (Pi.single.{u1, u2} n (fun (ᾰ : n) => α) (fun (a : n) (b : n) => _inst_1 a b) (fun (i : n) => CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) k (A i k)) j)
Case conversion may be inaccurate. Consider using '#align matrix.mul_adjugate_apply Matrix.mul_adjugate_applyₓ'. -/
theorem mul_adjugate_apply (A : Matrix n n α) (i j k) :
    A i k * adjugate A k j = cramer Aᵀ (Pi.single k (A i k)) j := by
  erw [← smul_eq_mul, ← Pi.smul_apply, ← LinearMap.map_smul, ← Pi.single_smul', smul_eq_mul,
    mul_one]
#align matrix.mul_adjugate_apply Matrix.mul_adjugate_apply

/- warning: matrix.mul_adjugate -> Matrix.mul_adjugate is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) A (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) A (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align matrix.mul_adjugate Matrix.mul_adjugateₓ'. -/
theorem mul_adjugate (A : Matrix n n α) : A ⬝ adjugate A = A.det • 1 :=
  by
  ext (i j)
  rw [mul_apply, Pi.smul_apply, Pi.smul_apply, one_apply, smul_eq_mul, mul_boole]
  simp [mul_adjugate_apply, sum_cramer_apply, cramer_transpose_row_self, Pi.single_apply, eq_comm]
#align matrix.mul_adjugate Matrix.mul_adjugate

/- warning: matrix.adjugate_mul -> Matrix.adjugate_mul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) A) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) A) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_mul Matrix.adjugate_mulₓ'. -/
theorem adjugate_mul (A : Matrix n n α) : adjugate A ⬝ A = A.det • 1 :=
  calc
    adjugate A ⬝ A = (Aᵀ ⬝ adjugate Aᵀ)ᵀ := by
      rw [← adjugate_transpose, ← transpose_mul, transpose_transpose]
    _ = A.det • 1 := by rw [mul_adjugate Aᵀ, det_transpose, transpose_smul, transpose_one]
    
#align matrix.adjugate_mul Matrix.adjugate_mul

/- warning: matrix.adjugate_smul -> Matrix.adjugate_smul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (r : α) (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) r A)) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_5)))) r (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (r : α) (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) r A)) (HSMul.hSMul.{u2, max u2 u1, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))) r (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_smul Matrix.adjugate_smulₓ'. -/
theorem adjugate_smul (r : α) (A : Matrix n n α) :
    adjugate (r • A) = r ^ (Fintype.card n - 1) • adjugate A :=
  by
  rw [adjugate, adjugate, transpose_smul, cramer_smul]
  rfl
#align matrix.adjugate_smul Matrix.adjugate_smul

/- warning: matrix.mul_vec_cramer -> Matrix.mulVec_cramer is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α), Eq.{max (succ u1) (succ u2)} (n -> α) (Matrix.mulVec.{u2, u1, u1} n n α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) _inst_2 A (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b)) (SMul.smul.{u2, max u1 u2} α (n -> α) (Function.hasSMul.{u1, u2, u2} n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) b)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α), Eq.{max (succ u1) (succ u2)} (n -> α) (Matrix.mulVec.{u2, u1, u1} n n α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) _inst_2 A (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) b)) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (n -> α) (n -> α) (instHSMul.{u2, max u1 u2} α (n -> α) (Pi.instSMul.{u1, u2, u2} n α (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.3226 : n) => α) (fun (i : n) => Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) b)
Case conversion may be inaccurate. Consider using '#align matrix.mul_vec_cramer Matrix.mulVec_cramerₓ'. -/
/-- A stronger form of **Cramer's rule** that allows us to solve some instances of `A ⬝ x = b` even
if the determinant is not a unit. A sufficient (but still not necessary) condition is that `A.det`
divides `b`. -/
@[simp]
theorem mulVec_cramer (A : Matrix n n α) (b : n → α) : A.mulVec (cramer A b) = A.det • b := by
  rw [cramer_eq_adjugate_mul_vec, mul_vec_mul_vec, mul_adjugate, smul_mul_vec_assoc, one_mul_vec]
#align matrix.mul_vec_cramer Matrix.mulVec_cramer

/- warning: matrix.adjugate_subsingleton -> Matrix.adjugate_subsingleton is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] [_inst_6 : Subsingleton.{succ u1} n] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_5)))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] [_inst_6 : Subsingleton.{succ u1} n] (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_subsingleton Matrix.adjugate_subsingletonₓ'. -/
theorem adjugate_subsingleton [Subsingleton n] (A : Matrix n n α) : adjugate A = 1 :=
  by
  ext (i j)
  simp [Subsingleton.elim i j, adjugate_apply, det_eq_elem_of_subsingleton _ i]
#align matrix.adjugate_subsingleton Matrix.adjugate_subsingleton

/- warning: matrix.adjugate_eq_one_of_card_eq_one -> Matrix.adjugate_eq_one_of_card_eq_one is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, (Eq.{1} Nat (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, (Eq.{1} Nat (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_eq_one_of_card_eq_one Matrix.adjugate_eq_one_of_card_eq_oneₓ'. -/
theorem adjugate_eq_one_of_card_eq_one {A : Matrix n n α} (h : Fintype.card n = 1) :
    adjugate A = 1 :=
  haveI : Subsingleton n := fintype.card_le_one_iff_subsingleton.mp h.le
  adjugate_subsingleton _
#align matrix.adjugate_eq_one_of_card_eq_one Matrix.adjugate_eq_one_of_card_eq_one

/- warning: matrix.adjugate_zero -> Matrix.adjugate_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] [_inst_6 : Nontrivial.{u1} n], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.zero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasZero.{u2, u1, u1} n n α (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))))))))) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.zero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasZero.{u2, u1, u1} n n α (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] [_inst_6 : Nontrivial.{u1} n], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.toOfNat0.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.zero.{u2, u1, u1} n n α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))))) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.toOfNat0.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.zero.{u2, u1, u1} n n α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_zero Matrix.adjugate_zeroₓ'. -/
@[simp]
theorem adjugate_zero [Nontrivial n] : adjugate (0 : Matrix n n α) = 0 :=
  by
  ext (i j)
  obtain ⟨j', hj'⟩ : ∃ j', j' ≠ j := exists_ne j
  apply det_eq_zero_of_column_eq_zero j'
  intro j''
  simp [update_column_ne hj']
#align matrix.adjugate_zero Matrix.adjugate_zero

/- warning: matrix.adjugate_one -> Matrix.adjugate_one is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_5)))))))))) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_5)))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))))) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_one Matrix.adjugate_oneₓ'. -/
@[simp]
theorem adjugate_one : adjugate (1 : Matrix n n α) = 1 :=
  by
  ext
  simp [adjugate_def, Matrix.one_apply, Pi.single_apply, eq_comm]
#align matrix.adjugate_one Matrix.adjugate_one

/- warning: matrix.adjugate_diagonal -> Matrix.adjugate_diagonal is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (v : n -> α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) v)) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) (fun (i : n) => Finset.prod.{u2, u1} α n (CommRing.toCommMonoid.{u2} α _inst_5) (Finset.erase.{u1} n (fun (a : n) (b : n) => _inst_1 a b) (Finset.univ.{u1} n _inst_2) i) (fun (j : n) => v j)))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (v : n -> α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) v)) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))) (fun (i : n) => Finset.prod.{u2, u1} α n (CommRing.toCommMonoid.{u2} α _inst_5) (Finset.erase.{u1} n (fun (a : n) (b : n) => _inst_1 a b) (Finset.univ.{u1} n _inst_2) i) (fun (j : n) => v j)))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_diagonal Matrix.adjugate_diagonalₓ'. -/
@[simp]
theorem adjugate_diagonal (v : n → α) :
    adjugate (diagonal v) = diagonal fun i => ∏ j in Finset.univ.eraseₓ i, v j :=
  by
  ext
  simp only [adjugate_def, cramer_apply, diagonal_transpose, of_apply]
  obtain rfl | hij := eq_or_ne i j
  ·
    rw [diagonal_apply_eq, diagonal_update_column_single, det_diagonal,
      prod_update_of_mem (Finset.mem_univ _), sdiff_singleton_eq_erase, one_mul]
  · rw [diagonal_apply_ne _ hij]
    refine' det_eq_zero_of_row_eq_zero j fun k => _
    obtain rfl | hjk := eq_or_ne k j
    · rw [update_column_self, Pi.single_eq_of_ne' hij]
    · rw [update_column_ne hjk, diagonal_apply_ne' _ hjk]
#align matrix.adjugate_diagonal Matrix.adjugate_diagonal

/- warning: ring_hom.map_adjugate -> RingHom.map_adjugate is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} {S : Type.{u3}} [_inst_6 : CommRing.{u2} R] [_inst_7 : CommRing.{u3} S] (f : RingHom.{u2, u3} R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_6))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_7)))) (M : Matrix.{u1, u1, u2} n n R), Eq.{succ (max u1 u3)} (Matrix.{u1, u1, u3} n n S) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (RingHom.{max u1 u2, max u1 u3} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (fun (_x : RingHom.{max u1 u2, max u1 u3} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) => (Matrix.{u1, u1, u2} n n R) -> (Matrix.{u1, u1, u3} n n S)) (RingHom.hasCoeToFun.{max u1 u2, max u1 u3} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (RingHom.mapMatrix.{u2, u3, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_6))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_7))) f) (Matrix.adjugate.{u1, u2} n R (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_6 M)) (Matrix.adjugate.{u1, u3} n S (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_7 (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (RingHom.{max u1 u2, max u1 u3} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (fun (_x : RingHom.{max u1 u2, max u1 u3} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) => (Matrix.{u1, u1, u2} n n R) -> (Matrix.{u1, u1, u3} n n S)) (RingHom.hasCoeToFun.{max u1 u2, max u1 u3} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (RingHom.mapMatrix.{u2, u3, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_6))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_7))) f) M))
but is expected to have type
  forall {n : Type.{u3}} [_inst_1 : DecidableEq.{succ u3} n] [_inst_2 : Fintype.{u3} n] {R : Type.{u2}} {S : Type.{u1}} [_inst_6 : CommRing.{u2} R] [_inst_7 : CommRing.{u1} S] (f : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7)))) (M : Matrix.{u3, u3, u2} n n R), Eq.{max (succ u3) (succ u1)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Matrix.{u3, u3, u2} n n R) => Matrix.{u3, u3, u1} n n S) (Matrix.adjugate.{u3, u2} n R (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_6 M)) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), max (succ u2) (succ u3), max (succ u1) (succ u3)} (RingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u3, u3, u2} n n R) (fun (_x : Matrix.{u3, u3, u2} n n R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Matrix.{u3, u3, u2} n n R) => Matrix.{u3, u3, u1} n n S) _x) (MulHomClass.toFunLike.{max (max u2 u1) u3, max u2 u3, max u1 u3} (RingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (NonUnitalNonAssocSemiring.toMul.{max u2 u3} (Matrix.{u3, u3, u2} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonUnitalNonAssocSemiring.toMul.{max u1 u3} (Matrix.{u3, u3, u1} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonUnitalRingHomClass.toMulHomClass.{max (max u2 u1) u3, max u2 u3, max u1 u3} (RingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (RingHomClass.toNonUnitalRingHomClass.{max (max u2 u1) u3, max u2 u3, max u1 u3} (RingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (RingHom.instRingHomClassRingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (RingHom.mapMatrix.{u2, u1, u3} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) f) (Matrix.adjugate.{u3, u2} n R (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_6 M)) (Matrix.adjugate.{u3, u1} n S (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_7 (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), max (succ u2) (succ u3), max (succ u1) (succ u3)} (RingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u3, u3, u2} n n R) (fun (_x : Matrix.{u3, u3, u2} n n R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Matrix.{u3, u3, u2} n n R) => Matrix.{u3, u3, u1} n n S) _x) (MulHomClass.toFunLike.{max (max u2 u1) u3, max u2 u3, max u1 u3} (RingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (NonUnitalNonAssocSemiring.toMul.{max u2 u3} (Matrix.{u3, u3, u2} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonUnitalNonAssocSemiring.toMul.{max u1 u3} (Matrix.{u3, u3, u1} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonUnitalRingHomClass.toMulHomClass.{max (max u2 u1) u3, max u2 u3, max u1 u3} (RingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u3} (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (RingHomClass.toNonUnitalRingHomClass.{max (max u2 u1) u3, max u2 u3, max u1 u3} (RingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (RingHom.instRingHomClassRingHom.{max u2 u3, max u1 u3} (Matrix.{u3, u3, u2} n n R) (Matrix.{u3, u3, u1} n n S) (Matrix.nonAssocSemiring.{u2, u3} n R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u1, u3} n S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (RingHom.mapMatrix.{u2, u1, u3} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_6))) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_7))) f) M))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_adjugate RingHom.map_adjugateₓ'. -/
theorem RingHom.map_adjugate {R S : Type _} [CommRing R] [CommRing S] (f : R →+* S)
    (M : Matrix n n R) : f.mapMatrix M.adjugate = Matrix.adjugate (f.mapMatrix M) :=
  by
  ext (i k)
  have : Pi.single i (1 : S) = f ∘ Pi.single i 1 :=
    by
    rw [← f.map_one]
    exact Pi.single_op (fun i => f) (fun i => f.map_zero) i (1 : R)
  rw [adjugate_apply, RingHom.mapMatrix_apply, map_apply, RingHom.mapMatrix_apply, this, ←
    map_update_row, ← RingHom.mapMatrix_apply, ← RingHom.map_det, ← adjugate_apply]
#align ring_hom.map_adjugate RingHom.map_adjugate

/- warning: alg_hom.map_adjugate -> AlgHom.map_adjugate is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} {A : Type.{u3}} {B : Type.{u4}} [_inst_6 : CommSemiring.{u2} R] [_inst_7 : CommRing.{u3} A] [_inst_8 : CommRing.{u4} B] [_inst_9 : Algebra.{u2, u3} R A _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7))] [_inst_10 : Algebra.{u2, u4} R B _inst_6 (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8))] (f : AlgHom.{u2, u3, u4} R A B _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_9 _inst_10) (M : Matrix.{u1, u1, u3} n n A), Eq.{succ (max u1 u4)} (Matrix.{u1, u1, u4} n n B) (coeFn.{max (succ (max u1 u3)) (succ (max u1 u4)), max (succ (max u1 u3)) (succ (max u1 u4))} (AlgHom.{u2, max u1 u3, max u1 u4} R (Matrix.{u1, u1, u3} n n A) (Matrix.{u1, u1, u4} n n B) _inst_6 (Matrix.semiring.{u3, u1} n A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n B (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u3, u1, u2} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_9) (Matrix.algebra.{u4, u1, u2} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_10)) (fun (_x : AlgHom.{u2, max u1 u3, max u1 u4} R (Matrix.{u1, u1, u3} n n A) (Matrix.{u1, u1, u4} n n B) _inst_6 (Matrix.semiring.{u3, u1} n A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n B (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u3, u1, u2} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_9) (Matrix.algebra.{u4, u1, u2} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_10)) => (Matrix.{u1, u1, u3} n n A) -> (Matrix.{u1, u1, u4} n n B)) ([anonymous].{u2, max u1 u3, max u1 u4} R (Matrix.{u1, u1, u3} n n A) (Matrix.{u1, u1, u4} n n B) _inst_6 (Matrix.semiring.{u3, u1} n A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n B (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u3, u1, u2} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_9) (Matrix.algebra.{u4, u1, u2} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_10)) (AlgHom.mapMatrix.{u3, u4, u1, u2} n R A B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_9 _inst_10 f) (Matrix.adjugate.{u1, u3} n A (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_7 M)) (Matrix.adjugate.{u1, u4} n B (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_8 (coeFn.{max (succ (max u1 u3)) (succ (max u1 u4)), max (succ (max u1 u3)) (succ (max u1 u4))} (AlgHom.{u2, max u1 u3, max u1 u4} R (Matrix.{u1, u1, u3} n n A) (Matrix.{u1, u1, u4} n n B) _inst_6 (Matrix.semiring.{u3, u1} n A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n B (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u3, u1, u2} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_9) (Matrix.algebra.{u4, u1, u2} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_10)) (fun (_x : AlgHom.{u2, max u1 u3, max u1 u4} R (Matrix.{u1, u1, u3} n n A) (Matrix.{u1, u1, u4} n n B) _inst_6 (Matrix.semiring.{u3, u1} n A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n B (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u3, u1, u2} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_9) (Matrix.algebra.{u4, u1, u2} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_10)) => (Matrix.{u1, u1, u3} n n A) -> (Matrix.{u1, u1, u4} n n B)) ([anonymous].{u2, max u1 u3, max u1 u4} R (Matrix.{u1, u1, u3} n n A) (Matrix.{u1, u1, u4} n n B) _inst_6 (Matrix.semiring.{u3, u1} n A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n B (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u3, u1, u2} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) _inst_9) (Matrix.algebra.{u4, u1, u2} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_10)) (AlgHom.mapMatrix.{u3, u4, u1, u2} n R A B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_7)) (Ring.toSemiring.{u4} B (CommRing.toRing.{u4} B _inst_8)) _inst_9 _inst_10 f) M))
but is expected to have type
  forall {n : Type.{u4}} [_inst_1 : DecidableEq.{succ u4} n] [_inst_2 : Fintype.{u4} n] {R : Type.{u3}} {A : Type.{u2}} {B : Type.{u1}} [_inst_6 : CommSemiring.{u3} R] [_inst_7 : CommRing.{u2} A] [_inst_8 : CommRing.{u1} B] [_inst_9 : Algebra.{u3, u2} R A _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7))] [_inst_10 : Algebra.{u3, u1} R B _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8))] (f : AlgHom.{u3, u2, u1} R A B _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_9 _inst_10) (M : Matrix.{u4, u4, u2} n n A), Eq.{max (succ u4) (succ u1)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Matrix.{u4, u4, u2} n n A) => Matrix.{u4, u4, u1} n n B) (Matrix.adjugate.{u4, u2} n A (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_7 M)) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u4), max (succ u2) (succ u4), max (succ u1) (succ u4)} (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) (Matrix.{u4, u4, u2} n n A) (fun (_x : Matrix.{u4, u4, u2} n n A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Matrix.{u4, u4, u2} n n A) => Matrix.{u4, u4, u1} n n B) _x) (SMulHomClass.toFunLike.{max (max u2 u1) u4, u3, max u2 u4, max u1 u4} (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (AddMonoid.toZero.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (AddCommMonoid.toAddMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribSMul.toSMulZeroClass.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (AddMonoid.toAddZeroClass.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (AddCommMonoid.toAddMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribMulAction.toDistribSMul.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_6))) (AddCommMonoid.toAddMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9)))))) (SMulZeroClass.toSMul.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (AddMonoid.toZero.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (AddCommMonoid.toAddMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribSMul.toSMulZeroClass.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (AddMonoid.toAddZeroClass.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (AddCommMonoid.toAddMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribMulAction.toDistribSMul.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_6))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u2 u1) u4, u3, max u2 u4, max u1 u4} (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_6))) (AddCommMonoid.toAddMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9))) (Module.toDistribMulAction.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10))) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max (max u2 u1) u4, u3, max u2 u4, max u1 u4} (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_6))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (Module.toDistribMulAction.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9))) (Module.toDistribMulAction.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10))) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u3, max u2 u4, max u1 u4, max (max u2 u1) u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10) (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) (AlgHom.algHomClass.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)))))) (AlgHom.mapMatrix.{u2, u1, u4, u3} n R A B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_9 _inst_10 f) (Matrix.adjugate.{u4, u2} n A (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_7 M)) (Matrix.adjugate.{u4, u1} n B (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_8 (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u4), max (succ u2) (succ u4), max (succ u1) (succ u4)} (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) (Matrix.{u4, u4, u2} n n A) (fun (_x : Matrix.{u4, u4, u2} n n A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Matrix.{u4, u4, u2} n n A) => Matrix.{u4, u4, u1} n n B) _x) (SMulHomClass.toFunLike.{max (max u2 u1) u4, u3, max u2 u4, max u1 u4} (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (AddMonoid.toZero.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (AddCommMonoid.toAddMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribSMul.toSMulZeroClass.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (AddMonoid.toAddZeroClass.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (AddCommMonoid.toAddMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribMulAction.toDistribSMul.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_6))) (AddCommMonoid.toAddMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9)))))) (SMulZeroClass.toSMul.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (AddMonoid.toZero.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (AddCommMonoid.toAddMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribSMul.toSMulZeroClass.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (AddMonoid.toAddZeroClass.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (AddCommMonoid.toAddMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribMulAction.toDistribSMul.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_6))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u2 u1) u4, u3, max u2 u4, max u1 u4} (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_6))) (AddCommMonoid.toAddMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9))) (Module.toDistribMulAction.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10))) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max (max u2 u1) u4, u3, max u2 u4, max u1 u4} (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (CommSemiring.toSemiring.{u3} R _inst_6))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (Module.toDistribMulAction.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Semiring.toNonAssocSemiring.{max u2 u4} (Matrix.{u4, u4, u2} n n A) (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u2 u4} R (Matrix.{u4, u4, u2} n n A) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9))) (Module.toDistribMulAction.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) (CommSemiring.toSemiring.{u3} R _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Semiring.toNonAssocSemiring.{max u1 u4} (Matrix.{u4, u4, u1} n n B) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u3, max u1 u4} R (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10))) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u3, max u2 u4, max u1 u4, max (max u2 u1) u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10) (AlgHom.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)) (AlgHom.algHomClass.{u3, max u2 u4, max u1 u4} R (Matrix.{u4, u4, u2} n n A) (Matrix.{u4, u4, u1} n n B) _inst_6 (Matrix.semiring.{u2, u4} n A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u1, u4} n B (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u2, u4, u3} n R A _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) _inst_9) (Matrix.instAlgebraMatrixSemiring.{u1, u4, u3} n R B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_10)))))) (AlgHom.mapMatrix.{u2, u1, u4, u3} n R A B _inst_2 (fun (a : n) (b : n) => _inst_1 a b) _inst_6 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_7)) (CommSemiring.toSemiring.{u1} B (CommRing.toCommSemiring.{u1} B _inst_8)) _inst_9 _inst_10 f) M))
Case conversion may be inaccurate. Consider using '#align alg_hom.map_adjugate AlgHom.map_adjugateₓ'. -/
theorem AlgHom.map_adjugate {R A B : Type _} [CommSemiring R] [CommRing A] [CommRing B]
    [Algebra R A] [Algebra R B] (f : A →ₐ[R] B) (M : Matrix n n A) :
    f.mapMatrix M.adjugate = Matrix.adjugate (f.mapMatrix M) :=
  f.toRingHom.map_adjugate _
#align alg_hom.map_adjugate AlgHom.map_adjugate

/- warning: matrix.det_adjugate -> Matrix.det_adjugate is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))
Case conversion may be inaccurate. Consider using '#align matrix.det_adjugate Matrix.det_adjugateₓ'. -/
theorem det_adjugate (A : Matrix n n α) : (adjugate A).det = A.det ^ (Fintype.card n - 1) :=
  by
  -- get rid of the `- 1`
  cases' (Fintype.card n).eq_zero_or_pos with h_card h_card
  · haveI : IsEmpty n := fintype.card_eq_zero_iff.mp h_card
    rw [h_card, Nat.zero_sub, pow_zero, adjugate_subsingleton, det_one]
  replace h_card := tsub_add_cancel_of_le h_card.nat_succ_le
  -- express `A` as an evaluation of a polynomial in n^2 variables, and solve in the polynomial ring
  -- where `A'.det` is non-zero.
  let A' := mv_polynomial_X n n ℤ
  suffices A'.adjugate.det = A'.det ^ (Fintype.card n - 1) by
    rw [← mv_polynomial_X_map_matrix_aeval ℤ A, ← AlgHom.map_adjugate, ← AlgHom.map_det, ←
      AlgHom.map_det, ← AlgHom.map_pow, this]
  apply mul_left_cancel₀ (show A'.det ≠ 0 from det_mv_polynomial_X_ne_zero n ℤ)
  calc
    A'.det * A'.adjugate.det = (A' ⬝ adjugate A').det := (det_mul _ _).symm
    _ = A'.det ^ Fintype.card n := by rw [mul_adjugate, det_smul, det_one, mul_one]
    _ = A'.det * A'.det ^ (Fintype.card n - 1) := by rw [← pow_succ, h_card]
    
#align matrix.det_adjugate Matrix.det_adjugate

/- warning: matrix.adjugate_fin_zero -> Matrix.adjugate_fin_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_5 : CommRing.{u1} α] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) α), Eq.{succ u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) α) (Matrix.adjugate.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) α (fun (a : Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (b : Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) => Fin.decidableEq (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) _inst_5 A) (OfNat.ofNat.{u1} (Matrix.{0, 0, u1} (Fin (Zero.zero.{0} Nat Nat.hasZero)) (Fin (Zero.zero.{0} Nat Nat.hasZero)) α) 0 (OfNat.mk.{u1} (Matrix.{0, 0, u1} (Fin (Zero.zero.{0} Nat Nat.hasZero)) (Fin (Zero.zero.{0} Nat Nat.hasZero)) α) 0 (Zero.zero.{u1} (Matrix.{0, 0, u1} (Fin (Zero.zero.{0} Nat Nat.hasZero)) (Fin (Zero.zero.{0} Nat Nat.hasZero)) α) (Matrix.hasZero.{u1, 0, 0} (Fin (Zero.zero.{0} Nat Nat.hasZero)) (Fin (Zero.zero.{0} Nat Nat.hasZero)) α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_5))))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_5 : CommRing.{u1} α] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) α), Eq.{succ u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) α) (Matrix.adjugate.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) α (fun (a : Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (b : Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) _inst_5 A) (OfNat.ofNat.{u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) α) 0 (Zero.toOfNat0.{u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) α) (Matrix.zero.{u1, 0, 0} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (CommRing.toCommSemiring.{u1} α _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_fin_zero Matrix.adjugate_fin_zeroₓ'. -/
@[simp]
theorem adjugate_fin_zero (A : Matrix (Fin 0) (Fin 0) α) : adjugate A = 0 :=
  Subsingleton.elim _ _
#align matrix.adjugate_fin_zero Matrix.adjugate_fin_zero

/- warning: matrix.adjugate_fin_one -> Matrix.adjugate_fin_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_5 : CommRing.{u1} α] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) α), Eq.{succ u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) α) (Matrix.adjugate.{0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) α (fun (a : Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (b : Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) => Fin.decidableEq (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) _inst_5 A) (OfNat.ofNat.{u1} (Matrix.{0, 0, u1} (Fin (One.one.{0} Nat Nat.hasOne)) (Fin (One.one.{0} Nat Nat.hasOne)) α) 1 (OfNat.mk.{u1} (Matrix.{0, 0, u1} (Fin (One.one.{0} Nat Nat.hasOne)) (Fin (One.one.{0} Nat Nat.hasOne)) α) 1 (One.one.{u1} (Matrix.{0, 0, u1} (Fin (One.one.{0} Nat Nat.hasOne)) (Fin (One.one.{0} Nat Nat.hasOne)) α) (Matrix.hasOne.{u1, 0} (Fin (One.one.{0} Nat Nat.hasOne)) α (fun (a : Fin (One.one.{0} Nat Nat.hasOne)) (b : Fin (One.one.{0} Nat Nat.hasOne)) => Fin.decidableEq (One.one.{0} Nat Nat.hasOne) a b) (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_5)))))) (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (AddCommGroupWithOne.toAddGroupWithOne.{u1} α (Ring.toAddCommGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_5)))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_5 : CommRing.{u1} α] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α), Eq.{succ u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α) (Matrix.adjugate.{0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α (fun (a : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (b : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) _inst_5 A) (OfNat.ofNat.{u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α) 1 (One.toOfNat1.{u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α) (Matrix.one.{u1, 0} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α (fun (a : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (b : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) a b) (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (CommRing.toCommSemiring.{u1} α _inst_5))) (Semiring.toOne.{u1} α (CommSemiring.toSemiring.{u1} α (CommRing.toCommSemiring.{u1} α _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_fin_one Matrix.adjugate_fin_oneₓ'. -/
@[simp]
theorem adjugate_fin_one (A : Matrix (Fin 1) (Fin 1) α) : adjugate A = 1 :=
  adjugate_subsingleton A
#align matrix.adjugate_fin_one Matrix.adjugate_fin_one

/- warning: matrix.adjugate_fin_two -> Matrix.adjugate_fin_two is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_5 : CommRing.{u1} α] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) α), Eq.{succ u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) α) (Matrix.adjugate.{0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) α (fun (a : Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (b : Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) => Fin.decidableEq (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) _inst_5 A) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} ((Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> α) (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) α)) (fun (_x : Equiv.{succ u1, succ u1} ((Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> α) (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) α)) => ((Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> α) -> (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) α)) (Equiv.hasCoeToFun.{succ u1, succ u1} ((Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> α) (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) α)) (Matrix.of.{u1, 0, 0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) α) (Matrix.vecCons.{u1} ((Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> α) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) (Matrix.vecCons.{u1} α (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) (A (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring))))))) (Matrix.vecCons.{u1} α (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (AddCommGroupWithOne.toAddGroupWithOne.{u1} α (Ring.toAddCommGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_5)))))) (A (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))))) (Matrix.vecEmpty.{u1} α))) (Matrix.vecCons.{u1} ((Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> α) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (Matrix.vecCons.{u1} α (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (AddCommGroupWithOne.toAddGroupWithOne.{u1} α (Ring.toAddCommGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_5)))))) (A (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))))) (Matrix.vecCons.{u1} α (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (A (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring))))))) (Matrix.vecEmpty.{u1} α))) (Matrix.vecEmpty.{u1} ((Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> α)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_5 : CommRing.{u1} α] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) α), Eq.{succ u1} (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) α) (Matrix.adjugate.{0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) α (fun (a : Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (b : Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) _inst_5 A) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} ((Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> α) (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) α)) ((Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> α) (fun (_x : (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> α) => Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) α) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} ((Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> α) (Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) α)) (Matrix.of.{u1, 0, 0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) α) (Matrix.vecCons.{u1} ((Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> α) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) (Matrix.vecCons.{u1} α (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) (A (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Matrix.vecCons.{u1} α (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α (CommRing.toRing.{u1} α _inst_5)) (A (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))) (Matrix.vecEmpty.{u1} α))) (Matrix.vecCons.{u1} ((Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> α) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (Matrix.vecCons.{u1} α (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α (CommRing.toRing.{u1} α _inst_5)) (A (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))) (Matrix.vecCons.{u1} α (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (A (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (Matrix.vecEmpty.{u1} α))) (Matrix.vecEmpty.{u1} ((Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> α)))))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_fin_two Matrix.adjugate_fin_twoₓ'. -/
theorem adjugate_fin_two (A : Matrix (Fin 2) (Fin 2) α) :
    adjugate A = !![A 1 1, -A 0 1; -A 1 0, A 0 0] :=
  by
  ext (i j)
  rw [adjugate_apply, det_fin_two]
  fin_cases i <;> fin_cases j <;>
    simp only [one_mul, Fin.one_eq_zero_iff, Pi.single_eq_same, MulZeroClass.mul_zero, sub_zero,
      Pi.single_eq_of_ne, Ne.def, not_false_iff, update_row_self, update_row_ne, cons_val_zero,
      of_apply, Nat.succ_succ_ne_one, Pi.single_eq_of_ne, update_row_self, Pi.single_eq_of_ne,
      Ne.def, Fin.zero_eq_one_iff, Nat.succ_succ_ne_one, not_false_iff, update_row_ne,
      Fin.one_eq_zero_iff, MulZeroClass.zero_mul, Pi.single_eq_same, one_mul, zero_sub, of_apply,
      cons_val', cons_val_fin_one, cons_val_one, head_fin_const, neg_inj, eq_self_iff_true,
      cons_val_zero, head_cons, mul_one]
#align matrix.adjugate_fin_two Matrix.adjugate_fin_two

#print Matrix.adjugate_fin_two_of /-
@[simp]
theorem adjugate_fin_two_of (a b c d : α) : adjugate !![a, b; c, d] = !![d, -b; -c, a] :=
  adjugate_fin_two _
#align matrix.adjugate_fin_two_of Matrix.adjugate_fin_two_of
-/

#print Matrix.adjugate_conjTranspose /-
theorem adjugate_conjTranspose [StarRing α] (A : Matrix n n α) : A.adjugateᴴ = adjugate Aᴴ :=
  by
  dsimp only [conj_transpose]
  have : Aᵀ.adjugate.map star = adjugate (Aᵀ.map star) := (starRingEnd α).map_adjugate Aᵀ
  rw [A.adjugate_transpose, this]
#align matrix.adjugate_conj_transpose Matrix.adjugate_conjTranspose
-/

/- warning: matrix.is_regular_of_is_left_regular_det -> Matrix.isRegular_of_isLeftRegular_det is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, (IsLeftRegular.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A)) -> (IsRegular.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_2 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, (IsLeftRegular.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A)) -> (IsRegular.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_2 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))))) A)
Case conversion may be inaccurate. Consider using '#align matrix.is_regular_of_is_left_regular_det Matrix.isRegular_of_isLeftRegular_detₓ'. -/
theorem isRegular_of_isLeftRegular_det {A : Matrix n n α} (hA : IsLeftRegular A.det) :
    IsRegular A := by
  constructor
  · intro B C h
    refine' hA.matrix _
    rw [← Matrix.one_mul B, ← Matrix.one_mul C, ← Matrix.smul_mul, ← Matrix.smul_mul, ←
      adjugate_mul, Matrix.mul_assoc, Matrix.mul_assoc, ← mul_eq_mul A, h, mul_eq_mul]
  · intro B C h
    simp only [mul_eq_mul] at h
    refine' hA.matrix _
    rw [← Matrix.mul_one B, ← Matrix.mul_one C, ← Matrix.mul_smul, ← Matrix.mul_smul, ←
      mul_adjugate, ← Matrix.mul_assoc, ← Matrix.mul_assoc, h]
#align matrix.is_regular_of_is_left_regular_det Matrix.isRegular_of_isLeftRegular_det

/- warning: matrix.adjugate_mul_distrib_aux -> Matrix.adjugate_mul_distrib_aux is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (IsLeftRegular.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A)) -> (IsLeftRegular.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 B)) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) A B)) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 B) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (IsLeftRegular.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A)) -> (IsLeftRegular.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 B)) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) A B)) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 B) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_mul_distrib_aux Matrix.adjugate_mul_distrib_auxₓ'. -/
theorem adjugate_mul_distrib_aux (A B : Matrix n n α) (hA : IsLeftRegular A.det)
    (hB : IsLeftRegular B.det) : adjugate (A ⬝ B) = adjugate B ⬝ adjugate A :=
  by
  have hAB : IsLeftRegular (A ⬝ B).det := by
    rw [det_mul]
    exact hA.mul hB
  refine' (is_regular_of_is_left_regular_det hAB).left _
  rw [mul_eq_mul, mul_adjugate, mul_eq_mul, Matrix.mul_assoc, ← Matrix.mul_assoc B, mul_adjugate,
    smul_mul, Matrix.one_mul, mul_smul, mul_adjugate, smul_smul, mul_comm, ← det_mul]
#align matrix.adjugate_mul_distrib_aux Matrix.adjugate_mul_distrib_aux

/- warning: matrix.adjugate_mul_distrib -> Matrix.adjugate_mul_distrib is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) A B)) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 B) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) A B)) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_2 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 B) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_mul_distrib Matrix.adjugate_mul_distribₓ'. -/
/-- Proof follows from "The trace Cayley-Hamilton theorem" by Darij Grinberg, Section 5.3
-/
theorem adjugate_mul_distrib (A B : Matrix n n α) : adjugate (A ⬝ B) = adjugate B ⬝ adjugate A :=
  by
  let g : Matrix n n α → Matrix n n α[X] := fun M => M.map Polynomial.C + (Polynomial.X : α[X]) • 1
  let f' : Matrix n n α[X] →+* Matrix n n α := (Polynomial.evalRingHom 0).mapMatrix
  have f'_inv : ∀ M, f' (g M) = M := by
    intro
    ext
    simp [f', g]
  have f'_adj : ∀ M : Matrix n n α, f' (adjugate (g M)) = adjugate M :=
    by
    intro
    rw [RingHom.map_adjugate, f'_inv]
  have f'_g_mul : ∀ M N : Matrix n n α, f' (g M ⬝ g N) = M ⬝ N :=
    by
    intros
    rw [← mul_eq_mul, RingHom.map_mul, f'_inv, f'_inv, mul_eq_mul]
  have hu : ∀ M : Matrix n n α, IsRegular (g M).det :=
    by
    intro M
    refine' Polynomial.Monic.isRegular _
    simp only [g, Polynomial.Monic.def, ← Polynomial.leadingCoeff_det_X_one_add_C M, add_comm]
  rw [← f'_adj, ← f'_adj, ← f'_adj, ← mul_eq_mul (f' (adjugate (g B))), ← f'.map_mul, mul_eq_mul, ←
    adjugate_mul_distrib_aux _ _ (hu A).left (hu B).left, RingHom.map_adjugate,
    RingHom.map_adjugate, f'_inv, f'_g_mul]
#align matrix.adjugate_mul_distrib Matrix.adjugate_mul_distrib

/- warning: matrix.adjugate_pow -> Matrix.adjugate_pow is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (k : Nat), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (HPow.hPow.{max u1 u2, 0, max u1 u2} (Matrix.{u1, u1, u2} n n α) Nat (Matrix.{u1, u1, u2} n n α) (instHPow.{max u1 u2, 0} (Matrix.{u1, u1, u2} n n α) Nat (Monoid.Pow.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_5))))) A k)) (HPow.hPow.{max u1 u2, 0, max u1 u2} (Matrix.{u1, u1, u2} n n α) Nat (Matrix.{u1, u1, u2} n n α) (instHPow.{max u1 u2, 0} (Matrix.{u1, u1, u2} n n α) Nat (Monoid.Pow.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_5))))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) k)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (k : Nat), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (HPow.hPow.{max u1 u2, 0, max u1 u2} (Matrix.{u1, u1, u2} n n α) Nat (Matrix.{u1, u1, u2} n n α) (instHPow.{max u1 u2, 0} (Matrix.{u1, u1, u2} n n α) Nat (Monoid.Pow.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) A k)) (HPow.hPow.{max u1 u2, 0, max u1 u2} (Matrix.{u1, u1, u2} n n α) Nat (Matrix.{u1, u1, u2} n n α) (instHPow.{max u1 u2, 0} (Matrix.{u1, u1, u2} n n α) Nat (Monoid.Pow.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A) k)
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_pow Matrix.adjugate_powₓ'. -/
@[simp]
theorem adjugate_pow (A : Matrix n n α) (k : ℕ) : adjugate (A ^ k) = adjugate A ^ k :=
  by
  induction' k with k IH
  · simp
  · rw [pow_succ', mul_eq_mul, adjugate_mul_distrib, IH, ← mul_eq_mul, pow_succ]
#align matrix.adjugate_pow Matrix.adjugate_pow

/- warning: matrix.det_smul_adjugate_adjugate -> Matrix.det_smul_adjugate_adjugate is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A))) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (HSMul.hSMul.{u2, max u2 u1, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A))) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) A)
Case conversion may be inaccurate. Consider using '#align matrix.det_smul_adjugate_adjugate Matrix.det_smul_adjugate_adjugateₓ'. -/
theorem det_smul_adjugate_adjugate (A : Matrix n n α) :
    det A • adjugate (adjugate A) = det A ^ (Fintype.card n - 1) • A :=
  by
  have : A ⬝ (A.adjugate ⬝ A.adjugate.adjugate) = A ⬝ (A.det ^ (Fintype.card n - 1) • 1) := by
    rw [← adjugate_mul_distrib, adjugate_mul, adjugate_smul, adjugate_one]
  rwa [← Matrix.mul_assoc, mul_adjugate, Matrix.mul_smul, Matrix.mul_one, Matrix.smul_mul,
    Matrix.one_mul] at this
#align matrix.det_smul_adjugate_adjugate Matrix.det_smul_adjugate_adjugate

/- warning: matrix.adjugate_adjugate -> Matrix.adjugate_adjugate is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (Ne.{1} Nat (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (Ne.{1} Nat (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) A))
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_adjugate Matrix.adjugate_adjugateₓ'. -/
/-- Note that this is not true for `fintype.card n = 1` since `1 - 2 = 0` and not `-1`. -/
theorem adjugate_adjugate (A : Matrix n n α) (h : Fintype.card n ≠ 1) :
    adjugate (adjugate A) = det A ^ (Fintype.card n - 2) • A :=
  by
  -- get rid of the `- 2`
  cases' h_card : Fintype.card n with n'
  · haveI : IsEmpty n := fintype.card_eq_zero_iff.mp h_card
    apply Subsingleton.elim
  cases n'
  · exact (h h_card).elim
  rw [← h_card]
  -- express `A` as an evaluation of a polynomial in n^2 variables, and solve in the polynomial ring
  -- where `A'.det` is non-zero.
  let A' := mv_polynomial_X n n ℤ
  suffices adjugate (adjugate A') = det A' ^ (Fintype.card n - 2) • A' by
    rw [← mv_polynomial_X_map_matrix_aeval ℤ A, ← AlgHom.map_adjugate, ← AlgHom.map_adjugate, this,
      ← AlgHom.map_det, ← AlgHom.map_pow, AlgHom.mapMatrix_apply, AlgHom.mapMatrix_apply,
      Matrix.map_smul' _ _ _ (_root_.map_mul _)]
  have h_card' : Fintype.card n - 2 + 1 = Fintype.card n - 1 := by simp [h_card]
  have is_reg : IsSMulRegular (MvPolynomial (n × n) ℤ) (det A') := fun x y =>
    mul_left_cancel₀ (det_mv_polynomial_X_ne_zero n ℤ)
  apply is_reg.matrix
  rw [smul_smul, ← pow_succ, h_card', det_smul_adjugate_adjugate]
#align matrix.adjugate_adjugate Matrix.adjugate_adjugate

/- warning: matrix.adjugate_adjugate' -> Matrix.adjugate_adjugate' is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_6 : Nontrivial.{u1} n], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_5))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_5)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_5 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_6 : Nontrivial.{u1} n], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_5 A)) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_5) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5))))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_5)))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_5 A) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) A)
Case conversion may be inaccurate. Consider using '#align matrix.adjugate_adjugate' Matrix.adjugate_adjugate'ₓ'. -/
/-- A weaker version of `matrix.adjugate_adjugate` that uses `nontrivial`. -/
theorem adjugate_adjugate' (A : Matrix n n α) [Nontrivial n] :
    adjugate (adjugate A) = det A ^ (Fintype.card n - 2) • A :=
  adjugate_adjugate _ <| Fintype.one_lt_card.ne'
#align matrix.adjugate_adjugate' Matrix.adjugate_adjugate'

end Adjugate

end Matrix

