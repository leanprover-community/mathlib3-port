import Mathbin.Data.Zmod.Basic 
import Mathbin.NumberTheory.Padics.PadicIntegers

/-!

# Relating `ℤ_[p]` to `zmod (p ^ n)`

In this file we establish connections between the `p`-adic integers $\mathbb{Z}_p$
and the integers modulo powers of `p`, $\mathbb{Z}/p^n\mathbb{Z}$.

## Main declarations

We show that $\mathbb{Z}_p$ has a ring hom to $\mathbb{Z}/p^n\mathbb{Z}$ for each `n`.
The case for `n = 1` is handled separately, since it is used in the general construction
and we may want to use it without the `^1` getting in the way.
* `padic_int.to_zmod`: ring hom to `zmod p`
* `padic_int.to_zmod_pow`: ring hom to `zmod (p^n)`
* `padic_int.ker_to_zmod` / `padic_int.ker_to_zmod_pow`: the kernels of these maps are the ideals
  generated by `p^n`

We also establish the universal property of $\mathbb{Z}_p$ as a projective limit.
Given a family of compatible ring homs $f_k : R \to \mathbb{Z}/p^n\mathbb{Z}$,
there is a unique limit $R \to \mathbb{Z}_p$.
* `padic_int.lift`: the limit function
* `padic_int.lift_spec` / `padic_int.lift_unique`: the universal property

## Implementation notes

The ring hom constructions go through an auxiliary constructor `padic_int.to_zmod_hom`,
which removes some boilerplate code.

-/


noncomputable theory

open_locale Classical

open Nat LocalRing Padic

namespace PadicInt

variable {p : ℕ} [hp_prime : Fact p.prime]

include hp_prime

section RingHoms

/-! ### Ring homomorphisms to `zmod p` and `zmod (p ^ n)` -/


variable (p) (r : ℚ)

omit hp_prime

/--
`mod_part p r` is an integer that satisfies
`∥(r - mod_part p r : ℚ_[p])∥ < 1` when `∥(r : ℚ_[p])∥ ≤ 1`,
see `padic_int.norm_sub_mod_part`.
It is the unique non-negative integer that is `< p` with this property.

(Note that this definition assumes `r : ℚ`.
See `padic_int.zmod_repr` for a version that takes values in `ℕ`
and works for arbitrary `x : ℤ_[p]`.) -/
def mod_part : ℤ :=
  (r.num*gcd_a r.denom p) % p

include hp_prime

variable {p}

theorem mod_part_lt_p : mod_part p r < p :=
  by 
    convert Int.mod_lt _ _
    ·
      simp 
    ·
      exactModCast hp_prime.1.ne_zero

theorem mod_part_nonneg : 0 ≤ mod_part p r :=
  Int.mod_nonneg _$
    by 
      exactModCast hp_prime.1.ne_zero

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_unit_denom
(r : exprℚ())
(h : «expr ≤ »(«expr∥ ∥»((r : «exprℚ_[ ]»(p))), 1)) : is_unit (r.denom : «exprℤ_[ ]»(p)) :=
begin
  rw [expr is_unit_iff] [],
  apply [expr le_antisymm (r.denom : «exprℤ_[ ]»(p)).2],
  rw ["[", "<-", expr not_lt, ",", expr val_eq_coe, ",", expr coe_coe, "]"] [],
  intro [ident norm_denom_lt],
  have [ident hr] [":", expr «expr = »(«expr∥ ∥»((«expr * »(r, r.denom) : «exprℚ_[ ]»(p))), «expr∥ ∥»((r.num : «exprℚ_[ ]»(p))))] [],
  { rw_mod_cast [expr @rat.mul_denom_eq_num r] [],
    refl },
  rw [expr padic_norm_e.mul] ["at", ident hr],
  have [ident key] [":", expr «expr < »(«expr∥ ∥»((r.num : «exprℚ_[ ]»(p))), 1)] [],
  { calc
      «expr = »(_, _) : hr.symm
      «expr < »(..., «expr * »(1, 1)) : mul_lt_mul' h norm_denom_lt (norm_nonneg _) zero_lt_one
      «expr = »(..., 1) : mul_one 1 },
  have [] [":", expr «expr ∧ »(«expr ∣ »(«expr↑ »(p), r.num), «expr ∣ »((p : exprℤ()), r.denom))] [],
  { simp [] [] ["only"] ["[", "<-", expr norm_int_lt_one_iff_dvd, ",", "<-", expr padic_norm_e_of_padic_int, "]"] [] [],
    norm_cast [],
    exact [expr ⟨key, norm_denom_lt⟩] },
  apply [expr hp_prime.1.not_dvd_one],
  rwa ["[", "<-", expr r.cop.gcd_eq_one, ",", expr nat.dvd_gcd_iff, ",", "<-", expr int.coe_nat_dvd_left, ",", "<-", expr int.coe_nat_dvd, "]"] []
end

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem norm_sub_mod_part_aux
(r : exprℚ())
(h : «expr ≤ »(«expr∥ ∥»((r : «exprℚ_[ ]»(p))), 1)) : «expr ∣ »(«expr↑ »(p), «expr - »(r.num, «expr * »(«expr % »(«expr * »(r.num, r.denom.gcd_a p), p), «expr↑ »(r.denom)))) :=
begin
  rw ["<-", expr zmod.int_coe_zmod_eq_zero_iff_dvd] [],
  simp [] [] ["only"] ["[", expr int.cast_coe_nat, ",", expr zmod.nat_cast_mod p, ",", expr int.cast_mul, ",", expr int.cast_sub, "]"] [] [],
  have [] [] [":=", expr congr_arg (coe : exprℤ() → zmod p) (gcd_eq_gcd_ab r.denom p)],
  simp [] [] ["only"] ["[", expr int.cast_coe_nat, ",", expr add_zero, ",", expr int.cast_add, ",", expr zmod.nat_cast_self, ",", expr int.cast_mul, ",", expr zero_mul, "]"] [] ["at", ident this],
  push_cast [] [],
  rw ["[", expr mul_right_comm, ",", expr mul_assoc, ",", "<-", expr this, "]"] [],
  suffices [ident rdcp] [":", expr r.denom.coprime p],
  { rw [expr rdcp.gcd_eq_one] [],
    simp [] [] ["only"] ["[", expr mul_one, ",", expr cast_one, ",", expr sub_self, "]"] [] [] },
  apply [expr coprime.symm],
  apply [expr (coprime_or_dvd_of_prime hp_prime.1 _).resolve_right],
  rw ["[", "<-", expr int.coe_nat_dvd, ",", "<-", expr norm_int_lt_one_iff_dvd, ",", expr not_lt, "]"] [],
  apply [expr ge_of_eq],
  rw ["<-", expr is_unit_iff] [],
  exact [expr is_unit_denom r h]
end

theorem norm_sub_mod_part (h : ∥(r : ℚ_[p])∥ ≤ 1) : ∥(⟨r, h⟩ - mod_part p r : ℤ_[p])∥ < 1 :=
  by 
    let n := mod_part p r 
    byCases' aux : (⟨r, h⟩ - n : ℤ_[p]) = 0
    ·
      rw [aux, norm_zero]
      exact zero_lt_one 
    rw [norm_lt_one_iff_dvd, ←(is_unit_denom r h).dvd_mul_right]
    suffices  : «expr↑ » p ∣ r.num - n*r.denom
    ·
      convert (Int.castRingHom ℤ_[p]).map_dvd this 
      simp only [sub_mul, Int.cast_coe_nat, RingHom.eq_int_cast, Int.cast_mul, sub_left_inj, Int.cast_sub]
      apply Subtype.coe_injective 
      simp only [coe_mul, Subtype.coe_mk, coe_coe]
      rwModCast [@Rat.mul_denom_eq_num r]
      rfl 
    exact norm_sub_mod_part_aux r h

theorem exists_mem_range_of_norm_rat_le_one (h : ∥(r : ℚ_[p])∥ ≤ 1) :
  ∃ n : ℤ, 0 ≤ n ∧ n < p ∧ ∥(⟨r, h⟩ - n : ℤ_[p])∥ < 1 :=
  ⟨mod_part p r, mod_part_nonneg _, mod_part_lt_p _, norm_sub_mod_part _ h⟩

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem zmod_congr_of_sub_mem_span_aux
(n : exprℕ())
(x : «exprℤ_[ ]»(p))
(a b : exprℤ())
(ha : «expr ∈ »(«expr - »(x, a), (ideal.span {«expr ^ »(p, n)} : ideal «exprℤ_[ ]»(p))))
(hb : «expr ∈ »(«expr - »(x, b), (ideal.span {«expr ^ »(p, n)} : ideal «exprℤ_[ ]»(p)))) : «expr = »((a : zmod «expr ^ »(p, n)), b) :=
begin
  rw ["[", expr ideal.mem_span_singleton, "]"] ["at", ident ha, ident hb],
  rw ["[", "<-", expr sub_eq_zero, ",", "<-", expr int.cast_sub, ",", expr zmod.int_coe_zmod_eq_zero_iff_dvd, ",", expr int.coe_nat_pow, "]"] [],
  rw ["[", "<-", expr dvd_neg, ",", expr neg_sub, "]"] ["at", ident ha],
  have [] [] [":=", expr dvd_add ha hb],
  rwa ["[", expr sub_eq_add_neg, ",", expr sub_eq_add_neg, ",", expr add_assoc, ",", expr neg_add_cancel_left, ",", "<-", expr sub_eq_add_neg, ",", "<-", expr int.cast_sub, ",", expr pow_p_dvd_int_iff, "]"] ["at", ident this]
end

theorem zmod_congr_of_sub_mem_span (n : ℕ) (x : ℤ_[p]) (a b : ℕ) (ha : x - a ∈ (Ideal.span {p^n} : Ideal ℤ_[p]))
  (hb : x - b ∈ (Ideal.span {p^n} : Ideal ℤ_[p])) : (a : Zmod (p^n)) = b :=
  zmod_congr_of_sub_mem_span_aux n x a b ha hb

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem zmod_congr_of_sub_mem_max_ideal
(x : «exprℤ_[ ]»(p))
(m n : exprℕ())
(hm : «expr ∈ »(«expr - »(x, m), maximal_ideal «exprℤ_[ ]»(p)))
(hn : «expr ∈ »(«expr - »(x, n), maximal_ideal «exprℤ_[ ]»(p))) : «expr = »((m : zmod p), n) :=
begin
  rw [expr maximal_ideal_eq_span_p] ["at", ident hm, ident hn],
  have [] [] [":=", expr zmod_congr_of_sub_mem_span_aux 1 x m n],
  simp [] [] ["only"] ["[", expr pow_one, "]"] [] ["at", ident this],
  specialize [expr this hm hn],
  apply_fun [expr zmod.cast_hom (show «expr ∣ »(p, «expr ^ »(p, 1)), by rw [expr pow_one] []) (zmod p)] ["at", ident this] [],
  simpa [] [] ["only"] ["[", expr ring_hom.map_int_cast, "]"] [] []
end

variable (x : ℤ_[p])

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem exists_mem_range : «expr∃ , »((n : exprℕ()), «expr ∧ »(«expr < »(n, p), «expr ∈ »(«expr - »(x, n), maximal_ideal «exprℤ_[ ]»(p)))) :=
begin
  simp [] [] ["only"] ["[", expr maximal_ideal_eq_span_p, ",", expr ideal.mem_span_singleton, ",", "<-", expr norm_lt_one_iff_dvd, "]"] [] [],
  obtain ["⟨", ident r, ",", ident hr, "⟩", ":=", expr rat_dense (x : «exprℚ_[ ]»(p)) zero_lt_one],
  have [ident H] [":", expr «expr ≤ »(«expr∥ ∥»((r : «exprℚ_[ ]»(p))), 1)] [],
  { rw [expr norm_sub_rev] ["at", ident hr],
    calc
      «expr = »(_, «expr∥ ∥»(«expr + »(«expr - »((r : «exprℚ_[ ]»(p)), x), x))) : by ring_nf [] [] []
      «expr ≤ »(..., _) : padic_norm_e.nonarchimedean _ _
      «expr ≤ »(..., _) : max_le (le_of_lt hr) x.2 },
  obtain ["⟨", ident n, ",", ident hzn, ",", ident hnp, ",", ident hn, "⟩", ":=", expr exists_mem_range_of_norm_rat_le_one r H],
  lift [expr n] ["to", expr exprℕ()] ["using", expr hzn] [],
  use [expr n],
  split,
  { exact_mod_cast [expr hnp] },
  simp [] [] ["only"] ["[", expr norm_def, ",", expr coe_sub, ",", expr subtype.coe_mk, ",", expr coe_coe, "]"] [] ["at", ident hn, "⊢"],
  rw [expr show «expr = »((«expr - »(x, n) : «exprℚ_[ ]»(p)), «expr + »(«expr - »(x, r), «expr - »(r, n))), by ring []] [],
  apply [expr lt_of_le_of_lt (padic_norm_e.nonarchimedean _ _)],
  apply [expr max_lt hr],
  simpa [] [] [] [] [] ["using", expr hn]
end

/--
`zmod_repr x` is the unique natural number smaller than `p`
satisfying `∥(x - zmod_repr x : ℤ_[p])∥ < 1`.
-/
def zmod_repr : ℕ :=
  Classical.some (exists_mem_range x)

theorem zmod_repr_spec : zmod_repr x < p ∧ x - zmod_repr x ∈ maximal_ideal ℤ_[p] :=
  Classical.some_spec (exists_mem_range x)

theorem zmod_repr_lt_p : zmod_repr x < p :=
  (zmod_repr_spec _).1

theorem sub_zmod_repr_mem : x - zmod_repr x ∈ maximal_ideal ℤ_[p] :=
  (zmod_repr_spec _).2

/--
`to_zmod_hom` is an auxiliary constructor for creating ring homs from `ℤ_[p]` to `zmod v`.
-/
def to_zmod_hom (v : ℕ) (f : ℤ_[p] → ℕ) (f_spec : ∀ x, x - f x ∈ (Ideal.span {v} : Ideal ℤ_[p]))
  (f_congr :
    ∀ x : ℤ_[p] a b : ℕ,
      x - a ∈ (Ideal.span {v} : Ideal ℤ_[p]) → x - b ∈ (Ideal.span {v} : Ideal ℤ_[p]) → (a : Zmod v) = b) :
  ℤ_[p] →+* Zmod v :=
  { toFun := fun x => f x,
    map_zero' :=
      by 
        rw [f_congr (0 : ℤ_[p]) _ 0, cast_zero]
        ·
          exact f_spec _
        ·
          simp only [sub_zero, cast_zero, Submodule.zero_mem],
    map_one' :=
      by 
        rw [f_congr (1 : ℤ_[p]) _ 1, cast_one]
        ·
          exact f_spec _
        ·
          simp only [sub_self, cast_one, Submodule.zero_mem],
    map_add' :=
      by 
        intro x y 
        rw [f_congr (x+y) _ (f x+f y), cast_add]
        ·
          exact f_spec _
        ·
          convert Ideal.add_mem _ (f_spec x) (f_spec y)
          rw [cast_add]
          ring,
    map_mul' :=
      by 
        intro x y 
        rw [f_congr (x*y) _ (f x*f y), cast_mul]
        ·
          exact f_spec _
        ·
          let I : Ideal ℤ_[p] := Ideal.span {v}
          convert I.add_mem (I.mul_mem_left x (f_spec y)) (I.mul_mem_right (f y) (f_spec x))
          rw [cast_mul]
          ring }

/--
`to_zmod` is a ring hom from `ℤ_[p]` to `zmod p`,
with the equality `to_zmod x = (zmod_repr x : zmod p)`.
-/
def to_zmod : ℤ_[p] →+* Zmod p :=
  to_zmod_hom p zmod_repr
    (by 
      rw [←maximal_ideal_eq_span_p]
      exact sub_zmod_repr_mem)
    (by 
      rw [←maximal_ideal_eq_span_p]
      exact zmod_congr_of_sub_mem_max_ideal)

/--
`z - (to_zmod z : ℤ_[p])` is contained in the maximal ideal of `ℤ_[p]`, for every `z : ℤ_[p]`.

The coercion from `zmod p` to `ℤ_[p]` is `zmod.has_coe_t`,
which coerces `zmod p` into artibrary rings.
This is unfortunate, but a consequence of the fact that we allow `zmod p`
to coerce to rings of arbitrary characteristic, instead of only rings of characteristic `p`.
This coercion is only a ring homomorphism if it coerces into a ring whose characteristic divides
`p`. While this is not the case here we can still make use of the coercion.
-/
theorem to_zmod_spec (z : ℤ_[p]) : z - (to_zmod z : ℤ_[p]) ∈ maximal_ideal ℤ_[p] :=
  by 
    convert sub_zmod_repr_mem z using 2
    dsimp [to_zmod, to_zmod_hom]
    (
      rcases exists_eq_add_of_lt hp_prime.1.Pos with ⟨p', rfl⟩)
    change «expr↑ » (Zmod.val _) = _ 
    simp only [Zmod.val_nat_cast, add_zeroₓ, add_def, Nat.cast_inj, zero_addₓ]
    apply mod_eq_of_lt 
    simpa only [zero_addₓ] using zmod_repr_lt_p z

theorem ker_to_zmod : (to_zmod : ℤ_[p] →+* Zmod p).ker = maximal_ideal ℤ_[p] :=
  by 
    ext x 
    rw [RingHom.mem_ker]
    split 
    ·
      intro h 
      simpa only [h, Zmod.cast_zero, sub_zero] using to_zmod_spec x
    ·
      intro h 
      rw [←sub_zero x] at h 
      dsimp [to_zmod, to_zmod_hom]
      convert zmod_congr_of_sub_mem_max_ideal x _ 0 _ h 
      apply sub_zmod_repr_mem

/-- `appr n x` gives a value `v : ℕ` such that `x` and `↑v : ℤ_p` are congruent mod `p^n`.
See `appr_spec`. -/
noncomputable def appr : ℤ_[p] → ℕ → ℕ
| x, 0 => 0
| x, n+1 =>
  let y := x - appr x n 
  if hy : y = 0 then appr x n else
    let u := unit_coeff hy 
    appr x n+(p^n)*(to_zmod ((u : ℤ_[p])*p^(y.valuation - n).natAbs)).val

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem appr_lt (x : «exprℤ_[ ]»(p)) (n : exprℕ()) : «expr < »(x.appr n, «expr ^ »(p, n)) :=
begin
  induction [expr n] [] ["with", ident n, ident ih] ["generalizing", ident x],
  { simp [] [] ["only"] ["[", expr appr, ",", expr succ_pos', ",", expr pow_zero, "]"] [] [] },
  simp [] [] ["only"] ["[", expr appr, ",", expr ring_hom.map_nat_cast, ",", expr zmod.nat_cast_self, ",", expr ring_hom.map_pow, ",", expr int.nat_abs, ",", expr ring_hom.map_mul, "]"] [] [],
  have [ident hp] [":", expr «expr < »(«expr ^ »(p, n), «expr ^ »(p, «expr + »(n, 1)))] [],
  { apply [expr pow_lt_pow hp_prime.1.one_lt (lt_add_one n)] },
  split_ifs [] ["with", ident h],
  { apply [expr lt_trans (ih _) hp] },
  { calc
      «expr < »(_, «expr + »(«expr ^ »(p, n), «expr * »(«expr ^ »(p, n), «expr - »(p, 1)))) : _
      «expr = »(..., «expr ^ »(p, «expr + »(n, 1))) : _,
    { apply [expr add_lt_add_of_lt_of_le (ih _)],
      apply [expr nat.mul_le_mul_left],
      apply [expr le_pred_of_lt],
      apply [expr zmod.val_lt] },
    { rw ["[", expr mul_tsub, ",", expr mul_one, ",", "<-", expr pow_succ', "]"] [],
      apply [expr add_tsub_cancel_of_le (le_of_lt hp)] } }
end

theorem appr_mono (x : ℤ_[p]) : Monotone x.appr :=
  by 
    apply monotone_nat_of_le_succ 
    intro n 
    dsimp [appr]
    splitIfs
    ·
      rfl 
    apply Nat.le_add_rightₓ

theorem dvd_appr_sub_appr (x : ℤ_[p]) (m n : ℕ) (h : m ≤ n) : (p^m) ∣ x.appr n - x.appr m :=
  by 
    obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h 
    clear h 
    induction' k with k ih
    ·
      simp only [add_zeroₓ, tsub_self, dvd_zero]
    rw [Nat.succ_eq_add_one, ←add_assocₓ]
    dsimp [appr]
    splitIfs with h
    ·
      exact ih 
    rw [add_commₓ, add_tsub_assoc_of_le (appr_mono _ (Nat.le_add_rightₓ m k))]
    apply dvd_add _ ih 
    apply dvd_mul_of_dvd_left 
    apply pow_dvd_pow _ (Nat.le_add_rightₓ m k)

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem appr_spec
(n : exprℕ()) : ∀
x : «exprℤ_[ ]»(p), «expr ∈ »(«expr - »(x, appr x n), (ideal.span {«expr ^ »(p, n)} : ideal «exprℤ_[ ]»(p))) :=
begin
  simp [] [] ["only"] ["[", expr ideal.mem_span_singleton, "]"] [] [],
  induction [expr n] [] ["with", ident n, ident ih] [],
  { simp [] [] ["only"] ["[", expr is_unit_one, ",", expr is_unit.dvd, ",", expr pow_zero, ",", expr forall_true_iff, "]"] [] [] },
  intro [ident x],
  dsimp ["only"] ["[", expr appr, "]"] [] [],
  split_ifs [] ["with", ident h],
  { rw [expr h] [],
    apply [expr dvd_zero] },
  push_cast [] [],
  rw [expr sub_add_eq_sub_sub] [],
  obtain ["⟨", ident c, ",", ident hc, "⟩", ":=", expr ih x],
  simp [] [] ["only"] ["[", expr ring_hom.map_nat_cast, ",", expr zmod.nat_cast_self, ",", expr ring_hom.map_pow, ",", expr ring_hom.map_mul, ",", expr zmod.nat_cast_val, "]"] [] [],
  have [ident hc'] [":", expr «expr ≠ »(c, 0)] [],
  { rintro [ident rfl],
    simp [] [] ["only"] ["[", expr mul_zero, "]"] [] ["at", ident hc],
    contradiction },
  conv_rhs [] [] { congr,
    simp ["only"] ["[", expr hc, "]"] [] },
  rw [expr show «expr = »(«expr - »(x, «expr↑ »(appr x n)).valuation, «expr * »(«expr ^ »(«expr↑ »(p), n), c).valuation), { rw [expr hc] [] }] [],
  rw ["[", expr valuation_p_pow_mul _ _ hc', ",", expr add_sub_cancel', ",", expr pow_succ', ",", "<-", expr mul_sub, "]"] [],
  apply [expr mul_dvd_mul_left],
  obtain [ident hc0, "|", ident hc0, ":=", expr c.valuation.nat_abs.eq_zero_or_pos],
  { simp [] [] ["only"] ["[", expr hc0, ",", expr mul_one, ",", expr pow_zero, "]"] [] [],
    rw ["[", expr mul_comm, ",", expr unit_coeff_spec h, "]"] ["at", ident hc],
    suffices [] [":", expr «expr = »(c, unit_coeff h)],
    { rw ["[", "<-", expr this, ",", "<-", expr ideal.mem_span_singleton, ",", "<-", expr maximal_ideal_eq_span_p, "]"] [],
      apply [expr to_zmod_spec] },
    obtain ["⟨", ident c, ",", ident rfl, "⟩", ":", expr is_unit c],
    { rw [expr int.nat_abs_eq_zero] ["at", ident hc0],
      rw ["[", expr is_unit_iff, ",", expr norm_eq_pow_val hc', ",", expr hc0, ",", expr neg_zero, ",", expr zpow_zero, "]"] [] },
    rw [expr discrete_valuation_ring.unit_mul_pow_congr_unit _ _ _ _ _ hc] [],
    exact [expr irreducible_p] },
  { rw [expr zero_pow hc0] [],
    simp [] [] ["only"] ["[", expr sub_zero, ",", expr zmod.cast_zero, ",", expr mul_zero, "]"] [] [],
    rw [expr unit_coeff_spec hc'] [],
    exact [expr (dvd_pow_self _ hc0.ne').mul_left _] }
end

/-- A ring hom from `ℤ_[p]` to `zmod (p^n)`, with underlying function `padic_int.appr n`. -/
def to_zmod_pow (n : ℕ) : ℤ_[p] →+* Zmod (p^n) :=
  to_zmod_hom (p^n) (fun x => appr x n)
    (by 
      intros 
      convert appr_spec n _ using 1
      simp )
    (by 
      intro x a b ha hb 
      apply zmod_congr_of_sub_mem_span n x a b
      ·
        simpa using ha
      ·
        simpa using hb)

theorem ker_to_zmod_pow (n : ℕ) : (to_zmod_pow n : ℤ_[p] →+* Zmod (p^n)).ker = Ideal.span {p^n} :=
  by 
    ext x 
    rw [RingHom.mem_ker]
    split 
    ·
      intro h 
      suffices  : x.appr n = 0
      ·
        convert appr_spec n x 
        simp only [this, sub_zero, cast_zero]
      dsimp [to_zmod_pow, to_zmod_hom]  at h 
      rw [Zmod.nat_coe_zmod_eq_zero_iff_dvd] at h 
      apply eq_zero_of_dvd_of_lt h (appr_lt _ _)
    ·
      intro h 
      rw [←sub_zero x] at h 
      dsimp [to_zmod_pow, to_zmod_hom]
      rw [zmod_congr_of_sub_mem_span n x _ 0 _ h, cast_zero]
      apply appr_spec

@[simp]
theorem zmod_cast_comp_to_zmod_pow (m n : ℕ) (h : m ≤ n) :
  (Zmod.castHom (pow_dvd_pow p h) (Zmod (p^m))).comp (to_zmod_pow n) = to_zmod_pow m :=
  by 
    apply Zmod.ring_hom_eq_of_ker_eq 
    ext x 
    rw [RingHom.mem_ker, RingHom.mem_ker]
    simp only [Function.comp_app, Zmod.cast_hom_apply, RingHom.coe_comp]
    simp only [to_zmod_pow, to_zmod_hom, RingHom.coe_mk]
    rw [Zmod.cast_nat_cast (pow_dvd_pow p h), zmod_congr_of_sub_mem_span m (x.appr n) (x.appr n) (x.appr m)]
    ·
      rw [sub_self]
      apply Ideal.zero_mem _
    ·
      rw [Ideal.mem_span_singleton]
      rcases dvd_appr_sub_appr x m n h with ⟨c, hc⟩
      use c 
      rw [←Nat.cast_sub (appr_mono _ h), hc, Nat.cast_mul, Nat.cast_pow]
    ·
      infer_instance

@[simp]
theorem cast_to_zmod_pow (m n : ℕ) (h : m ≤ n) (x : ℤ_[p]) : «expr↑ » (to_zmod_pow n x) = to_zmod_pow m x :=
  by 
    rw [←zmod_cast_comp_to_zmod_pow _ _ h]
    rfl

theorem dense_range_nat_cast : DenseRange (Nat.cast : ℕ → ℤ_[p]) :=
  by 
    intro x 
    rw [Metric.mem_closure_range_iff]
    intro ε hε 
    obtain ⟨n, hn⟩ := exists_pow_neg_lt p hε 
    use x.appr n 
    rw [dist_eq_norm]
    apply lt_of_le_of_ltₓ _ hn 
    rw [norm_le_pow_iff_mem_span_pow]
    apply appr_spec

theorem dense_range_int_cast : DenseRange (Int.cast : ℤ → ℤ_[p]) :=
  by 
    intro x 
    apply dense_range_nat_cast.induction_on x
    ·
      exact is_closed_closure
    ·
      intro a 
      change (a.cast : ℤ_[p]) with (a : ℤ).cast 
      apply subset_closure 
      exact Set.mem_range_self _

end RingHoms

section lift

/-! ### Universal property as projective limit -/


open CauSeq PadicSeq

variable {R : Type _} [CommRingₓ R] (f : ∀ k : ℕ, R →+* Zmod (p^k))
  (f_compat : ∀ k1 k2 hk : k1 ≤ k2, (Zmod.castHom (pow_dvd_pow p hk) _).comp (f k2) = f k1)

omit hp_prime

/--
Given a family of ring homs `f : Π n : ℕ, R →+* zmod (p ^ n)`,
`nth_hom f r` is an integer-valued sequence
whose `n`th value is the unique integer `k` such that `0 ≤ k < p ^ n`
and `f n r = (k : zmod (p ^ n))`.
-/
def nth_hom (r : R) : ℕ → ℤ :=
  fun n => (f n r : Zmod (p^n)).val

@[simp]
theorem nth_hom_zero : nth_hom f 0 = 0 :=
  by 
    simp [nth_hom] <;> rfl

variable {f}

include hp_prime

include f_compat

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem pow_dvd_nth_hom_sub
(r : R)
(i j : exprℕ())
(h : «expr ≤ »(i, j)) : «expr ∣ »(«expr ^ »(«expr↑ »(p), i), «expr - »(nth_hom f r j, nth_hom f r i)) :=
begin
  specialize [expr f_compat i j h],
  rw ["[", "<-", expr int.coe_nat_pow, ",", "<-", expr zmod.int_coe_zmod_eq_zero_iff_dvd, ",", expr int.cast_sub, "]"] [],
  dsimp [] ["[", expr nth_hom, "]"] [] [],
  rw ["[", "<-", expr f_compat, ",", expr ring_hom.comp_apply, "]"] [],
  have [] [":", expr fact «expr > »(«expr ^ »(p, i), 0)] [":=", expr ⟨pow_pos hp_prime.1.pos _⟩],
  have [] [":", expr fact «expr > »(«expr ^ »(p, j), 0)] [":=", expr ⟨pow_pos hp_prime.1.pos _⟩],
  unfreezingI { simp [] [] ["only"] ["[", expr zmod.cast_id, ",", expr zmod.cast_hom_apply, ",", expr sub_self, ",", expr zmod.nat_cast_val, "]"] [] [] }
end

theorem is_cau_seq_nth_hom (r : R) : IsCauSeq (padicNorm p) fun n => nth_hom f r n :=
  by 
    intro ε hε 
    obtain ⟨k, hk⟩ : ∃ k : ℕ, (p^-(«expr↑ » (k : ℕ) : ℤ) : ℚ) < ε := exists_pow_neg_lt_rat p hε 
    use k 
    intro j hj 
    refine' lt_of_le_of_ltₓ _ hk 
    normCast 
    rw [←padicNorm.dvd_iff_norm_le]
    exactModCast pow_dvd_nth_hom_sub f_compat r k j hj

/--
`nth_hom_seq f_compat r` bundles `padic_int.nth_hom f r`
as a Cauchy sequence of rationals with respect to the `p`-adic norm.
The `n`th value of the sequence is `((f n r).val : ℚ)`.
-/
def nth_hom_seq (r : R) : PadicSeq p :=
  ⟨fun n => nth_hom f r n, is_cau_seq_nth_hom f_compat r⟩

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem nth_hom_seq_one : «expr ≈ »(nth_hom_seq f_compat 1, 1) :=
begin
  intros [ident ε, ident hε],
  change [expr «expr < »(_, _)] [] ["at", ident hε],
  use [expr 1],
  intros [ident j, ident hj],
  haveI [] [":", expr fact «expr < »(1, «expr ^ »(p, j))] [":=", expr ⟨nat.one_lt_pow _ _ (by linarith [] [] []) hp_prime.1.one_lt⟩],
  simp [] [] [] ["[", expr nth_hom_seq, ",", expr nth_hom, ",", expr zmod.val_one, ",", expr hε, "]"] [] []
end

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem nth_hom_seq_add
(r
 s : R) : «expr ≈ »(nth_hom_seq f_compat «expr + »(r, s), «expr + »(nth_hom_seq f_compat r, nth_hom_seq f_compat s)) :=
begin
  intros [ident ε, ident hε],
  obtain ["⟨", ident n, ",", ident hn, "⟩", ":=", expr exists_pow_neg_lt_rat p hε],
  use [expr n],
  intros [ident j, ident hj],
  dsimp [] ["[", expr nth_hom_seq, "]"] [] [],
  apply [expr lt_of_le_of_lt _ hn],
  rw ["[", "<-", expr int.cast_add, ",", "<-", expr int.cast_sub, ",", "<-", expr padic_norm.dvd_iff_norm_le, ",", "<-", expr zmod.int_coe_zmod_eq_zero_iff_dvd, "]"] [],
  dsimp [] ["[", expr nth_hom, "]"] [] [],
  have [] [":", expr fact «expr > »(«expr ^ »(p, n), 0)] [":=", expr ⟨pow_pos hp_prime.1.pos _⟩],
  have [] [":", expr fact «expr > »(«expr ^ »(p, j), 0)] [":=", expr ⟨pow_pos hp_prime.1.pos _⟩],
  unfreezingI { simp [] [] ["only"] ["[", expr int.cast_coe_nat, ",", expr int.cast_add, ",", expr ring_hom.map_add, ",", expr int.cast_sub, ",", expr zmod.nat_cast_val, "]"] [] [] },
  rw ["[", expr zmod.cast_add (show «expr ∣ »(«expr ^ »(p, n), «expr ^ »(p, j)), from _), ",", expr sub_self, "]"] [],
  { apply_instance },
  { apply [expr pow_dvd_pow],
    linarith [] ["only"] ["[", expr hj, "]"] }
end

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem nth_hom_seq_mul
(r
 s : R) : «expr ≈ »(nth_hom_seq f_compat «expr * »(r, s), «expr * »(nth_hom_seq f_compat r, nth_hom_seq f_compat s)) :=
begin
  intros [ident ε, ident hε],
  obtain ["⟨", ident n, ",", ident hn, "⟩", ":=", expr exists_pow_neg_lt_rat p hε],
  use [expr n],
  intros [ident j, ident hj],
  dsimp [] ["[", expr nth_hom_seq, "]"] [] [],
  apply [expr lt_of_le_of_lt _ hn],
  rw ["[", "<-", expr int.cast_mul, ",", "<-", expr int.cast_sub, ",", "<-", expr padic_norm.dvd_iff_norm_le, ",", "<-", expr zmod.int_coe_zmod_eq_zero_iff_dvd, "]"] [],
  dsimp [] ["[", expr nth_hom, "]"] [] [],
  have [] [":", expr fact «expr > »(«expr ^ »(p, n), 0)] [":=", expr ⟨pow_pos hp_prime.1.pos _⟩],
  have [] [":", expr fact «expr > »(«expr ^ »(p, j), 0)] [":=", expr ⟨pow_pos hp_prime.1.pos _⟩],
  unfreezingI { simp [] [] ["only"] ["[", expr int.cast_coe_nat, ",", expr int.cast_mul, ",", expr int.cast_sub, ",", expr ring_hom.map_mul, ",", expr zmod.nat_cast_val, "]"] [] [] },
  rw ["[", expr zmod.cast_mul (show «expr ∣ »(«expr ^ »(p, n), «expr ^ »(p, j)), from _), ",", expr sub_self, "]"] [],
  { apply_instance },
  { apply [expr pow_dvd_pow],
    linarith [] ["only"] ["[", expr hj, "]"] }
end

/--
`lim_nth_hom f_compat r` is the limit of a sequence `f` of compatible ring homs `R →+* zmod (p^k)`.
This is itself a ring hom: see `padic_int.lift`.
-/
def lim_nth_hom (r : R) : ℤ_[p] :=
  of_int_seq (nth_hom f r) (is_cau_seq_nth_hom f_compat r)

theorem lim_nth_hom_spec (r : R) :
  ∀ ε : ℝ, 0 < ε → ∃ N : ℕ, ∀ n _ : n ≥ N, ∥lim_nth_hom f_compat r - nth_hom f r n∥ < ε :=
  by 
    intro ε hε 
    obtain ⟨ε', hε'0, hε'⟩ : ∃ v : ℚ, (0 : ℝ) < v ∧ «expr↑ » v < ε := exists_rat_btwn hε 
    normCast  at hε'0 
    obtain ⟨N, hN⟩ := padicNormE.defn (nth_hom_seq f_compat r) hε'0 
    use N 
    intro n hn 
    apply lt_transₓ _ hε' 
    change «expr↑ » (padicNormE _) < _ 
    normCast 
    convert hN _ hn 
    simp [nth_hom, lim_nth_hom, nth_hom_seq, of_int_seq]

theorem lim_nth_hom_zero : lim_nth_hom f_compat 0 = 0 :=
  by 
    simp [lim_nth_hom] <;> rfl

theorem lim_nth_hom_one : lim_nth_hom f_compat 1 = 1 :=
  Subtype.ext$ Quot.sound$ nth_hom_seq_one _

theorem lim_nth_hom_add (r s : R) : lim_nth_hom f_compat (r+s) = lim_nth_hom f_compat r+lim_nth_hom f_compat s :=
  Subtype.ext$ Quot.sound$ nth_hom_seq_add _ _ _

theorem lim_nth_hom_mul (r s : R) : lim_nth_hom f_compat (r*s) = lim_nth_hom f_compat r*lim_nth_hom f_compat s :=
  Subtype.ext$ Quot.sound$ nth_hom_seq_mul _ _ _

/--
`lift f_compat` is the limit of a sequence `f` of compatible ring homs `R →+* zmod (p^k)`,
with the equality `lift f_compat r = padic_int.lim_nth_hom f_compat r`.
-/
def lift : R →+* ℤ_[p] :=
  { toFun := lim_nth_hom f_compat, map_one' := lim_nth_hom_one f_compat, map_mul' := lim_nth_hom_mul f_compat,
    map_zero' := lim_nth_hom_zero f_compat, map_add' := lim_nth_hom_add f_compat }

omit f_compat

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem lift_sub_val_mem_span
(r : R)
(n : exprℕ()) : «expr ∈ »(«expr - »(lift f_compat r, (f n r).val), (ideal.span {«expr ^ »(«expr↑ »(p), n)} : ideal «exprℤ_[ ]»(p))) :=
begin
  obtain ["⟨", ident k, ",", ident hk, "⟩", ":=", expr lim_nth_hom_spec f_compat r _ (show «expr < »((0 : exprℝ()), «expr ^ »(p, («expr- »(n) : exprℤ()))), from nat.zpow_pos_of_pos hp_prime.1.pos _)],
  have [] [] [":=", expr le_of_lt (hk (max n k) (le_max_right _ _))],
  rw [expr norm_le_pow_iff_mem_span_pow] ["at", ident this],
  dsimp [] ["[", expr lift, "]"] [] [],
  rw [expr sub_eq_sub_add_sub (lim_nth_hom f_compat r) _ «expr↑ »(nth_hom f r (max n k))] [],
  apply [expr ideal.add_mem _ _ this],
  rw ["[", expr ideal.mem_span_singleton, "]"] [],
  simpa [] [] ["only"] ["[", expr ring_hom.eq_int_cast, ",", expr ring_hom.map_pow, ",", expr int.cast_sub, "]"] [] ["using", expr (int.cast_ring_hom «exprℤ_[ ]»(p)).map_dvd (pow_dvd_nth_hom_sub f_compat r n (max n k) (le_max_left _ _))]
end

-- error in NumberTheory.Padics.RingHoms: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/--
One part of the universal property of `ℤ_[p]` as a projective limit.
See also `padic_int.lift_unique`.
-/ theorem lift_spec (n : exprℕ()) : «expr = »((to_zmod_pow n).comp (lift f_compat), f n) :=
begin
  ext [] [ident r] [],
  haveI [] [":", expr fact «expr < »(0, «expr ^ »(p, n))] [":=", expr ⟨pow_pos hp_prime.1.pos n⟩],
  rw ["[", expr ring_hom.comp_apply, ",", "<-", expr zmod.nat_cast_zmod_val (f n r), ",", "<-", expr (to_zmod_pow n).map_nat_cast, ",", "<-", expr sub_eq_zero, ",", "<-", expr ring_hom.map_sub, ",", "<-", expr ring_hom.mem_ker, ",", expr ker_to_zmod_pow, "]"] [],
  apply [expr lift_sub_val_mem_span]
end

/--
One part of the universal property of `ℤ_[p]` as a projective limit.
See also `padic_int.lift_spec`.
-/
theorem lift_unique (g : R →+* ℤ_[p]) (hg : ∀ n, (to_zmod_pow n).comp g = f n) : lift f_compat = g :=
  by 
    ext1 r 
    apply eq_of_forall_dist_le 
    intro ε hε 
    obtain ⟨n, hn⟩ := exists_pow_neg_lt p hε 
    apply le_transₓ _ (le_of_ltₓ hn)
    rw [dist_eq_norm, norm_le_pow_iff_mem_span_pow, ←ker_to_zmod_pow, RingHom.mem_ker, RingHom.map_sub,
      ←RingHom.comp_apply, ←RingHom.comp_apply, lift_spec, hg, sub_self]

@[simp]
theorem lift_self (z : ℤ_[p]) : @lift p _ ℤ_[p] _ to_zmod_pow zmod_cast_comp_to_zmod_pow z = z :=
  by 
    show _ = RingHom.id _ z 
    rw [@lift_unique p _ ℤ_[p] _ _ zmod_cast_comp_to_zmod_pow (RingHom.id ℤ_[p])]
    intro 
    rw [RingHom.comp_id]

end lift

theorem ext_of_to_zmod_pow {x y : ℤ_[p]} : (∀ n, to_zmod_pow n x = to_zmod_pow n y) ↔ x = y :=
  by 
    split 
    ·
      intro h 
      rw [←lift_self x, ←lift_self y]
      simp [lift, lim_nth_hom, nth_hom, h]
    ·
      rintro rfl _ 
      rfl

theorem to_zmod_pow_eq_iff_ext {R : Type _} [CommRingₓ R] {g g' : R →+* ℤ_[p]} :
  (∀ n, (to_zmod_pow n).comp g = (to_zmod_pow n).comp g') ↔ g = g' :=
  by 
    split 
    ·
      intro hg 
      ext x : 1
      apply ext_of_to_zmod_pow.mp 
      intro n 
      show (to_zmod_pow n).comp g x = (to_zmod_pow n).comp g' x 
      rw [hg n]
    ·
      rintro rfl _ 
      rfl

end PadicInt

