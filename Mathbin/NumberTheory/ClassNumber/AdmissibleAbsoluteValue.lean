/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen

! This file was ported from Lean 3 source module number_theory.class_number.admissible_absolute_value
! leanprover-community/mathlib commit d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Real.Basic
import Mathbin.Combinatorics.Pigeonhole
import Mathbin.Algebra.Order.EuclideanAbsoluteValue

/-!
# Admissible absolute values
This file defines a structure `absolute_value.is_admissible` which we use to show the class number
of the ring of integers of a global field is finite.

## Main definitions

 * `absolute_value.is_admissible abv` states the absolute value `abv : R ‚Üí ‚Ñ§`
   respects the Euclidean domain structure on `R`, and that a large enough set
   of elements of `R^n` contains a pair of elements whose remainders are
   pointwise close together.

## Main results

 * `absolute_value.abs_is_admissible` shows the "standard" absolute value on `‚Ñ§`,
   mapping negative `x` to `-x`, is admissible.
 * `polynomial.card_pow_degree_is_admissible` shows `card_pow_degree`,
   mapping `p : polynomial ùîΩ_q` to `q ^ degree p`, is admissible
-/


-- mathport name: ¬´expr ‚â∫ ¬ª
local infixl:50 " ‚â∫ " => EuclideanDomain.r

namespace AbsoluteValue

variable {R : Type _} [EuclideanDomain R]

variable (abv : AbsoluteValue R ‚Ñ§)

#print AbsoluteValue.IsAdmissible /-
/-- An absolute value `R ‚Üí ‚Ñ§` is admissible if it respects the Euclidean domain
structure and a large enough set of elements in `R^n` will contain a pair of
elements whose remainders are pointwise close together. -/
structure IsAdmissible extends IsEuclidean abv where
  card : ‚Ñù ‚Üí ‚Ñï
  exists_partition' :
    ‚àÄ (n : ‚Ñï) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {b : R} (hb : b ‚â† 0) (A : Fin n ‚Üí R),
      ‚àÉ t : Fin n ‚Üí Fin (card Œµ), ‚àÄ i‚ÇÄ i‚ÇÅ, t i‚ÇÄ = t i‚ÇÅ ‚Üí (abv (A i‚ÇÅ % b - A i‚ÇÄ % b) : ‚Ñù) < abv b ‚Ä¢ Œµ
#align absolute_value.is_admissible AbsoluteValue.IsAdmissible
-/

attribute [protected] is_admissible.card

namespace IsAdmissible

variable {abv}

/- warning: absolute_value.is_admissible.exists_partition -> AbsoluteValue.IsAdmissible.exists_partition is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : EuclideanDomain.{u1} R] {abv : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))} {Œπ : Type.{u2}} [_inst_2 : Fintype.{u2} Œπ] {Œµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Œµ) -> (forall {b : R}, (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))))))) -> (forall (A : Œπ -> R) (h : AbsoluteValue.IsAdmissible.{u1} R _inst_1 abv), Exists.{succ u2} (Œπ -> (Fin (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ))) (fun (t : Œπ -> (Fin (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ))) => forall (i‚ÇÄ : Œπ) (i‚ÇÅ : Œπ), (Eq.{1} (Fin (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ)) (t i‚ÇÄ) (t i‚ÇÅ)) -> (LT.lt.{0} Real Real.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTC‚Çì.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => R -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1)))))))) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.hasMod.{u1} R _inst_1)) (A i‚ÇÅ) b) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.hasMod.{u1} R _inst_1)) (A i‚ÇÄ) b)))) (SMul.smul.{0, 0} Int Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.addGroup)) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => R -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) abv b) Œµ)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : EuclideanDomain.{u1} R] {abv : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))} {Œπ : Type.{u2}} [_inst_2 : Fintype.{u2} Œπ] {Œµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Œµ) -> (forall {b : R}, (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))) -> (forall (A : Œπ -> R) (h : AbsoluteValue.IsAdmissible.{u1} R _inst_1 abv), Exists.{succ u2} (Œπ -> (Fin (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ))) (fun (t : Œπ -> (Fin (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ))) => forall (i‚ÇÄ : Œπ) (i‚ÇÅ : Œπ), (Eq.{1} (Fin (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ)) (t i‚ÇÄ) (t i‚ÇÅ)) -> (LT.lt.{0} Real Real.instLTReal (Int.cast.{0} Real Real.intCast (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R Int (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1)))) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.instMod.{u1} R _inst_1)) (A i‚ÇÅ) b) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.instMod.{u1} R _inst_1)) (A i‚ÇÄ) b)))) (HSMul.hSMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) b) Real Real (instHSMul.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) b) Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.instAddGroupReal))) (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R Int (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) abv b) Œµ)))))
Case conversion may be inaccurate. Consider using '#align absolute_value.is_admissible.exists_partition AbsoluteValue.IsAdmissible.exists_partition‚Çì'. -/
/-- For all `Œµ > 0` and finite families `A`, we can partition the remainders of `A` mod `b`
into `abv.card Œµ` sets, such that all elements in each part of remainders are close together. -/
theorem exists_partition {Œπ : Type _} [Fintype Œπ] {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {b : R} (hb : b ‚â† 0)
    (A : Œπ ‚Üí R) (h : abv.IsAdmissible) :
    ‚àÉ t : Œπ ‚Üí Fin (h.card Œµ), ‚àÄ i‚ÇÄ i‚ÇÅ, t i‚ÇÄ = t i‚ÇÅ ‚Üí (abv (A i‚ÇÅ % b - A i‚ÇÄ % b) : ‚Ñù) < abv b ‚Ä¢ Œµ :=
  by
  let e := Fintype.equivFin Œπ
  obtain ‚ü®t, ht‚ü© := h.exists_partition' (Fintype.card Œπ) hŒµ hb (A ‚àò e.symm)
  refine' ‚ü®t ‚àò e, fun i‚ÇÄ i‚ÇÅ h => _‚ü©
  convert ht (e i‚ÇÄ) (e i‚ÇÅ) h <;> simp only [e.symm_apply_apply]
#align absolute_value.is_admissible.exists_partition AbsoluteValue.IsAdmissible.exists_partition

/- warning: absolute_value.is_admissible.exists_approx_aux -> AbsoluteValue.IsAdmissible.exists_approx_aux is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : EuclideanDomain.{u1} R] {abv : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))} (n : Nat) (h : AbsoluteValue.IsAdmissible.{u1} R _inst_1 abv) {Œµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Œµ) -> (forall {b : R}, (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))))))) -> (forall (A : (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) -> (Fin n) -> R), Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) (fun (i‚ÇÄ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) => Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) (fun (i‚ÇÅ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) => And (Ne.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) i‚ÇÄ i‚ÇÅ) (forall (k : Fin n), LT.lt.{0} Real Real.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTC‚Çì.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => R -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1)))))))) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.hasMod.{u1} R _inst_1)) (A i‚ÇÅ k) b) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.hasMod.{u1} R _inst_1)) (A i‚ÇÄ k) b)))) (SMul.smul.{0, 0} Int Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.addGroup)) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => R -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) abv b) Œµ))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : EuclideanDomain.{u1} R] {abv : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))} (n : Nat) (h : AbsoluteValue.IsAdmissible.{u1} R _inst_1 abv) {Œµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Œµ) -> (forall {b : R}, (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))) -> (forall (A : (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) -> (Fin n) -> R), Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) (fun (i‚ÇÄ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) => Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) (fun (i‚ÇÅ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) => And (Ne.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) n))) i‚ÇÄ i‚ÇÅ) (forall (k : Fin n), LT.lt.{0} Real Real.instLTReal (Int.cast.{0} Real Real.intCast (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R Int (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1)))) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.instMod.{u1} R _inst_1)) (A i‚ÇÅ k) b) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.instMod.{u1} R _inst_1)) (A i‚ÇÄ k) b)))) (HSMul.hSMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) b) Real Real (instHSMul.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) b) Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.instAddGroupReal))) (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R Int (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) abv b) Œµ))))))
Case conversion may be inaccurate. Consider using '#align absolute_value.is_admissible.exists_approx_aux AbsoluteValue.IsAdmissible.exists_approx_aux‚Çì'. -/
/-- Any large enough family of vectors in `R^n` has a pair of elements
whose remainders are close together, pointwise. -/
theorem exists_approx_aux (n : ‚Ñï) (h : abv.IsAdmissible) :
    ‚àÄ {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {b : R} (hb : b ‚â† 0) (A : Fin (h.card Œµ ^ n).succ ‚Üí Fin n ‚Üí R),
      ‚àÉ i‚ÇÄ i‚ÇÅ, i‚ÇÄ ‚â† i‚ÇÅ ‚àß ‚àÄ k, (abv (A i‚ÇÅ k % b - A i‚ÇÄ k % b) : ‚Ñù) < abv b ‚Ä¢ Œµ :=
  by
  haveI := Classical.decEq R
  induction' n with n ih
  ¬∑ intro Œµ hŒµ b hb A
    refine' ‚ü®0, 1, _, _‚ü©
    ¬∑ simp
    rintro ‚ü®i, ‚ü®‚ü©‚ü©
  intro Œµ hŒµ b hb A
  set M := h.card Œµ with hM
  -- By the "nicer" pigeonhole principle, we can find a collection `s`
  -- of more than `M^n` remainders where the first components lie close together:
  obtain ‚ü®s, s_inj, hs‚ü© :
    ‚àÉ s : Fin (M ^ n).succ ‚Üí Fin (M ^ n.succ).succ,
      Function.Injective s ‚àß ‚àÄ i‚ÇÄ i‚ÇÅ, (abv (A (s i‚ÇÅ) 0 % b - A (s i‚ÇÄ) 0 % b) : ‚Ñù) < abv b ‚Ä¢ Œµ :=
    by
    -- We can partition the `A`s into `M` subsets where
    -- the first components lie close together:
    obtain ‚ü®t, ht‚ü© :
      ‚àÉ t : Fin (M ^ n.succ).succ ‚Üí Fin M,
        ‚àÄ i‚ÇÄ i‚ÇÅ, t i‚ÇÄ = t i‚ÇÅ ‚Üí (abv (A i‚ÇÅ 0 % b - A i‚ÇÄ 0 % b) : ‚Ñù) < abv b ‚Ä¢ Œµ :=
      h.exists_partition hŒµ hb fun x => A x 0
    -- Since the `M` subsets contain more than `M * M^n` elements total,
    -- there must be a subset that contains more than `M^n` elements.
    obtain ‚ü®s, hs‚ü© :=
      @Fintype.exists_lt_card_fiber_of_mul_lt_card _ _ _ _ _ t (M ^ n)
        (by simpa only [Fintype.card_fin, pow_succ] using Nat.lt_succ_self (M ^ n.succ))
    refine'
      ‚ü®fun i => (finset.univ.filter fun x => t x = s).toList.nthLe i _, _, fun i‚ÇÄ i‚ÇÅ => ht _ _ _‚ü©
    ¬∑ refine' i.2.trans_le _
      rwa [Finset.length_toList]
    ¬∑ intro i j h
      ext
      exact list.nodup_iff_nth_le_inj.mp (Finset.nodup_toList _) _ _ _ _ h
    have :
      ‚àÄ i h,
        (finset.univ.filter fun x => t x = s).toList.nthLe i h ‚àà
          finset.univ.filter fun x => t x = s :=
      by
      intro i h
      exact finset.mem_to_list.mp (List.nthLe_mem _ _ _)
    obtain ‚ü®_, h‚ÇÄ‚ü© := finset.mem_filter.mp (this i‚ÇÄ _)
    obtain ‚ü®_, h‚ÇÅ‚ü© := finset.mem_filter.mp (this i‚ÇÅ _)
    exact h‚ÇÄ.trans h‚ÇÅ.symm
  -- Since `s` is large enough, there are two elements of `A ‚àò s`
  -- where the second components lie close together.
  obtain ‚ü®k‚ÇÄ, k‚ÇÅ, hk, h‚ü© := ih hŒµ hb fun x => Fin.tail (A (s x))
  refine' ‚ü®s k‚ÇÄ, s k‚ÇÅ, fun h => hk (s_inj h), fun i => Fin.cases _ (fun i => _) i‚ü©
  ¬∑ exact hs k‚ÇÄ k‚ÇÅ
  ¬∑ exact h i
#align absolute_value.is_admissible.exists_approx_aux AbsoluteValue.IsAdmissible.exists_approx_aux

/- warning: absolute_value.is_admissible.exists_approx -> AbsoluteValue.IsAdmissible.exists_approx is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : EuclideanDomain.{u1} R] {abv : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))} {Œπ : Type.{u2}} [_inst_2 : Fintype.{u2} Œπ] {Œµ : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) Œµ) -> (forall {b : R}, (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))))))) -> (forall (h : AbsoluteValue.IsAdmissible.{u1} R _inst_1 abv) (A : (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) -> Œπ -> R), Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) (fun (i‚ÇÄ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) => Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) (fun (i‚ÇÅ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) => And (Ne.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) i‚ÇÄ i‚ÇÅ) (forall (k : Œπ), LT.lt.{0} Real Real.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTC‚Çì.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => R -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1)))))))) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.hasMod.{u1} R _inst_1)) (A i‚ÇÅ k) b) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.hasMod.{u1} R _inst_1)) (A i‚ÇÄ k) b)))) (SMul.smul.{0, 0} Int Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.addGroup)) (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => R -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) abv b) Œµ))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : EuclideanDomain.{u1} R] {abv : AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))} {Œπ : Type.{u2}} [_inst_2 : Fintype.{u2} Œπ] {Œµ : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) Œµ) -> (forall {b : R}, (Ne.{succ u1} R b (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))) -> (forall (h : AbsoluteValue.IsAdmissible.{u1} R _inst_1 abv) (A : (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) -> Œπ -> R), Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) (fun (i‚ÇÄ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) => Exists.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) (fun (i‚ÇÅ : Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) => And (Ne.{1} (Fin (Nat.succ (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (AbsoluteValue.IsAdmissible.card.{u1} R _inst_1 abv h Œµ) (Fintype.card.{u2} Œπ _inst_2)))) i‚ÇÄ i‚ÇÅ) (forall (k : Œπ), LT.lt.{0} Real Real.instLTReal (Int.cast.{0} Real Real.intCast (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R Int (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1)))) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.instMod.{u1} R _inst_1)) (A i‚ÇÅ k) b) (HMod.hMod.{u1, u1, u1} R R R (instHMod.{u1} R (EuclideanDomain.instMod.{u1} R _inst_1)) (A i‚ÇÄ k) b)))) (HSMul.hSMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) b) Real Real (instHSMul.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) b) Real (SubNegMonoid.SMulInt.{0} Real (AddGroup.toSubNegMonoid.{0} Real Real.instAddGroupReal))) (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) R Int (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} R Int (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R (EuclideanDomain.toCommRing.{u1} R _inst_1))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) abv b) Œµ))))))
Case conversion may be inaccurate. Consider using '#align absolute_value.is_admissible.exists_approx AbsoluteValue.IsAdmissible.exists_approx‚Çì'. -/
/-- Any large enough family of vectors in `R^Œπ` has a pair of elements
whose remainders are close together, pointwise. -/
theorem exists_approx {Œπ : Type _} [Fintype Œπ] {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {b : R} (hb : b ‚â† 0)
    (h : abv.IsAdmissible) (A : Fin (h.card Œµ ^ Fintype.card Œπ).succ ‚Üí Œπ ‚Üí R) :
    ‚àÉ i‚ÇÄ i‚ÇÅ, i‚ÇÄ ‚â† i‚ÇÅ ‚àß ‚àÄ k, (abv (A i‚ÇÅ k % b - A i‚ÇÄ k % b) : ‚Ñù) < abv b ‚Ä¢ Œµ :=
  by
  let e := Fintype.equivFin Œπ
  obtain ‚ü®i‚ÇÄ, i‚ÇÅ, ne, h‚ü© := h.exists_approx_aux (Fintype.card Œπ) hŒµ hb fun x y => A x (e.symm y)
  refine' ‚ü®i‚ÇÄ, i‚ÇÅ, Ne, fun k => _‚ü©
  convert h (e k) <;> simp only [e.symm_apply_apply]
#align absolute_value.is_admissible.exists_approx AbsoluteValue.IsAdmissible.exists_approx

end IsAdmissible

end AbsoluteValue

