/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Scott Morrison, Ainsley Pahljina

! This file was ported from Lean 3 source module number_theory.lucas_lehmer
! leanprover-community/mathlib commit ce38d86c0b2d427ce208c3cee3159cb421d2b3c4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Nat.Parity
import Mathbin.Data.Pnat.Interval
import Mathbin.Data.Zmod.Basic
import Mathbin.GroupTheory.OrderOfElement
import Mathbin.RingTheory.Fintype
import Mathbin.Tactic.IntervalCases
import Mathbin.Tactic.RingExp

/-!
# The Lucas-Lehmer test for Mersenne primes.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define `lucas_lehmer_residue : Π p : ℕ, zmod (2^p - 1)`, and
prove `lucas_lehmer_residue p = 0 → prime (mersenne p)`.

We construct a tactic `lucas_lehmer.run_test`, which iteratively certifies the arithmetic
required to calculate the residue, and enables us to prove

```
example : prime (mersenne 127) :=
lucas_lehmer_sufficiency _ (by norm_num) (by lucas_lehmer.run_test)
```

## TODO

- Show reverse implication.
- Speed up the calculations using `n ≡ (n % 2^p) + (n / 2^p) [MOD 2^p - 1]`.
- Find some bigger primes!

## History

This development began as a student project by Ainsley Pahljina,
and was then cleaned up for mathlib by Scott Morrison.
The tactic for certified computation of Lucas-Lehmer residues was provided by Mario Carneiro.
-/


#print mersenne /-
/-- The Mersenne numbers, 2^p - 1. -/
def mersenne (p : ℕ) : ℕ :=
  2 ^ p - 1
#align mersenne mersenne
-/

#print mersenne_pos /-
theorem mersenne_pos {p : ℕ} (h : 0 < p) : 0 < mersenne p :=
  by
  dsimp [mersenne]
  calc
    0 < 2 ^ 1 - 1 := by norm_num
    _ ≤ 2 ^ p - 1 := Nat.pred_le_pred (Nat.pow_le_pow_of_le_right (Nat.succ_pos 1) h)
    
#align mersenne_pos mersenne_pos
-/

#print succ_mersenne /-
@[simp]
theorem succ_mersenne (k : ℕ) : mersenne k + 1 = 2 ^ k :=
  by
  rw [mersenne, tsub_add_cancel_of_le]
  exact one_le_pow_of_one_le (by norm_num) k
#align succ_mersenne succ_mersenne
-/

namespace LucasLehmer

open Nat

/-!
We now define three(!) different versions of the recurrence
`s (i+1) = (s i)^2 - 2`.

These versions take values either in `ℤ`, in `zmod (2^p - 1)`, or
in `ℤ` but applying `% (2^p - 1)` at each step.

They are each useful at different points in the proof,
so we take a moment setting up the lemmas relating them.
-/


#print LucasLehmer.s /-
/-- The recurrence `s (i+1) = (s i)^2 - 2` in `ℤ`. -/
def s : ℕ → ℤ
  | 0 => 4
  | i + 1 => s i ^ 2 - 2
#align lucas_lehmer.s LucasLehmer.s
-/

#print LucasLehmer.sZMod /-
/-- The recurrence `s (i+1) = (s i)^2 - 2` in `zmod (2^p - 1)`. -/
def sZMod (p : ℕ) : ℕ → ZMod (2 ^ p - 1)
  | 0 => 4
  | i + 1 => s_zmod i ^ 2 - 2
#align lucas_lehmer.s_zmod LucasLehmer.sZMod
-/

#print LucasLehmer.sMod /-
/-- The recurrence `s (i+1) = ((s i)^2 - 2) % (2^p - 1)` in `ℤ`. -/
def sMod (p : ℕ) : ℕ → ℤ
  | 0 => 4 % (2 ^ p - 1)
  | i + 1 => (s_mod i ^ 2 - 2) % (2 ^ p - 1)
#align lucas_lehmer.s_mod LucasLehmer.sMod
-/

/- warning: lucas_lehmer.mersenne_int_ne_zero -> LucasLehmer.mersenne_int_ne_zero is a dubious translation:
lean 3 declaration is
  forall (p : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) p) -> (Ne.{1} Int (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))) p) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))))
but is expected to have type
  forall (p : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) p) -> (Ne.{1} Int (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2)) p) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.mersenne_int_ne_zero LucasLehmer.mersenne_int_ne_zeroₓ'. -/
theorem mersenne_int_ne_zero (p : ℕ) (w : 0 < p) : (2 ^ p - 1 : ℤ) ≠ 0 :=
  by
  apply ne_of_gt; simp only [gt_iff_lt, sub_pos]
  exact_mod_cast Nat.one_lt_two_pow p w
#align lucas_lehmer.mersenne_int_ne_zero LucasLehmer.mersenne_int_ne_zero

#print LucasLehmer.sMod_nonneg /-
theorem sMod_nonneg (p : ℕ) (w : 0 < p) (i : ℕ) : 0 ≤ sMod p i :=
  by
  cases i <;> dsimp [s_mod]
  · exact sup_eq_right.mp rfl
  · apply Int.emod_nonneg
    exact mersenne_int_ne_zero p w
#align lucas_lehmer.s_mod_nonneg LucasLehmer.sMod_nonneg
-/

/- warning: lucas_lehmer.s_mod_mod -> LucasLehmer.sMod_mod is a dubious translation:
lean 3 declaration is
  forall (p : Nat) (i : Nat), Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) (LucasLehmer.sMod p i) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))) p) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))) (LucasLehmer.sMod p i)
but is expected to have type
  forall (p : Nat) (i : Nat), Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) (LucasLehmer.sMod p i) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2)) p) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) (LucasLehmer.sMod p i)
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.s_mod_mod LucasLehmer.sMod_modₓ'. -/
theorem sMod_mod (p i : ℕ) : sMod p i % (2 ^ p - 1) = sMod p i := by cases i <;> simp [s_mod]
#align lucas_lehmer.s_mod_mod LucasLehmer.sMod_mod

/- warning: lucas_lehmer.s_mod_lt -> LucasLehmer.sMod_lt is a dubious translation:
lean 3 declaration is
  forall (p : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) p) -> (forall (i : Nat), LT.lt.{0} Int Int.hasLt (LucasLehmer.sMod p i) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))) p) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))))
but is expected to have type
  forall (p : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) p) -> (forall (i : Nat), LT.lt.{0} Int Int.instLTInt (LucasLehmer.sMod p i) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2)) p) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.s_mod_lt LucasLehmer.sMod_ltₓ'. -/
theorem sMod_lt (p : ℕ) (w : 0 < p) (i : ℕ) : sMod p i < 2 ^ p - 1 :=
  by
  rw [← s_mod_mod]
  convert Int.emod_lt _ _
  · refine' (abs_of_nonneg _).symm
    simp only [sub_nonneg, ge_iff_le]
    exact_mod_cast Nat.one_le_two_pow p
  · exact mersenne_int_ne_zero p w
#align lucas_lehmer.s_mod_lt LucasLehmer.sMod_lt

/- warning: lucas_lehmer.s_zmod_eq_s -> LucasLehmer.sZMod_eq_s is a dubious translation:
lean 3 declaration is
  forall (p' : Nat) (i : Nat), Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.sZMod (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) i) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (HasLiftT.mk.{1, 1} Int (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Int.castCoe.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))))))) (LucasLehmer.s i))
but is expected to have type
  forall (p' : Nat) (i : Nat), Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (LucasLehmer.sZMod (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) i) (Int.cast.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Ring.toIntCast.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (LucasLehmer.s i))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.s_zmod_eq_s LucasLehmer.sZMod_eq_sₓ'. -/
theorem sZMod_eq_s (p' : ℕ) (i : ℕ) : sZMod (p' + 2) i = (s i : ZMod (2 ^ (p' + 2) - 1)) :=
  by
  induction' i with i ih
  · dsimp [s, s_zmod]
    norm_num
  · push_cast [s, s_zmod, ih]
#align lucas_lehmer.s_zmod_eq_s LucasLehmer.sZMod_eq_s

/- warning: lucas_lehmer.int.coe_nat_pow_pred -> LucasLehmer.Int.coe_nat_pow_pred is a dubious translation:
lean 3 declaration is
  forall (b : Nat) (p : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) b) -> (Eq.{1} Int ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) b p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) b) p) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))))
but is expected to have type
  forall (b : Nat) (p : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) b) -> (Eq.{1} Int (Nat.cast.{0} Int instNatCastInt (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) b p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (HPow.hPow.{0, 0, 0} Int Nat Int Int.instHPowIntNat (Nat.cast.{0} Int instNatCastInt b) p) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.int.coe_nat_pow_pred LucasLehmer.Int.coe_nat_pow_predₓ'. -/
-- These next two don't make good `norm_cast` lemmas.
theorem Int.coe_nat_pow_pred (b p : ℕ) (w : 0 < b) : ((b ^ p - 1 : ℕ) : ℤ) = (b ^ p - 1 : ℤ) :=
  by
  have : 1 ≤ b ^ p := Nat.one_le_pow p b w
  norm_cast
#align lucas_lehmer.int.coe_nat_pow_pred LucasLehmer.Int.coe_nat_pow_pred

/- warning: lucas_lehmer.int.coe_nat_two_pow_pred -> LucasLehmer.Int.coe_nat_two_pow_pred is a dubious translation:
lean 3 declaration is
  forall (p : Nat), Eq.{1} Int ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))) p) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))
but is expected to have type
  forall (p : Nat), Eq.{1} Int (Nat.cast.{0} Int instNatCastInt (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2)) p) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.int.coe_nat_two_pow_pred LucasLehmer.Int.coe_nat_two_pow_predₓ'. -/
theorem Int.coe_nat_two_pow_pred (p : ℕ) : ((2 ^ p - 1 : ℕ) : ℤ) = (2 ^ p - 1 : ℤ) :=
  Int.coe_nat_pow_pred 2 p (by decide)
#align lucas_lehmer.int.coe_nat_two_pow_pred LucasLehmer.Int.coe_nat_two_pow_pred

/- warning: lucas_lehmer.s_zmod_eq_s_mod -> LucasLehmer.sZMod_eq_sMod is a dubious translation:
lean 3 declaration is
  forall (p : Nat) (i : Nat), Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.sZMod p i) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (HasLiftT.mk.{1, 1} Int (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Int.castCoe.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))))))) (LucasLehmer.sMod p i))
but is expected to have type
  forall (p : Nat) (i : Nat), Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (LucasLehmer.sZMod p i) (Int.cast.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Ring.toIntCast.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (LucasLehmer.sMod p i))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.s_zmod_eq_s_mod LucasLehmer.sZMod_eq_sModₓ'. -/
theorem sZMod_eq_sMod (p : ℕ) (i : ℕ) : sZMod p i = (sMod p i : ZMod (2 ^ p - 1)) := by
  induction i <;> push_cast [← int.coe_nat_two_pow_pred p, s_mod, s_zmod, *]
#align lucas_lehmer.s_zmod_eq_s_mod LucasLehmer.sZMod_eq_sMod

#print LucasLehmer.lucasLehmerResidue /-
/-- The Lucas-Lehmer residue is `s p (p-2)` in `zmod (2^p - 1)`. -/
def lucasLehmerResidue (p : ℕ) : ZMod (2 ^ p - 1) :=
  sZMod p (p - 2)
#align lucas_lehmer.lucas_lehmer_residue LucasLehmer.lucasLehmerResidue
-/

/- warning: lucas_lehmer.residue_eq_zero_iff_s_mod_eq_zero -> LucasLehmer.residue_eq_zero_iff_sMod_eq_zero is a dubious translation:
lean 3 declaration is
  forall (p : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) p) -> (Iff (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.lucasLehmerResidue p) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))) (MulZeroClass.toHasZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))) (Ring.toNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) p) (One.one.{0} Nat Nat.hasOne))))))))))))) (Eq.{1} Int (LucasLehmer.sMod p (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) p (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))))
but is expected to have type
  forall (p : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) p) -> (Iff (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (LucasLehmer.lucasLehmerResidue p) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Zero.toOfNat0.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommMonoidWithZero.toZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommSemiring.toCommMonoidWithZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommRing.toCommSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))) (Eq.{1} Int (LucasLehmer.sMod p (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) p (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.residue_eq_zero_iff_s_mod_eq_zero LucasLehmer.residue_eq_zero_iff_sMod_eq_zeroₓ'. -/
theorem residue_eq_zero_iff_sMod_eq_zero (p : ℕ) (w : 1 < p) :
    lucasLehmerResidue p = 0 ↔ sMod p (p - 2) = 0 :=
  by
  dsimp [lucas_lehmer_residue]
  rw [s_zmod_eq_s_mod p]
  constructor
  · -- We want to use that fact that `0 ≤ s_mod p (p-2) < 2^p - 1`
    -- and `lucas_lehmer_residue p = 0 → 2^p - 1 ∣ s_mod p (p-2)`.
    intro h
    simp [ZMod.int_cast_zmod_eq_zero_iff_dvd] at h
    apply Int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h <;> clear h
    apply s_mod_nonneg _ (Nat.lt_of_succ_lt w)
    exact s_mod_lt _ (Nat.lt_of_succ_lt w) (p - 2)
  · intro h
    rw [h]
    simp
#align lucas_lehmer.residue_eq_zero_iff_s_mod_eq_zero LucasLehmer.residue_eq_zero_iff_sMod_eq_zero

#print LucasLehmer.LucasLehmerTest /-
/-- A Mersenne number `2^p-1` is prime if and only if
the Lucas-Lehmer residue `s p (p-2) % (2^p - 1)` is zero.
-/
def LucasLehmerTest (p : ℕ) : Prop :=
  lucasLehmerResidue p = 0deriving DecidablePred
#align lucas_lehmer.lucas_lehmer_test LucasLehmer.LucasLehmerTest
-/

#print LucasLehmer.q /-
/-- `q` is defined as the minimum factor of `mersenne p`, bundled as an `ℕ+`. -/
def q (p : ℕ) : ℕ+ :=
  ⟨Nat.minFac (mersenne p), Nat.minFac_pos (mersenne p)⟩
#align lucas_lehmer.q LucasLehmer.q
-/

#print LucasLehmer.X /-
-- It would be nice to define this as (ℤ/qℤ)[x] / (x^2 - 3),
-- obtaining the ring structure for free,
-- but that seems to be more trouble than it's worth;
-- if it were easy to make the definition,
-- cardinality calculations would be somewhat more involved, too.
/-- We construct the ring `X q` as ℤ/qℤ + √3 ℤ/qℤ. -/
def X (q : ℕ+) : Type :=
  ZMod q × ZMod q deriving AddCommGroup, DecidableEq, Fintype, Inhabited
#align lucas_lehmer.X LucasLehmer.X
-/

namespace X

variable {q : ℕ+}

#print LucasLehmer.X.ext /-
@[ext]
theorem ext {x y : X q} (h₁ : x.1 = y.1) (h₂ : x.2 = y.2) : x = y :=
  by
  cases x; cases y
  congr <;> assumption
#align lucas_lehmer.X.ext LucasLehmer.X.ext
-/

/- warning: lucas_lehmer.X.add_fst -> LucasLehmer.X.add_fst is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (SubNegMonoid.toAddMonoid.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.addCommGroup q))))))) x y)) (HAdd.hAdd.{0, 0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (instHAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) y))
but is expected to have type
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q), Eq.{1} (ZMod (PNat.val q)) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (SubNegMonoid.toAddMonoid.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.instAddCommGroupX q))))))) x y)) (HAdd.hAdd.{0, 0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (ZMod (PNat.val q)) (instHAdd.{0} (ZMod (PNat.val q)) (Distrib.toAdd.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocSemiring.toDistrib.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (PNat.val q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))))))) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) x) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) y))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.add_fst LucasLehmer.X.add_fstₓ'. -/
@[simp]
theorem add_fst (x y : X q) : (x + y).1 = x.1 + y.1 :=
  rfl
#align lucas_lehmer.X.add_fst LucasLehmer.X.add_fst

/- warning: lucas_lehmer.X.add_snd -> LucasLehmer.X.add_snd is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (SubNegMonoid.toAddMonoid.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.addCommGroup q))))))) x y)) (HAdd.hAdd.{0, 0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (instHAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) y))
but is expected to have type
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q), Eq.{1} (ZMod (PNat.val q)) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (SubNegMonoid.toAddMonoid.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.instAddCommGroupX q))))))) x y)) (HAdd.hAdd.{0, 0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (ZMod (PNat.val q)) (instHAdd.{0} (ZMod (PNat.val q)) (Distrib.toAdd.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocSemiring.toDistrib.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (PNat.val q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))))))) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) x) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) y))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.add_snd LucasLehmer.X.add_sndₓ'. -/
@[simp]
theorem add_snd (x y : X q) : (x + y).2 = x.2 + y.2 :=
  rfl
#align lucas_lehmer.X.add_snd LucasLehmer.X.add_snd

/- warning: lucas_lehmer.X.neg_fst -> LucasLehmer.X.neg_fst is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Neg.neg.{0} (LucasLehmer.X q) (SubNegMonoid.toHasNeg.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.addCommGroup q)))) x)) (Neg.neg.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (SubNegMonoid.toHasNeg.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroup.toSubNegMonoid.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroupWithOne.toAddGroup.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toAddCommGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))))) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x))
but is expected to have type
  forall {q : PNat} (x : LucasLehmer.X q), Eq.{1} (ZMod (PNat.val q)) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (Neg.neg.{0} (LucasLehmer.X q) (NegZeroClass.toNeg.{0} (LucasLehmer.X q) (SubNegZeroMonoid.toNegZeroClass.{0} (LucasLehmer.X q) (SubtractionMonoid.toSubNegZeroMonoid.{0} (LucasLehmer.X q) (SubtractionCommMonoid.toSubtractionMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toDivisionAddCommMonoid.{0} (LucasLehmer.X q) (LucasLehmer.X.instAddCommGroupX q)))))) x)) (Neg.neg.{0} (ZMod (PNat.val q)) (Ring.toNeg.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q)))) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) x))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.neg_fst LucasLehmer.X.neg_fstₓ'. -/
@[simp]
theorem neg_fst (x : X q) : (-x).1 = -x.1 :=
  rfl
#align lucas_lehmer.X.neg_fst LucasLehmer.X.neg_fst

/- warning: lucas_lehmer.X.neg_snd -> LucasLehmer.X.neg_snd is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Neg.neg.{0} (LucasLehmer.X q) (SubNegMonoid.toHasNeg.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.addCommGroup q)))) x)) (Neg.neg.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (SubNegMonoid.toHasNeg.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroup.toSubNegMonoid.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroupWithOne.toAddGroup.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toAddCommGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))))) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x))
but is expected to have type
  forall {q : PNat} (x : LucasLehmer.X q), Eq.{1} (ZMod (PNat.val q)) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (Neg.neg.{0} (LucasLehmer.X q) (NegZeroClass.toNeg.{0} (LucasLehmer.X q) (SubNegZeroMonoid.toNegZeroClass.{0} (LucasLehmer.X q) (SubtractionMonoid.toSubNegZeroMonoid.{0} (LucasLehmer.X q) (SubtractionCommMonoid.toSubtractionMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toDivisionAddCommMonoid.{0} (LucasLehmer.X q) (LucasLehmer.X.instAddCommGroupX q)))))) x)) (Neg.neg.{0} (ZMod (PNat.val q)) (Ring.toNeg.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q)))) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) x))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.neg_snd LucasLehmer.X.neg_sndₓ'. -/
@[simp]
theorem neg_snd (x : X q) : (-x).2 = -x.2 :=
  rfl
#align lucas_lehmer.X.neg_snd LucasLehmer.X.neg_snd

instance : Mul (X q) where mul x y := (x.1 * y.1 + 3 * x.2 * y.2, x.1 * y.2 + x.2 * y.1)

/- warning: lucas_lehmer.X.mul_fst -> LucasLehmer.X.mul_fst is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) x y)) (HAdd.hAdd.{0, 0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (instHAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))) (HMul.hMul.{0, 0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (instHMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) y)) (HMul.hMul.{0, 0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (instHMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))) (HMul.hMul.{0, 0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (instHMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))) (OfNat.ofNat.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 3 (OfNat.mk.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 3 (bit1.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddMonoidWithOne.toOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toAddCommGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))))) (Distrib.toHasAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))) (One.one.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddMonoidWithOne.toOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toAddCommGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))))))))) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x)) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) y)))
but is expected to have type
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q), Eq.{1} (ZMod (PNat.val q)) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) x y)) (HAdd.hAdd.{0, 0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (ZMod (PNat.val q)) (instHAdd.{0} (ZMod (PNat.val q)) (Distrib.toAdd.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocSemiring.toDistrib.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (PNat.val q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))))))) (HMul.hMul.{0, 0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (ZMod (PNat.val q)) (instHMul.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocRing.toMul.{0} (ZMod (PNat.val q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))))) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) x) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) y)) (HMul.hMul.{0, 0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (ZMod (PNat.val q)) (instHMul.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocRing.toMul.{0} (ZMod (PNat.val q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))))) (HMul.hMul.{0, 0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (ZMod (PNat.val q)) (instHMul.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocRing.toMul.{0} (ZMod (PNat.val q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))))) (OfNat.ofNat.{0} (ZMod (PNat.val q)) 3 (instOfNat.{0} (ZMod (PNat.val q)) 3 (NonAssocRing.toNatCast.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) x)) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) y)))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.mul_fst LucasLehmer.X.mul_fstₓ'. -/
@[simp]
theorem mul_fst (x y : X q) : (x * y).1 = x.1 * y.1 + 3 * x.2 * y.2 :=
  rfl
#align lucas_lehmer.X.mul_fst LucasLehmer.X.mul_fst

/- warning: lucas_lehmer.X.mul_snd -> LucasLehmer.X.mul_snd is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) x y)) (HAdd.hAdd.{0, 0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (instHAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))) (HMul.hMul.{0, 0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (instHMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) y)) (HMul.hMul.{0, 0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (instHMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasMul.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) y)))
but is expected to have type
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q), Eq.{1} (ZMod (PNat.val q)) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) x y)) (HAdd.hAdd.{0, 0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (ZMod (PNat.val q)) (instHAdd.{0} (ZMod (PNat.val q)) (Distrib.toAdd.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocSemiring.toDistrib.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (PNat.val q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))))))) (HMul.hMul.{0, 0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (ZMod (PNat.val q)) (instHMul.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocRing.toMul.{0} (ZMod (PNat.val q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))))) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) x) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) y)) (HMul.hMul.{0, 0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (ZMod (PNat.val q)) (instHMul.{0} (ZMod (PNat.val q)) (NonUnitalNonAssocRing.toMul.{0} (ZMod (PNat.val q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))))) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) x) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) y)))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.mul_snd LucasLehmer.X.mul_sndₓ'. -/
@[simp]
theorem mul_snd (x y : X q) : (x * y).2 = x.1 * y.2 + x.2 * y.1 :=
  rfl
#align lucas_lehmer.X.mul_snd LucasLehmer.X.mul_snd

instance : One (X q) where one := ⟨1, 0⟩

/- warning: lucas_lehmer.X.one_fst -> LucasLehmer.X.one_fst is a dubious translation:
lean 3 declaration is
  forall {q : PNat}, Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (OfNat.ofNat.{0} (LucasLehmer.X q) 1 (OfNat.mk.{0} (LucasLehmer.X q) 1 (One.one.{0} (LucasLehmer.X q) (LucasLehmer.X.hasOne q))))) (OfNat.ofNat.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 1 (OfNat.mk.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 1 (One.one.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddMonoidWithOne.toOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toAddCommGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))))))))
but is expected to have type
  forall {q : PNat}, Eq.{1} (ZMod (PNat.val q)) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (OfNat.ofNat.{0} (LucasLehmer.X q) 1 (One.toOfNat1.{0} (LucasLehmer.X q) (LucasLehmer.X.instOneX q)))) (OfNat.ofNat.{0} (ZMod (PNat.val q)) 1 (One.toOfNat1.{0} (ZMod (PNat.val q)) (NonAssocRing.toOne.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q)))))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.one_fst LucasLehmer.X.one_fstₓ'. -/
@[simp]
theorem one_fst : (1 : X q).1 = 1 :=
  rfl
#align lucas_lehmer.X.one_fst LucasLehmer.X.one_fst

/- warning: lucas_lehmer.X.one_snd -> LucasLehmer.X.one_snd is a dubious translation:
lean 3 declaration is
  forall {q : PNat}, Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (OfNat.ofNat.{0} (LucasLehmer.X q) 1 (OfNat.mk.{0} (LucasLehmer.X q) 1 (One.one.{0} (LucasLehmer.X q) (LucasLehmer.X.hasOne q))))) (OfNat.ofNat.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 0 (OfNat.mk.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 0 (Zero.zero.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (MulZeroClass.toHasZero.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toNonAssocRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))))))))
but is expected to have type
  forall {q : PNat}, Eq.{1} (ZMod (PNat.val q)) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (OfNat.ofNat.{0} (LucasLehmer.X q) 1 (One.toOfNat1.{0} (LucasLehmer.X q) (LucasLehmer.X.instOneX q)))) (OfNat.ofNat.{0} (ZMod (PNat.val q)) 0 (Zero.toOfNat0.{0} (ZMod (PNat.val q)) (CommMonoidWithZero.toZero.{0} (ZMod (PNat.val q)) (CommSemiring.toCommMonoidWithZero.{0} (ZMod (PNat.val q)) (CommRing.toCommSemiring.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q)))))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.one_snd LucasLehmer.X.one_sndₓ'. -/
@[simp]
theorem one_snd : (1 : X q).2 = 0 :=
  rfl
#align lucas_lehmer.X.one_snd LucasLehmer.X.one_snd

/- warning: lucas_lehmer.X.bit0_fst clashes with [anonymous] -> [anonymous]
warning: lucas_lehmer.X.bit0_fst -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (bit0.{0} (LucasLehmer.X q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (SubNegMonoid.toAddMonoid.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.addCommGroup q)))))) x)) (bit0.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x))
but is expected to have type
  forall {q : Type.{u}} {x : Type.{v}}, (Nat -> q -> x) -> Nat -> (List.{u} q) -> (List.{v} x)
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.bit0_fst [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (x : X q) : (bit0 x).1 = bit0 x.1 :=
  rfl
#align lucas_lehmer.X.bit0_fst [anonymous]

/- warning: lucas_lehmer.X.bit0_snd clashes with [anonymous] -> [anonymous]
warning: lucas_lehmer.X.bit0_snd -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (bit0.{0} (LucasLehmer.X q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (SubNegMonoid.toAddMonoid.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.addCommGroup q)))))) x)) (bit0.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x))
but is expected to have type
  forall {q : Type.{u}} {x : Type.{v}}, (Nat -> q -> x) -> Nat -> (List.{u} q) -> (List.{v} x)
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.bit0_snd [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (x : X q) : (bit0 x).2 = bit0 x.2 :=
  rfl
#align lucas_lehmer.X.bit0_snd [anonymous]

/- warning: lucas_lehmer.X.bit1_fst clashes with [anonymous] -> [anonymous]
warning: lucas_lehmer.X.bit1_fst -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (bit1.{0} (LucasLehmer.X q) (LucasLehmer.X.hasOne q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (SubNegMonoid.toAddMonoid.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.addCommGroup q)))))) x)) (bit1.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddMonoidWithOne.toOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toAddCommGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))))) (Distrib.toHasAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x))
but is expected to have type
  forall {q : Type.{u}} {x : Type.{v}}, (Nat -> q -> x) -> Nat -> (List.{u} q) -> (List.{v} x)
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.bit1_fst [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (x : X q) : (bit1 x).1 = bit1 x.1 :=
  rfl
#align lucas_lehmer.X.bit1_fst [anonymous]

/- warning: lucas_lehmer.X.bit1_snd clashes with [anonymous] -> [anonymous]
warning: lucas_lehmer.X.bit1_snd -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (bit1.{0} (LucasLehmer.X q) (LucasLehmer.X.hasOne q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (SubNegMonoid.toAddMonoid.{0} (LucasLehmer.X q) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X q) (AddCommGroup.toAddGroup.{0} (LucasLehmer.X q) (LucasLehmer.X.addCommGroup q)))))) x)) (bit0.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Distrib.toHasAdd.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toDistrib.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) x))
but is expected to have type
  forall {q : Type.{u}} {x : Type.{v}}, (Nat -> q -> x) -> Nat -> (List.{u} q) -> (List.{v} x)
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.bit1_snd [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (x : X q) : (bit1 x).2 = bit0 x.2 :=
  by
  dsimp [bit1]
  simp
#align lucas_lehmer.X.bit1_snd [anonymous]

instance : Monoid (X q) :=
  {
    (inferInstance :
      Mul
        (X
          q)) with
    mul_assoc := fun x y z => by
      ext <;>
        · dsimp
          ring
    one := ⟨1, 0⟩
    one_mul := fun x => by ext <;> simp
    mul_one := fun x => by ext <;> simp }

instance : AddGroupWithOne (X q) :=
  { X.monoid, X.addCommGroup _ with
    natCast := fun n => ⟨n, 0⟩
    natCast_zero := by simp
    natCast_succ := by simp [Nat.cast, Monoid.one]
    intCast := fun n => ⟨n, 0⟩
    intCast_ofNat := fun n => by simp <;> rfl
    intCast_negSucc := fun n => by ext <;> simp <;> rfl }

/- warning: lucas_lehmer.X.left_distrib -> LucasLehmer.X.left_distrib is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q) (z : LucasLehmer.X q), Eq.{1} (LucasLehmer.X q) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) x (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (AddMonoidWithOne.toAddMonoid.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q)))))) y z)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (AddMonoidWithOne.toAddMonoid.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q)))))) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) x y) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) x z))
but is expected to have type
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q) (z : LucasLehmer.X q), Eq.{1} (LucasLehmer.X q) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) x (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (AddMonoidWithOne.toAddMonoid.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.instAddGroupWithOneX q)))))) y z)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (AddMonoidWithOne.toAddMonoid.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.instAddGroupWithOneX q)))))) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) x y) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) x z))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.left_distrib LucasLehmer.X.left_distribₓ'. -/
theorem left_distrib (x y z : X q) : x * (y + z) = x * y + x * z := by
  ext <;>
    · dsimp
      ring
#align lucas_lehmer.X.left_distrib LucasLehmer.X.left_distrib

/- warning: lucas_lehmer.X.right_distrib -> LucasLehmer.X.right_distrib is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q) (z : LucasLehmer.X q), Eq.{1} (LucasLehmer.X q) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (AddMonoidWithOne.toAddMonoid.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q)))))) x y) z) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toHasAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (AddMonoidWithOne.toAddMonoid.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q)))))) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) x z) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) y z))
but is expected to have type
  forall {q : PNat} (x : LucasLehmer.X q) (y : LucasLehmer.X q) (z : LucasLehmer.X q), Eq.{1} (LucasLehmer.X q) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (AddMonoidWithOne.toAddMonoid.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.instAddGroupWithOneX q)))))) x y) z) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (AddZeroClass.toAdd.{0} (LucasLehmer.X q) (AddMonoid.toAddZeroClass.{0} (LucasLehmer.X q) (AddMonoidWithOne.toAddMonoid.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.instAddGroupWithOneX q)))))) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) x z) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) y z))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.right_distrib LucasLehmer.X.right_distribₓ'. -/
theorem right_distrib (x y z : X q) : (x + y) * z = x * z + y * z := by
  ext <;>
    · dsimp
      ring
#align lucas_lehmer.X.right_distrib LucasLehmer.X.right_distrib

instance : Ring (X q) :=
  { X.addGroupWithOne, (inferInstance : AddCommGroup (X q)),
    (inferInstance : Monoid (X q)) with
    left_distrib := left_distrib
    right_distrib := right_distrib }

instance : CommRing (X q) :=
  { (inferInstance : Ring (X q)) with
    mul_comm := fun x y => by
      ext <;>
        · dsimp
          ring }

instance [Fact (1 < (q : ℕ))] : Nontrivial (X q) :=
  ⟨⟨0, 1, fun h => by
      injection h with h1 _
      exact zero_ne_one h1⟩⟩

/- warning: lucas_lehmer.X.nat_coe_fst -> LucasLehmer.X.nat_coe_fst is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (n : Nat), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Nat (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Nat (LucasLehmer.X q) (Nat.castCoe.{0} (LucasLehmer.X q) (AddMonoidWithOne.toNatCast.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q)))))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (HasLiftT.mk.{1, 1} Nat (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CoeTCₓ.coe.{1, 1} Nat (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Nat.castCoe.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddMonoidWithOne.toNatCast.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toAddCommGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))))))) n)
but is expected to have type
  forall {q : PNat} (n : Nat), Eq.{1} (ZMod (PNat.val q)) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (Nat.cast.{0} (LucasLehmer.X q) (LucasLehmer.X.instNatCastX q) n)) (Nat.cast.{0} (ZMod (PNat.val q)) (NonAssocRing.toNatCast.{0} (ZMod (PNat.val q)) (Ring.toNonAssocRing.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q))))) n)
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.nat_coe_fst LucasLehmer.X.nat_coe_fstₓ'. -/
@[simp]
theorem nat_coe_fst (n : ℕ) : (n : X q).fst = (n : ZMod q) :=
  rfl
#align lucas_lehmer.X.nat_coe_fst LucasLehmer.X.nat_coe_fst

/- warning: lucas_lehmer.X.nat_coe_snd -> LucasLehmer.X.nat_coe_snd is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (n : Nat), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Nat (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Nat (LucasLehmer.X q) (Nat.castCoe.{0} (LucasLehmer.X q) (AddMonoidWithOne.toNatCast.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q)))))) n)) (OfNat.ofNat.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 0 (OfNat.mk.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 0 (Zero.zero.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (MulZeroClass.toHasZero.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toNonAssocRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))))))))
but is expected to have type
  forall {q : PNat} (n : Nat), Eq.{1} (ZMod (PNat.val q)) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (Nat.cast.{0} (LucasLehmer.X q) (LucasLehmer.X.instNatCastX q) n)) (OfNat.ofNat.{0} (ZMod (PNat.val q)) 0 (Zero.toOfNat0.{0} (ZMod (PNat.val q)) (CommMonoidWithZero.toZero.{0} (ZMod (PNat.val q)) (CommSemiring.toCommMonoidWithZero.{0} (ZMod (PNat.val q)) (CommRing.toCommSemiring.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q)))))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.nat_coe_snd LucasLehmer.X.nat_coe_sndₓ'. -/
@[simp]
theorem nat_coe_snd (n : ℕ) : (n : X q).snd = (0 : ZMod q) :=
  rfl
#align lucas_lehmer.X.nat_coe_snd LucasLehmer.X.nat_coe_snd

/- warning: lucas_lehmer.X.int_coe_fst -> LucasLehmer.X.int_coe_fst is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (n : Int), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.fst.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Int (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Int (LucasLehmer.X q) (Int.castCoe.{0} (LucasLehmer.X q) (AddGroupWithOne.toHasIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q))))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (HasLiftT.mk.{1, 1} Int (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CoeTCₓ.coe.{1, 1} Int (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Int.castCoe.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddGroupWithOne.toHasIntCast.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toAddCommGroupWithOne.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q))))))))) n)
but is expected to have type
  forall {q : PNat} (n : Int), Eq.{1} (ZMod (PNat.val q)) (Prod.fst.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (Int.cast.{0} (LucasLehmer.X q) (Ring.toIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.instRingX q)) n)) (Int.cast.{0} (ZMod (PNat.val q)) (Ring.toIntCast.{0} (ZMod (PNat.val q)) (CommRing.toRing.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q)))) n)
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.int_coe_fst LucasLehmer.X.int_coe_fstₓ'. -/
@[simp]
theorem int_coe_fst (n : ℤ) : (n : X q).fst = (n : ZMod q) :=
  rfl
#align lucas_lehmer.X.int_coe_fst LucasLehmer.X.int_coe_fst

/- warning: lucas_lehmer.X.int_coe_snd -> LucasLehmer.X.int_coe_snd is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (n : Int), Eq.{1} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Prod.snd.{0, 0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Int (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Int (LucasLehmer.X q) (Int.castCoe.{0} (LucasLehmer.X q) (AddGroupWithOne.toHasIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q))))) n)) (OfNat.ofNat.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 0 (OfNat.mk.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) 0 (Zero.zero.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (MulZeroClass.toHasZero.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (Ring.toNonAssocRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (CommRing.toRing.{0} (ZMod ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)) (ZMod.commRing ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q)))))))))))
but is expected to have type
  forall {q : PNat} (n : Int), Eq.{1} (ZMod (PNat.val q)) (Prod.snd.{0, 0} (ZMod (PNat.val q)) (ZMod (PNat.val q)) (Int.cast.{0} (LucasLehmer.X q) (Ring.toIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.instRingX q)) n)) (OfNat.ofNat.{0} (ZMod (PNat.val q)) 0 (Zero.toOfNat0.{0} (ZMod (PNat.val q)) (CommMonoidWithZero.toZero.{0} (ZMod (PNat.val q)) (CommSemiring.toCommMonoidWithZero.{0} (ZMod (PNat.val q)) (CommRing.toCommSemiring.{0} (ZMod (PNat.val q)) (ZMod.commRing (PNat.val q)))))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.int_coe_snd LucasLehmer.X.int_coe_sndₓ'. -/
@[simp]
theorem int_coe_snd (n : ℤ) : (n : X q).snd = (0 : ZMod q) :=
  rfl
#align lucas_lehmer.X.int_coe_snd LucasLehmer.X.int_coe_snd

/- warning: lucas_lehmer.X.coe_mul -> LucasLehmer.X.coe_mul is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (n : Int) (m : Int), Eq.{1} (LucasLehmer.X q) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Int (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Int (LucasLehmer.X q) (Int.castCoe.{0} (LucasLehmer.X q) (AddGroupWithOne.toHasIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q))))) (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.hasMul) n m)) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Int (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Int (LucasLehmer.X q) (Int.castCoe.{0} (LucasLehmer.X q) (AddGroupWithOne.toHasIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q))))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Int (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Int (LucasLehmer.X q) (Int.castCoe.{0} (LucasLehmer.X q) (AddGroupWithOne.toHasIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q))))) m))
but is expected to have type
  forall {q : PNat} (n : Int) (m : Int), Eq.{1} (LucasLehmer.X q) (Int.cast.{0} (LucasLehmer.X q) (Ring.toIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.instRingX q)) (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.instMulInt) n m)) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) (Int.cast.{0} (LucasLehmer.X q) (Ring.toIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.instRingX q)) n) (Int.cast.{0} (LucasLehmer.X q) (Ring.toIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.instRingX q)) m))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.coe_mul LucasLehmer.X.coe_mulₓ'. -/
@[norm_cast]
theorem coe_mul (n m : ℤ) : ((n * m : ℤ) : X q) = (n : X q) * (m : X q) := by ext <;> simp <;> ring
#align lucas_lehmer.X.coe_mul LucasLehmer.X.coe_mul

/- warning: lucas_lehmer.X.coe_nat -> LucasLehmer.X.coe_nat is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (n : Nat), Eq.{1} (LucasLehmer.X q) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Int (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Int (LucasLehmer.X q) (Int.castCoe.{0} (LucasLehmer.X q) (AddGroupWithOne.toHasIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Nat (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Nat (LucasLehmer.X q) (Nat.castCoe.{0} (LucasLehmer.X q) (AddMonoidWithOne.toNatCast.{0} (LucasLehmer.X q) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q)))))) n)
but is expected to have type
  forall {q : PNat} (n : Nat), Eq.{1} (LucasLehmer.X q) (Int.cast.{0} (LucasLehmer.X q) (Ring.toIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.instRingX q)) (Nat.cast.{0} Int instNatCastInt n)) (Nat.cast.{0} (LucasLehmer.X q) (LucasLehmer.X.instNatCastX q) n)
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.coe_nat LucasLehmer.X.coe_natₓ'. -/
@[norm_cast]
theorem coe_nat (n : ℕ) : ((n : ℤ) : X q) = (n : X q) := by ext <;> simp
#align lucas_lehmer.X.coe_nat LucasLehmer.X.coe_nat

#print LucasLehmer.X.card_eq /-
/-- The cardinality of `X` is `q^2`. -/
theorem card_eq : Fintype.card (X q) = q ^ 2 :=
  by
  dsimp [X]
  rw [Fintype.card_prod, ZMod.card q]
  ring
#align lucas_lehmer.X.X_card LucasLehmer.X.card_eq
-/

/- warning: lucas_lehmer.X.units_card -> LucasLehmer.X.card_units_lt is a dubious translation:
lean 3 declaration is
  forall {q : PNat}, (LT.lt.{0} PNat (Preorder.toLT.{0} PNat (PartialOrder.toPreorder.{0} PNat (OrderedCancelCommMonoid.toPartialOrder.{0} PNat (LinearOrderedCancelCommMonoid.toOrderedCancelCommMonoid.{0} PNat PNat.linearOrderedCancelCommMonoid)))) (OfNat.ofNat.{0} PNat 1 (OfNat.mk.{0} PNat 1 (One.one.{0} PNat PNat.hasOne))) q) -> (LT.lt.{0} Nat Nat.hasLt (Fintype.card.{0} (Units.{0} (LucasLehmer.X q) (LucasLehmer.X.monoid q)) (Units.fintype.{0} (LucasLehmer.X q) (LucasLehmer.X.monoid q) (LucasLehmer.X.fintype q) (fun (a : LucasLehmer.X q) (b : LucasLehmer.X q) => LucasLehmer.X.decidableEq q a b))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) q) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {q : PNat}, (LT.lt.{0} PNat (Preorder.toLT.{0} PNat (PartialOrder.toPreorder.{0} PNat (OrderedCancelCommMonoid.toPartialOrder.{0} PNat (LinearOrderedCancelCommMonoid.toOrderedCancelCommMonoid.{0} PNat instPNatLinearOrderedCancelCommMonoid)))) (OfNat.ofNat.{0} PNat 1 (instOfNatPNatHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) q) -> (LT.lt.{0} Nat instLTNat (Fintype.card.{0} (Units.{0} (LucasLehmer.X q) (LucasLehmer.X.instMonoidX q)) (instFintypeUnits.{0} (LucasLehmer.X q) (LucasLehmer.X.instMonoidX q) (LucasLehmer.X.instFintypeX q) (fun (a : LucasLehmer.X q) (b : LucasLehmer.X q) => LucasLehmer.X.instDecidableEqX q a b))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (PNat.val q) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.units_card LucasLehmer.X.card_units_ltₓ'. -/
/-- There are strictly fewer than `q^2` units, since `0` is not a unit. -/
theorem card_units_lt (w : 1 < q) : Fintype.card (X q)ˣ < q ^ 2 :=
  by
  haveI : Fact (1 < (q : ℕ)) := ⟨w⟩
  convert card_units_lt (X q)
  rw [X_card]
#align lucas_lehmer.X.units_card LucasLehmer.X.card_units_lt

#print LucasLehmer.X.ω /-
/-- We define `ω = 2 + √3`. -/
def ω : X q :=
  (2, 1)
#align lucas_lehmer.X.ω LucasLehmer.X.ω
-/

#print LucasLehmer.X.ωb /-
/-- We define `ωb = 2 - √3`, which is the inverse of `ω`. -/
def ωb : X q :=
  (2, -1)
#align lucas_lehmer.X.ωb LucasLehmer.X.ωb
-/

/- warning: lucas_lehmer.X.ω_mul_ωb -> LucasLehmer.X.ω_mul_ωb is a dubious translation:
lean 3 declaration is
  forall (q : PNat), Eq.{1} (LucasLehmer.X q) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) (LucasLehmer.X.ω q) (LucasLehmer.X.ωb q)) (OfNat.ofNat.{0} (LucasLehmer.X q) 1 (OfNat.mk.{0} (LucasLehmer.X q) 1 (One.one.{0} (LucasLehmer.X q) (LucasLehmer.X.hasOne q))))
but is expected to have type
  forall (q : PNat), Eq.{1} (LucasLehmer.X q) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) (LucasLehmer.X.ω q) (LucasLehmer.X.ωb q)) (OfNat.ofNat.{0} (LucasLehmer.X q) 1 (One.toOfNat1.{0} (LucasLehmer.X q) (LucasLehmer.X.instOneX q)))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.ω_mul_ωb LucasLehmer.X.ω_mul_ωbₓ'. -/
theorem ω_mul_ωb (q : ℕ+) : (ω : X q) * ωb = 1 :=
  by
  dsimp [ω, ωb]
  ext <;> simp <;> ring
#align lucas_lehmer.X.ω_mul_ωb LucasLehmer.X.ω_mul_ωb

/- warning: lucas_lehmer.X.ωb_mul_ω -> LucasLehmer.X.ωb_mul_ω is a dubious translation:
lean 3 declaration is
  forall (q : PNat), Eq.{1} (LucasLehmer.X q) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.hasMul q)) (LucasLehmer.X.ωb q) (LucasLehmer.X.ω q)) (OfNat.ofNat.{0} (LucasLehmer.X q) 1 (OfNat.mk.{0} (LucasLehmer.X q) 1 (One.one.{0} (LucasLehmer.X q) (LucasLehmer.X.hasOne q))))
but is expected to have type
  forall (q : PNat), Eq.{1} (LucasLehmer.X q) (HMul.hMul.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHMul.{0} (LucasLehmer.X q) (LucasLehmer.X.instMulX q)) (LucasLehmer.X.ωb q) (LucasLehmer.X.ω q)) (OfNat.ofNat.{0} (LucasLehmer.X q) 1 (One.toOfNat1.{0} (LucasLehmer.X q) (LucasLehmer.X.instOneX q)))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.ωb_mul_ω LucasLehmer.X.ωb_mul_ωₓ'. -/
theorem ωb_mul_ω (q : ℕ+) : (ωb : X q) * ω = 1 :=
  by
  dsimp [ω, ωb]
  ext <;> simp <;> ring
#align lucas_lehmer.X.ωb_mul_ω LucasLehmer.X.ωb_mul_ω

/- warning: lucas_lehmer.X.closed_form -> LucasLehmer.X.closed_form is a dubious translation:
lean 3 declaration is
  forall {q : PNat} (i : Nat), Eq.{1} (LucasLehmer.X q) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (LucasLehmer.X q) (HasLiftT.mk.{1, 1} Int (LucasLehmer.X q) (CoeTCₓ.coe.{1, 1} Int (LucasLehmer.X q) (Int.castCoe.{0} (LucasLehmer.X q) (AddGroupWithOne.toHasIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.addGroupWithOne q))))) (LucasLehmer.s i)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (Distrib.toHasAdd.{0} (LucasLehmer.X q) (Ring.toDistrib.{0} (LucasLehmer.X q) (LucasLehmer.X.ring q)))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X q) Nat (LucasLehmer.X q) (instHPow.{0, 0} (LucasLehmer.X q) Nat (Monoid.Pow.{0} (LucasLehmer.X q) (LucasLehmer.X.monoid q))) (LucasLehmer.X.ω q) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) i)) (HPow.hPow.{0, 0, 0} (LucasLehmer.X q) Nat (LucasLehmer.X q) (instHPow.{0, 0} (LucasLehmer.X q) Nat (Monoid.Pow.{0} (LucasLehmer.X q) (LucasLehmer.X.monoid q))) (LucasLehmer.X.ωb q) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) i)))
but is expected to have type
  forall {q : PNat} (i : Nat), Eq.{1} (LucasLehmer.X q) (Int.cast.{0} (LucasLehmer.X q) (Ring.toIntCast.{0} (LucasLehmer.X q) (LucasLehmer.X.instRingX q)) (LucasLehmer.s i)) (HAdd.hAdd.{0, 0, 0} (LucasLehmer.X q) (LucasLehmer.X q) (LucasLehmer.X q) (instHAdd.{0} (LucasLehmer.X q) (Distrib.toAdd.{0} (LucasLehmer.X q) (NonUnitalNonAssocSemiring.toDistrib.{0} (LucasLehmer.X q) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (LucasLehmer.X q) (NonAssocRing.toNonUnitalNonAssocRing.{0} (LucasLehmer.X q) (Ring.toNonAssocRing.{0} (LucasLehmer.X q) (LucasLehmer.X.instRingX q))))))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X q) Nat (LucasLehmer.X q) (instHPow.{0, 0} (LucasLehmer.X q) Nat (Monoid.Pow.{0} (LucasLehmer.X q) (LucasLehmer.X.instMonoidX q))) (LucasLehmer.X.ω q) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) i)) (HPow.hPow.{0, 0, 0} (LucasLehmer.X q) Nat (LucasLehmer.X q) (instHPow.{0, 0} (LucasLehmer.X q) Nat (Monoid.Pow.{0} (LucasLehmer.X q) (LucasLehmer.X.instMonoidX q))) (LucasLehmer.X.ωb q) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) i)))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.X.closed_form LucasLehmer.X.closed_formₓ'. -/
/-- A closed form for the recurrence relation. -/
theorem closed_form (i : ℕ) : (s i : X q) = (ω : X q) ^ 2 ^ i + (ωb : X q) ^ 2 ^ i :=
  by
  induction' i with i ih
  · dsimp [s, ω, ωb]
    ext <;> · simp <;> rfl
  ·
    calc
      (s (i + 1) : X q) = (s i ^ 2 - 2 : ℤ) := rfl
      _ = (s i : X q) ^ 2 - 2 := by push_cast
      _ = (ω ^ 2 ^ i + ωb ^ 2 ^ i) ^ 2 - 2 := by rw [ih]
      _ = (ω ^ 2 ^ i) ^ 2 + (ωb ^ 2 ^ i) ^ 2 + 2 * (ωb ^ 2 ^ i * ω ^ 2 ^ i) - 2 := by ring
      _ = (ω ^ 2 ^ i) ^ 2 + (ωb ^ 2 ^ i) ^ 2 := by
        rw [← mul_pow ωb ω, ωb_mul_ω, one_pow, mul_one, add_sub_cancel]
      _ = ω ^ 2 ^ (i + 1) + ωb ^ 2 ^ (i + 1) := by rw [← pow_mul, ← pow_mul, pow_succ']
      
#align lucas_lehmer.X.closed_form LucasLehmer.X.closed_form

end X

open X

/-!
Here and below, we introduce `p' = p - 2`, in order to avoid using subtraction in `ℕ`.
-/


/- warning: lucas_lehmer.two_lt_q -> LucasLehmer.two_lt_q is a dubious translation:
lean 3 declaration is
  forall (p' : Nat), LT.lt.{0} PNat (Preorder.toLT.{0} PNat (PartialOrder.toPreorder.{0} PNat (OrderedCancelCommMonoid.toPartialOrder.{0} PNat (LinearOrderedCancelCommMonoid.toOrderedCancelCommMonoid.{0} PNat PNat.linearOrderedCancelCommMonoid)))) (OfNat.ofNat.{0} PNat 2 (OfNat.mk.{0} PNat 2 (bit0.{0} PNat PNat.hasAdd (One.one.{0} PNat PNat.hasOne)))) (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall (p' : Nat), LT.lt.{0} PNat (Preorder.toLT.{0} PNat (PartialOrder.toPreorder.{0} PNat (OrderedCancelCommMonoid.toPartialOrder.{0} PNat (LinearOrderedCancelCommMonoid.toOrderedCancelCommMonoid.{0} PNat instPNatLinearOrderedCancelCommMonoid)))) (OfNat.ofNat.{0} PNat 2 (instOfNatPNatHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.two_lt_q LucasLehmer.two_lt_qₓ'. -/
/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/
theorem two_lt_q (p' : ℕ) : 2 < q (p' + 2) :=
  by
  by_contra H
  simp at H
  interval_cases; clear H
  · -- If q = 1, we get a contradiction from 2^p = 2
    dsimp [q] at h
    injection h with h'
    clear h
    simp [mersenne] at h'
    exact
      lt_irrefl 2
        (calc
          2 ≤ p' + 2 := Nat.le_add_left _ _
          _ < 2 ^ (p' + 2) := (Nat.lt_two_pow _)
          _ = 2 := Nat.pred_inj (Nat.one_le_two_pow _) (by decide) h'
          )
  · -- If q = 2, we get a contradiction from 2 ∣ 2^p - 1
    dsimp [q] at h
    injection h with h'
    clear h
    rw [mersenne, PNat.one_coe, Nat.minFac_eq_two_iff, pow_succ] at h'
    exact Nat.two_not_dvd_two_mul_sub_one (Nat.one_le_two_pow _) h'
#align lucas_lehmer.two_lt_q LucasLehmer.two_lt_q

/- warning: lucas_lehmer.ω_pow_formula -> LucasLehmer.ω_pow_formula is a dubious translation:
lean 3 declaration is
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (MulZeroClass.toHasZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (Ring.toNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))))))))))))) -> (Exists.{1} Int (fun (k : Int) => Eq.{1} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (instHPow.{0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Nat (Monoid.Pow.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.monoid (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))) (LucasLehmer.X.ω (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HSub.hSub.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (instHSub.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (SubNegMonoid.toHasSub.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toAddGroup.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.addGroupWithOne (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (HMul.hMul.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (instHMul.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.hasMul (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) (HMul.hMul.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (instHMul.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.hasMul (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Int (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Int (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Int.castCoe.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toHasIntCast.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.addGroupWithOne (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) k) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Nat.castCoe.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddMonoidWithOne.toNatCast.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.addGroupWithOne (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))) (mersenne (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (instHPow.{0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Nat (Monoid.Pow.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.monoid (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))) (LucasLehmer.X.ω (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) p'))) (OfNat.ofNat.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) 1 (OfNat.mk.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) 1 (One.one.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.X.hasOne (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))
but is expected to have type
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Zero.toOfNat0.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommMonoidWithZero.toZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommSemiring.toCommMonoidWithZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommRing.toCommSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))) -> (Exists.{1} Int (fun (k : Int) => Eq.{1} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (instHPow.{0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) Nat (Monoid.Pow.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMonoidX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))))) (LucasLehmer.X.ω (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HSub.hSub.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (instHSub.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (Ring.toSub.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instRingX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))))) (HMul.hMul.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (instHMul.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMulX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) (HMul.hMul.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (instHMul.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMulX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) (Int.cast.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (Ring.toIntCast.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instRingX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) k) (Nat.cast.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instNatCastX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (mersenne (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (instHPow.{0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) Nat (Monoid.Pow.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMonoidX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))))) (LucasLehmer.X.ω (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) p'))) (OfNat.ofNat.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) 1 (One.toOfNat1.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instOneX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))))))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.ω_pow_formula LucasLehmer.ω_pow_formulaₓ'. -/
theorem ω_pow_formula (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :
    ∃ k : ℤ,
      (ω : X (q (p' + 2))) ^ 2 ^ (p' + 1) =
        k * mersenne (p' + 2) * (ω : X (q (p' + 2))) ^ 2 ^ p' - 1 :=
  by
  dsimp [lucas_lehmer_residue] at h
  rw [s_zmod_eq_s p'] at h
  simp [ZMod.int_cast_zmod_eq_zero_iff_dvd] at h
  cases' h with k h
  use k
  replace h := congr_arg (fun n : ℤ => (n : X (q (p' + 2)))) h
  -- coercion from ℤ to X q
  dsimp at h
  rw [closed_form] at h
  replace h := congr_arg (fun x => ω ^ 2 ^ p' * x) h
  dsimp at h
  have t : 2 ^ p' + 2 ^ p' = 2 ^ (p' + 1) := by ring
  rw [mul_add, ← pow_add ω, t, ← mul_pow ω ωb (2 ^ p'), ω_mul_ωb, one_pow] at h
  rw [mul_comm, coe_mul] at h
  rw [mul_comm _ (k : X (q (p' + 2)))] at h
  replace h := eq_sub_of_add_eq h
  have : 1 ≤ 2 ^ (p' + 2) := Nat.one_le_pow _ _ (by decide)
  exact_mod_cast h
#align lucas_lehmer.ω_pow_formula LucasLehmer.ω_pow_formula

/- warning: lucas_lehmer.mersenne_coe_X -> LucasLehmer.mersenne_coe_X is a dubious translation:
lean 3 declaration is
  forall (p : Nat), Eq.{1} (LucasLehmer.X (LucasLehmer.q p)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (LucasLehmer.X (LucasLehmer.q p)) (HasLiftT.mk.{1, 1} Nat (LucasLehmer.X (LucasLehmer.q p)) (CoeTCₓ.coe.{1, 1} Nat (LucasLehmer.X (LucasLehmer.q p)) (Nat.castCoe.{0} (LucasLehmer.X (LucasLehmer.q p)) (AddMonoidWithOne.toNatCast.{0} (LucasLehmer.X (LucasLehmer.q p)) (AddGroupWithOne.toAddMonoidWithOne.{0} (LucasLehmer.X (LucasLehmer.q p)) (LucasLehmer.X.addGroupWithOne (LucasLehmer.q p))))))) (mersenne p)) (OfNat.ofNat.{0} (LucasLehmer.X (LucasLehmer.q p)) 0 (OfNat.mk.{0} (LucasLehmer.X (LucasLehmer.q p)) 0 (Zero.zero.{0} (LucasLehmer.X (LucasLehmer.q p)) (MulZeroClass.toHasZero.{0} (LucasLehmer.X (LucasLehmer.q p)) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (LucasLehmer.X (LucasLehmer.q p)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (LucasLehmer.X (LucasLehmer.q p)) (NonAssocRing.toNonUnitalNonAssocRing.{0} (LucasLehmer.X (LucasLehmer.q p)) (Ring.toNonAssocRing.{0} (LucasLehmer.X (LucasLehmer.q p)) (LucasLehmer.X.ring (LucasLehmer.q p))))))))))
but is expected to have type
  forall (p : Nat), Eq.{1} (LucasLehmer.X (LucasLehmer.q p)) (Nat.cast.{0} (LucasLehmer.X (LucasLehmer.q p)) (LucasLehmer.X.instNatCastX (LucasLehmer.q p)) (mersenne p)) (OfNat.ofNat.{0} (LucasLehmer.X (LucasLehmer.q p)) 0 (Zero.toOfNat0.{0} (LucasLehmer.X (LucasLehmer.q p)) (CommMonoidWithZero.toZero.{0} (LucasLehmer.X (LucasLehmer.q p)) (CommSemiring.toCommMonoidWithZero.{0} (LucasLehmer.X (LucasLehmer.q p)) (CommRing.toCommSemiring.{0} (LucasLehmer.X (LucasLehmer.q p)) (LucasLehmer.X.instCommRingX (LucasLehmer.q p)))))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.mersenne_coe_X LucasLehmer.mersenne_coe_Xₓ'. -/
/-- `q` is the minimum factor of `mersenne p`, so `M p = 0` in `X q`. -/
theorem mersenne_coe_X (p : ℕ) : (mersenne p : X (q p)) = 0 :=
  by
  ext <;> simp [mersenne, q, ZMod.nat_cast_zmod_eq_zero_iff_dvd, -pow_pos]
  apply Nat.minFac_dvd
#align lucas_lehmer.mersenne_coe_X LucasLehmer.mersenne_coe_X

/- warning: lucas_lehmer.ω_pow_eq_neg_one -> LucasLehmer.ω_pow_eq_neg_one is a dubious translation:
lean 3 declaration is
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (MulZeroClass.toHasZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (Ring.toNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))))))))))))) -> (Eq.{1} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (instHPow.{0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Nat (Monoid.Pow.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.monoid (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))) (LucasLehmer.X.ω (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Neg.neg.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (SubNegMonoid.toHasNeg.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroup.toSubNegMonoid.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toAddGroup.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.addGroupWithOne (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))) (OfNat.ofNat.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) 1 (OfNat.mk.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) 1 (One.one.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.X.hasOne (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))
but is expected to have type
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Zero.toOfNat0.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommMonoidWithZero.toZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommSemiring.toCommMonoidWithZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommRing.toCommSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))) -> (Eq.{1} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (instHPow.{0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) Nat (Monoid.Pow.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMonoidX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))))) (LucasLehmer.X.ω (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Neg.neg.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (Ring.toNeg.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instRingX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) (OfNat.ofNat.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) 1 (One.toOfNat1.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instOneX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.ω_pow_eq_neg_one LucasLehmer.ω_pow_eq_neg_oneₓ'. -/
theorem ω_pow_eq_neg_one (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :
    (ω : X (q (p' + 2))) ^ 2 ^ (p' + 1) = -1 :=
  by
  cases' ω_pow_formula p' h with k w
  rw [mersenne_coe_X] at w
  simpa using w
#align lucas_lehmer.ω_pow_eq_neg_one LucasLehmer.ω_pow_eq_neg_one

/- warning: lucas_lehmer.ω_pow_eq_one -> LucasLehmer.ω_pow_eq_one is a dubious translation:
lean 3 declaration is
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (MulZeroClass.toHasZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (Ring.toNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))))))))))))) -> (Eq.{1} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (instHPow.{0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Nat (Monoid.Pow.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.monoid (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))) (LucasLehmer.X.ω (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) 1 (OfNat.mk.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) 1 (One.one.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.X.hasOne (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))
but is expected to have type
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Zero.toOfNat0.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommMonoidWithZero.toZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommSemiring.toCommMonoidWithZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommRing.toCommSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))) -> (Eq.{1} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HPow.hPow.{0, 0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) Nat (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (instHPow.{0, 0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) Nat (Monoid.Pow.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMonoidX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))))) (LucasLehmer.X.ω (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (OfNat.ofNat.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) 1 (One.toOfNat1.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instOneX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.ω_pow_eq_one LucasLehmer.ω_pow_eq_oneₓ'. -/
theorem ω_pow_eq_one (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :
    (ω : X (q (p' + 2))) ^ 2 ^ (p' + 2) = 1 :=
  calc
    (ω : X (q (p' + 2))) ^ 2 ^ (p' + 2) = (ω ^ 2 ^ (p' + 1)) ^ 2 := by rw [← pow_mul, ← pow_succ']
    _ = (-1) ^ 2 := by rw [ω_pow_eq_neg_one p' h]
    _ = 1 := by simp
    
#align lucas_lehmer.ω_pow_eq_one LucasLehmer.ω_pow_eq_one

/- warning: lucas_lehmer.ω_unit -> LucasLehmer.ωUnit is a dubious translation:
lean 3 declaration is
  forall (p : Nat), Units.{0} (LucasLehmer.X (LucasLehmer.q p)) (LucasLehmer.X.monoid (LucasLehmer.q p))
but is expected to have type
  forall (p : Nat), Units.{0} (LucasLehmer.X (LucasLehmer.q p)) (LucasLehmer.X.instMonoidX (LucasLehmer.q p))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.ω_unit LucasLehmer.ωUnitₓ'. -/
/-- `ω` as an element of the group of units. -/
def ωUnit (p : ℕ) : Units (X (q p)) where
  val := ω
  inv := ωb
  val_inv := by simp [ω_mul_ωb]
  inv_val := by simp [ωb_mul_ω]
#align lucas_lehmer.ω_unit LucasLehmer.ωUnit

#print LucasLehmer.ωUnit_coe /-
@[simp]
theorem ωUnit_coe (p : ℕ) : (ωUnit p : X (q p)) = ω :=
  rfl
#align lucas_lehmer.ω_unit_coe LucasLehmer.ωUnit_coe
-/

/- warning: lucas_lehmer.order_ω -> LucasLehmer.order_ω is a dubious translation:
lean 3 declaration is
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (MulZeroClass.toHasZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (Ring.toNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))))))))))))) -> (Eq.{1} Nat (orderOf.{0} (Units.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.monoid (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) (DivInvMonoid.toMonoid.{0} (Units.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.monoid (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) (Group.toDivInvMonoid.{0} (Units.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.monoid (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) (Units.group.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (LucasLehmer.X.monoid (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))) (LucasLehmer.ωUnit (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))
but is expected to have type
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Zero.toOfNat0.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommMonoidWithZero.toZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommSemiring.toCommMonoidWithZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommRing.toCommSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))) -> (Eq.{1} Nat (orderOf.{0} (Units.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMonoidX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) (DivInvMonoid.toMonoid.{0} (Units.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMonoidX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) (Group.toDivInvMonoid.{0} (Units.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMonoidX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) (Units.instGroupUnits.{0} (LucasLehmer.X (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (LucasLehmer.X.instMonoidX (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))))) (LucasLehmer.ωUnit (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.order_ω LucasLehmer.order_ωₓ'. -/
/-- The order of `ω` in the unit group is exactly `2^p`. -/
theorem order_ω (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :
    orderOf (ωUnit (p' + 2)) = 2 ^ (p' + 2) :=
  by
  apply Nat.eq_prime_pow_of_dvd_least_prime_pow
  -- the order of ω divides 2^p
  · exact Nat.prime_two
  · intro o
    have ω_pow := orderOf_dvd_iff_pow_eq_one.1 o
    replace ω_pow :=
      congr_arg (Units.coeHom (X (q (p' + 2))) : Units (X (q (p' + 2))) → X (q (p' + 2))) ω_pow
    simp at ω_pow
    have h : (1 : ZMod (q (p' + 2))) = -1 :=
      congr_arg Prod.fst (ω_pow.symm.trans (ω_pow_eq_neg_one p' h))
    haveI : Fact (2 < (q (p' + 2) : ℕ)) := ⟨two_lt_q _⟩
    apply ZMod.neg_one_ne_one h.symm
  · apply orderOf_dvd_iff_pow_eq_one.2
    apply Units.ext
    push_cast
    exact ω_pow_eq_one p' h
#align lucas_lehmer.order_ω LucasLehmer.order_ω

/- warning: lucas_lehmer.order_ineq -> LucasLehmer.order_ineq is a dubious translation:
lean 3 declaration is
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (MulZeroClass.toHasZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocSemiring.toMulZeroClass.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (Ring.toNonAssocRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (CommRing.toRing.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (One.one.{0} Nat Nat.hasOne))))))))))))) -> (LT.lt.{0} Nat Nat.hasLt (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) PNat Nat (HasLiftT.mk.{1, 1} PNat Nat (CoeTCₓ.coe.{1, 1} PNat Nat (coeBase.{1, 1} PNat Nat coePNatNat))) (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) p' (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall (p' : Nat), (Eq.{1} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (LucasLehmer.lucasLehmerResidue (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Zero.toOfNat0.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommMonoidWithZero.toZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommSemiring.toCommMonoidWithZero.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (CommRing.toCommSemiring.{0} (ZMod (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (ZMod.commRing (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))) -> (LT.lt.{0} Nat instLTNat (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (PNat.val (LucasLehmer.q (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) p' (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.order_ineq LucasLehmer.order_ineqₓ'. -/
theorem order_ineq (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :
    2 ^ (p' + 2) < (q (p' + 2) : ℕ) ^ 2 :=
  calc
    2 ^ (p' + 2) = orderOf (ωUnit (p' + 2)) := (order_ω p' h).symm
    _ ≤ Fintype.card (X _)ˣ := orderOf_le_card_univ
    _ < (q (p' + 2) : ℕ) ^ 2 := card_units_lt (Nat.lt_of_succ_lt (two_lt_q _))
    
#align lucas_lehmer.order_ineq LucasLehmer.order_ineq

end LucasLehmer

export LucasLehmer (LucasLehmerTest lucasLehmerResidue)

open LucasLehmer

#print lucas_lehmer_sufficiency /-
theorem lucas_lehmer_sufficiency (p : ℕ) (w : 1 < p) : LucasLehmerTest p → (mersenne p).Prime :=
  by
  let p' := p - 2
  have z : p = p' + 2 := (tsub_eq_iff_eq_add_of_le w.nat_succ_le).mp rfl
  have w : 1 < p' + 2 := Nat.lt_of_sub_eq_succ rfl
  contrapose
  intro a t
  rw [z] at a
  rw [z] at t
  have h₁ := order_ineq p' t
  have h₂ := Nat.minFac_sq_le_self (mersenne_pos (Nat.lt_of_succ_lt w)) a
  have h := lt_of_lt_of_le h₁ h₂
  exact not_lt_of_ge (Nat.sub_le _ _) h
#align lucas_lehmer_sufficiency lucas_lehmer_sufficiency
-/

-- Here we calculate the residue, very inefficiently, using `dec_trivial`. We can do much better.
example : (mersenne 5).Prime :=
  lucas_lehmer_sufficiency 5 (by norm_num) (by decide)

-- Next we use `norm_num` to calculate each `s p i`.
namespace LucasLehmer

open Tactic

/- warning: lucas_lehmer.s_mod_succ -> LucasLehmer.sMod_succ is a dubious translation:
lean 3 declaration is
  forall {p : Nat} {a : Int} {i : Nat} {b : Int} {c : Int}, (Eq.{1} Int (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))) p) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) a) -> (Eq.{1} Int (LucasLehmer.sMod p i) b) -> (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.hasMul) b b) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))) a) c) -> (Eq.{1} Int (LucasLehmer.sMod p (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) i (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) c)
but is expected to have type
  forall {p : Nat} {a : Int} {i : Nat} {b : Int} {c : Int}, (Eq.{1} Int (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2)) p) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) a) -> (Eq.{1} Int (LucasLehmer.sMod p i) b) -> (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.instMulInt) b b) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2))) a) c) -> (Eq.{1} Int (LucasLehmer.sMod p (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) i (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) c)
Case conversion may be inaccurate. Consider using '#align lucas_lehmer.s_mod_succ LucasLehmer.sMod_succₓ'. -/
theorem sMod_succ {p a i b c} (h1 : (2 ^ p - 1 : ℤ) = a) (h2 : sMod p i = b)
    (h3 : (b * b - 2) % a = c) : sMod p (i + 1) = c :=
  by
  dsimp [s_mod, mersenne]
  rw [h1, h2, sq, h3]
#align lucas_lehmer.s_mod_succ LucasLehmer.sMod_succ

/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/
/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/
/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/
/-- Given a goal of the form `lucas_lehmer_test p`,
attempt to do the calculation using `norm_num` to certify each step.
-/
unsafe def run_test : tactic Unit := do
  let q(LucasLehmerTest $(p)) ← target
  sorry
  sorry
  let p ← eval_expr ℕ p
  let-- Calculate the candidate Mersenne prime
  M : ℤ := 2 ^ p - 1
  let t ← to_expr ``(2 ^ $(q(p)) - 1 = $(q(M)))
  let v ← to_expr ``((by norm_num : 2 ^ $(q(p)) - 1 = $(q(M))))
  let w ← assertv `w t v
  let t
    ←-- base case
        to_expr
        ``(sMod $(q(p)) 0 = 4)
  let v ← to_expr ``((by norm_num [LucasLehmer.sMod] : sMod $(q(p)) 0 = 4))
  let h ← assertv `h t v
  -- step case, repeated p-2 times
      iterate_exactly
      (p - 2) sorry
  let h
    ←-- now close the goal
        get_local
        `h
  exact h
#align lucas_lehmer.run_test lucas_lehmer.run_test

end LucasLehmer

/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic lucas_lehmer.run_test -/
/-- We verify that the tactic works to prove `127.prime`. -/
example : (mersenne 7).Prime :=
  lucas_lehmer_sufficiency _ (by norm_num)
    (by
      run_tac
        lucas_lehmer.run_test)

/-!
This implementation works successfully to prove `(2^127 - 1).prime`,
and all the Mersenne primes up to this point appear in [archive/examples/mersenne_primes.lean].

`(2^127 - 1).prime` takes about 5 minutes to run (depending on your CPU!),
and unfortunately the next Mersenne prime `(2^521 - 1)`,
which was the first "computer era" prime,
is out of reach with the current implementation.

There's still low hanging fruit available to do faster computations
based on the formula
```
n ≡ (n % 2^p) + (n / 2^p) [MOD 2^p - 1]
```
and the fact that `% 2^p` and `/ 2^p` can be very efficient on the binary representation.
Someone should do this, too!
-/


#print modEq_mersenne /-
theorem modEq_mersenne (n k : ℕ) : k ≡ k / 2 ^ n + k % 2 ^ n [MOD 2 ^ n - 1] :=
  by
  -- See https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/help.20finding.20a.20lemma/near/177698446
  conv in k => rw [← Nat.div_add_mod k (2 ^ n)]
  refine' Nat.ModEq.add_right _ _
  conv =>
    congr
    skip
    skip
    rw [← one_mul (k / 2 ^ n)]
  exact (Nat.modEq_sub <| Nat.succ_le_of_lt <| pow_pos zero_lt_two _).mul_right _
#align modeq_mersenne modEq_mersenne
-/

-- It's hard to know what the limiting factor for large Mersenne primes would be.
-- In the purely computational world, I think it's the squaring operation in `s`.
