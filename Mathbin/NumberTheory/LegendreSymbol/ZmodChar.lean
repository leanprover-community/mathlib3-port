/-
Copyright (c) 2022 Michael Stoll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael Stoll

! This file was ported from Lean 3 source module number_theory.legendre_symbol.zmod_char
! leanprover-community/mathlib commit 38df578a6450a8c5142b3727e3ae894c2300cae0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Int.Range
import Mathbin.Data.Zmod.Basic
import Mathbin.NumberTheory.LegendreSymbol.MulCharacter

/-!
# Quadratic characters on ℤ/nℤ

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines some quadratic characters on the rings ℤ/4ℤ and ℤ/8ℤ.

We set them up to be of type `mul_char (zmod n) ℤ`, where `n` is `4` or `8`.

## Tags

quadratic character, zmod
-/


/-!
### Quadratic characters mod 4 and 8

We define the primitive quadratic characters `χ₄`on `zmod 4`
and `χ₈`, `χ₈'` on `zmod 8`.
-/


namespace ZMod

section QuadCharModP

/- warning: zmod.χ₄ -> ZMod.χ₄ is a dubious translation:
lean 3 declaration is
  MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)
but is expected to have type
  MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄ ZMod.χ₄ₓ'. -/
/-- Define the nontrivial quadratic character on `zmod 4`, `χ₄`.
It corresponds to the extension `ℚ(√-1)/ℚ`. -/
@[simps]
def χ₄ : MulChar (ZMod 4) ℤ
    where
  toFun := (![0, 1, 0, -1] : ZMod 4 → ℤ)
  map_one' := rfl
  map_mul' := by decide
  map_nonunit' := by decide
#align zmod.χ₄ ZMod.χ₄

/- warning: zmod.is_quadratic_χ₄ -> ZMod.isQuadratic_χ₄ is a dubious translation:
lean 3 declaration is
  MulChar.IsQuadratic.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) Int Int.commRing ZMod.χ₄
but is expected to have type
  MulChar.IsQuadratic.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) Int Int.instCommRingInt ZMod.χ₄
Case conversion may be inaccurate. Consider using '#align zmod.is_quadratic_χ₄ ZMod.isQuadratic_χ₄ₓ'. -/
/-- `χ₄` takes values in `{0, 1, -1}` -/
theorem isQuadratic_χ₄ : χ₄.IsQuadratic := by intro a; decide!
#align zmod.is_quadratic_χ₄ ZMod.isQuadratic_χ₄

/- warning: zmod.χ₄_nat_mod_four -> ZMod.χ₄_nat_mod_four is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) n)) (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))
but is expected to have type
  forall (n : Nat), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))))) n)) (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))))) (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄_nat_mod_four ZMod.χ₄_nat_mod_fourₓ'. -/
/-- The value of `χ₄ n`, for `n : ℕ`, depends only on `n % 4`. -/
theorem χ₄_nat_mod_four (n : ℕ) : χ₄ n = χ₄ (n % 4 : ℕ) := by rw [← ZMod.nat_cast_mod n 4]
#align zmod.χ₄_nat_mod_four ZMod.χ₄_nat_mod_four

/- warning: zmod.χ₄_int_mod_four -> ZMod.χ₄_int_mod_four is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Int.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))))) n)) (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Int.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))))) (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 4 (OfNat.mk.{0} Int 4 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))))
but is expected to have type
  forall (n : Int), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Int.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Ring.toIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))))) n)) (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Int.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Ring.toIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))))) (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 4 (instOfNatInt 4)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄_int_mod_four ZMod.χ₄_int_mod_fourₓ'. -/
/-- The value of `χ₄ n`, for `n : ℤ`, depends only on `n % 4`. -/
theorem χ₄_int_mod_four (n : ℤ) : χ₄ n = χ₄ (n % 4 : ℤ) := by rw [← ZMod.int_cast_mod n 4];
  norm_cast
#align zmod.χ₄_int_mod_four ZMod.χ₄_int_mod_four

/- warning: zmod.χ₄_int_eq_if_mod_four -> ZMod.χ₄_int_eq_if_mod_four is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Int.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))))) n)) (ite.{1} Int (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))) (Int.decidableEq (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) (ite.{1} Int (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 4 (OfNat.mk.{0} Int 4 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (Int.decidableEq (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 4 (OfNat.mk.{0} Int 4 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))) (Neg.neg.{0} Int Int.hasNeg (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))))
but is expected to have type
  forall (n : Int), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Int.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Ring.toIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))))) n)) (ite.{1} Int (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 2 (instOfNatInt 2))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))) (Int.instDecidableEqInt (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 2 (instOfNatInt 2))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) (ite.{1} Int (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 4 (instOfNatInt 4))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (Int.instDecidableEqInt (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 4 (instOfNatInt 4))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)) (Neg.neg.{0} Int Int.instNegInt (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄_int_eq_if_mod_four ZMod.χ₄_int_eq_if_mod_fourₓ'. -/
/-- An explicit description of `χ₄` on integers / naturals -/
theorem χ₄_int_eq_if_mod_four (n : ℤ) :
    χ₄ n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1 :=
  by
  have help : ∀ m : ℤ, 0 ≤ m → m < 4 → χ₄ m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1 := by
    decide
  rw [← Int.emod_emod_of_dvd n (by norm_num : (2 : ℤ) ∣ 4), ← ZMod.int_cast_mod n 4]
  exact help (n % 4) (Int.emod_nonneg n (by norm_num)) (Int.emod_lt n (by norm_num))
#align zmod.χ₄_int_eq_if_mod_four ZMod.χ₄_int_eq_if_mod_four

/- warning: zmod.χ₄_nat_eq_if_mod_four -> ZMod.χ₄_nat_eq_if_mod_four is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) n)) (ite.{1} Int (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (Nat.decidableEq (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) (ite.{1} Int (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Nat.decidableEq (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))) (Neg.neg.{0} Int Int.hasNeg (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))))
but is expected to have type
  forall (n : Nat), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))))) n)) (ite.{1} Int (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (instDecidableEqNat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) (ite.{1} Int (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (instDecidableEqNat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)) (Neg.neg.{0} Int Int.instNegInt (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄_nat_eq_if_mod_four ZMod.χ₄_nat_eq_if_mod_fourₓ'. -/
theorem χ₄_nat_eq_if_mod_four (n : ℕ) :
    χ₄ n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1 := by
  exact_mod_cast χ₄_int_eq_if_mod_four n
#align zmod.χ₄_nat_eq_if_mod_four ZMod.χ₄_nat_eq_if_mod_four

/- warning: zmod.χ₄_eq_neg_one_pow -> ZMod.χ₄_eq_neg_one_pow is a dubious translation:
lean 3 declaration is
  forall {n : Nat}, (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) n)) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) (Neg.neg.{0} Int Int.hasNeg (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (HDiv.hDiv.{0, 0, 0} Nat Nat Nat (instHDiv.{0} Nat Nat.hasDiv) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))
but is expected to have type
  forall {n : Nat}, (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))))) n)) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) (Neg.neg.{0} Int Int.instNegInt (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (HDiv.hDiv.{0, 0, 0} Nat Nat Nat (instHDiv.{0} Nat Nat.instDivNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄_eq_neg_one_pow ZMod.χ₄_eq_neg_one_powₓ'. -/
/-- Alternative description of `χ₄ n` for odd `n : ℕ` in terms of powers of `-1` -/
theorem χ₄_eq_neg_one_pow {n : ℕ} (hn : n % 2 = 1) : χ₄ n = (-1) ^ (n / 2) :=
  by
  rw [χ₄_nat_eq_if_mod_four]
  simp only [hn, Nat.one_ne_zero, if_false]
  nth_rw 1 [← Nat.div_add_mod n 4]
  nth_rw 1 [(by norm_num : 4 = 2 * 2)]
  rw [mul_assoc, add_comm, Nat.add_mul_div_left _ _ (by norm_num : 0 < 2), pow_add, pow_mul,
    neg_one_sq, one_pow, mul_one]
  have help : ∀ m : ℕ, m < 4 → m % 2 = 1 → ite (m = 1) (1 : ℤ) (-1) = (-1) ^ (m / 2) := by decide
  exact
    help (n % 4) (Nat.mod_lt n (by norm_num))
      ((Nat.mod_mod_of_dvd n (by norm_num : 2 ∣ 4)).trans hn)
#align zmod.χ₄_eq_neg_one_pow ZMod.χ₄_eq_neg_one_pow

/- warning: zmod.χ₄_nat_one_mod_four -> ZMod.χ₄_nat_one_mod_four is a dubious translation:
lean 3 declaration is
  forall {n : Nat}, (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) n)) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))
but is expected to have type
  forall {n : Nat}, (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))))) n)) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄_nat_one_mod_four ZMod.χ₄_nat_one_mod_fourₓ'. -/
/-- If `n % 4 = 1`, then `χ₄ n = 1`. -/
theorem χ₄_nat_one_mod_four {n : ℕ} (hn : n % 4 = 1) : χ₄ n = 1 := by rw [χ₄_nat_mod_four, hn]; rfl
#align zmod.χ₄_nat_one_mod_four ZMod.χ₄_nat_one_mod_four

/- warning: zmod.χ₄_nat_three_mod_four -> ZMod.χ₄_nat_three_mod_four is a dubious translation:
lean 3 declaration is
  forall {n : Nat}, (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) n)) (Neg.neg.{0} Int Int.hasNeg (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))))
but is expected to have type
  forall {n : Nat}, (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> (Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))))) n)) (Neg.neg.{0} Int Int.instNegInt (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄_nat_three_mod_four ZMod.χ₄_nat_three_mod_fourₓ'. -/
/-- If `n % 4 = 3`, then `χ₄ n = -1`. -/
theorem χ₄_nat_three_mod_four {n : ℕ} (hn : n % 4 = 3) : χ₄ n = -1 := by rw [χ₄_nat_mod_four, hn];
  rfl
#align zmod.χ₄_nat_three_mod_four ZMod.χ₄_nat_three_mod_four

/- warning: zmod.χ₄_int_one_mod_four -> ZMod.χ₄_int_one_mod_four is a dubious translation:
lean 3 declaration is
  forall {n : Int}, (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 4 (OfNat.mk.{0} Int 4 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) -> (Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Int.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))))) n)) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))
but is expected to have type
  forall {n : Int}, (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 4 (instOfNatInt 4))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) -> (Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Int.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Ring.toIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))))) n)) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄_int_one_mod_four ZMod.χ₄_int_one_mod_fourₓ'. -/
/-- If `n % 4 = 1`, then `χ₄ n = 1`. -/
theorem χ₄_int_one_mod_four {n : ℤ} (hn : n % 4 = 1) : χ₄ n = 1 := by rw [χ₄_int_mod_four, hn]; rfl
#align zmod.χ₄_int_one_mod_four ZMod.χ₄_int_one_mod_four

/- warning: zmod.χ₄_int_three_mod_four -> ZMod.χ₄_int_three_mod_four is a dubious translation:
lean 3 declaration is
  forall {n : Int}, (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 4 (OfNat.mk.{0} Int 4 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))))) (OfNat.ofNat.{0} Int 3 (OfNat.mk.{0} Int 3 (bit1.{0} Int Int.hasOne Int.hasAdd (One.one.{0} Int Int.hasOne))))) -> (Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Int.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))))) n)) (Neg.neg.{0} Int Int.hasNeg (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))))
but is expected to have type
  forall {n : Int}, (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 4 (instOfNatInt 4))) (OfNat.ofNat.{0} Int 3 (instOfNatInt 3))) -> (Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (Int.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Ring.toIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))))) n)) (Neg.neg.{0} Int Int.instNegInt (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₄_int_three_mod_four ZMod.χ₄_int_three_mod_fourₓ'. -/
/-- If `n % 4 = 3`, then `χ₄ n = -1`. -/
theorem χ₄_int_three_mod_four {n : ℤ} (hn : n % 4 = 3) : χ₄ n = -1 := by rw [χ₄_int_mod_four, hn];
  rfl
#align zmod.χ₄_int_three_mod_four ZMod.χ₄_int_three_mod_four

/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/
theorem neg_one_pow_div_two_of_one_mod_four {n : ℕ} (hn : n % 4 = 1) : (-1 : ℤ) ^ (n / 2) = 1 := by
  rw [← χ₄_eq_neg_one_pow (Nat.odd_of_mod_four_eq_one hn), ← nat_cast_mod, hn]; rfl
#align neg_one_pow_div_two_of_one_mod_four neg_one_pow_div_two_of_one_mod_four

/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/
theorem neg_one_pow_div_two_of_three_mod_four {n : ℕ} (hn : n % 4 = 3) : (-1 : ℤ) ^ (n / 2) = -1 :=
  by rw [← χ₄_eq_neg_one_pow (Nat.odd_of_mod_four_eq_three hn), ← nat_cast_mod, hn]; rfl
#align neg_one_pow_div_two_of_three_mod_four neg_one_pow_div_two_of_three_mod_four

/- warning: zmod.χ₈ -> ZMod.χ₈ is a dubious translation:
lean 3 declaration is
  MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)
but is expected to have type
  MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₈ ZMod.χ₈ₓ'. -/
/-- Define the first primitive quadratic character on `zmod 8`, `χ₈`.
It corresponds to the extension `ℚ(√2)/ℚ`. -/
@[simps]
def χ₈ : MulChar (ZMod 8) ℤ
    where
  toFun := (![0, 1, 0, -1, 0, -1, 0, 1] : ZMod 8 → ℤ)
  map_one' := rfl
  map_mul' := by decide
  map_nonunit' := by decide
#align zmod.χ₈ ZMod.χ₈

/- warning: zmod.is_quadratic_χ₈ -> ZMod.isQuadratic_χ₈ is a dubious translation:
lean 3 declaration is
  MulChar.IsQuadratic.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int Int.commRing ZMod.χ₈
but is expected to have type
  MulChar.IsQuadratic.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) Int Int.instCommRingInt ZMod.χ₈
Case conversion may be inaccurate. Consider using '#align zmod.is_quadratic_χ₈ ZMod.isQuadratic_χ₈ₓ'. -/
/-- `χ₈` takes values in `{0, 1, -1}` -/
theorem isQuadratic_χ₈ : χ₈.IsQuadratic := by intro a; decide!
#align zmod.is_quadratic_χ₈ ZMod.isQuadratic_χ₈

/- warning: zmod.χ₈_nat_mod_eight -> ZMod.χ₈_nat_mod_eight is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))))))) n)) (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))))))) (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))
but is expected to have type
  forall (n : Nat), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈ (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))))) n)) (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈ (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))))) (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₈_nat_mod_eight ZMod.χ₈_nat_mod_eightₓ'. -/
/-- The value of `χ₈ n`, for `n : ℕ`, depends only on `n % 8`. -/
theorem χ₈_nat_mod_eight (n : ℕ) : χ₈ n = χ₈ (n % 8 : ℕ) := by rw [← ZMod.nat_cast_mod n 8]
#align zmod.χ₈_nat_mod_eight ZMod.χ₈_nat_mod_eight

/- warning: zmod.χ₈_int_mod_eight -> ZMod.χ₈_int_mod_eight is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Int.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) n)) (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Int.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))))))))
but is expected to have type
  forall (n : Int), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈ (Int.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (Ring.toIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))))) n)) (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈ (Int.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (Ring.toIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))))) (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₈_int_mod_eight ZMod.χ₈_int_mod_eightₓ'. -/
/-- The value of `χ₈ n`, for `n : ℤ`, depends only on `n % 8`. -/
theorem χ₈_int_mod_eight (n : ℤ) : χ₈ n = χ₈ (n % 8 : ℤ) := by rw [← ZMod.int_cast_mod n 8];
  norm_cast
#align zmod.χ₈_int_mod_eight ZMod.χ₈_int_mod_eight

/- warning: zmod.χ₈_int_eq_if_mod_eight -> ZMod.χ₈_int_eq_if_mod_eight is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Int.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) n)) (ite.{1} Int (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))) (Int.decidableEq (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) (ite.{1} Int (Or (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 7 (OfNat.mk.{0} Int 7 (bit1.{0} Int Int.hasOne Int.hasAdd (bit1.{0} Int Int.hasOne Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (Or.decidable (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 7 (OfNat.mk.{0} Int 7 (bit1.{0} Int Int.hasOne Int.hasAdd (bit1.{0} Int Int.hasOne Int.hasAdd (One.one.{0} Int Int.hasOne)))))) (Int.decidableEq (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (Int.decidableEq (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 7 (OfNat.mk.{0} Int 7 (bit1.{0} Int Int.hasOne Int.hasAdd (bit1.{0} Int Int.hasOne Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))) (Neg.neg.{0} Int Int.hasNeg (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))))
but is expected to have type
  forall (n : Int), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈ (Int.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (Ring.toIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))))) n)) (ite.{1} Int (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 2 (instOfNatInt 2))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))) (Int.instDecidableEqInt (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 2 (instOfNatInt 2))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) (ite.{1} Int (Or (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 7 (instOfNatInt 7)))) (instDecidableOr (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 7 (instOfNatInt 7))) (Int.instDecidableEqInt (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (Int.instDecidableEqInt (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 7 (instOfNatInt 7)))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)) (Neg.neg.{0} Int Int.instNegInt (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₈_int_eq_if_mod_eight ZMod.χ₈_int_eq_if_mod_eightₓ'. -/
/-- An explicit description of `χ₈` on integers / naturals -/
theorem χ₈_int_eq_if_mod_eight (n : ℤ) :
    χ₈ n = if n % 2 = 0 then 0 else if n % 8 = 1 ∨ n % 8 = 7 then 1 else -1 :=
  by
  have help :
    ∀ m : ℤ, 0 ≤ m → m < 8 → χ₈ m = if m % 2 = 0 then 0 else if m = 1 ∨ m = 7 then 1 else -1 := by
    decide
  rw [← Int.emod_emod_of_dvd n (by norm_num : (2 : ℤ) ∣ 8), ← ZMod.int_cast_mod n 8]
  exact help (n % 8) (Int.emod_nonneg n (by norm_num)) (Int.emod_lt n (by norm_num))
#align zmod.χ₈_int_eq_if_mod_eight ZMod.χ₈_int_eq_if_mod_eight

/- warning: zmod.χ₈_nat_eq_if_mod_eight -> ZMod.χ₈_nat_eq_if_mod_eight is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))))))) n)) (ite.{1} Int (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (Nat.decidableEq (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) (ite.{1} Int (Or (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 7 (OfNat.mk.{0} Nat 7 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Or.decidable (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 7 (OfNat.mk.{0} Nat 7 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Nat.decidableEq (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Nat.decidableEq (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 7 (OfNat.mk.{0} Nat 7 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))) (Neg.neg.{0} Int Int.hasNeg (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))))
but is expected to have type
  forall (n : Nat), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈ (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))))) n)) (ite.{1} Int (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (instDecidableEqNat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) (ite.{1} Int (Or (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 7 (instOfNatNat 7)))) (instDecidableOr (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 7 (instOfNatNat 7))) (instDecidableEqNat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (instDecidableEqNat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 7 (instOfNatNat 7)))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)) (Neg.neg.{0} Int Int.instNegInt (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₈_nat_eq_if_mod_eight ZMod.χ₈_nat_eq_if_mod_eightₓ'. -/
theorem χ₈_nat_eq_if_mod_eight (n : ℕ) :
    χ₈ n = if n % 2 = 0 then 0 else if n % 8 = 1 ∨ n % 8 = 7 then 1 else -1 := by
  exact_mod_cast χ₈_int_eq_if_mod_eight n
#align zmod.χ₈_nat_eq_if_mod_eight ZMod.χ₈_nat_eq_if_mod_eight

/- warning: zmod.χ₈' -> ZMod.χ₈' is a dubious translation:
lean 3 declaration is
  MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)
but is expected to have type
  MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₈' ZMod.χ₈'ₓ'. -/
/-- Define the second primitive quadratic character on `zmod 8`, `χ₈'`.
It corresponds to the extension `ℚ(√-2)/ℚ`. -/
@[simps]
def χ₈' : MulChar (ZMod 8) ℤ
    where
  toFun := (![0, 1, 0, 1, 0, -1, 0, -1] : ZMod 8 → ℤ)
  map_one' := rfl
  map_mul' := by decide
  map_nonunit' := by decide
#align zmod.χ₈' ZMod.χ₈'

/- warning: zmod.is_quadratic_χ₈' -> ZMod.isQuadratic_χ₈' is a dubious translation:
lean 3 declaration is
  MulChar.IsQuadratic.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int Int.commRing ZMod.χ₈'
but is expected to have type
  MulChar.IsQuadratic.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) Int Int.instCommRingInt ZMod.χ₈'
Case conversion may be inaccurate. Consider using '#align zmod.is_quadratic_χ₈' ZMod.isQuadratic_χ₈'ₓ'. -/
/-- `χ₈'` takes values in `{0, 1, -1}` -/
theorem isQuadratic_χ₈' : χ₈'.IsQuadratic := by intro a; decide!
#align zmod.is_quadratic_χ₈' ZMod.isQuadratic_χ₈'

/- warning: zmod.χ₈'_int_eq_if_mod_eight -> ZMod.χ₈'_int_eq_if_mod_eight is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈' ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Int (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Int.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toHasIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))))) n)) (ite.{1} Int (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))) (Int.decidableEq (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) (ite.{1} Int (Or (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 3 (OfNat.mk.{0} Int 3 (bit1.{0} Int Int.hasOne Int.hasAdd (One.one.{0} Int Int.hasOne)))))) (Or.decidable (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 3 (OfNat.mk.{0} Int 3 (bit1.{0} Int Int.hasOne Int.hasAdd (One.one.{0} Int Int.hasOne))))) (Int.decidableEq (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (Int.decidableEq (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.hasMod) n (OfNat.ofNat.{0} Int 8 (OfNat.mk.{0} Int 8 (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne))))))) (OfNat.ofNat.{0} Int 3 (OfNat.mk.{0} Int 3 (bit1.{0} Int Int.hasOne Int.hasAdd (One.one.{0} Int Int.hasOne)))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))) (Neg.neg.{0} Int Int.hasNeg (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))))
but is expected to have type
  forall (n : Int), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈' (Int.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (Ring.toIntCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))))) n)) (ite.{1} Int (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 2 (instOfNatInt 2))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))) (Int.instDecidableEqInt (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 2 (instOfNatInt 2))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) (ite.{1} Int (Or (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 3 (instOfNatInt 3)))) (instDecidableOr (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (Eq.{1} Int (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 3 (instOfNatInt 3))) (Int.instDecidableEqInt (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (Int.instDecidableEqInt (HMod.hMod.{0, 0, 0} Int Int Int (instHMod.{0} Int Int.instModInt_1) n (OfNat.ofNat.{0} Int 8 (instOfNatInt 8))) (OfNat.ofNat.{0} Int 3 (instOfNatInt 3)))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)) (Neg.neg.{0} Int Int.instNegInt (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₈'_int_eq_if_mod_eight ZMod.χ₈'_int_eq_if_mod_eightₓ'. -/
/-- An explicit description of `χ₈'` on integers / naturals -/
theorem χ₈'_int_eq_if_mod_eight (n : ℤ) :
    χ₈' n = if n % 2 = 0 then 0 else if n % 8 = 1 ∨ n % 8 = 3 then 1 else -1 :=
  by
  have help :
    ∀ m : ℤ, 0 ≤ m → m < 8 → χ₈' m = if m % 2 = 0 then 0 else if m = 1 ∨ m = 3 then 1 else -1 := by
    decide
  rw [← Int.emod_emod_of_dvd n (by norm_num : (2 : ℤ) ∣ 8), ← ZMod.int_cast_mod n 8]
  exact help (n % 8) (Int.emod_nonneg n (by norm_num)) (Int.emod_lt n (by norm_num))
#align zmod.χ₈'_int_eq_if_mod_eight ZMod.χ₈'_int_eq_if_mod_eight

/- warning: zmod.χ₈'_nat_eq_if_mod_eight -> ZMod.χ₈'_nat_eq_if_mod_eight is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈' ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HasLiftT.mk.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CoeTCₓ.coe.{1, 1} Nat (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Nat.castCoe.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddMonoidWithOne.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddGroupWithOne.toAddMonoidWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))))))) n)) (ite.{1} Int (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (Nat.decidableEq (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) (ite.{1} Int (Or (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Or.decidable (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Nat.decidableEq (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Nat.decidableEq (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))) (Neg.neg.{0} Int Int.hasNeg (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))))
but is expected to have type
  forall (n : Nat), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈' (Nat.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (Semiring.toNatCast.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommSemiring.toSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommSemiring.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))))) n)) (ite.{1} Int (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (instDecidableEqNat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) (ite.{1} Int (Or (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)))) (instDecidableOr (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Eq.{1} Nat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) (instDecidableEqNat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (instDecidableEqNat (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)))) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)) (Neg.neg.{0} Int Int.instNegInt (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))))
Case conversion may be inaccurate. Consider using '#align zmod.χ₈'_nat_eq_if_mod_eight ZMod.χ₈'_nat_eq_if_mod_eightₓ'. -/
theorem χ₈'_nat_eq_if_mod_eight (n : ℕ) :
    χ₈' n = if n % 2 = 0 then 0 else if n % 8 = 1 ∨ n % 8 = 3 then 1 else -1 := by
  exact_mod_cast χ₈'_int_eq_if_mod_eight n
#align zmod.χ₈'_nat_eq_if_mod_eight ZMod.χ₈'_nat_eq_if_mod_eight

/- warning: zmod.χ₈'_eq_χ₄_mul_χ₈ -> ZMod.χ₈'_eq_χ₄_mul_χ₈ is a dubious translation:
lean 3 declaration is
  forall (a : ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))), Eq.{1} Int (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈' a) (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.hasMul) (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₄ ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.hasCoeT.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (AddCommGroupWithOne.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Ring.toAddCommGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (OfNat.mk.{0} Nat 4 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))) (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))) a)) (coeFn.{1, 1} (MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) (fun (_x : MulChar.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) => (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) -> Int) (MulChar.coeToFun.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (OfNat.mk.{0} Nat 8 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) Int (CommSemiring.toCommMonoidWithZero.{0} Int Int.commSemiring)) ZMod.χ₈ a))
but is expected to have type
  forall (a : ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))), Eq.{1} Int (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈' a) (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.instMulInt) (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₄ (ZMod.cast.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (Ring.toAddGroupWithOne.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (CommRing.toRing.{0} (ZMod (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (ZMod.commRing (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))))) (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)) a)) (MulChar.toFun'.{0, 0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (CommRing.toCommMonoid.{0} (ZMod (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8))) (ZMod.commRing (OfNat.ofNat.{0} Nat 8 (instOfNatNat 8)))) Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) ZMod.χ₈ a))
Case conversion may be inaccurate. Consider using '#align zmod.χ₈'_eq_χ₄_mul_χ₈ ZMod.χ₈'_eq_χ₄_mul_χ₈ₓ'. -/
/-- The relation between `χ₄`, `χ₈` and `χ₈'` -/
theorem χ₈'_eq_χ₄_mul_χ₈ (a : ZMod 8) : χ₈' a = χ₄ a * χ₈ a := by decide!
#align zmod.χ₈'_eq_χ₄_mul_χ₈ ZMod.χ₈'_eq_χ₄_mul_χ₈

/- warning: zmod.χ₈'_int_eq_χ₄_mul_χ₈ -> ZMod.χ₈'_int_eq_χ₄_mul_χ₈ is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align zmod.χ₈'_int_eq_χ₄_mul_χ₈ ZMod.χ₈'_int_eq_χ₄_mul_χ₈ₓ'. -/
theorem χ₈'_int_eq_χ₄_mul_χ₈ (a : ℤ) : χ₈' a = χ₄ a * χ₈ a :=
  by
  rw [← @cast_int_cast 8 (ZMod 4) _ 4 _ (by norm_num) a]
  exact χ₈'_eq_χ₄_mul_χ₈ a
#align zmod.χ₈'_int_eq_χ₄_mul_χ₈ ZMod.χ₈'_int_eq_χ₄_mul_χ₈

end QuadCharModP

end ZMod

