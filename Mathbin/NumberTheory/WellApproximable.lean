/-
Copyright (c) 2022 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash

! This file was ported from Lean 3 source module number_theory.well_approximable
! leanprover-community/mathlib commit 6d0adfa76594f304b4650d098273d4366edeb61b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Dynamics.Ergodic.AddCircle
import Mathbin.MeasureTheory.Covering.LiminfLimsup
import Mathbin.Data.Nat.Totient

/-!
# Well-approximable numbers and Gallagher's ergodic theorem

Gallagher's ergodic theorem is a result in metric number theory. It thus belongs to that branch of
mathematics concerning arithmetic properties of real numbers which hold almost eveywhere with
respect to the Lebesgue measure.

Gallagher's theorem concerns the approximation of real numbers by rational numbers. The input is a
sequence of distances `Œ¥‚ÇÅ, Œ¥‚ÇÇ, ...`, and the theorem concerns the set of real numbers `x` for which
there is an infinity of solutions to:
$$
  |x - m/n| < Œ¥‚Çô,
$$
where the rational number `m/n` is in lowest terms. The result is that for any `Œ¥`, this set is
either almost all `x` or almost no `x`.

This result was proved by Gallagher in 1959
[P. Gallagher, *Approximation by reduced fractions*](Gallagher1961). It is formalised here as
`add_circle.add_well_approximable_ae_empty_or_univ` except with `x` belonging to the circle `‚Ñù ‚ß∏ ‚Ñ§`
since this turns out to be more natural.

Given a particular `Œ¥`, the Duffin-Schaeffer conjecture (now a theorem) gives a criterion for
deciding which of the two cases in the conclusion of Gallagher's theorem actually occurs. It was
proved by Koukoulopoulos and Maynard in 2019
[D. Koukoulopoulos, J. Maynard, *On the Duffin-Schaeffer conjecture*](KoukoulopoulosMaynard2020).
We do *not* include a formalisation of the Koukoulopoulos-Maynard result here.

## Main definitions and results:

 * `approx_order_of`: in a seminormed group `A`, given `n : ‚Ñï` and `Œ¥ : ‚Ñù`, `approx_order_of A n Œ¥`
   is the set of elements within a distance `Œ¥` of a point of order `n`.
 * `well_approximable`: in a seminormed group `A`, given a sequence of distances `Œ¥‚ÇÅ, Œ¥‚ÇÇ, ...`,
   `well_approximable A Œ¥` is the limsup as `n ‚Üí ‚àû` of the sets `approx_order_of A n Œ¥‚Çô`. Thus, it
   is the set of points that lie in infinitely many of the sets `approx_order_of A n Œ¥‚Çô`.
 * `add_circle.add_well_approximable_ae_empty_or_univ`: *Gallagher's ergodic theorem* says that for
   for the (additive) circle `ùïä`, for any sequence of distances `Œ¥`, the set
   `add_well_approximable ùïä Œ¥` is almost empty or almost full.

## TODO:

The hypothesis `hŒ¥` in `add_circle.add_well_approximable_ae_empty_or_univ` can be dropped.
An elementary (non-measure-theoretic) argument shows that if `¬¨ hŒ¥` holds then
`add_well_approximable ùïä Œ¥ = univ` (provided `Œ¥` is non-negative).
-/


open Set Filter Function Metric MeasureTheory

open MeasureTheory TopologicalSpace Pointwise

/-- In a seminormed group `A`, given `n : ‚Ñï` and `Œ¥ : ‚Ñù`, `approx_order_of A n Œ¥` is the set of
elements within a distance `Œ¥` of a point of order `n`. -/
@[to_additive approxAddOrderOf
      "In a seminormed additive group `A`, given `n : ‚Ñï` and `Œ¥ : ‚Ñù`,\n`approx_add_order_of A n Œ¥` is the set of elements within a distance `Œ¥` of a point of order `n`."]
def approxOrderOf (A : Type _) [SeminormedGroup A] (n : ‚Ñï) (Œ¥ : ‚Ñù) : Set A :=
  thickening Œ¥ { y | orderOf y = n }
#align approx_order_of approxOrderOf

@[to_additive mem_approx_add_order_of_iff]
theorem mem_approx_order_of_iff {A : Type _} [SeminormedGroup A] {n : ‚Ñï} {Œ¥ : ‚Ñù} {a : A} :
    a ‚àà approxOrderOf A n Œ¥ ‚Üî ‚àÉ b : A, orderOf b = n ‚àß a ‚àà ball b Œ¥ := by
  simp only [approxOrderOf, thickening_eq_bUnion_ball, mem_Union‚ÇÇ, mem_set_of_eq, exists_prop]
#align mem_approx_order_of_iff mem_approx_order_of_iff

/-- In a seminormed group `A`, given a sequence of distances `Œ¥‚ÇÅ, Œ¥‚ÇÇ, ...`, `well_approximable A Œ¥`
is the limsup as `n ‚Üí ‚àû` of the sets `approx_order_of A n Œ¥‚Çô`. Thus, it is the set of points that
lie in infinitely many of the sets `approx_order_of A n Œ¥‚Çô`. -/
@[to_additive addWellApproximable
      "In a seminormed additive group `A`, given a sequence of\ndistances `Œ¥‚ÇÅ, Œ¥‚ÇÇ, ...`, `add_well_approximable A Œ¥` is the limsup as `n ‚Üí ‚àû` of the sets\n`approx_add_order_of A n Œ¥‚Çô`. Thus, it is the set of points that lie in infinitely many of the sets\n`approx_add_order_of A n Œ¥‚Çô`."]
def wellApproximable (A : Type _) [SeminormedGroup A] (Œ¥ : ‚Ñï ‚Üí ‚Ñù) : Set A :=
  blimsup (fun n => approxOrderOf A n (Œ¥ n)) atTop fun n => 0 < n
#align well_approximable wellApproximable

@[to_additive mem_add_well_approximable_iff]
theorem mem_well_approximable_iff {A : Type _} [SeminormedGroup A] {Œ¥ : ‚Ñï ‚Üí ‚Ñù} {a : A} :
    a ‚àà wellApproximable A Œ¥ ‚Üî
      a ‚àà blimsup (fun n => approxOrderOf A n (Œ¥ n)) atTop fun n => 0 < n :=
  Iff.rfl
#align mem_well_approximable_iff mem_well_approximable_iff

namespace approxOrderOf

variable {A : Type _} [SeminormedCommGroup A] {a : A} {m n : ‚Ñï} (Œ¥ : ‚Ñù)

@[to_additive]
theorem image_pow_subset_of_coprime (hm : 0 < m) (hmn : n.Coprime m) :
    (fun y => y ^ m) '' approxOrderOf A n Œ¥ ‚äÜ approxOrderOf A n (m * Œ¥) :=
  by
  rintro - ‚ü®a, ha, rfl‚ü©
  obtain ‚ü®b, hb, hab‚ü© := mem_approx_order_of_iff.mp ha
  replace hb : b ^ m ‚àà { u : A | orderOf u = n };
  ¬∑ rw [‚Üê hb] at hmn‚ä¢
    exact order_of_pow_coprime hmn
  apply ball_subset_thickening hb ((m : ‚Ñù) ‚Ä¢ Œ¥)
  convert pow_mem_ball hm hab using 1
  simp only [nsmul_eq_mul, Algebra.id.smul_eq_mul]
#align approx_order_of.image_pow_subset_of_coprime approxOrderOf.image_pow_subset_of_coprime

@[to_additive]
theorem image_pow_subset (n : ‚Ñï) (hm : 0 < m) :
    (fun y => y ^ m) '' approxOrderOf A (n * m) Œ¥ ‚äÜ approxOrderOf A n (m * Œ¥) :=
  by
  rintro - ‚ü®a, ha, rfl‚ü©
  obtain ‚ü®b, hb : orderOf b = n * m, hab : a ‚àà ball b Œ¥‚ü© := mem_approx_order_of_iff.mp ha
  replace hb : b ^ m ‚àà { y : A | orderOf y = n }
  ¬∑ rw [mem_set_of_eq, order_of_pow' b hm.ne', hb, Nat.gcd_mul_left_left, n.mul_div_cancel hm]
  apply ball_subset_thickening hb (m * Œ¥)
  convert pow_mem_ball hm hab
  simp only [nsmul_eq_mul]
#align approx_order_of.image_pow_subset approxOrderOf.image_pow_subset

@[to_additive]
theorem smul_subset_of_coprime (han : (orderOf a).Coprime n) :
    a ‚Ä¢ approxOrderOf A n Œ¥ ‚äÜ approxOrderOf A (orderOf a * n) Œ¥ :=
  by
  simp_rw [approxOrderOf, thickening_eq_bUnion_ball, ‚Üê image_smul, image_Union‚ÇÇ, image_smul,
    smul_ball'', smul_eq_mul, mem_set_of_eq]
  refine' Union‚ÇÇ_subset_iff.mpr fun b hb c hc => _
  simp only [mem_Union, exists_prop]
  refine' ‚ü®a * b, _, hc‚ü©
  rw [‚Üê hb] at han‚ä¢
  exact (Commute.all a b).order_of_mul_eq_mul_order_of_of_coprime han
#align approx_order_of.smul_subset_of_coprime approxOrderOf.smul_subset_of_coprime

@[to_additive vadd_eq_of_mul_dvd]
theorem smul_eq_of_mul_dvd (hn : 0 < n) (han : orderOf a ^ 2 ‚à£ n) :
    a ‚Ä¢ approxOrderOf A n Œ¥ = approxOrderOf A n Œ¥ :=
  by
  simp_rw [approxOrderOf, thickening_eq_bUnion_ball, ‚Üê image_smul, image_Union‚ÇÇ, image_smul,
    smul_ball'', smul_eq_mul, mem_set_of_eq]
  replace han : ‚àÄ {b : A}, orderOf b = n ‚Üí orderOf (a * b) = n
  ¬∑ intro b hb
    rw [‚Üê hb] at han hn
    rw [sq] at han
    rwa [(Commute.all a b).order_of_mul_eq_right_of_forall_prime_mul_dvd (order_of_pos_iff.mp hn)
        fun p hp hp' => dvd_trans (mul_dvd_mul_right hp' <| orderOf a) han]
  let f : { b : A | orderOf b = n } ‚Üí { b : A | orderOf b = n } := fun b => ‚ü®a * b, han b.property‚ü©
  have hf : surjective f := by
    rintro ‚ü®b, hb‚ü©
    refine' ‚ü®‚ü®a‚Åª¬π * b, _‚ü©, _‚ü©
    ¬∑ rw [mem_set_of_eq, ‚Üê order_of_inv, mul_inv_rev, inv_inv, mul_comm]
      apply han
      simpa
    ¬∑ simp only [Subtype.mk_eq_mk, Subtype.coe_mk, mul_inv_cancel_left]
  simpa only [f, mem_set_of_eq, Subtype.coe_mk, Union_coe_set] using
    hf.Union_comp fun b => ball (b : A) Œ¥
#align approx_order_of.smul_eq_of_mul_dvd approxOrderOf.smul_eq_of_mul_dvd

end approxOrderOf

namespace UnitAddCircle

theorem mem_approx_add_order_of_iff {Œ¥ : ‚Ñù} {x : UnitAddCircle} {n : ‚Ñï} (hn : 0 < n) :
    x ‚àà approxAddOrderOf UnitAddCircle n Œ¥ ‚Üî ‚àÉ m < n, gcd m n = 1 ‚àß ‚Äñx - ‚Üë((m : ‚Ñù) / n)‚Äñ < Œ¥ :=
  by
  haveI : Fact ((0 : ‚Ñù) < 1) := ‚ü®zero_lt_one‚ü©
  simp only [mem_approx_add_order_of_iff, mem_set_of_eq, ball, exists_prop, dist_eq_norm,
    AddCircle.add_order_of_eq_pos_iff hn, mul_one]
  constructor
  ¬∑ rintro ‚ü®y, ‚ü®m, hm‚ÇÅ, hm‚ÇÇ, rfl‚ü©, hx‚ü©
    exact ‚ü®m, hm‚ÇÅ, hm‚ÇÇ, hx‚ü©
  ¬∑ rintro ‚ü®m, hm‚ÇÅ, hm‚ÇÇ, hx‚ü©
    exact ‚ü®‚Üë((m : ‚Ñù) / n), ‚ü®m, hm‚ÇÅ, hm‚ÇÇ, rfl‚ü©, hx‚ü©
#align unit_add_circle.mem_approx_add_order_of_iff UnitAddCircle.mem_approx_add_order_of_iff

theorem mem_add_well_approximable_iff (Œ¥ : ‚Ñï ‚Üí ‚Ñù) (x : UnitAddCircle) :
    x ‚àà addWellApproximable UnitAddCircle Œ¥ ‚Üî
      { n : ‚Ñï | ‚àÉ m < n, gcd m n = 1 ‚àß ‚Äñx - ‚Üë((m : ‚Ñù) / n)‚Äñ < Œ¥ n }.Infinite :=
  by
  simp only [mem_add_well_approximable_iff, ‚Üê Nat.cofinite_eq_at_top, cofinite.blimsup_set_eq,
    mem_set_of_eq]
  refine' iff_of_eq (congr_arg Set.Infinite <| ext fun n => ‚ü®fun hn => _, fun hn => _‚ü©)
  ¬∑ exact (mem_approx_add_order_of_iff hn.1).mp hn.2
  ¬∑ have h : 0 < n := by
      obtain ‚ü®m, hm‚ÇÅ, hm‚ÇÇ, hm‚ÇÉ‚ü© := hn
      exact pos_of_gt hm‚ÇÅ
    exact ‚ü®h, (mem_approx_add_order_of_iff h).mpr hn‚ü©
#align unit_add_circle.mem_add_well_approximable_iff UnitAddCircle.mem_add_well_approximable_iff

end UnitAddCircle

namespace AddCircle

variable {T : ‚Ñù} [hT : Fact (0 < T)]

include hT

-- mathport name: ¬´expr ‚à§ ¬ª
local notation a "‚à§" b => ¬¨a ‚à£ b

-- mathport name: ¬´expr ‚à£‚à£ ¬ª
/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.notation
     []
     []
     (Term.attrKind [(Term.local "local")])
     "notation"
     []
     []
     []
     [(Command.identPrec `a []) (str "\"‚à£‚à£\"") (Command.identPrec `b [])]
     "=>"
     (¬´term_‚àß_¬ª
      (¬´term_‚à£_¬ª `a "‚à£" `b)
      "‚àß"
      (AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª (¬´term_*_¬ª `a "*" `a) "‚à§" `b)))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (¬´term_‚àß_¬ª
       (¬´term_‚à£_¬ª `a "‚à£" `b)
       "‚àß"
       (AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª (¬´term_*_¬ª `a "*" `a) "‚à§" `b))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª (¬´term_*_¬ª `a "*" `a) "‚à§" `b)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª', expected 'AddCircle.NumberTheory.WellApproximable.term_‚à§_._@.NumberTheory.WellApproximable._hyg.11'-/-- failed to format: format: uncaught backtrack exception
local notation a "‚à£‚à£" b => a ‚à£ b ‚àß a * a ‚à§ b

-- mathport name: exprùïä
local notation "ùïä" => AddCircle T

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment "/--" "*Gallagher's ergodic theorem* on Diophantine approximation. -/")]
      []
      []
      []
      []
      [])
     (Command.theorem
      "theorem"
      (Command.declId `add_well_approximable_ae_empty_or_univ [])
      (Command.declSig
       [(Term.explicitBinder
         "("
         [`Œ¥]
         [":" (Term.arrow (term‚Ñï "‚Ñï") "‚Üí" (Data.Real.Basic.term‚Ñù "‚Ñù"))]
         []
         ")")
        (Term.explicitBinder
         "("
         [`hŒ¥]
         [":"
          (Term.app
           `Tendsto
           [`Œ¥ `atTop (Term.app (TopologicalSpace.Topology.Basic.nhds "ùìù") [(num "0")])])]
         []
         ")")]
       (Term.typeSpec
        ":"
        (¬´term_‚à®_¬ª
         (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term‚àÄ·µê_,_¬ª
          "‚àÄ·µê"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `x) []))
          ", "
          (¬´term¬¨_¬ª
           "¬¨"
           (Term.app
            `addWellApproximable
            [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä") `Œ¥ `x])))
         "‚à®"
         (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term‚àÄ·µê_,_¬ª
          "‚àÄ·µê"
          (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `x) []))
          ", "
          (Term.app
           `addWellApproximable
           [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä") `Œ¥ `x])))))
      (Command.declValSimple
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(Std.Tactic.tacticLetI_
            "letI"
            (Term.haveDecl
             (Term.haveIdDecl
              []
              [(Term.typeSpec ":" (Term.app `SemilatticeSup [`Nat.Primes]))]
              ":="
              (Term.app `Nat.Subtype.semilatticeSup [(Term.hole "_")]))))
           []
           (Mathlib.Tactic.set
            "set"
            []
            (Mathlib.Tactic.setArgsRest
             `Œº
             [":" (Term.app `Measure [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
             ":="
             `volume
             []))
           []
           (Mathlib.Tactic.set
            "set"
            []
            (Mathlib.Tactic.setArgsRest
             `u
             [":" (Term.arrow `Nat.Primes "‚Üí" (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä"))]
             ":="
             (Term.fun
              "fun"
              (Term.basicFun
               [`p]
               []
               "=>"
               (coeNotation
                "‚Üë"
                (¬´term_*_¬ª
                 (¬´term_/_¬ª
                  (Term.typeAscription
                   "("
                   (coeNotation "‚Üë" (Term.typeAscription "(" (num "1") ":" [(term‚Ñï "‚Ñï")] ")"))
                   ":"
                   [(Data.Real.Basic.term‚Ñù "‚Ñù")]
                   ")")
                  "/"
                  `p)
                 "*"
                 `T))))
             []))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hu‚ÇÄ []]
              [(Term.typeSpec
                ":"
                (Term.forall
                 "‚àÄ"
                 [`p]
                 [(Term.typeSpec ":" `Nat.Primes)]
                 ","
                 (¬´term_=_¬ª
                  (Term.app `addOrderOf [(Term.app `u [`p])])
                  "="
                  (Term.typeAscription "(" `p ":" [(term‚Ñï "‚Ñï")] ")"))))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Std.Tactic.rintro
                   "rintro"
                   [(Std.Tactic.RCases.rintroPat.one
                     (Std.Tactic.RCases.rcasesPat.tuple
                      "‚ü®"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                        [])]
                      "‚ü©"))]
                   [])
                  []
                  (Tactic.exact
                   "exact"
                   (Term.app
                    `add_order_of_div_of_gcd_eq_one
                    [`hp.pos (Term.app `gcd_one_left [`p])]))]))))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hu []]
              [(Term.typeSpec
                ":"
                (Term.app `tendsto [(¬´term_‚àò_¬ª `addOrderOf "‚àò" `u) `at_top `at_top]))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule
                      []
                      (Term.typeAscription
                       "("
                       (Term.app `funext [`hu‚ÇÄ])
                       ":"
                       [(¬´term_=_¬ª (¬´term_‚àò_¬ª `addOrderOf "‚àò" `u) "=" `coe)]
                       ")"))]
                    "]")
                   [])
                  []
                  (Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`h_mono []]
                     [(Term.typeSpec
                       ":"
                       (Term.app
                        `Monotone
                        [(Term.typeAscription
                          "("
                          `coe
                          ":"
                          [(Term.arrow `Nat.Primes "‚Üí" (term‚Ñï "‚Ñï"))]
                          ")")]))]
                     ":="
                     (Term.fun "fun" (Term.basicFun [`p `q `hpq] [] "=>" `hpq)))))
                  []
                  (Tactic.refine'
                   "refine'"
                   (Term.app
                    `h_mono.tendsto_at_top_at_top
                    [(Term.fun "fun" (Term.basicFun [`n] [] "=>" (Term.hole "_")))]))
                  []
                  (Std.Tactic.obtain
                   "obtain"
                   [(Std.Tactic.RCases.rcasesPatMed
                     [(Std.Tactic.RCases.rcasesPat.tuple
                       "‚ü®"
                       [(Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                         [])
                        ","
                        (Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                         [])
                        ","
                        (Std.Tactic.RCases.rcasesPatLo
                         (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp')])
                         [])]
                       "‚ü©")])]
                   []
                   [":=" [`n.exists_infinite_primes]])
                  []
                  (Tactic.exact
                   "exact"
                   (Term.anonymousCtor
                    "‚ü®"
                    [(Term.anonymousCtor "‚ü®" [`p "," `hp'] "‚ü©") "," `hp]
                    "‚ü©"))]))))))
           []
           (Mathlib.Tactic.set
            "set"
            []
            (Mathlib.Tactic.setArgsRest
             `E
             []
             ":="
             (Term.app
              `addWellApproximable
              [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä") `Œ¥])
             []))
           []
           (Mathlib.Tactic.set
            "set"
            []
            (Mathlib.Tactic.setArgsRest
             `X
             [":"
              (Term.arrow
               (term‚Ñï "‚Ñï")
               "‚Üí"
               (Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")]))]
             ":="
             (Term.fun
              "fun"
              (Term.basicFun
               [`n]
               []
               "=>"
               (Term.app
                `approxAddOrderOf
                [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä") `n (Term.app `Œ¥ [`n])])))
             []))
           []
           (Mathlib.Tactic.set
            "set"
            []
            (Mathlib.Tactic.setArgsRest
             `A
             [":"
              (Term.arrow
               (term‚Ñï "‚Ñï")
               "‚Üí"
               (Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")]))]
             ":="
             (Term.fun
              "fun"
              (Term.basicFun
               [`p]
               []
               "=>"
               (Term.app
                `blimsup
                [`X
                 `at_top
                 (Term.fun
                  "fun"
                  (Term.basicFun
                   [`n]
                   []
                   "=>"
                   (¬´term_‚àß_¬ª
                    (¬´term_<_¬ª (num "0") "<" `n)
                    "‚àß"
                    (AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª `p "‚à§" `n))))])))
             []))
           []
           (Mathlib.Tactic.set
            "set"
            []
            (Mathlib.Tactic.setArgsRest
             `B
             [":"
              (Term.arrow
               (term‚Ñï "‚Ñï")
               "‚Üí"
               (Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")]))]
             ":="
             (Term.fun
              "fun"
              (Term.basicFun
               [`p]
               []
               "=>"
               (Term.app
                `blimsup
                [`X
                 `at_top
                 (Term.fun
                  "fun"
                  (Term.basicFun
                   [`n]
                   []
                   "=>"
                   (¬´term_‚àß_¬ª
                    (¬´term_<_¬ª (num "0") "<" `n)
                    "‚àß"
                    (AddCircle.NumberTheory.WellApproximable.¬´term_‚à£‚à£_¬ª `p "‚à£‚à£" `n))))])))
             []))
           []
           (Mathlib.Tactic.set
            "set"
            []
            (Mathlib.Tactic.setArgsRest
             `C
             [":"
              (Term.arrow
               (term‚Ñï "‚Ñï")
               "‚Üí"
               (Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")]))]
             ":="
             (Term.fun
              "fun"
              (Term.basicFun
               [`p]
               []
               "=>"
               (Term.app
                `blimsup
                [`X
                 `at_top
                 (Term.fun
                  "fun"
                  (Term.basicFun
                   [`n]
                   []
                   "=>"
                   (¬´term_‚àß_¬ª
                    (¬´term_<_¬ª (num "0") "<" `n)
                    "‚àß"
                    (¬´term_‚à£_¬ª (¬´term_^_¬ª `p "^" (num "2")) "‚à£" `n))))])))
             []))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hA‚ÇÄ []]
              [(Term.typeSpec
                ":"
                (Term.forall "‚àÄ" [`p] [] "," (Term.app `MeasurableSet [(Term.app `A [`p])])))]
              ":="
              (Term.fun
               "fun"
               (Term.basicFun
                [`p]
                []
                "=>"
                (Term.app
                 `MeasurableSet.measurable_set_blimsup
                 [(Term.fun
                   "fun"
                   (Term.basicFun [`n `hn] [] "=>" `is_open_thickening.measurable_set))]))))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hB‚ÇÄ []]
              [(Term.typeSpec
                ":"
                (Term.forall "‚àÄ" [`p] [] "," (Term.app `MeasurableSet [(Term.app `B [`p])])))]
              ":="
              (Term.fun
               "fun"
               (Term.basicFun
                [`p]
                []
                "=>"
                (Term.app
                 `MeasurableSet.measurable_set_blimsup
                 [(Term.fun
                   "fun"
                   (Term.basicFun [`n `hn] [] "=>" `is_open_thickening.measurable_set))]))))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hE‚ÇÄ []]
              [(Term.typeSpec ":" (Term.app `null_measurable_set [`E `Œº]))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.refine'
                   "refine'"
                   (Term.proj
                    (Term.app
                     `MeasurableSet.measurable_set_blimsup
                     [(Term.fun
                       "fun"
                       (Term.basicFun
                        [`n `hn]
                        []
                        "=>"
                        (Term.app `IsOpen.measurable_set [(Term.hole "_")])))])
                    "."
                    `NullMeasurableSet))
                  []
                  (Tactic.exact "exact" `is_open_thickening)]))))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hE‚ÇÅ []]
              [(Term.typeSpec
                ":"
                (Term.forall
                 "‚àÄ"
                 [`p]
                 []
                 ","
                 (¬´term_=_¬ª
                  `E
                  "="
                  (¬´term_‚à™_¬ª
                   (¬´term_‚à™_¬ª (Term.app `A [`p]) "‚à™" (Term.app `B [`p]))
                   "‚à™"
                   (Term.app `C [`p])))))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.intro "intro" [`p])
                  []
                  (Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `E)
                     ","
                     (Tactic.simpLemma [] [] `addWellApproximable)
                     ","
                     (Tactic.simpLemma [] [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `blimsup_or_eq_sup)
                     ","
                     (Tactic.simpLemma [] [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `and_or_left)
                     ","
                     (Tactic.simpLemma [] [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `sup_eq_union)
                     ","
                     (Tactic.simpLemma [] [] `sq)]
                    "]"]
                   [])
                  []
                  (Tactic.congr "congr" [])
                  []
                  (Tactic.refine'
                   "refine'"
                   (Term.app
                    `funext
                    [(Term.fun
                      "fun"
                      (Term.basicFun
                       [`n]
                       []
                       "=>"
                       (¬´term_<|_¬ª
                        `propext
                        "<|"
                        (Term.app
                         `iff_self_and.mpr
                         [(Term.fun "fun" (Term.basicFun [`hn] [] "=>" (Term.hole "_")))]))))]))
                  []
                  (Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma
                      []
                      []
                      (Term.proj (Term.app `em [(¬´term_‚à£_¬ª `p "‚à£" `n)]) "." `symm))
                     ","
                     (Tactic.simpLemma
                      []
                      []
                      (Term.proj
                       (Term.app `em [(¬´term_‚à£_¬ª (¬´term_*_¬ª `p "*" `p) "‚à£" `n)])
                       "."
                       `symm))
                     ","
                     (Tactic.simpLemma [] [] `or_and_left)
                     ","
                     (Tactic.simpLemma [] [] `or_true_iff)
                     ","
                     (Tactic.simpLemma [] [] `true_and_iff)
                     ","
                     (Tactic.simpLemma [] [] `or_assoc')]
                    "]"]
                   [])]))))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hE‚ÇÇ []]
              [(Term.typeSpec
                ":"
                (Term.forall
                 "‚àÄ"
                 [`p]
                 [(Term.typeSpec ":" `Nat.Primes)]
                 ","
                 (Term.arrow
                  (¬´term_‚àß_¬ª
                   (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                    (Term.app `A [`p])
                    " =·µê["
                    `Œº
                    "] "
                    (Term.typeAscription
                     "("
                     (¬´term‚àÖ¬ª "‚àÖ")
                     ":"
                     [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                     ")"))
                   "‚àß"
                   (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                    (Term.app `B [`p])
                    " =·µê["
                    `Œº
                    "] "
                    (Term.typeAscription
                     "("
                     (¬´term‚àÖ¬ª "‚àÖ")
                     ":"
                     [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                     ")")))
                  "‚Üí"
                  (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                   `E
                   " =·µê["
                   `Œº
                   "] "
                   (Term.app `C [`p])))))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Std.Tactic.rintro
                   "rintro"
                   [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `p))
                    (Std.Tactic.RCases.rintroPat.one
                     (Std.Tactic.RCases.rcasesPat.tuple
                      "‚ü®"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hA)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hB)])
                        [])]
                      "‚ü©"))]
                   [])
                  []
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hE‚ÇÅ [`p]))] "]")
                   [])
                  []
                  (Tactic.exact
                   "exact"
                   (Term.app
                    `union_ae_eq_right_of_ae_eq_empty
                    [(Term.app
                      (Term.proj (Term.app `union_ae_eq_right_of_ae_eq_empty [`hA]) "." `trans)
                      [`hB])]))]))))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hA []]
              [(Term.typeSpec
                ":"
                (Term.forall
                 "‚àÄ"
                 [`p]
                 [(Term.typeSpec ":" `Nat.Primes)]
                 ","
                 (¬´term_‚à®_¬ª
                  (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                   (Term.app `A [`p])
                   " =·µê["
                   `Œº
                   "] "
                   (Term.typeAscription
                    "("
                    (¬´term‚àÖ¬ª "‚àÖ")
                    ":"
                    [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                    ")"))
                  "‚à®"
                  (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                   (Term.app `A [`p])
                   " =·µê["
                   `Œº
                   "] "
                   `univ))))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Std.Tactic.rintro
                   "rintro"
                   [(Std.Tactic.RCases.rintroPat.one
                     (Std.Tactic.RCases.rcasesPat.tuple
                      "‚ü®"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                        [])]
                      "‚ü©"))]
                   [])
                  []
                  (Tactic.tacticLet_
                   "let"
                   (Term.letDecl
                    (Term.letIdDecl
                     `f
                     []
                     [(Term.typeSpec
                       ":"
                       (Term.arrow
                        (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                        "‚Üí"
                        (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")))]
                     ":="
                     (Term.fun
                      "fun"
                      (Term.basicFun
                       [`y]
                       []
                       "=>"
                       (Algebra.Group.Defs.¬´term_‚Ä¢_¬ª
                        (Term.typeAscription "(" `p ":" [(term‚Ñï "‚Ñï")] ")")
                        " ‚Ä¢ "
                        `y))))))
                  []
                  (Tactic.tacticSuffices_
                   "suffices"
                   (Term.sufficesDecl
                    []
                    (¬´term_‚äÜ_¬ª
                     (Set.Data.Set.Image.term_''_ `f " '' " (Term.app `A [`p]))
                     "‚äÜ"
                     (Term.app
                      `blimsup
                      [(Term.fun
                        "fun"
                        (Term.basicFun
                         [`n]
                         []
                         "=>"
                         (Term.app
                          `approxAddOrderOf
                          [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                           `n
                           (¬´term_*_¬ª `p "*" (Term.app `Œ¥ [`n]))])))
                       `at_top
                       (Term.fun
                        "fun"
                        (Term.basicFun
                         [`n]
                         []
                         "=>"
                         (¬´term_‚àß_¬ª
                          (¬´term_<_¬ª (num "0") "<" `n)
                          "‚àß"
                          (AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª `p "‚à§" `n))))]))
                    (Term.byTactic'
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(Tactic.apply
                         "apply"
                         (Term.app
                          (Term.proj
                           (Term.app `ergodic_nsmul [`hp.one_lt])
                           "."
                           `ae_empty_or_univ_of_image_ae_le)
                          [(Term.app `hA‚ÇÄ [`p])]))
                        []
                        (Tactic.apply
                         "apply"
                         (Term.app
                          (Term.proj (Term.app `HasSubset.Subset.eventually_le [`this]) "." `congr)
                          [`eventually_eq.rfl]))
                        []
                        (Tactic.exact
                         "exact"
                         (Term.app
                          `blimsup_thickening_mul_ae_eq
                          [`Œº
                           (Term.fun
                            "fun"
                            (Term.basicFun
                             [`n]
                             []
                             "=>"
                             (¬´term_‚àß_¬ª
                              (¬´term_<_¬ª (num "0") "<" `n)
                              "‚àß"
                              (AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª `p "‚à§" `n))))
                           (Term.fun
                            "fun"
                            (Term.basicFun
                             [`n]
                             []
                             "=>"
                             (Set.¬´term{_|_}¬ª
                              "{"
                              (Std.ExtendedBinder.extBinder (Lean.binderIdent `y) [])
                              "|"
                              (¬´term_=_¬ª (Term.app `addOrderOf [`y]) "=" `n)
                              "}")))
                           (Term.app `nat.cast_pos.mpr [`hp.pos])
                           (Term.hole "_")
                           `hŒ¥]))])))))
                  []
                  (Tactic.refine'
                   "refine'"
                   (Term.app
                    (Term.proj
                     (Term.proj (Term.app `SupHom.setImage [`f]) "." `apply_blimsup_le)
                     "."
                     `trans)
                    [(Term.app
                      `mono_blimsup
                      [(Term.fun "fun" (Term.basicFun [`n `hn] [] "=>" (Term.hole "_")))])]))
                  []
                  (Mathlib.Tactic.tacticReplace_
                   "replace"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`hn []]
                     []
                     ":="
                     (Term.app
                      `nat.coprime_comm.mp
                      [(Term.app
                        (Term.proj `hp.coprime_iff_not_dvd "." (fieldIdx "2"))
                        [(Term.proj `hn "." (fieldIdx "2"))])]))))
                  []
                  (Tactic.exact
                   "exact"
                   (Term.app
                    `approxAddOrderOf.image_nsmul_subset_of_coprime
                    [(Term.app `Œ¥ [`n]) `hp.pos `hn]))]))))))
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hB []]
              [(Term.typeSpec
                ":"
                (Term.forall
                 "‚àÄ"
                 [`p]
                 [(Term.typeSpec ":" `Nat.Primes)]
                 ","
                 (¬´term_‚à®_¬ª
                  (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                   (Term.app `B [`p])
                   " =·µê["
                   `Œº
                   "] "
                   (Term.typeAscription
                    "("
                    (¬´term‚àÖ¬ª "‚àÖ")
                    ":"
                    [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                    ")"))
                  "‚à®"
                  (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                   (Term.app `B [`p])
                   " =·µê["
                   `Œº
                   "] "
                   `univ))))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Std.Tactic.rintro
                   "rintro"
                   [(Std.Tactic.RCases.rintroPat.one
                     (Std.Tactic.RCases.rcasesPat.tuple
                      "‚ü®"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                        [])]
                      "‚ü©"))]
                   [])
                  []
                  (Tactic.tacticLet_
                   "let"
                   (Term.letDecl
                    (Term.letIdDecl
                     `x
                     []
                     []
                     ":="
                     (Term.app `u [(Term.anonymousCtor "‚ü®" [`p "," `hp] "‚ü©")]))))
                  []
                  (Tactic.tacticLet_
                   "let"
                   (Term.letDecl
                    (Term.letIdDecl
                     `f
                     []
                     [(Term.typeSpec
                       ":"
                       (Term.arrow
                        (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                        "‚Üí"
                        (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")))]
                     ":="
                     (Term.fun
                      "fun"
                      (Term.basicFun
                       [`y]
                       []
                       "=>"
                       (¬´term_+_¬ª (Algebra.Group.Defs.¬´term_‚Ä¢_¬ª `p " ‚Ä¢ " `y) "+" `x))))))
                  []
                  (Tactic.tacticSuffices_
                   "suffices"
                   (Term.sufficesDecl
                    []
                    (¬´term_‚äÜ_¬ª
                     (Set.Data.Set.Image.term_''_ `f " '' " (Term.app `B [`p]))
                     "‚äÜ"
                     (Term.app
                      `blimsup
                      [(Term.fun
                        "fun"
                        (Term.basicFun
                         [`n]
                         []
                         "=>"
                         (Term.app
                          `approxAddOrderOf
                          [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                           `n
                           (¬´term_*_¬ª `p "*" (Term.app `Œ¥ [`n]))])))
                       `at_top
                       (Term.fun
                        "fun"
                        (Term.basicFun
                         [`n]
                         []
                         "=>"
                         (¬´term_‚àß_¬ª
                          (¬´term_<_¬ª (num "0") "<" `n)
                          "‚àß"
                          (AddCircle.NumberTheory.WellApproximable.¬´term_‚à£‚à£_¬ª `p "‚à£‚à£" `n))))]))
                    (Term.byTactic'
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(Tactic.apply
                         "apply"
                         (Term.app
                          (Term.proj
                           (Term.app `ergodic_nsmul_add [`x `hp.one_lt])
                           "."
                           `ae_empty_or_univ_of_image_ae_le)
                          [(Term.app `hB‚ÇÄ [`p])]))
                        []
                        (Tactic.apply
                         "apply"
                         (Term.app
                          (Term.proj (Term.app `HasSubset.Subset.eventually_le [`this]) "." `congr)
                          [`eventually_eq.rfl]))
                        []
                        (Tactic.exact
                         "exact"
                         (Term.app
                          `blimsup_thickening_mul_ae_eq
                          [`Œº
                           (Term.fun
                            "fun"
                            (Term.basicFun
                             [`n]
                             []
                             "=>"
                             (¬´term_‚àß_¬ª
                              (¬´term_<_¬ª (num "0") "<" `n)
                              "‚àß"
                              (AddCircle.NumberTheory.WellApproximable.¬´term_‚à£‚à£_¬ª `p "‚à£‚à£" `n))))
                           (Term.fun
                            "fun"
                            (Term.basicFun
                             [`n]
                             []
                             "=>"
                             (Set.¬´term{_|_}¬ª
                              "{"
                              (Std.ExtendedBinder.extBinder (Lean.binderIdent `y) [])
                              "|"
                              (¬´term_=_¬ª (Term.app `addOrderOf [`y]) "=" `n)
                              "}")))
                           (Term.app `nat.cast_pos.mpr [`hp.pos])
                           (Term.hole "_")
                           `hŒ¥]))])))))
                  []
                  (Tactic.refine'
                   "refine'"
                   (Term.app
                    (Term.proj
                     (Term.proj (Term.app `SupHom.setImage [`f]) "." `apply_blimsup_le)
                     "."
                     `trans)
                    [(Term.app `mono_blimsup [(Term.hole "_")])]))
                  []
                  (Std.Tactic.rintro
                   "rintro"
                   [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `n))
                    (Std.Tactic.RCases.rintroPat.one
                     (Std.Tactic.RCases.rcasesPat.tuple
                      "‚ü®"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hn)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h_div)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h_ndiv)])
                        [])]
                      "‚ü©"))]
                   [])
                  []
                  (Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`h_cop []]
                     [(Term.typeSpec
                       ":"
                       (Term.app
                        (Term.proj (Term.app `addOrderOf [`x]) "." `Coprime)
                        [(¬´term_/_¬ª `n "/" `p)]))]
                     ":="
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(Std.Tactic.obtain
                          "obtain"
                          [(Std.Tactic.RCases.rcasesPatMed
                            [(Std.Tactic.RCases.rcasesPat.tuple
                              "‚ü®"
                              [(Std.Tactic.RCases.rcasesPatLo
                                (Std.Tactic.RCases.rcasesPatMed
                                 [(Std.Tactic.RCases.rcasesPat.one `q)])
                                [])
                               ","
                               (Std.Tactic.RCases.rcasesPatLo
                                (Std.Tactic.RCases.rcasesPatMed
                                 [(Std.Tactic.RCases.rcasesPat.one `rfl)])
                                [])]
                              "‚ü©")])]
                          []
                          [":=" [`h_div]])
                         []
                         (Tactic.rwSeq
                          "rw"
                          []
                          (Tactic.rwRuleSeq
                           "["
                           [(Tactic.rwRule [] `hu‚ÇÄ)
                            ","
                            (Tactic.rwRule [] `Subtype.coe_mk)
                            ","
                            (Tactic.rwRule [] `hp.coprime_iff_not_dvd)
                            ","
                            (Tactic.rwRule [] (Term.app `q.mul_div_cancel_left [`hp.pos]))]
                           "]")
                          [])
                         []
                         (Tactic.exact
                          "exact"
                          (Term.fun
                           "fun"
                           (Term.basicFun
                            [`contra]
                            []
                            "=>"
                            (Term.app `h_ndiv [(Term.app `mul_dvd_mul_left [`p `contra])]))))]))))))
                  []
                  (Mathlib.Tactic.tacticReplace_
                   "replace"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`h_div []]
                     [(Term.typeSpec
                       ":"
                       (¬´term_=_¬ª (¬´term_*_¬ª (¬´term_/_¬ª `n "/" `p) "*" `p) "=" `n))]
                     ":="
                     (Term.app `Nat.div_mul_cancel [`h_div]))))
                  []
                  (Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`hf []]
                     [(Term.typeSpec
                       ":"
                       (¬´term_=_¬ª
                        `f
                        "="
                        (¬´term_‚àò_¬ª
                         (Term.fun "fun" (Term.basicFun [`y] [] "=>" (¬´term_+_¬ª `x "+" `y)))
                         "‚àò"
                         (Term.fun
                          "fun"
                          (Term.basicFun
                           [`y]
                           []
                           "=>"
                           (Algebra.Group.Defs.¬´term_‚Ä¢_¬ª `p " ‚Ä¢ " `y))))))]
                     ":="
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(Std.Tactic.Ext.¬´tacticExt___:_¬ª "ext" [] [])
                         []
                         (Tactic.simp
                          "simp"
                          []
                          []
                          []
                          ["[" [(Tactic.simpLemma [] [] (Term.app `add_comm [`x]))] "]"]
                          [])]))))))
                  []
                  (Mathlib.Tactic.tacticSimp_rw__
                   "simp_rw"
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `comp_app)] "]")
                   [])
                  []
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [] `le_eq_subset)
                     ","
                     (Tactic.rwRule [] `SupHom.set_image_to_fun)
                     ","
                     (Tactic.rwRule [] `hf)
                     ","
                     (Tactic.rwRule [] `image_comp)]
                    "]")
                   [])
                  []
                  (Tactic.tacticHave_
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     []
                     []
                     ":="
                     (Term.app
                      (Term.explicit "@" `monotone_image)
                      [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                       (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                       (Term.fun "fun" (Term.basicFun [`y] [] "=>" (¬´term_+_¬ª `x "+" `y)))]))))
                  []
                  (Tactic.specialize
                   "specialize"
                   (Term.app
                    `this
                    [(Term.app
                      `approxAddOrderOf.image_nsmul_subset
                      [(Term.app `Œ¥ [`n]) (¬´term_/_¬ª `n "/" `p) `hp.pos])]))
                  []
                  (Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["[" [(Tactic.simpLemma [] [] `h_div)] "]"]
                   [(Tactic.location
                     "at"
                     (Tactic.locationHyp [`this] [(patternIgnore (token.¬´‚ä¢¬ª "‚ä¢"))]))])
                  []
                  (Tactic.refine' "refine'" (Term.app `this.trans [(Term.hole "_")]))
                  []
                  (convert
                   "convert"
                   []
                   (Term.app
                    `approxAddOrderOf.vadd_subset_of_coprime
                    [(¬´term_*_¬ª `p "*" (Term.app `Œ¥ [`n])) `h_cop])
                   [])
                  []
                  (Tactic.simp
                   "simp"
                   []
                   []
                   ["only"]
                   ["["
                    [(Tactic.simpLemma [] [] `hu‚ÇÄ)
                     ","
                     (Tactic.simpLemma [] [] `Subtype.coe_mk)
                     ","
                     (Tactic.simpLemma [] [] `h_div)
                     ","
                     (Tactic.simpLemma [] [] (Term.app `mul_comm [`p]))]
                    "]"]
                   [])]))))))
           []
           (Tactic.change
            "change"
            (¬´term_‚à®_¬ª
             (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term‚àÄ·µê_,_¬ª
              "‚àÄ·µê"
              (Std.ExtendedBinder.extBinders
               (Std.ExtendedBinder.extBinder (Lean.binderIdent `x) []))
              ", "
              (¬´term_‚àâ_¬ª `x "‚àâ" `E))
             "‚à®"
             (¬´term_‚àà_¬ª `E "‚àà" `volume.ae))
            [])
           []
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `eventually_eq_empty)
              ","
              (Tactic.rwRule [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `eventually_eq_univ)]
             "]")
            [])
           []
           (Tactic.tacticHave_
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hC []]
              [(Term.typeSpec
                ":"
                (Term.forall
                 "‚àÄ"
                 [`p]
                 [(Term.typeSpec ":" `Nat.Primes)]
                 ","
                 (¬´term_=_¬ª
                  (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " (Term.app `C [`p]))
                  "="
                  (Term.app `C [`p]))))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.intro "intro" [`p])
                  []
                  (Tactic.tacticLet_
                   "let"
                   (Term.letDecl
                    (Term.letIdDecl
                     `e
                     []
                     []
                     ":="
                     (Term.proj
                      (Term.typeAscription
                       "("
                       (Term.app `AddAction.toPerm [(Term.app `u [`p])])
                       ":"
                       [(Term.app
                         `Equiv.Perm
                         [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                       ")")
                      "."
                      `toOrderIsoSet))))
                  []
                  (Tactic.change
                   "change"
                   (¬´term_=_¬ª (Term.app `e [(Term.app `C [`p])]) "=" (Term.app `C [`p]))
                   [])
                  []
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [] `e.apply_blimsup)
                     ","
                     (Tactic.rwRule [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] (Term.app `hu‚ÇÄ [`p]))]
                    "]")
                   [])
                  []
                  (Tactic.exact
                   "exact"
                   (Term.app
                    `blimsup_congr
                    [(Term.app
                      `eventually_of_forall
                      [(Term.fun
                        "fun"
                        (Term.basicFun
                         [`n `hn]
                         []
                         "=>"
                         (Term.app
                          `approxAddOrderOf.vadd_eq_of_mul_dvd
                          [(Term.app `Œ¥ [`n])
                           (Term.proj `hn "." (fieldIdx "1"))
                           (Term.proj `hn "." (fieldIdx "2"))])))])]))]))))))
           []
           (Classical.¬´tacticBy_cases_:_¬ª
            "by_cases"
            [`h ":"]
            (Term.forall
             "‚àÄ"
             [`p]
             [(Term.typeSpec ":" `Nat.Primes)]
             ","
             (¬´term_‚àß_¬ª
              (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
               (Term.app `A [`p])
               " =·µê["
               `Œº
               "] "
               (Term.typeAscription
                "("
                (¬´term‚àÖ¬ª "‚àÖ")
                ":"
                [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                ")"))
              "‚àß"
              (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
               (Term.app `B [`p])
               " =·µê["
               `Œº
               "] "
               (Term.typeAscription
                "("
                (¬´term‚àÖ¬ª "‚àÖ")
                ":"
                [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                ")")))))
           []
           (tactic__
            (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
            [(Mathlib.Tactic.replace'
              "replace"
              [`h []]
              [(Term.typeSpec
                ":"
                (Term.forall
                 "‚àÄ"
                 [`p]
                 [(Term.typeSpec ":" `Nat.Primes)]
                 ","
                 (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                  (Term.typeAscription
                   "("
                   (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " `E)
                   ":"
                   [(Term.app `Set [(Term.hole "_")])]
                   ")")
                  " =·µê["
                  `Œº
                  "] "
                  `E)))])
             []
             (tactic__
              (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
              [(Tactic.intro "intro" [`p])
               []
               (Mathlib.Tactic.tacticReplace_
                "replace"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`hE‚ÇÇ []]
                  [(Term.typeSpec
                    ":"
                    (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                     `E
                     " =·µê["
                     `Œº
                     "] "
                     (Term.app `C [`p])))]
                  ":="
                  (Term.app `hE‚ÇÇ [`p (Term.app `h [`p])]))))
               []
               (Tactic.tacticHave_
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`h_qmp []]
                  [(Term.typeSpec
                    ":"
                    (Term.app
                     `MeasureTheory.Measure.QuasiMeasurePreserving
                     [(Term.app
                       (Term.paren
                        "("
                        (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑"))
                        ")")
                       [(¬´term-_¬ª "-" (Term.app `u [`p]))])
                      `Œº
                      `Œº]))]
                  ":="
                  (Term.proj
                   (Term.app `measure_preserving_vadd [(Term.hole "_") `Œº])
                   "."
                   `QuasiMeasurePreserving))))
               []
               (Tactic.refine'
                "refine'"
                (Term.app
                 (Term.proj
                  (Term.app `h_qmp.vadd_ae_eq_of_ae_eq [(Term.app `u [`p]) `hE‚ÇÇ])
                  "."
                  `trans)
                 [(Term.app `ae_eq_trans [(Term.hole "_") `hE‚ÇÇ.symm])]))
               []
               (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hC)] "]") [])])
             []
             (Tactic.exact
              "exact"
              (Term.app `ae_empty_or_univ_of_forall_vadd_ae_eq_self [`hE‚ÇÄ `h `hu]))])
           []
           (tactic__
            (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
            [(Mathlib.Tactic.tacticRight "right")
             []
             (Tactic.simp
              "simp"
              []
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `not_forall) "," (Tactic.simpLemma [] [] `not_and_or)]
               "]"]
              [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
             []
             (Std.Tactic.obtain
              "obtain"
              [(Std.Tactic.RCases.rcasesPatMed
                [(Std.Tactic.RCases.rcasesPat.tuple
                  "‚ü®"
                  [(Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                    [])
                   ","
                   (Std.Tactic.RCases.rcasesPatLo
                    (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                    [])]
                  "‚ü©")])]
              []
              [":=" [`h]])
             []
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hE‚ÇÅ [`p]))] "]")
              [])
             []
             (Tactic.cases "cases" [(Tactic.casesTarget [] `hp)] [] [])
             []
             (tactic__
              (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
              [(Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hA [`p]))] [] [])
               []
               (tactic__
                (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
                [(Tactic.contradiction "contradiction")])
               []
               (Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `h)
                  ","
                  (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)]
                 "]"]
                [])])
             []
             (tactic__
              (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
              [(Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hB [`p]))] [] [])
               []
               (tactic__
                (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
                [(Tactic.contradiction "contradiction")])
               []
               (Tactic.simp
                "simp"
                []
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `h)
                  ","
                  (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)
                  ","
                  (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_right)]
                 "]"]
                [])])])])))
       [])
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Std.Tactic.tacticLetI_
           "letI"
           (Term.haveDecl
            (Term.haveIdDecl
             []
             [(Term.typeSpec ":" (Term.app `SemilatticeSup [`Nat.Primes]))]
             ":="
             (Term.app `Nat.Subtype.semilatticeSup [(Term.hole "_")]))))
          []
          (Mathlib.Tactic.set
           "set"
           []
           (Mathlib.Tactic.setArgsRest
            `Œº
            [":" (Term.app `Measure [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
            ":="
            `volume
            []))
          []
          (Mathlib.Tactic.set
           "set"
           []
           (Mathlib.Tactic.setArgsRest
            `u
            [":" (Term.arrow `Nat.Primes "‚Üí" (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä"))]
            ":="
            (Term.fun
             "fun"
             (Term.basicFun
              [`p]
              []
              "=>"
              (coeNotation
               "‚Üë"
               (¬´term_*_¬ª
                (¬´term_/_¬ª
                 (Term.typeAscription
                  "("
                  (coeNotation "‚Üë" (Term.typeAscription "(" (num "1") ":" [(term‚Ñï "‚Ñï")] ")"))
                  ":"
                  [(Data.Real.Basic.term‚Ñù "‚Ñù")]
                  ")")
                 "/"
                 `p)
                "*"
                `T))))
            []))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hu‚ÇÄ []]
             [(Term.typeSpec
               ":"
               (Term.forall
                "‚àÄ"
                [`p]
                [(Term.typeSpec ":" `Nat.Primes)]
                ","
                (¬´term_=_¬ª
                 (Term.app `addOrderOf [(Term.app `u [`p])])
                 "="
                 (Term.typeAscription "(" `p ":" [(term‚Ñï "‚Ñï")] ")"))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Std.Tactic.rintro
                  "rintro"
                  [(Std.Tactic.RCases.rintroPat.one
                    (Std.Tactic.RCases.rcasesPat.tuple
                     "‚ü®"
                     [(Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                       [])
                      ","
                      (Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                       [])]
                     "‚ü©"))]
                  [])
                 []
                 (Tactic.exact
                  "exact"
                  (Term.app
                   `add_order_of_div_of_gcd_eq_one
                   [`hp.pos (Term.app `gcd_one_left [`p])]))]))))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hu []]
             [(Term.typeSpec
               ":"
               (Term.app `tendsto [(¬´term_‚àò_¬ª `addOrderOf "‚àò" `u) `at_top `at_top]))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq
                   "["
                   [(Tactic.rwRule
                     []
                     (Term.typeAscription
                      "("
                      (Term.app `funext [`hu‚ÇÄ])
                      ":"
                      [(¬´term_=_¬ª (¬´term_‚àò_¬ª `addOrderOf "‚àò" `u) "=" `coe)]
                      ")"))]
                   "]")
                  [])
                 []
                 (Tactic.tacticHave_
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`h_mono []]
                    [(Term.typeSpec
                      ":"
                      (Term.app
                       `Monotone
                       [(Term.typeAscription
                         "("
                         `coe
                         ":"
                         [(Term.arrow `Nat.Primes "‚Üí" (term‚Ñï "‚Ñï"))]
                         ")")]))]
                    ":="
                    (Term.fun "fun" (Term.basicFun [`p `q `hpq] [] "=>" `hpq)))))
                 []
                 (Tactic.refine'
                  "refine'"
                  (Term.app
                   `h_mono.tendsto_at_top_at_top
                   [(Term.fun "fun" (Term.basicFun [`n] [] "=>" (Term.hole "_")))]))
                 []
                 (Std.Tactic.obtain
                  "obtain"
                  [(Std.Tactic.RCases.rcasesPatMed
                    [(Std.Tactic.RCases.rcasesPat.tuple
                      "‚ü®"
                      [(Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                        [])
                       ","
                       (Std.Tactic.RCases.rcasesPatLo
                        (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp')])
                        [])]
                      "‚ü©")])]
                  []
                  [":=" [`n.exists_infinite_primes]])
                 []
                 (Tactic.exact
                  "exact"
                  (Term.anonymousCtor
                   "‚ü®"
                   [(Term.anonymousCtor "‚ü®" [`p "," `hp'] "‚ü©") "," `hp]
                   "‚ü©"))]))))))
          []
          (Mathlib.Tactic.set
           "set"
           []
           (Mathlib.Tactic.setArgsRest
            `E
            []
            ":="
            (Term.app `addWellApproximable [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä") `Œ¥])
            []))
          []
          (Mathlib.Tactic.set
           "set"
           []
           (Mathlib.Tactic.setArgsRest
            `X
            [":"
             (Term.arrow
              (term‚Ñï "‚Ñï")
              "‚Üí"
              (Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")]))]
            ":="
            (Term.fun
             "fun"
             (Term.basicFun
              [`n]
              []
              "=>"
              (Term.app
               `approxAddOrderOf
               [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä") `n (Term.app `Œ¥ [`n])])))
            []))
          []
          (Mathlib.Tactic.set
           "set"
           []
           (Mathlib.Tactic.setArgsRest
            `A
            [":"
             (Term.arrow
              (term‚Ñï "‚Ñï")
              "‚Üí"
              (Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")]))]
            ":="
            (Term.fun
             "fun"
             (Term.basicFun
              [`p]
              []
              "=>"
              (Term.app
               `blimsup
               [`X
                `at_top
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [`n]
                  []
                  "=>"
                  (¬´term_‚àß_¬ª
                   (¬´term_<_¬ª (num "0") "<" `n)
                   "‚àß"
                   (AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª `p "‚à§" `n))))])))
            []))
          []
          (Mathlib.Tactic.set
           "set"
           []
           (Mathlib.Tactic.setArgsRest
            `B
            [":"
             (Term.arrow
              (term‚Ñï "‚Ñï")
              "‚Üí"
              (Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")]))]
            ":="
            (Term.fun
             "fun"
             (Term.basicFun
              [`p]
              []
              "=>"
              (Term.app
               `blimsup
               [`X
                `at_top
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [`n]
                  []
                  "=>"
                  (¬´term_‚àß_¬ª
                   (¬´term_<_¬ª (num "0") "<" `n)
                   "‚àß"
                   (AddCircle.NumberTheory.WellApproximable.¬´term_‚à£‚à£_¬ª `p "‚à£‚à£" `n))))])))
            []))
          []
          (Mathlib.Tactic.set
           "set"
           []
           (Mathlib.Tactic.setArgsRest
            `C
            [":"
             (Term.arrow
              (term‚Ñï "‚Ñï")
              "‚Üí"
              (Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")]))]
            ":="
            (Term.fun
             "fun"
             (Term.basicFun
              [`p]
              []
              "=>"
              (Term.app
               `blimsup
               [`X
                `at_top
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [`n]
                  []
                  "=>"
                  (¬´term_‚àß_¬ª
                   (¬´term_<_¬ª (num "0") "<" `n)
                   "‚àß"
                   (¬´term_‚à£_¬ª (¬´term_^_¬ª `p "^" (num "2")) "‚à£" `n))))])))
            []))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hA‚ÇÄ []]
             [(Term.typeSpec
               ":"
               (Term.forall "‚àÄ" [`p] [] "," (Term.app `MeasurableSet [(Term.app `A [`p])])))]
             ":="
             (Term.fun
              "fun"
              (Term.basicFun
               [`p]
               []
               "=>"
               (Term.app
                `MeasurableSet.measurable_set_blimsup
                [(Term.fun
                  "fun"
                  (Term.basicFun [`n `hn] [] "=>" `is_open_thickening.measurable_set))]))))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hB‚ÇÄ []]
             [(Term.typeSpec
               ":"
               (Term.forall "‚àÄ" [`p] [] "," (Term.app `MeasurableSet [(Term.app `B [`p])])))]
             ":="
             (Term.fun
              "fun"
              (Term.basicFun
               [`p]
               []
               "=>"
               (Term.app
                `MeasurableSet.measurable_set_blimsup
                [(Term.fun
                  "fun"
                  (Term.basicFun [`n `hn] [] "=>" `is_open_thickening.measurable_set))]))))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hE‚ÇÄ []]
             [(Term.typeSpec ":" (Term.app `null_measurable_set [`E `Œº]))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.refine'
                  "refine'"
                  (Term.proj
                   (Term.app
                    `MeasurableSet.measurable_set_blimsup
                    [(Term.fun
                      "fun"
                      (Term.basicFun
                       [`n `hn]
                       []
                       "=>"
                       (Term.app `IsOpen.measurable_set [(Term.hole "_")])))])
                   "."
                   `NullMeasurableSet))
                 []
                 (Tactic.exact "exact" `is_open_thickening)]))))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hE‚ÇÅ []]
             [(Term.typeSpec
               ":"
               (Term.forall
                "‚àÄ"
                [`p]
                []
                ","
                (¬´term_=_¬ª
                 `E
                 "="
                 (¬´term_‚à™_¬ª
                  (¬´term_‚à™_¬ª (Term.app `A [`p]) "‚à™" (Term.app `B [`p]))
                  "‚à™"
                  (Term.app `C [`p])))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.intro "intro" [`p])
                 []
                 (Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `E)
                    ","
                    (Tactic.simpLemma [] [] `addWellApproximable)
                    ","
                    (Tactic.simpLemma [] [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `blimsup_or_eq_sup)
                    ","
                    (Tactic.simpLemma [] [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `and_or_left)
                    ","
                    (Tactic.simpLemma [] [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `sup_eq_union)
                    ","
                    (Tactic.simpLemma [] [] `sq)]
                   "]"]
                  [])
                 []
                 (Tactic.congr "congr" [])
                 []
                 (Tactic.refine'
                  "refine'"
                  (Term.app
                   `funext
                   [(Term.fun
                     "fun"
                     (Term.basicFun
                      [`n]
                      []
                      "=>"
                      (¬´term_<|_¬ª
                       `propext
                       "<|"
                       (Term.app
                        `iff_self_and.mpr
                        [(Term.fun "fun" (Term.basicFun [`hn] [] "=>" (Term.hole "_")))]))))]))
                 []
                 (Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma
                     []
                     []
                     (Term.proj (Term.app `em [(¬´term_‚à£_¬ª `p "‚à£" `n)]) "." `symm))
                    ","
                    (Tactic.simpLemma
                     []
                     []
                     (Term.proj
                      (Term.app `em [(¬´term_‚à£_¬ª (¬´term_*_¬ª `p "*" `p) "‚à£" `n)])
                      "."
                      `symm))
                    ","
                    (Tactic.simpLemma [] [] `or_and_left)
                    ","
                    (Tactic.simpLemma [] [] `or_true_iff)
                    ","
                    (Tactic.simpLemma [] [] `true_and_iff)
                    ","
                    (Tactic.simpLemma [] [] `or_assoc')]
                   "]"]
                  [])]))))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hE‚ÇÇ []]
             [(Term.typeSpec
               ":"
               (Term.forall
                "‚àÄ"
                [`p]
                [(Term.typeSpec ":" `Nat.Primes)]
                ","
                (Term.arrow
                 (¬´term_‚àß_¬ª
                  (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                   (Term.app `A [`p])
                   " =·µê["
                   `Œº
                   "] "
                   (Term.typeAscription
                    "("
                    (¬´term‚àÖ¬ª "‚àÖ")
                    ":"
                    [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                    ")"))
                  "‚àß"
                  (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                   (Term.app `B [`p])
                   " =·µê["
                   `Œº
                   "] "
                   (Term.typeAscription
                    "("
                    (¬´term‚àÖ¬ª "‚àÖ")
                    ":"
                    [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                    ")")))
                 "‚Üí"
                 (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                  `E
                  " =·µê["
                  `Œº
                  "] "
                  (Term.app `C [`p])))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Std.Tactic.rintro
                  "rintro"
                  [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `p))
                   (Std.Tactic.RCases.rintroPat.one
                    (Std.Tactic.RCases.rcasesPat.tuple
                     "‚ü®"
                     [(Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hA)])
                       [])
                      ","
                      (Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hB)])
                       [])]
                     "‚ü©"))]
                  [])
                 []
                 (Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hE‚ÇÅ [`p]))] "]")
                  [])
                 []
                 (Tactic.exact
                  "exact"
                  (Term.app
                   `union_ae_eq_right_of_ae_eq_empty
                   [(Term.app
                     (Term.proj (Term.app `union_ae_eq_right_of_ae_eq_empty [`hA]) "." `trans)
                     [`hB])]))]))))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hA []]
             [(Term.typeSpec
               ":"
               (Term.forall
                "‚àÄ"
                [`p]
                [(Term.typeSpec ":" `Nat.Primes)]
                ","
                (¬´term_‚à®_¬ª
                 (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                  (Term.app `A [`p])
                  " =·µê["
                  `Œº
                  "] "
                  (Term.typeAscription
                   "("
                   (¬´term‚àÖ¬ª "‚àÖ")
                   ":"
                   [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                   ")"))
                 "‚à®"
                 (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                  (Term.app `A [`p])
                  " =·µê["
                  `Œº
                  "] "
                  `univ))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Std.Tactic.rintro
                  "rintro"
                  [(Std.Tactic.RCases.rintroPat.one
                    (Std.Tactic.RCases.rcasesPat.tuple
                     "‚ü®"
                     [(Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                       [])
                      ","
                      (Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                       [])]
                     "‚ü©"))]
                  [])
                 []
                 (Tactic.tacticLet_
                  "let"
                  (Term.letDecl
                   (Term.letIdDecl
                    `f
                    []
                    [(Term.typeSpec
                      ":"
                      (Term.arrow
                       (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                       "‚Üí"
                       (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")))]
                    ":="
                    (Term.fun
                     "fun"
                     (Term.basicFun
                      [`y]
                      []
                      "=>"
                      (Algebra.Group.Defs.¬´term_‚Ä¢_¬ª
                       (Term.typeAscription "(" `p ":" [(term‚Ñï "‚Ñï")] ")")
                       " ‚Ä¢ "
                       `y))))))
                 []
                 (Tactic.tacticSuffices_
                  "suffices"
                  (Term.sufficesDecl
                   []
                   (¬´term_‚äÜ_¬ª
                    (Set.Data.Set.Image.term_''_ `f " '' " (Term.app `A [`p]))
                    "‚äÜ"
                    (Term.app
                     `blimsup
                     [(Term.fun
                       "fun"
                       (Term.basicFun
                        [`n]
                        []
                        "=>"
                        (Term.app
                         `approxAddOrderOf
                         [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                          `n
                          (¬´term_*_¬ª `p "*" (Term.app `Œ¥ [`n]))])))
                      `at_top
                      (Term.fun
                       "fun"
                       (Term.basicFun
                        [`n]
                        []
                        "=>"
                        (¬´term_‚àß_¬ª
                         (¬´term_<_¬ª (num "0") "<" `n)
                         "‚àß"
                         (AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª `p "‚à§" `n))))]))
                   (Term.byTactic'
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.apply
                        "apply"
                        (Term.app
                         (Term.proj
                          (Term.app `ergodic_nsmul [`hp.one_lt])
                          "."
                          `ae_empty_or_univ_of_image_ae_le)
                         [(Term.app `hA‚ÇÄ [`p])]))
                       []
                       (Tactic.apply
                        "apply"
                        (Term.app
                         (Term.proj (Term.app `HasSubset.Subset.eventually_le [`this]) "." `congr)
                         [`eventually_eq.rfl]))
                       []
                       (Tactic.exact
                        "exact"
                        (Term.app
                         `blimsup_thickening_mul_ae_eq
                         [`Œº
                          (Term.fun
                           "fun"
                           (Term.basicFun
                            [`n]
                            []
                            "=>"
                            (¬´term_‚àß_¬ª
                             (¬´term_<_¬ª (num "0") "<" `n)
                             "‚àß"
                             (AddCircle.NumberTheory.WellApproximable.¬´term_‚à§_¬ª `p "‚à§" `n))))
                          (Term.fun
                           "fun"
                           (Term.basicFun
                            [`n]
                            []
                            "=>"
                            (Set.¬´term{_|_}¬ª
                             "{"
                             (Std.ExtendedBinder.extBinder (Lean.binderIdent `y) [])
                             "|"
                             (¬´term_=_¬ª (Term.app `addOrderOf [`y]) "=" `n)
                             "}")))
                          (Term.app `nat.cast_pos.mpr [`hp.pos])
                          (Term.hole "_")
                          `hŒ¥]))])))))
                 []
                 (Tactic.refine'
                  "refine'"
                  (Term.app
                   (Term.proj
                    (Term.proj (Term.app `SupHom.setImage [`f]) "." `apply_blimsup_le)
                    "."
                    `trans)
                   [(Term.app
                     `mono_blimsup
                     [(Term.fun "fun" (Term.basicFun [`n `hn] [] "=>" (Term.hole "_")))])]))
                 []
                 (Mathlib.Tactic.tacticReplace_
                  "replace"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`hn []]
                    []
                    ":="
                    (Term.app
                     `nat.coprime_comm.mp
                     [(Term.app
                       (Term.proj `hp.coprime_iff_not_dvd "." (fieldIdx "2"))
                       [(Term.proj `hn "." (fieldIdx "2"))])]))))
                 []
                 (Tactic.exact
                  "exact"
                  (Term.app
                   `approxAddOrderOf.image_nsmul_subset_of_coprime
                   [(Term.app `Œ¥ [`n]) `hp.pos `hn]))]))))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hB []]
             [(Term.typeSpec
               ":"
               (Term.forall
                "‚àÄ"
                [`p]
                [(Term.typeSpec ":" `Nat.Primes)]
                ","
                (¬´term_‚à®_¬ª
                 (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                  (Term.app `B [`p])
                  " =·µê["
                  `Œº
                  "] "
                  (Term.typeAscription
                   "("
                   (¬´term‚àÖ¬ª "‚àÖ")
                   ":"
                   [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                   ")"))
                 "‚à®"
                 (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                  (Term.app `B [`p])
                  " =·µê["
                  `Œº
                  "] "
                  `univ))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Std.Tactic.rintro
                  "rintro"
                  [(Std.Tactic.RCases.rintroPat.one
                    (Std.Tactic.RCases.rcasesPat.tuple
                     "‚ü®"
                     [(Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                       [])
                      ","
                      (Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                       [])]
                     "‚ü©"))]
                  [])
                 []
                 (Tactic.tacticLet_
                  "let"
                  (Term.letDecl
                   (Term.letIdDecl
                    `x
                    []
                    []
                    ":="
                    (Term.app `u [(Term.anonymousCtor "‚ü®" [`p "," `hp] "‚ü©")]))))
                 []
                 (Tactic.tacticLet_
                  "let"
                  (Term.letDecl
                   (Term.letIdDecl
                    `f
                    []
                    [(Term.typeSpec
                      ":"
                      (Term.arrow
                       (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                       "‚Üí"
                       (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")))]
                    ":="
                    (Term.fun
                     "fun"
                     (Term.basicFun
                      [`y]
                      []
                      "=>"
                      (¬´term_+_¬ª (Algebra.Group.Defs.¬´term_‚Ä¢_¬ª `p " ‚Ä¢ " `y) "+" `x))))))
                 []
                 (Tactic.tacticSuffices_
                  "suffices"
                  (Term.sufficesDecl
                   []
                   (¬´term_‚äÜ_¬ª
                    (Set.Data.Set.Image.term_''_ `f " '' " (Term.app `B [`p]))
                    "‚äÜ"
                    (Term.app
                     `blimsup
                     [(Term.fun
                       "fun"
                       (Term.basicFun
                        [`n]
                        []
                        "=>"
                        (Term.app
                         `approxAddOrderOf
                         [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                          `n
                          (¬´term_*_¬ª `p "*" (Term.app `Œ¥ [`n]))])))
                      `at_top
                      (Term.fun
                       "fun"
                       (Term.basicFun
                        [`n]
                        []
                        "=>"
                        (¬´term_‚àß_¬ª
                         (¬´term_<_¬ª (num "0") "<" `n)
                         "‚àß"
                         (AddCircle.NumberTheory.WellApproximable.¬´term_‚à£‚à£_¬ª `p "‚à£‚à£" `n))))]))
                   (Term.byTactic'
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(Tactic.apply
                        "apply"
                        (Term.app
                         (Term.proj
                          (Term.app `ergodic_nsmul_add [`x `hp.one_lt])
                          "."
                          `ae_empty_or_univ_of_image_ae_le)
                         [(Term.app `hB‚ÇÄ [`p])]))
                       []
                       (Tactic.apply
                        "apply"
                        (Term.app
                         (Term.proj (Term.app `HasSubset.Subset.eventually_le [`this]) "." `congr)
                         [`eventually_eq.rfl]))
                       []
                       (Tactic.exact
                        "exact"
                        (Term.app
                         `blimsup_thickening_mul_ae_eq
                         [`Œº
                          (Term.fun
                           "fun"
                           (Term.basicFun
                            [`n]
                            []
                            "=>"
                            (¬´term_‚àß_¬ª
                             (¬´term_<_¬ª (num "0") "<" `n)
                             "‚àß"
                             (AddCircle.NumberTheory.WellApproximable.¬´term_‚à£‚à£_¬ª `p "‚à£‚à£" `n))))
                          (Term.fun
                           "fun"
                           (Term.basicFun
                            [`n]
                            []
                            "=>"
                            (Set.¬´term{_|_}¬ª
                             "{"
                             (Std.ExtendedBinder.extBinder (Lean.binderIdent `y) [])
                             "|"
                             (¬´term_=_¬ª (Term.app `addOrderOf [`y]) "=" `n)
                             "}")))
                          (Term.app `nat.cast_pos.mpr [`hp.pos])
                          (Term.hole "_")
                          `hŒ¥]))])))))
                 []
                 (Tactic.refine'
                  "refine'"
                  (Term.app
                   (Term.proj
                    (Term.proj (Term.app `SupHom.setImage [`f]) "." `apply_blimsup_le)
                    "."
                    `trans)
                   [(Term.app `mono_blimsup [(Term.hole "_")])]))
                 []
                 (Std.Tactic.rintro
                  "rintro"
                  [(Std.Tactic.RCases.rintroPat.one (Std.Tactic.RCases.rcasesPat.one `n))
                   (Std.Tactic.RCases.rintroPat.one
                    (Std.Tactic.RCases.rcasesPat.tuple
                     "‚ü®"
                     [(Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hn)])
                       [])
                      ","
                      (Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h_div)])
                       [])
                      ","
                      (Std.Tactic.RCases.rcasesPatLo
                       (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h_ndiv)])
                       [])]
                     "‚ü©"))]
                  [])
                 []
                 (Tactic.tacticHave_
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`h_cop []]
                    [(Term.typeSpec
                      ":"
                      (Term.app
                       (Term.proj (Term.app `addOrderOf [`x]) "." `Coprime)
                       [(¬´term_/_¬ª `n "/" `p)]))]
                    ":="
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(Std.Tactic.obtain
                         "obtain"
                         [(Std.Tactic.RCases.rcasesPatMed
                           [(Std.Tactic.RCases.rcasesPat.tuple
                             "‚ü®"
                             [(Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `q)])
                               [])
                              ","
                              (Std.Tactic.RCases.rcasesPatLo
                               (Std.Tactic.RCases.rcasesPatMed
                                [(Std.Tactic.RCases.rcasesPat.one `rfl)])
                               [])]
                             "‚ü©")])]
                         []
                         [":=" [`h_div]])
                        []
                        (Tactic.rwSeq
                         "rw"
                         []
                         (Tactic.rwRuleSeq
                          "["
                          [(Tactic.rwRule [] `hu‚ÇÄ)
                           ","
                           (Tactic.rwRule [] `Subtype.coe_mk)
                           ","
                           (Tactic.rwRule [] `hp.coprime_iff_not_dvd)
                           ","
                           (Tactic.rwRule [] (Term.app `q.mul_div_cancel_left [`hp.pos]))]
                          "]")
                         [])
                        []
                        (Tactic.exact
                         "exact"
                         (Term.fun
                          "fun"
                          (Term.basicFun
                           [`contra]
                           []
                           "=>"
                           (Term.app `h_ndiv [(Term.app `mul_dvd_mul_left [`p `contra])]))))]))))))
                 []
                 (Mathlib.Tactic.tacticReplace_
                  "replace"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`h_div []]
                    [(Term.typeSpec
                      ":"
                      (¬´term_=_¬ª (¬´term_*_¬ª (¬´term_/_¬ª `n "/" `p) "*" `p) "=" `n))]
                    ":="
                    (Term.app `Nat.div_mul_cancel [`h_div]))))
                 []
                 (Tactic.tacticHave_
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`hf []]
                    [(Term.typeSpec
                      ":"
                      (¬´term_=_¬ª
                       `f
                       "="
                       (¬´term_‚àò_¬ª
                        (Term.fun "fun" (Term.basicFun [`y] [] "=>" (¬´term_+_¬ª `x "+" `y)))
                        "‚àò"
                        (Term.fun
                         "fun"
                         (Term.basicFun
                          [`y]
                          []
                          "=>"
                          (Algebra.Group.Defs.¬´term_‚Ä¢_¬ª `p " ‚Ä¢ " `y))))))]
                    ":="
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(Std.Tactic.Ext.¬´tacticExt___:_¬ª "ext" [] [])
                        []
                        (Tactic.simp
                         "simp"
                         []
                         []
                         []
                         ["[" [(Tactic.simpLemma [] [] (Term.app `add_comm [`x]))] "]"]
                         [])]))))))
                 []
                 (Mathlib.Tactic.tacticSimp_rw__
                  "simp_rw"
                  (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `comp_app)] "]")
                  [])
                 []
                 (Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq
                   "["
                   [(Tactic.rwRule [] `le_eq_subset)
                    ","
                    (Tactic.rwRule [] `SupHom.set_image_to_fun)
                    ","
                    (Tactic.rwRule [] `hf)
                    ","
                    (Tactic.rwRule [] `image_comp)]
                   "]")
                  [])
                 []
                 (Tactic.tacticHave_
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    []
                    []
                    ":="
                    (Term.app
                     (Term.explicit "@" `monotone_image)
                     [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                      (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
                      (Term.fun "fun" (Term.basicFun [`y] [] "=>" (¬´term_+_¬ª `x "+" `y)))]))))
                 []
                 (Tactic.specialize
                  "specialize"
                  (Term.app
                   `this
                   [(Term.app
                     `approxAddOrderOf.image_nsmul_subset
                     [(Term.app `Œ¥ [`n]) (¬´term_/_¬ª `n "/" `p) `hp.pos])]))
                 []
                 (Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["[" [(Tactic.simpLemma [] [] `h_div)] "]"]
                  [(Tactic.location
                    "at"
                    (Tactic.locationHyp [`this] [(patternIgnore (token.¬´‚ä¢¬ª "‚ä¢"))]))])
                 []
                 (Tactic.refine' "refine'" (Term.app `this.trans [(Term.hole "_")]))
                 []
                 (convert
                  "convert"
                  []
                  (Term.app
                   `approxAddOrderOf.vadd_subset_of_coprime
                   [(¬´term_*_¬ª `p "*" (Term.app `Œ¥ [`n])) `h_cop])
                  [])
                 []
                 (Tactic.simp
                  "simp"
                  []
                  []
                  ["only"]
                  ["["
                   [(Tactic.simpLemma [] [] `hu‚ÇÄ)
                    ","
                    (Tactic.simpLemma [] [] `Subtype.coe_mk)
                    ","
                    (Tactic.simpLemma [] [] `h_div)
                    ","
                    (Tactic.simpLemma [] [] (Term.app `mul_comm [`p]))]
                   "]"]
                  [])]))))))
          []
          (Tactic.change
           "change"
           (¬´term_‚à®_¬ª
            (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term‚àÄ·µê_,_¬ª
             "‚àÄ·µê"
             (Std.ExtendedBinder.extBinders (Std.ExtendedBinder.extBinder (Lean.binderIdent `x) []))
             ", "
             (¬´term_‚àâ_¬ª `x "‚àâ" `E))
            "‚à®"
            (¬´term_‚àà_¬ª `E "‚àà" `volume.ae))
           [])
          []
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `eventually_eq_empty)
             ","
             (Tactic.rwRule [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] `eventually_eq_univ)]
            "]")
           [])
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hC []]
             [(Term.typeSpec
               ":"
               (Term.forall
                "‚àÄ"
                [`p]
                [(Term.typeSpec ":" `Nat.Primes)]
                ","
                (¬´term_=_¬ª
                 (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " (Term.app `C [`p]))
                 "="
                 (Term.app `C [`p]))))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(Tactic.intro "intro" [`p])
                 []
                 (Tactic.tacticLet_
                  "let"
                  (Term.letDecl
                   (Term.letIdDecl
                    `e
                    []
                    []
                    ":="
                    (Term.proj
                     (Term.typeAscription
                      "("
                      (Term.app `AddAction.toPerm [(Term.app `u [`p])])
                      ":"
                      [(Term.app `Equiv.Perm [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
                      ")")
                     "."
                     `toOrderIsoSet))))
                 []
                 (Tactic.change
                  "change"
                  (¬´term_=_¬ª (Term.app `e [(Term.app `C [`p])]) "=" (Term.app `C [`p]))
                  [])
                 []
                 (Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq
                   "["
                   [(Tactic.rwRule [] `e.apply_blimsup)
                    ","
                    (Tactic.rwRule [(patternIgnore (token.¬´‚Üê ¬ª "‚Üê"))] (Term.app `hu‚ÇÄ [`p]))]
                   "]")
                  [])
                 []
                 (Tactic.exact
                  "exact"
                  (Term.app
                   `blimsup_congr
                   [(Term.app
                     `eventually_of_forall
                     [(Term.fun
                       "fun"
                       (Term.basicFun
                        [`n `hn]
                        []
                        "=>"
                        (Term.app
                         `approxAddOrderOf.vadd_eq_of_mul_dvd
                         [(Term.app `Œ¥ [`n])
                          (Term.proj `hn "." (fieldIdx "1"))
                          (Term.proj `hn "." (fieldIdx "2"))])))])]))]))))))
          []
          (Classical.¬´tacticBy_cases_:_¬ª
           "by_cases"
           [`h ":"]
           (Term.forall
            "‚àÄ"
            [`p]
            [(Term.typeSpec ":" `Nat.Primes)]
            ","
            (¬´term_‚àß_¬ª
             (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
              (Term.app `A [`p])
              " =·µê["
              `Œº
              "] "
              (Term.typeAscription
               "("
               (¬´term‚àÖ¬ª "‚àÖ")
               ":"
               [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
               ")"))
             "‚àß"
             (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
              (Term.app `B [`p])
              " =·µê["
              `Œº
              "] "
              (Term.typeAscription
               "("
               (¬´term‚àÖ¬ª "‚àÖ")
               ":"
               [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
               ")")))))
          []
          (tactic__
           (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
           [(Mathlib.Tactic.replace'
             "replace"
             [`h []]
             [(Term.typeSpec
               ":"
               (Term.forall
                "‚àÄ"
                [`p]
                [(Term.typeSpec ":" `Nat.Primes)]
                ","
                (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                 (Term.typeAscription
                  "("
                  (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " `E)
                  ":"
                  [(Term.app `Set [(Term.hole "_")])]
                  ")")
                 " =·µê["
                 `Œº
                 "] "
                 `E)))])
            []
            (tactic__
             (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
             [(Tactic.intro "intro" [`p])
              []
              (Mathlib.Tactic.tacticReplace_
               "replace"
               (Term.haveDecl
                (Term.haveIdDecl
                 [`hE‚ÇÇ []]
                 [(Term.typeSpec
                   ":"
                   (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                    `E
                    " =·µê["
                    `Œº
                    "] "
                    (Term.app `C [`p])))]
                 ":="
                 (Term.app `hE‚ÇÇ [`p (Term.app `h [`p])]))))
              []
              (Tactic.tacticHave_
               "have"
               (Term.haveDecl
                (Term.haveIdDecl
                 [`h_qmp []]
                 [(Term.typeSpec
                   ":"
                   (Term.app
                    `MeasureTheory.Measure.QuasiMeasurePreserving
                    [(Term.app
                      (Term.paren
                       "("
                       (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑"))
                       ")")
                      [(¬´term-_¬ª "-" (Term.app `u [`p]))])
                     `Œº
                     `Œº]))]
                 ":="
                 (Term.proj
                  (Term.app `measure_preserving_vadd [(Term.hole "_") `Œº])
                  "."
                  `QuasiMeasurePreserving))))
              []
              (Tactic.refine'
               "refine'"
               (Term.app
                (Term.proj
                 (Term.app `h_qmp.vadd_ae_eq_of_ae_eq [(Term.app `u [`p]) `hE‚ÇÇ])
                 "."
                 `trans)
                [(Term.app `ae_eq_trans [(Term.hole "_") `hE‚ÇÇ.symm])]))
              []
              (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hC)] "]") [])])
            []
            (Tactic.exact
             "exact"
             (Term.app `ae_empty_or_univ_of_forall_vadd_ae_eq_self [`hE‚ÇÄ `h `hu]))])
          []
          (tactic__
           (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
           [(Mathlib.Tactic.tacticRight "right")
            []
            (Tactic.simp
             "simp"
             []
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `not_forall) "," (Tactic.simpLemma [] [] `not_and_or)]
              "]"]
             [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
            []
            (Std.Tactic.obtain
             "obtain"
             [(Std.Tactic.RCases.rcasesPatMed
               [(Std.Tactic.RCases.rcasesPat.tuple
                 "‚ü®"
                 [(Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
                   [])
                  ","
                  (Std.Tactic.RCases.rcasesPatLo
                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
                   [])]
                 "‚ü©")])]
             []
             [":=" [`h]])
            []
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hE‚ÇÅ [`p]))] "]")
             [])
            []
            (Tactic.cases "cases" [(Tactic.casesTarget [] `hp)] [] [])
            []
            (tactic__
             (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
             [(Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hA [`p]))] [] [])
              []
              (tactic__
               (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
               [(Tactic.contradiction "contradiction")])
              []
              (Tactic.simp
               "simp"
               []
               []
               ["only"]
               ["["
                [(Tactic.simpLemma [] [] `h)
                 ","
                 (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)]
                "]"]
               [])])
            []
            (tactic__
             (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
             [(Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hB [`p]))] [] [])
              []
              (tactic__
               (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
               [(Tactic.contradiction "contradiction")])
              []
              (Tactic.simp
               "simp"
               []
               []
               ["only"]
               ["["
                [(Tactic.simpLemma [] [] `h)
                 ","
                 (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)
                 ","
                 (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_right)]
                "]"]
               [])])])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
       [(Mathlib.Tactic.tacticRight "right")
        []
        (Tactic.simp
         "simp"
         []
         []
         ["only"]
         ["[" [(Tactic.simpLemma [] [] `not_forall) "," (Tactic.simpLemma [] [] `not_and_or)] "]"]
         [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
        []
        (Std.Tactic.obtain
         "obtain"
         [(Std.Tactic.RCases.rcasesPatMed
           [(Std.Tactic.RCases.rcasesPat.tuple
             "‚ü®"
             [(Std.Tactic.RCases.rcasesPatLo
               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
               [])
              ","
              (Std.Tactic.RCases.rcasesPatLo
               (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
               [])]
             "‚ü©")])]
         []
         [":=" [`h]])
        []
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hE‚ÇÅ [`p]))] "]")
         [])
        []
        (Tactic.cases "cases" [(Tactic.casesTarget [] `hp)] [] [])
        []
        (tactic__
         (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
         [(Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hA [`p]))] [] [])
          []
          (tactic__
           (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
           [(Tactic.contradiction "contradiction")])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `h)
             ","
             (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)]
            "]"]
           [])])
        []
        (tactic__
         (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
         [(Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hB [`p]))] [] [])
          []
          (tactic__
           (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
           [(Tactic.contradiction "contradiction")])
          []
          (Tactic.simp
           "simp"
           []
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `h)
             ","
             (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)
             ","
             (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_right)]
            "]"]
           [])])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
       [(Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hB [`p]))] [] [])
        []
        (tactic__
         (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
         [(Tactic.contradiction "contradiction")])
        []
        (Tactic.simp
         "simp"
         []
         []
         ["only"]
         ["["
          [(Tactic.simpLemma [] [] `h)
           ","
           (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)
           ","
           (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_right)]
          "]"]
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `h)
         ","
         (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)
         ","
         (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_right)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `union_ae_eq_univ_of_ae_eq_univ_right
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `union_ae_eq_univ_of_ae_eq_univ_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__ (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑"))) [(Tactic.contradiction "contradiction")])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.contradiction "contradiction")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hB [`p]))] [] [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hB [`p])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hB
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
       [(Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hA [`p]))] [] [])
        []
        (tactic__
         (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
         [(Tactic.contradiction "contradiction")])
        []
        (Tactic.simp
         "simp"
         []
         []
         ["only"]
         ["["
          [(Tactic.simpLemma [] [] `h)
           ","
           (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)]
          "]"]
         [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["["
        [(Tactic.simpLemma [] [] `h)
         ","
         (Tactic.simpLemma [] [] `union_ae_eq_univ_of_ae_eq_univ_left)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `union_ae_eq_univ_of_ae_eq_univ_left
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__ (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑"))) [(Tactic.contradiction "contradiction")])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.contradiction "contradiction")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.cases "cases" [(Tactic.casesTarget [] (Term.app `hA [`p]))] [] [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hA [`p])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hA
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.cases "cases" [(Tactic.casesTarget [] `hp)] [] [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hp
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hE‚ÇÅ [`p]))] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hE‚ÇÅ [`p])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hE‚ÇÅ
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Std.Tactic.obtain
       "obtain"
       [(Std.Tactic.RCases.rcasesPatMed
         [(Std.Tactic.RCases.rcasesPat.tuple
           "‚ü®"
           [(Std.Tactic.RCases.rcasesPatLo
             (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `p)])
             [])
            ","
            (Std.Tactic.RCases.rcasesPatLo
             (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp)])
             [])]
           "‚ü©")])]
       []
       [":=" [`h]])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       ["only"]
       ["[" [(Tactic.simpLemma [] [] `not_forall) "," (Tactic.simpLemma [] [] `not_and_or)] "]"]
       [(Tactic.location "at" (Tactic.locationHyp [`h] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `not_and_or
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `not_forall
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticRight "right")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
       [(Mathlib.Tactic.replace'
         "replace"
         [`h []]
         [(Term.typeSpec
           ":"
           (Term.forall
            "‚àÄ"
            [`p]
            [(Term.typeSpec ":" `Nat.Primes)]
            ","
            (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
             (Term.typeAscription
              "("
              (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " `E)
              ":"
              [(Term.app `Set [(Term.hole "_")])]
              ")")
             " =·µê["
             `Œº
             "] "
             `E)))])
        []
        (tactic__
         (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
         [(Tactic.intro "intro" [`p])
          []
          (Mathlib.Tactic.tacticReplace_
           "replace"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hE‚ÇÇ []]
             [(Term.typeSpec
               ":"
               (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
                `E
                " =·µê["
                `Œº
                "] "
                (Term.app `C [`p])))]
             ":="
             (Term.app `hE‚ÇÇ [`p (Term.app `h [`p])]))))
          []
          (Tactic.tacticHave_
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`h_qmp []]
             [(Term.typeSpec
               ":"
               (Term.app
                `MeasureTheory.Measure.QuasiMeasurePreserving
                [(Term.app
                  (Term.paren
                   "("
                   (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑"))
                   ")")
                  [(¬´term-_¬ª "-" (Term.app `u [`p]))])
                 `Œº
                 `Œº]))]
             ":="
             (Term.proj
              (Term.app `measure_preserving_vadd [(Term.hole "_") `Œº])
              "."
              `QuasiMeasurePreserving))))
          []
          (Tactic.refine'
           "refine'"
           (Term.app
            (Term.proj (Term.app `h_qmp.vadd_ae_eq_of_ae_eq [(Term.app `u [`p]) `hE‚ÇÇ]) "." `trans)
            [(Term.app `ae_eq_trans [(Term.hole "_") `hE‚ÇÇ.symm])]))
          []
          (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hC)] "]") [])])
        []
        (Tactic.exact
         "exact"
         (Term.app `ae_empty_or_univ_of_forall_vadd_ae_eq_self [`hE‚ÇÄ `h `hu]))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact "exact" (Term.app `ae_empty_or_univ_of_forall_vadd_ae_eq_self [`hE‚ÇÄ `h `hu]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `ae_empty_or_univ_of_forall_vadd_ae_eq_self [`hE‚ÇÄ `h `hu])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hu
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `hE‚ÇÄ
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `ae_empty_or_univ_of_forall_vadd_ae_eq_self
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (tactic__
       (cdotTk (patternIgnore (token.¬´¬∑ ¬ª "¬∑")))
       [(Tactic.intro "intro" [`p])
        []
        (Mathlib.Tactic.tacticReplace_
         "replace"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hE‚ÇÇ []]
           [(Term.typeSpec
             ":"
             (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
              `E
              " =·µê["
              `Œº
              "] "
              (Term.app `C [`p])))]
           ":="
           (Term.app `hE‚ÇÇ [`p (Term.app `h [`p])]))))
        []
        (Tactic.tacticHave_
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`h_qmp []]
           [(Term.typeSpec
             ":"
             (Term.app
              `MeasureTheory.Measure.QuasiMeasurePreserving
              [(Term.app
                (Term.paren
                 "("
                 (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑"))
                 ")")
                [(¬´term-_¬ª "-" (Term.app `u [`p]))])
               `Œº
               `Œº]))]
           ":="
           (Term.proj
            (Term.app `measure_preserving_vadd [(Term.hole "_") `Œº])
            "."
            `QuasiMeasurePreserving))))
        []
        (Tactic.refine'
         "refine'"
         (Term.app
          (Term.proj (Term.app `h_qmp.vadd_ae_eq_of_ae_eq [(Term.app `u [`p]) `hE‚ÇÇ]) "." `trans)
          [(Term.app `ae_eq_trans [(Term.hole "_") `hE‚ÇÇ.symm])]))
        []
        (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hC)] "]") [])])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `hC)] "]") [])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hC
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.refine'
       "refine'"
       (Term.app
        (Term.proj (Term.app `h_qmp.vadd_ae_eq_of_ae_eq [(Term.app `u [`p]) `hE‚ÇÇ]) "." `trans)
        [(Term.app `ae_eq_trans [(Term.hole "_") `hE‚ÇÇ.symm])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       (Term.proj (Term.app `h_qmp.vadd_ae_eq_of_ae_eq [(Term.app `u [`p]) `hE‚ÇÇ]) "." `trans)
       [(Term.app `ae_eq_trans [(Term.hole "_") `hE‚ÇÇ.symm])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `ae_eq_trans [(Term.hole "_") `hE‚ÇÇ.symm])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hE‚ÇÇ.symm
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `ae_eq_trans
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `ae_eq_trans [(Term.hole "_") `hE‚ÇÇ.symm])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.proj (Term.app `h_qmp.vadd_ae_eq_of_ae_eq [(Term.app `u [`p]) `hE‚ÇÇ]) "." `trans)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `h_qmp.vadd_ae_eq_of_ae_eq [(Term.app `u [`p]) `hE‚ÇÇ])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `hE‚ÇÇ
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `u [`p])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `u [`p]) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h_qmp.vadd_ae_eq_of_ae_eq
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `h_qmp.vadd_ae_eq_of_ae_eq [(Term.paren "(" (Term.app `u [`p]) ")") `hE‚ÇÇ])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticHave_
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h_qmp []]
         [(Term.typeSpec
           ":"
           (Term.app
            `MeasureTheory.Measure.QuasiMeasurePreserving
            [(Term.app
              (Term.paren
               "("
               (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑"))
               ")")
              [(¬´term-_¬ª "-" (Term.app `u [`p]))])
             `Œº
             `Œº]))]
         ":="
         (Term.proj
          (Term.app `measure_preserving_vadd [(Term.hole "_") `Œº])
          "."
          `QuasiMeasurePreserving))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.proj
       (Term.app `measure_preserving_vadd [(Term.hole "_") `Œº])
       "."
       `QuasiMeasurePreserving)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app `measure_preserving_vadd [(Term.hole "_") `Œº])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Œº
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `measure_preserving_vadd
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app `measure_preserving_vadd [(Term.hole "_") `Œº])
     ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `MeasureTheory.Measure.QuasiMeasurePreserving
       [(Term.app
         (Term.paren "(" (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑")) ")")
         [(¬´term-_¬ª "-" (Term.app `u [`p]))])
        `Œº
        `Œº])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Œº
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `Œº
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.app
       (Term.paren "(" (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑")) ")")
       [(¬´term-_¬ª "-" (Term.app `u [`p]))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '¬´term-_¬ª', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '¬´term-_¬ª', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (¬´term-_¬ª "-" (Term.app `u [`p]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `u [`p])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 75 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 75, (some 75, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (¬´term-_¬ª "-" (Term.app `u [`p])) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Term.paren "(" (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑")) ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.cdot "¬∑")
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      (Term.cdot "¬∑")
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1024, (none, [anonymous]) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
     "("
     (Term.app
      (Term.paren "(" (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.cdot "¬∑") " +·µ• " (Term.cdot "¬∑")) ")")
      [(Term.paren "(" (¬´term-_¬ª "-" (Term.app `u [`p])) ")")])
     ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `MeasureTheory.Measure.QuasiMeasurePreserving
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.tacticReplace_
       "replace"
       (Term.haveDecl
        (Term.haveIdDecl
         [`hE‚ÇÇ []]
         [(Term.typeSpec
           ":"
           (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
            `E
            " =·µê["
            `Œº
            "] "
            (Term.app `C [`p])))]
         ":="
         (Term.app `hE‚ÇÇ [`p (Term.app `h [`p])]))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `hE‚ÇÇ [`p (Term.app `h [`p])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `h [`p])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `h
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `h [`p]) ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `hE‚ÇÇ
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
       `E
       " =·µê["
       `Œº
       "] "
       (Term.app `C [`p]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `C [`p])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `C
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 50 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Œº
[PrettyPrinter.parenthesize] ...precedences are 50 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      `E
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 50, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.intro "intro" [`p])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Mathlib.Tactic.replace'
       "replace"
       [`h []]
       [(Term.typeSpec
         ":"
         (Term.forall
          "‚àÄ"
          [`p]
          [(Term.typeSpec ":" `Nat.Primes)]
          ","
          (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
           (Term.typeAscription
            "("
            (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " `E)
            ":"
            [(Term.app `Set [(Term.hole "_")])]
            ")")
           " =·µê["
           `Œº
           "] "
           `E)))])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "‚àÄ"
       [`p]
       [(Term.typeSpec ":" `Nat.Primes)]
       ","
       (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
        (Term.typeAscription
         "("
         (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " `E)
         ":"
         [(Term.app `Set [(Term.hole "_")])]
         ")")
        " =·µê["
        `Œº
        "] "
        `E))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
       (Term.typeAscription
        "("
        (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " `E)
        ":"
        [(Term.app `Set [(Term.hole "_")])]
        ")")
       " =·µê["
       `Œº
       "] "
       `E)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `E
[PrettyPrinter.parenthesize] ...precedences are 50 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Œº
[PrettyPrinter.parenthesize] ...precedences are 50 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
      (Term.typeAscription
       "("
       (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " `E)
       ":"
       [(Term.app `Set [(Term.hole "_")])]
       ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Set [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `Set
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Algebra.Group.Defs.¬´term_+·µ•_¬ª (Term.app `u [`p]) " +·µ• " `E)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `E
[PrettyPrinter.parenthesize] ...precedences are 66 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 65, term))
      (Term.app `u [`p])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `p
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `u
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 65 >? 1022, (some 1023, term) <=? (some 65, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 65, (some 66, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 50, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `Nat.Primes
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Classical.¬´tacticBy_cases_:_¬ª
       "by_cases"
       [`h ":"]
       (Term.forall
        "‚àÄ"
        [`p]
        [(Term.typeSpec ":" `Nat.Primes)]
        ","
        (¬´term_‚àß_¬ª
         (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
          (Term.app `A [`p])
          " =·µê["
          `Œº
          "] "
          (Term.typeAscription
           "("
           (¬´term‚àÖ¬ª "‚àÖ")
           ":"
           [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
           ")"))
         "‚àß"
         (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
          (Term.app `B [`p])
          " =·µê["
          `Œº
          "] "
          (Term.typeAscription
           "("
           (¬´term‚àÖ¬ª "‚àÖ")
           ":"
           [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
           ")")))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.forall
       "‚àÄ"
       [`p]
       [(Term.typeSpec ":" `Nat.Primes)]
       ","
       (¬´term_‚àß_¬ª
        (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
         (Term.app `A [`p])
         " =·µê["
         `Œº
         "] "
         (Term.typeAscription
          "("
          (¬´term‚àÖ¬ª "‚àÖ")
          ":"
          [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
          ")"))
        "‚àß"
        (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
         (Term.app `B [`p])
         " =·µê["
         `Œº
         "] "
         (Term.typeAscription
          "("
          (¬´term‚àÖ¬ª "‚àÖ")
          ":"
          [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
          ")"))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (¬´term_‚àß_¬ª
       (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
        (Term.app `A [`p])
        " =·µê["
        `Œº
        "] "
        (Term.typeAscription
         "("
         (¬´term‚àÖ¬ª "‚àÖ")
         ":"
         [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
         ")"))
       "‚àß"
       (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
        (Term.app `B [`p])
        " =·µê["
        `Œº
        "] "
        (Term.typeAscription
         "("
         (¬´term‚àÖ¬ª "‚àÖ")
         ":"
         [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
         ")")))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (MeasureTheory.MeasureTheory.Measure.MeasureSpaceDef.¬´term_=·µê[_]_¬ª
       (Term.app `B [`p])
       " =·µê["
       `Œº
       "] "
       (Term.typeAscription
        "("
        (¬´term‚àÖ¬ª "‚àÖ")
        ":"
        [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
        ")"))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.typeAscription
       "("
       (¬´term‚àÖ¬ª "‚àÖ")
       ":"
       [(Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])]
       ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `Set [(AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'AddCircle.NumberTheory.WellApproximable.termùïä', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'AddCircle.NumberTheory.WellApproximable.termùïä', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (AddCircle.NumberTheory.WellApproximable.termùïä "ùïä")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'AddCircle.NumberTheory.WellApproximable.termùïä', expected 'AddCircle.NumberTheory.WellApproximable.termùïä._@.NumberTheory.WellApproximable._hyg.103'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- *Gallagher's ergodic theorem* on Diophantine approximation. -/
  theorem
    add_well_approximable_ae_empty_or_univ
    ( Œ¥ : ‚Ñï ‚Üí ‚Ñù ) ( hŒ¥ : Tendsto Œ¥ atTop ùìù 0 )
      : ‚àÄ·µê x , ¬¨ addWellApproximable ùïä Œ¥ x ‚à® ‚àÄ·µê x , addWellApproximable ùïä Œ¥ x
    :=
      by
        letI : SemilatticeSup Nat.Primes := Nat.Subtype.semilatticeSup _
          set Œº : Measure ùïä := volume
          set u : Nat.Primes ‚Üí ùïä := fun p => ‚Üë ( ‚Üë ( 1 : ‚Ñï ) : ‚Ñù ) / p * T
          have
            hu‚ÇÄ
              : ‚àÄ p : Nat.Primes , addOrderOf u p = ( p : ‚Ñï )
              :=
              by rintro ‚ü® p , hp ‚ü© exact add_order_of_div_of_gcd_eq_one hp.pos gcd_one_left p
          have
            hu
              : tendsto addOrderOf ‚àò u at_top at_top
              :=
              by
                rw [ ( funext hu‚ÇÄ : addOrderOf ‚àò u = coe ) ]
                  have h_mono : Monotone ( coe : Nat.Primes ‚Üí ‚Ñï ) := fun p q hpq => hpq
                  refine' h_mono.tendsto_at_top_at_top fun n => _
                  obtain ‚ü® p , hp , hp' ‚ü© := n.exists_infinite_primes
                  exact ‚ü® ‚ü® p , hp' ‚ü© , hp ‚ü©
          set E := addWellApproximable ùïä Œ¥
          set X : ‚Ñï ‚Üí Set ùïä := fun n => approxAddOrderOf ùïä n Œ¥ n
          set A : ‚Ñï ‚Üí Set ùïä := fun p => blimsup X at_top fun n => 0 < n ‚àß p ‚à§ n
          set B : ‚Ñï ‚Üí Set ùïä := fun p => blimsup X at_top fun n => 0 < n ‚àß p ‚à£‚à£ n
          set C : ‚Ñï ‚Üí Set ùïä := fun p => blimsup X at_top fun n => 0 < n ‚àß p ^ 2 ‚à£ n
          have
            hA‚ÇÄ
              : ‚àÄ p , MeasurableSet A p
              :=
              fun
                p
                  =>
                  MeasurableSet.measurable_set_blimsup fun n hn => is_open_thickening.measurable_set
          have
            hB‚ÇÄ
              : ‚àÄ p , MeasurableSet B p
              :=
              fun
                p
                  =>
                  MeasurableSet.measurable_set_blimsup fun n hn => is_open_thickening.measurable_set
          have
            hE‚ÇÄ
              : null_measurable_set E Œº
              :=
              by
                refine'
                    MeasurableSet.measurable_set_blimsup fun n hn => IsOpen.measurable_set _
                      .
                      NullMeasurableSet
                  exact is_open_thickening
          have
            hE‚ÇÅ
              : ‚àÄ p , E = A p ‚à™ B p ‚à™ C p
              :=
              by
                intro p
                  simp
                    only
                    [
                      E
                        ,
                        addWellApproximable
                        ,
                        ‚Üê blimsup_or_eq_sup
                        ,
                        ‚Üê and_or_left
                        ,
                        ‚Üê sup_eq_union
                        ,
                        sq
                      ]
                  congr
                  refine' funext fun n => propext <| iff_self_and.mpr fun hn => _
                  simp
                    only
                    [
                      em p ‚à£ n . symm
                        ,
                        em p * p ‚à£ n . symm
                        ,
                        or_and_left
                        ,
                        or_true_iff
                        ,
                        true_and_iff
                        ,
                        or_assoc'
                      ]
          have
            hE‚ÇÇ
              :
                ‚àÄ
                  p
                  : Nat.Primes
                  ,
                  A p =·µê[ Œº ] ( ‚àÖ : Set ùïä ) ‚àß B p =·µê[ Œº ] ( ‚àÖ : Set ùïä ) ‚Üí E =·µê[ Œº ] C p
              :=
              by
                rintro p ‚ü® hA , hB ‚ü©
                  rw [ hE‚ÇÅ p ]
                  exact
                    union_ae_eq_right_of_ae_eq_empty union_ae_eq_right_of_ae_eq_empty hA . trans hB
          have
            hA
              : ‚àÄ p : Nat.Primes , A p =·µê[ Œº ] ( ‚àÖ : Set ùïä ) ‚à® A p =·µê[ Œº ] univ
              :=
              by
                rintro ‚ü® p , hp ‚ü©
                  let f : ùïä ‚Üí ùïä := fun y => ( p : ‚Ñï ) ‚Ä¢ y
                  suffices
                    f '' A p
                        ‚äÜ
                        blimsup fun n => approxAddOrderOf ùïä n p * Œ¥ n at_top fun n => 0 < n ‚àß p ‚à§ n
                      by
                        apply ergodic_nsmul hp.one_lt . ae_empty_or_univ_of_image_ae_le hA‚ÇÄ p
                          apply HasSubset.Subset.eventually_le this . congr eventually_eq.rfl
                          exact
                            blimsup_thickening_mul_ae_eq
                              Œº
                                fun n => 0 < n ‚àß p ‚à§ n
                                fun n => { y | addOrderOf y = n }
                                nat.cast_pos.mpr hp.pos
                                _
                                hŒ¥
                  refine' SupHom.setImage f . apply_blimsup_le . trans mono_blimsup fun n hn => _
                  replace hn := nat.coprime_comm.mp hp.coprime_iff_not_dvd . 2 hn . 2
                  exact approxAddOrderOf.image_nsmul_subset_of_coprime Œ¥ n hp.pos hn
          have
            hB
              : ‚àÄ p : Nat.Primes , B p =·µê[ Œº ] ( ‚àÖ : Set ùïä ) ‚à® B p =·µê[ Œº ] univ
              :=
              by
                rintro ‚ü® p , hp ‚ü©
                  let x := u ‚ü® p , hp ‚ü©
                  let f : ùïä ‚Üí ùïä := fun y => p ‚Ä¢ y + x
                  suffices
                    f '' B p
                        ‚äÜ
                        blimsup fun n => approxAddOrderOf ùïä n p * Œ¥ n at_top fun n => 0 < n ‚àß p ‚à£‚à£ n
                      by
                        apply ergodic_nsmul_add x hp.one_lt . ae_empty_or_univ_of_image_ae_le hB‚ÇÄ p
                          apply HasSubset.Subset.eventually_le this . congr eventually_eq.rfl
                          exact
                            blimsup_thickening_mul_ae_eq
                              Œº
                                fun n => 0 < n ‚àß p ‚à£‚à£ n
                                fun n => { y | addOrderOf y = n }
                                nat.cast_pos.mpr hp.pos
                                _
                                hŒ¥
                  refine' SupHom.setImage f . apply_blimsup_le . trans mono_blimsup _
                  rintro n ‚ü® hn , h_div , h_ndiv ‚ü©
                  have
                    h_cop
                      : addOrderOf x . Coprime n / p
                      :=
                      by
                        obtain ‚ü® q , rfl ‚ü© := h_div
                          rw
                            [
                              hu‚ÇÄ
                                ,
                                Subtype.coe_mk
                                ,
                                hp.coprime_iff_not_dvd
                                ,
                                q.mul_div_cancel_left hp.pos
                              ]
                          exact fun contra => h_ndiv mul_dvd_mul_left p contra
                  replace h_div : n / p * p = n := Nat.div_mul_cancel h_div
                  have hf : f = fun y => x + y ‚àò fun y => p ‚Ä¢ y := by ext simp [ add_comm x ]
                  simp_rw [ comp_app ]
                  rw [ le_eq_subset , SupHom.set_image_to_fun , hf , image_comp ]
                  have := @ monotone_image ùïä ùïä fun y => x + y
                  specialize this approxAddOrderOf.image_nsmul_subset Œ¥ n n / p hp.pos
                  simp only [ h_div ] at this ‚ä¢
                  refine' this.trans _
                  convert approxAddOrderOf.vadd_subset_of_coprime p * Œ¥ n h_cop
                  simp only [ hu‚ÇÄ , Subtype.coe_mk , h_div , mul_comm p ]
          change ‚àÄ·µê x , x ‚àâ E ‚à® E ‚àà volume.ae
          rw [ ‚Üê eventually_eq_empty , ‚Üê eventually_eq_univ ]
          have
            hC
              : ‚àÄ p : Nat.Primes , u p +·µ• C p = C p
              :=
              by
                intro p
                  let e := ( AddAction.toPerm u p : Equiv.Perm ùïä ) . toOrderIsoSet
                  change e C p = C p
                  rw [ e.apply_blimsup , ‚Üê hu‚ÇÄ p ]
                  exact
                    blimsup_congr
                      eventually_of_forall
                        fun n hn => approxAddOrderOf.vadd_eq_of_mul_dvd Œ¥ n hn . 1 hn . 2
          by_cases h : ‚àÄ p : Nat.Primes , A p =·µê[ Œº ] ( ‚àÖ : Set ùïä ) ‚àß B p =·µê[ Œº ] ( ‚àÖ : Set ùïä )
          ¬∑
            replace h : ‚àÄ p : Nat.Primes , ( u p +·µ• E : Set _ ) =·µê[ Œº ] E
              ¬∑
                intro p
                  replace hE‚ÇÇ : E =·µê[ Œº ] C p := hE‚ÇÇ p h p
                  have
                    h_qmp
                      : MeasureTheory.Measure.QuasiMeasurePreserving ( ¬∑ +·µ• ¬∑ ) - u p Œº Œº
                      :=
                      measure_preserving_vadd _ Œº . QuasiMeasurePreserving
                  refine' h_qmp.vadd_ae_eq_of_ae_eq u p hE‚ÇÇ . trans ae_eq_trans _ hE‚ÇÇ.symm
                  rw [ hC ]
              exact ae_empty_or_univ_of_forall_vadd_ae_eq_self hE‚ÇÄ h hu
          ¬∑
            right
              simp only [ not_forall , not_and_or ] at h
              obtain ‚ü® p , hp ‚ü© := h
              rw [ hE‚ÇÅ p ]
              cases hp
              ¬∑ cases hA p ¬∑ contradiction simp only [ h , union_ae_eq_univ_of_ae_eq_univ_left ]
              ¬∑
                cases hB p
                  ¬∑ contradiction
                  simp
                    only
                    [
                      h , union_ae_eq_univ_of_ae_eq_univ_left , union_ae_eq_univ_of_ae_eq_univ_right
                      ]
#align
  add_circle.add_well_approximable_ae_empty_or_univ AddCircle.add_well_approximable_ae_empty_or_univ

end AddCircle

