/-
Copyright (c) 2020 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov

! This file was ported from Lean 3 source module dynamics.circle.rotation_number.translation_number
! leanprover-community/mathlib commit f2ce6086713c78a7f880485f7917ea547a215982
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Hom.Iterate
import Mathbin.Analysis.SpecificLimits.Basic
import Mathbin.Order.Iterate
import Mathbin.Order.SemiconjSup
import Mathbin.Topology.Algebra.Order.MonotoneContinuity

/-!
# Translation number of a monotone real map that commutes with `x ↦ x + 1`

Let `f : ℝ → ℝ` be a monotone map such that `f (x + 1) = f x + 1` for all `x`. Then the limit
$$
  \tau(f)=\lim_{n\to\infty}{f^n(x)-x}{n}
$$
exists and does not depend on `x`. This number is called the *translation number* of `f`.
Different authors use different notation for this number: `τ`, `ρ`, `rot`, etc

In this file we define a structure `circle_deg1_lift` for bundled maps with these properties, define
translation number of `f : circle_deg1_lift`, prove some estimates relating `f^n(x)-x` to `τ(f)`. In
case of a continuous map `f` we also prove that `f` admits a point `x` such that `f^n(x)=x+m` if and
only if `τ(f)=m/n`.

Maps of this type naturally appear as lifts of orientation preserving circle homeomorphisms. More
precisely, let `f` be an orientation preserving homeomorphism of the circle $S^1=ℝ/ℤ$, and
consider a real number `a` such that
`⟦a⟧ = f 0`, where `⟦⟧` means the natural projection `ℝ → ℝ/ℤ`. Then there exists a unique
continuous function `F : ℝ → ℝ` such that `F 0 = a` and `⟦F x⟧ = f ⟦x⟧` for all `x` (this fact is
not formalized yet). This function is strictly monotone, continuous, and satisfies
`F (x + 1) = F x + 1`. The number `⟦τ F⟧ : ℝ / ℤ` is called the *rotation number* of `f`.
It does not depend on the choice of `a`.

## Main definitions

* `circle_deg1_lift`: a monotone map `f : ℝ → ℝ` such that `f (x + 1) = f x + 1` for all `x`;
  the type `circle_deg1_lift` is equipped with `lattice` and `monoid` structures; the
  multiplication is given by composition: `(f * g) x = f (g x)`.
* `circle_deg1_lift.translation_number`: translation number of `f : circle_deg1_lift`.

## Main statements

We prove the following properties of `circle_deg1_lift.translation_number`.

* `circle_deg1_lift.translation_number_eq_of_dist_bounded`: if the distance between `(f^n) 0`
  and `(g^n) 0` is bounded from above uniformly in `n : ℕ`, then `f` and `g` have equal
  translation numbers.

* `circle_deg1_lift.translation_number_eq_of_semiconj_by`: if two `circle_deg1_lift` maps `f`, `g`
  are semiconjugate by a `circle_deg1_lift` map, then `τ f = τ g`.

* `circle_deg1_lift.translation_number_units_inv`: if `f` is an invertible `circle_deg1_lift` map
  (equivalently, `f` is a lift of an orientation-preserving circle homeomorphism), then
  the translation number of `f⁻¹` is the negative of the translation number of `f`.

* `circle_deg1_lift.translation_number_mul_of_commute`: if `f` and `g` commute, then
  `τ (f * g) = τ f + τ g`.

* `circle_deg1_lift.translation_number_eq_rat_iff`: the translation number of `f` is equal to
  a rational number `m / n` if and only if `(f^n) x = x + m` for some `x`.

* `circle_deg1_lift.semiconj_of_bijective_of_translation_number_eq`: if `f` and `g` are two
  bijective `circle_deg1_lift` maps and their translation numbers are equal, then these
  maps are semiconjugate to each other.

* `circle_deg1_lift.semiconj_of_group_action_of_forall_translation_number_eq`: let `f₁` and `f₂` be
  two actions of a group `G` on the circle by degree 1 maps (formally, `f₁` and `f₂` are two
  homomorphisms from `G →* circle_deg1_lift`). If the translation numbers of `f₁ g` and `f₂ g` are
  equal to each other for all `g : G`, then these two actions are semiconjugate by some `F :
  circle_deg1_lift`. This is a version of Proposition 5.4 from [Étienne Ghys, Groupes
  d'homeomorphismes du cercle et cohomologie bornee][ghys87:groupes].

## Notation

We use a local notation `τ` for the translation number of `f : circle_deg1_lift`.

## Implementation notes

We define the translation number of `f : circle_deg1_lift` to be the limit of the sequence
`(f ^ (2 ^ n)) 0 / (2 ^ n)`, then prove that `((f ^ n) x - x) / n` tends to this number for any `x`.
This way it is much easier to prove that the limit exists and basic properties of the limit.

We define translation number for a wider class of maps `f : ℝ → ℝ` instead of lifts of orientation
preserving circle homeomorphisms for two reasons:

* non-strictly monotone circle self-maps with discontinuities naturally appear as Poincaré maps
  for some flows on the two-torus (e.g., one can take a constant flow and glue in a few Cherry
  cells);
* definition and some basic properties still work for this class.

## References

* [Étienne Ghys, Groupes d'homeomorphismes du cercle et cohomologie bornee][ghys87:groupes]

## TODO

Here are some short-term goals.

* Introduce a structure or a typeclass for lifts of circle homeomorphisms. We use `units
  circle_deg1_lift` for now, but it's better to have a dedicated type (or a typeclass?).

* Prove that the `semiconj_by` relation on circle homeomorphisms is an equivalence relation.

* Introduce `conditionally_complete_lattice` structure, use it in the proof of
  `circle_deg1_lift.semiconj_of_group_action_of_forall_translation_number_eq`.

* Prove that the orbits of the irrational rotation are dense in the circle. Deduce that a
  homeomorphism with an irrational rotation is semiconjugate to the corresponding irrational
  translation by a continuous `circle_deg1_lift`.

## Tags

circle homeomorphism, rotation number
-/


open Filter Set

open Function hiding Commute

open Int

open Topology Classical

/-!
### Definition and monoid structure
-/


#print CircleDeg1Lift /-
/-- A lift of a monotone degree one map `S¹ → S¹`. -/
structure CircleDeg1Lift : Type where
  toFun : ℝ → ℝ
  monotone' : Monotone to_fun
  map_add_one' : ∀ x, to_fun (x + 1) = to_fun x + 1
#align circle_deg1_lift CircleDeg1Lift
-/

namespace CircleDeg1Lift

instance : CoeFun CircleDeg1Lift fun _ => ℝ → ℝ :=
  ⟨CircleDeg1Lift.toFun⟩

/- warning: circle_deg1_lift.coe_mk -> CircleDeg1Lift.coe_mk is a dubious translation:
lean 3 declaration is
  forall (f : Real -> Real) (h₁ : Monotone.{0, 0} Real Real Real.preorder Real.preorder f) (h₂ : forall (x : Real), Eq.{1} Real (f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (f x) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))), Eq.{1} (Real -> Real) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (CircleDeg1Lift.mk f h₁ h₂)) f
but is expected to have type
  forall (f : OrderHom.{0, 0} Real Real Real.instPreorderReal Real.instPreorderReal) (h₁ : forall (x : Real), Eq.{1} Real (OrderHom.toFun.{0, 0} Real Real Real.instPreorderReal Real.instPreorderReal f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (OrderHom.toFun.{0, 0} Real Real Real.instPreorderReal Real.instPreorderReal f x) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))), Eq.{1} (forall (a : Real), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (CircleDeg1Lift.mk f h₁)) (OrderHom.toFun.{0, 0} Real Real Real.instPreorderReal Real.instPreorderReal f)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.coe_mk CircleDeg1Lift.coe_mkₓ'. -/
@[simp]
theorem coe_mk (f h₁ h₂) : ⇑(mk f h₁ h₂) = f :=
  rfl
#align circle_deg1_lift.coe_mk CircleDeg1Lift.coe_mk

variable (f g : CircleDeg1Lift)

/- warning: circle_deg1_lift.monotone -> CircleDeg1Lift.monotone is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), Monotone.{0, 0} Real Real Real.preorder Real.preorder (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f)
but is expected to have type
  forall (f : CircleDeg1Lift), Monotone.{0, 0} Real Real Real.instPreorderReal Real.instPreorderReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.monotone CircleDeg1Lift.monotoneₓ'. -/
protected theorem monotone : Monotone f :=
  f.monotone'
#align circle_deg1_lift.monotone CircleDeg1Lift.monotone

/- warning: circle_deg1_lift.mono -> CircleDeg1Lift.mono is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {y : Real}, (LE.le.{0} Real Real.hasLe x y) -> (LE.le.{0} Real Real.hasLe (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f y))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {y : Real}, (LE.le.{0} Real Real.instLEReal x y) -> (LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLEReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f y))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.mono CircleDeg1Lift.monoₓ'. -/
@[mono]
theorem mono {x y} (h : x ≤ y) : f x ≤ f y :=
  f.Monotone h
#align circle_deg1_lift.mono CircleDeg1Lift.mono

/- warning: circle_deg1_lift.strict_mono_iff_injective -> CircleDeg1Lift.strictMono_iff_injective is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), Iff (StrictMono.{0, 0} Real Real Real.preorder Real.preorder (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f)) (Function.Injective.{1, 1} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f))
but is expected to have type
  forall (f : CircleDeg1Lift), Iff (StrictMono.{0, 0} Real Real Real.instPreorderReal Real.instPreorderReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f)) (Function.Injective.{1, 1} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.strict_mono_iff_injective CircleDeg1Lift.strictMono_iff_injectiveₓ'. -/
theorem strictMono_iff_injective : StrictMono f ↔ Injective f :=
  f.Monotone.strictMono_iff_injective
#align circle_deg1_lift.strict_mono_iff_injective CircleDeg1Lift.strictMono_iff_injective

/- warning: circle_deg1_lift.map_add_one -> CircleDeg1Lift.map_add_one is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_add_one CircleDeg1Lift.map_add_oneₓ'. -/
@[simp]
theorem map_add_one : ∀ x, f (x + 1) = f x + 1 :=
  f.map_add_one'
#align circle_deg1_lift.map_add_one CircleDeg1Lift.map_add_one

/- warning: circle_deg1_lift.map_one_add -> CircleDeg1Lift.map_one_add is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) x)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) x)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) x)) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) x)) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) x)) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) x)) Real.instAddReal) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) x)) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) x)) Real.instOneReal)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_one_add CircleDeg1Lift.map_one_addₓ'. -/
@[simp]
theorem map_one_add (x : ℝ) : f (1 + x) = 1 + f x := by rw [add_comm, map_add_one, add_comm]
#align circle_deg1_lift.map_one_add CircleDeg1Lift.map_one_add

/- warning: circle_deg1_lift.coe_inj clashes with [anonymous] -> [anonymous]
warning: circle_deg1_lift.coe_inj -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {{f : CircleDeg1Lift}} {{g : CircleDeg1Lift}}, (Eq.{1} ((fun (_x : CircleDeg1Lift) => Real -> Real) f) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g)) -> (Eq.{1} CircleDeg1Lift f g)
but is expected to have type
  forall {f : Type.{u}} {g : Type.{v}}, (Nat -> f -> g) -> Nat -> (List.{u} f) -> (List.{v} g)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.coe_inj [anonymous]ₓ'. -/
theorem [anonymous] : ∀ ⦃f g : CircleDeg1Lift⦄, (f : ℝ → ℝ) = g → f = g :=
  fun ⟨f, fm, fd⟩ ⟨g, gm, gd⟩ h => by congr <;> exact h
#align circle_deg1_lift.coe_inj [anonymous]

/- warning: circle_deg1_lift.ext -> CircleDeg1Lift.ext is a dubious translation:
lean 3 declaration is
  forall {{f : CircleDeg1Lift}} {{g : CircleDeg1Lift}}, (forall (x : Real), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g x)) -> (Eq.{1} CircleDeg1Lift f g)
but is expected to have type
  forall {{f : CircleDeg1Lift}} {{g : CircleDeg1Lift}}, (forall (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g x)) -> (Eq.{1} CircleDeg1Lift f g)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.ext CircleDeg1Lift.extₓ'. -/
@[ext]
theorem ext ⦃f g : CircleDeg1Lift⦄ (h : ∀ x, f x = g x) : f = g :=
  [anonymous] <| funext h
#align circle_deg1_lift.ext CircleDeg1Lift.ext

/- warning: circle_deg1_lift.ext_iff -> CircleDeg1Lift.ext_iff is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, Iff (Eq.{1} CircleDeg1Lift f g) (forall (x : Real), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g x))
but is expected to have type
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, Iff (Eq.{1} CircleDeg1Lift f g) (forall (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.ext_iff CircleDeg1Lift.ext_iffₓ'. -/
theorem ext_iff {f g : CircleDeg1Lift} : f = g ↔ ∀ x, f x = g x :=
  ⟨fun h x => h ▸ rfl, fun h => ext h⟩
#align circle_deg1_lift.ext_iff CircleDeg1Lift.ext_iff

instance : Monoid CircleDeg1Lift
    where
  mul f g :=
    { toFun := f ∘ g
      monotone' := f.Monotone.comp g.Monotone
      map_add_one' := fun x => by simp [map_add_one] }
  one := ⟨id, monotone_id, fun _ => rfl⟩
  mul_one f := [anonymous] <| Function.comp.right_id f
  one_mul f := [anonymous] <| Function.comp.left_id f
  mul_assoc f₁ f₂ f₃ := [anonymous] rfl

instance : Inhabited CircleDeg1Lift :=
  ⟨1⟩

/- warning: circle_deg1_lift.coe_mul -> CircleDeg1Lift.coe_mul is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), Eq.{1} (Real -> Real) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid))) f g)) (Function.comp.{1, 1, 1} Real Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), Eq.{1} (forall (ᾰ : Real), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) ᾰ) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift))) f g)) (Function.comp.{1, 1, 1} Real Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.coe_mul CircleDeg1Lift.coe_mulₓ'. -/
@[simp]
theorem coe_mul : ⇑(f * g) = f ∘ g :=
  rfl
#align circle_deg1_lift.coe_mul CircleDeg1Lift.coe_mul

/- warning: circle_deg1_lift.mul_apply -> CircleDeg1Lift.mul_apply is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift) (x : Real), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid))) f g) x) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g x))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift))) f g) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.mul_apply CircleDeg1Lift.mul_applyₓ'. -/
theorem mul_apply (x) : (f * g) x = f (g x) :=
  rfl
#align circle_deg1_lift.mul_apply CircleDeg1Lift.mul_apply

/- warning: circle_deg1_lift.coe_one -> CircleDeg1Lift.coe_one is a dubious translation:
lean 3 declaration is
  Eq.{1} (Real -> Real) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (OfNat.ofNat.{0} CircleDeg1Lift 1 (OfNat.mk.{0} CircleDeg1Lift 1 (One.one.{0} CircleDeg1Lift (MulOneClass.toHasOne.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))))) (id.{1} Real)
but is expected to have type
  Eq.{1} (forall (ᾰ : Real), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) ᾰ) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (OfNat.ofNat.{0} CircleDeg1Lift 1 (One.toOfNat1.{0} CircleDeg1Lift (Monoid.toOne.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) (id.{1} Real)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.coe_one CircleDeg1Lift.coe_oneₓ'. -/
@[simp]
theorem coe_one : ⇑(1 : CircleDeg1Lift) = id :=
  rfl
#align circle_deg1_lift.coe_one CircleDeg1Lift.coe_one

/- warning: circle_deg1_lift.units_has_coe_to_fun -> CircleDeg1Lift.unitsHasCoeToFun is a dubious translation:
lean 3 declaration is
  CoeFun.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real)
but is expected to have type
  CoeFun.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => Real -> Real)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.units_has_coe_to_fun CircleDeg1Lift.unitsHasCoeToFunₓ'. -/
instance unitsHasCoeToFun : CoeFun CircleDeg1Liftˣ fun _ => ℝ → ℝ :=
  ⟨fun f => ⇑(f : CircleDeg1Lift)⟩
#align circle_deg1_lift.units_has_coe_to_fun CircleDeg1Lift.unitsHasCoeToFun

/- warning: circle_deg1_lift.units_coe clashes with [anonymous] -> [anonymous]
warning: circle_deg1_lift.units_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid), Eq.{1} (Real -> Real) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) f)) (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun f)
but is expected to have type
  forall {f : Type.{u}} {β : Type.{v}}, (Nat -> f -> β) -> Nat -> (List.{u} f) -> (List.{v} β)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.units_coe [anonymous]ₓ'. -/
@[simp, norm_cast]
theorem [anonymous] (f : CircleDeg1Liftˣ) : ⇑(f : CircleDeg1Lift) = f :=
  rfl
#align circle_deg1_lift.units_coe [anonymous]

/- warning: circle_deg1_lift.units_inv_apply_apply -> CircleDeg1Lift.units_inv_apply_apply is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (x : Real), Eq.{1} Real (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.hasInv.{0} CircleDeg1Lift CircleDeg1Lift.monoid) f) (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun f x)) x
but is expected to have type
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f) x)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instInvUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) f)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f) x)) x
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.units_inv_apply_apply CircleDeg1Lift.units_inv_apply_applyₓ'. -/
@[simp]
theorem units_inv_apply_apply (f : CircleDeg1Liftˣ) (x : ℝ) : (f⁻¹ : CircleDeg1Liftˣ) (f x) = x :=
  by simp only [← units_coe, ← mul_apply, f.inv_mul, coe_one, id]
#align circle_deg1_lift.units_inv_apply_apply CircleDeg1Lift.units_inv_apply_apply

/- warning: circle_deg1_lift.units_apply_inv_apply -> CircleDeg1Lift.units_apply_inv_apply is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (x : Real), Eq.{1} Real (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun f (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.hasInv.{0} CircleDeg1Lift CircleDeg1Lift.monoid) f) x)) x
but is expected to have type
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instInvUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) f)) x)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instInvUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) f)) x)) x
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.units_apply_inv_apply CircleDeg1Lift.units_apply_inv_applyₓ'. -/
@[simp]
theorem units_apply_inv_apply (f : CircleDeg1Liftˣ) (x : ℝ) : f ((f⁻¹ : CircleDeg1Liftˣ) x) = x :=
  by simp only [← units_coe, ← mul_apply, f.mul_inv, coe_one, id]
#align circle_deg1_lift.units_apply_inv_apply CircleDeg1Lift.units_apply_inv_apply

/- warning: circle_deg1_lift.to_order_iso -> CircleDeg1Lift.toOrderIso is a dubious translation:
lean 3 declaration is
  MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))
but is expected to have type
  MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.to_order_iso CircleDeg1Lift.toOrderIsoₓ'. -/
/-- If a lift of a circle map is bijective, then it is an order automorphism of the line. -/
def toOrderIso : CircleDeg1Liftˣ →* ℝ ≃o ℝ
    where
  toFun f :=
    { toFun := f
      invFun := ⇑f⁻¹
      left_inv := units_inv_apply_apply f
      right_inv := units_apply_inv_apply f
      map_rel_iff' := fun x y => ⟨fun h => by simpa using mono (↑f⁻¹) h, mono f⟩ }
  map_one' := rfl
  map_mul' f g := rfl
#align circle_deg1_lift.to_order_iso CircleDeg1Lift.toOrderIso

/- warning: circle_deg1_lift.coe_to_order_iso -> CircleDeg1Lift.coe_toOrderIso is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid), Eq.{1} (Real -> Real) (coeFn.{1, 1} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (fun (_x : RelIso.{0, 0} Real Real (LE.le.{0} Real Real.hasLe) (LE.le.{0} Real Real.hasLe)) => Real -> Real) (RelIso.hasCoeToFun.{0, 0} Real Real (LE.le.{0} Real Real.hasLe) (LE.le.{0} Real Real.hasLe)) (coeFn.{1, 1} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))) (fun (_x : MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))) => (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) -> (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe)) (MonoidHom.hasCoeToFun.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))) CircleDeg1Lift.toOrderIso f)) (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun f)
but is expected to have type
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift), Eq.{1} (forall (ᾰ : Real), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Real) => Real) ᾰ) (FunLike.coe.{1, 1, 1} (Function.Embedding.{1, 1} Real Real) Real (fun (_x : Real) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Real) => Real) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Function.Embedding.{1, 1} Real Real) Real Real (Function.instEmbeddingLikeEmbedding.{1, 1} Real Real)) (RelEmbedding.toEmbedding.{0, 0} Real Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{0, 0} Real Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (fun (a : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) a) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MulOneClass.toMul.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283))))) (MonoidHom.monoidHomClass.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))))) CircleDeg1Lift.toOrderIso f)))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.coe_to_order_iso CircleDeg1Lift.coe_toOrderIsoₓ'. -/
@[simp]
theorem coe_toOrderIso (f : CircleDeg1Liftˣ) : ⇑(toOrderIso f) = f :=
  rfl
#align circle_deg1_lift.coe_to_order_iso CircleDeg1Lift.coe_toOrderIso

/- warning: circle_deg1_lift.coe_to_order_iso_symm -> CircleDeg1Lift.coe_toOrderIso_symm is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid), Eq.{1} (Real -> Real) (coeFn.{1, 1} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (fun (_x : RelIso.{0, 0} Real Real (LE.le.{0} Real Real.hasLe) (LE.le.{0} Real Real.hasLe)) => Real -> Real) (RelIso.hasCoeToFun.{0, 0} Real Real (LE.le.{0} Real Real.hasLe) (LE.le.{0} Real Real.hasLe)) (OrderIso.symm.{0, 0} Real Real Real.hasLe Real.hasLe (coeFn.{1, 1} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))) (fun (_x : MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))) => (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) -> (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe)) (MonoidHom.hasCoeToFun.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))) CircleDeg1Lift.toOrderIso f))) (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.hasInv.{0} CircleDeg1Lift CircleDeg1Lift.monoid) f))
but is expected to have type
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift), Eq.{1} (forall (ᾰ : Real), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Real) => Real) ᾰ) (FunLike.coe.{1, 1, 1} (Function.Embedding.{1, 1} Real Real) Real (fun (_x : Real) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Real) => Real) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Function.Embedding.{1, 1} Real Real) Real Real (Function.instEmbeddingLikeEmbedding.{1, 1} Real Real)) (RelEmbedding.toEmbedding.{0, 0} Real Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{0, 0} Real Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (OrderIso.symm.{0, 0} Real Real Real.instLEReal Real.instLEReal (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (fun (a : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) a) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MulOneClass.toMul.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283))))) (MonoidHom.monoidHomClass.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))))) CircleDeg1Lift.toOrderIso f))))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instInvUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) f)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.coe_to_order_iso_symm CircleDeg1Lift.coe_toOrderIso_symmₓ'. -/
@[simp]
theorem coe_toOrderIso_symm (f : CircleDeg1Liftˣ) :
    ⇑(toOrderIso f).symm = (f⁻¹ : CircleDeg1Liftˣ) :=
  rfl
#align circle_deg1_lift.coe_to_order_iso_symm CircleDeg1Lift.coe_toOrderIso_symm

/- warning: circle_deg1_lift.coe_to_order_iso_inv -> CircleDeg1Lift.coe_toOrderIso_inv is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid), Eq.{1} (Real -> Real) (coeFn.{1, 1} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (fun (_x : RelIso.{0, 0} Real Real (LE.le.{0} Real Real.hasLe) (LE.le.{0} Real Real.hasLe)) => Real -> Real) (RelIso.hasCoeToFun.{0, 0} Real Real (LE.le.{0} Real Real.hasLe) (LE.le.{0} Real Real.hasLe)) (Inv.inv.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toHasInv.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))) (coeFn.{1, 1} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))) (fun (_x : MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))) => (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) -> (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe)) (MonoidHom.hasCoeToFun.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.hasLe Real.hasLe) (RelIso.group.{0} Real (LE.le.{0} Real Real.hasLe)))))) CircleDeg1Lift.toOrderIso f))) (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.hasInv.{0} CircleDeg1Lift CircleDeg1Lift.monoid) f))
but is expected to have type
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift), Eq.{1} (forall (ᾰ : Real), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Real) => Real) ᾰ) (FunLike.coe.{1, 1, 1} (Function.Embedding.{1, 1} Real Real) Real (fun (_x : Real) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Real) => Real) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Function.Embedding.{1, 1} Real Real) Real Real (Function.instEmbeddingLikeEmbedding.{1, 1} Real Real)) (RelEmbedding.toEmbedding.{0, 0} Real Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.toRelEmbedding.{0, 0} Real Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (Inv.inv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) f) (InvOneClass.toInv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) f) (DivInvOneMonoid.toInvOneClass.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) f) (DivisionMonoid.toDivInvOneMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) f) (Group.toDivisionMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) f) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (fun (a : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) => OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) a) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MulOneClass.toMul.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283))))) (MonoidHom.monoidHomClass.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Monoid.toMulOneClass.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (DivInvMonoid.toMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (Group.toDivInvMonoid.{0} (OrderIso.{0, 0} Real Real Real.instLEReal Real.instLEReal) (RelIso.instGroupRelIso.{0} Real (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : Real) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : Real) => LE.le.{0} Real Real.instLEReal x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283)))))))) CircleDeg1Lift.toOrderIso f))))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instInvUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) f)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.coe_to_order_iso_inv CircleDeg1Lift.coe_toOrderIso_invₓ'. -/
@[simp]
theorem coe_toOrderIso_inv (f : CircleDeg1Liftˣ) : ⇑(toOrderIso f)⁻¹ = (f⁻¹ : CircleDeg1Liftˣ) :=
  rfl
#align circle_deg1_lift.coe_to_order_iso_inv CircleDeg1Lift.coe_toOrderIso_inv

/- warning: circle_deg1_lift.is_unit_iff_bijective -> CircleDeg1Lift.isUnit_iff_bijective is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift}, Iff (IsUnit.{0} CircleDeg1Lift CircleDeg1Lift.monoid f) (Function.Bijective.{1, 1} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f))
but is expected to have type
  forall {f : CircleDeg1Lift}, Iff (IsUnit.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f) (Function.Bijective.{1, 1} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.is_unit_iff_bijective CircleDeg1Lift.isUnit_iff_bijectiveₓ'. -/
theorem isUnit_iff_bijective {f : CircleDeg1Lift} : IsUnit f ↔ Bijective f :=
  ⟨fun ⟨u, h⟩ => h ▸ (toOrderIso u).Bijective, fun h =>
    Units.isUnit
      { val := f
        inv :=
          { toFun := (Equiv.ofBijective f h).symm
            monotone' := fun x y hxy =>
              (f.strictMono_iff_injective.2 h.1).le_iff_le.1
                (by simp only [Equiv.ofBijective_apply_symm_apply f h, hxy])
            map_add_one' := fun x =>
              h.1 <| by simp only [Equiv.ofBijective_apply_symm_apply f, f.map_add_one] }
        val_inv := ext <| Equiv.ofBijective_apply_symm_apply f h
        inv_val := ext <| Equiv.ofBijective_symm_apply_apply f h }⟩
#align circle_deg1_lift.is_unit_iff_bijective CircleDeg1Lift.isUnit_iff_bijective

/- warning: circle_deg1_lift.coe_pow -> CircleDeg1Lift.coe_pow is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Nat), Eq.{1} (Real -> Real) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n)) (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n)
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Nat), Eq.{1} (forall (ᾰ : Real), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) ᾰ) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n)) (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.coe_pow CircleDeg1Lift.coe_powₓ'. -/
theorem coe_pow : ∀ n : ℕ, ⇑(f ^ n) = f^[n]
  | 0 => rfl
  | n + 1 => by
    ext x
    simp [coe_pow n, pow_succ']
#align circle_deg1_lift.coe_pow CircleDeg1Lift.coe_pow

/- warning: circle_deg1_lift.semiconj_by_iff_semiconj -> CircleDeg1Lift.semiconjBy_iff_semiconj is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, Iff (SemiconjBy.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f g₁ g₂) (Function.Semiconj.{0, 0} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₁) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₂))
but is expected to have type
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, Iff (SemiconjBy.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f g₁ g₂) (Function.Semiconj.{0, 0} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₁) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₂))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.semiconj_by_iff_semiconj CircleDeg1Lift.semiconjBy_iff_semiconjₓ'. -/
theorem semiconjBy_iff_semiconj {f g₁ g₂ : CircleDeg1Lift} :
    SemiconjBy f g₁ g₂ ↔ Semiconj f g₁ g₂ :=
  ext_iff
#align circle_deg1_lift.semiconj_by_iff_semiconj CircleDeg1Lift.semiconjBy_iff_semiconj

/- warning: circle_deg1_lift.commute_iff_commute -> CircleDeg1Lift.commute_iff_commute is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, Iff (Commute.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f g) (Function.Commute.{0} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g))
but is expected to have type
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, Iff (Commute.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f g) (Function.Commute.{0} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.commute_iff_commute CircleDeg1Lift.commute_iff_commuteₓ'. -/
theorem commute_iff_commute {f g : CircleDeg1Lift} : Commute f g ↔ Function.Commute f g :=
  ext_iff
#align circle_deg1_lift.commute_iff_commute CircleDeg1Lift.commute_iff_commute

/-!
### Translate by a constant
-/


/- warning: circle_deg1_lift.translate -> CircleDeg1Lift.translate is a dubious translation:
lean 3 declaration is
  MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)
but is expected to have type
  MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translate CircleDeg1Lift.translateₓ'. -/
/-- The map `y ↦ x + y` as a `circle_deg1_lift`. More precisely, we define a homomorphism from
`multiplicative ℝ` to `circle_deg1_liftˣ`, so the translation by `x` is
`translation (multiplicative.of_add x)`. -/
def translate : Multiplicative ℝ →* CircleDeg1Liftˣ := by
  refine' (Units.map _).comp to_units.to_monoid_hom <;>
    exact
      { toFun := fun x =>
          ⟨fun y => x.toAdd + y, fun y₁ y₂ h => add_le_add_left h _, fun y =>
            (add_assoc _ _ _).symm⟩
        map_one' := ext <| zero_add
        map_mul' := fun x y => ext <| add_assoc _ _ }
#align circle_deg1_lift.translate CircleDeg1Lift.translate

/- warning: circle_deg1_lift.translate_apply -> CircleDeg1Lift.translate_apply is a dubious translation:
lean 3 declaration is
  forall (x : Real) (y : Real), Eq.{1} Real (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun (coeFn.{1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => (Multiplicative.{0} Real) -> (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) CircleDeg1Lift.translate (coeFn.{1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) (fun (_x : Equiv.{1, 1} Real (Multiplicative.{0} Real)) => Real -> (Multiplicative.{0} Real)) (Equiv.hasCoeToFun.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) y) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x y)
but is expected to have type
  forall (x : Real) (y : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) y) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (fun (_x : Multiplicative.{0} Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MulOneClass.toMul.{0} (Multiplicative.{0} Real) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal))) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) CircleDeg1Lift.translate (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x))) y) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x y)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translate_apply CircleDeg1Lift.translate_applyₓ'. -/
@[simp]
theorem translate_apply (x y : ℝ) : translate (Multiplicative.ofAdd x) y = x + y :=
  rfl
#align circle_deg1_lift.translate_apply CircleDeg1Lift.translate_apply

/- warning: circle_deg1_lift.translate_inv_apply -> CircleDeg1Lift.translate_inv_apply is a dubious translation:
lean 3 declaration is
  forall (x : Real) (y : Real), Eq.{1} Real (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.hasInv.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (coeFn.{1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => (Multiplicative.{0} Real) -> (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) CircleDeg1Lift.translate (coeFn.{1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) (fun (_x : Equiv.{1, 1} Real (Multiplicative.{0} Real)) => Real -> (Multiplicative.{0} Real)) (Equiv.hasCoeToFun.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x))) y) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Neg.neg.{0} Real Real.hasNeg x) y)
but is expected to have type
  forall (x : Real) (y : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) y) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (Inv.inv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (Units.instInvUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (fun (_x : Multiplicative.{0} Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MulOneClass.toMul.{0} (Multiplicative.{0} Real) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal))) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) CircleDeg1Lift.translate (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)))) y) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Neg.neg.{0} Real Real.instNegReal x) y)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translate_inv_apply CircleDeg1Lift.translate_inv_applyₓ'. -/
@[simp]
theorem translate_inv_apply (x y : ℝ) : (translate <| Multiplicative.ofAdd x)⁻¹ y = -x + y :=
  rfl
#align circle_deg1_lift.translate_inv_apply CircleDeg1Lift.translate_inv_apply

/- warning: circle_deg1_lift.translate_zpow -> CircleDeg1Lift.translate_zpow is a dubious translation:
lean 3 declaration is
  forall (x : Real) (n : Int), Eq.{1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (HPow.hPow.{0, 0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) Int (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (instHPow.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) Int (DivInvMonoid.Pow.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Group.toDivInvMonoid.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.group.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) (coeFn.{1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => (Multiplicative.{0} Real) -> (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) CircleDeg1Lift.translate (coeFn.{1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) (fun (_x : Equiv.{1, 1} Real (Multiplicative.{0} Real)) => Real -> (Multiplicative.{0} Real)) (Equiv.hasCoeToFun.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) n) (coeFn.{1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => (Multiplicative.{0} Real) -> (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) CircleDeg1Lift.translate (coeFn.{1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) (fun (_x : Equiv.{1, 1} Real (Multiplicative.{0} Real)) => Real -> (Multiplicative.{0} Real)) (Equiv.hasCoeToFun.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n) x)))
but is expected to have type
  forall (x : Real) (n : Int), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) Int ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) Int (DivInvMonoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (Group.toDivInvMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (Units.instGroupUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (fun (_x : Multiplicative.{0} Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MulOneClass.toMul.{0} (Multiplicative.{0} Real) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal))) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) CircleDeg1Lift.translate (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (_x : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) _x) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) n) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (fun (_x : Multiplicative.{0} Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MulOneClass.toMul.{0} (Multiplicative.{0} Real) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal))) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) CircleDeg1Lift.translate (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (_x : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) _x) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Int.cast.{0} Real Real.intCast n) x)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translate_zpow CircleDeg1Lift.translate_zpowₓ'. -/
@[simp]
theorem translate_zpow (x : ℝ) (n : ℤ) :
    translate (Multiplicative.ofAdd x) ^ n = translate (Multiplicative.ofAdd <| ↑n * x) := by
  simp only [← zsmul_eq_mul, ofAdd_zsmul, MonoidHom.map_zpow]
#align circle_deg1_lift.translate_zpow CircleDeg1Lift.translate_zpow

/- warning: circle_deg1_lift.translate_pow -> CircleDeg1Lift.translate_pow is a dubious translation:
lean 3 declaration is
  forall (x : Real) (n : Nat), Eq.{1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (HPow.hPow.{0, 0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) Nat (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (instHPow.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) Nat (Monoid.Pow.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (DivInvMonoid.toMonoid.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Group.toDivInvMonoid.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.group.{0} CircleDeg1Lift CircleDeg1Lift.monoid))))) (coeFn.{1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => (Multiplicative.{0} Real) -> (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) CircleDeg1Lift.translate (coeFn.{1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) (fun (_x : Equiv.{1, 1} Real (Multiplicative.{0} Real)) => Real -> (Multiplicative.{0} Real)) (Equiv.hasCoeToFun.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) n) (coeFn.{1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => (Multiplicative.{0} Real) -> (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) CircleDeg1Lift.translate (coeFn.{1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) (fun (_x : Equiv.{1, 1} Real (Multiplicative.{0} Real)) => Real -> (Multiplicative.{0} Real)) (Equiv.hasCoeToFun.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) x)))
but is expected to have type
  forall (x : Real) (n : Nat), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) Nat (Monoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (DivInvMonoid.toMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (Group.toDivInvMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) (Units.instGroupUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift))))) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (fun (_x : Multiplicative.{0} Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MulOneClass.toMul.{0} (Multiplicative.{0} Real) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal))) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) CircleDeg1Lift.translate (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (_x : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) _x) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)) n) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (fun (_x : Multiplicative.{0} Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MulOneClass.toMul.{0} (Multiplicative.{0} Real) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal))) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) CircleDeg1Lift.translate (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (_x : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) _x) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) x)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translate_pow CircleDeg1Lift.translate_powₓ'. -/
@[simp]
theorem translate_pow (x : ℝ) (n : ℕ) :
    translate (Multiplicative.ofAdd x) ^ n = translate (Multiplicative.ofAdd <| ↑n * x) :=
  translate_zpow x n
#align circle_deg1_lift.translate_pow CircleDeg1Lift.translate_pow

/- warning: circle_deg1_lift.translate_iterate -> CircleDeg1Lift.translate_iterate is a dubious translation:
lean 3 declaration is
  forall (x : Real) (n : Nat), Eq.{1} (Real -> Real) (Nat.iterate.{1} Real (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun (coeFn.{1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => (Multiplicative.{0} Real) -> (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) CircleDeg1Lift.translate (coeFn.{1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) (fun (_x : Equiv.{1, 1} Real (Multiplicative.{0} Real)) => Real -> (Multiplicative.{0} Real)) (Equiv.hasCoeToFun.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x))) n) (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun (coeFn.{1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => (Multiplicative.{0} Real) -> (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) CircleDeg1Lift.translate (coeFn.{1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) (fun (_x : Equiv.{1, 1} Real (Multiplicative.{0} Real)) => Real -> (Multiplicative.{0} Real)) (Equiv.hasCoeToFun.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) x))))
but is expected to have type
  forall (x : Real) (n : Nat), Eq.{1} (Real -> Real) (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (fun (_x : Multiplicative.{0} Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MulOneClass.toMul.{0} (Multiplicative.{0} Real) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal))) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) CircleDeg1Lift.translate (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)))) n) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (fun (_x : Multiplicative.{0} Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MulOneClass.toMul.{0} (Multiplicative.{0} Real) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal))) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) CircleDeg1Lift.translate (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (a : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) a) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) x)))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translate_iterate CircleDeg1Lift.translate_iterateₓ'. -/
@[simp]
theorem translate_iterate (x : ℝ) (n : ℕ) :
    translate (Multiplicative.ofAdd x)^[n] = translate (Multiplicative.ofAdd <| ↑n * x) := by
  rw [← units_coe, ← coe_pow, ← Units.val_pow_eq_pow_val, translate_pow, units_coe]
#align circle_deg1_lift.translate_iterate CircleDeg1Lift.translate_iterate

/-!
### Commutativity with integer translations

In this section we prove that `f` commutes with translations by an integer number.
First we formulate these statements (for a natural or an integer number,
addition on the left or on the right, addition or subtraction) using `function.commute`,
then reformulate as `simp` lemmas `map_int_add` etc.
-/


/- warning: circle_deg1_lift.commute_nat_add -> CircleDeg1Lift.commute_nat_add is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Nat), Function.Commute.{0} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Nat), Function.Commute.{0} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (fun (x._@.Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber._hyg.1529 : Real) => HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) x._@.Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber._hyg.1529)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.commute_nat_add CircleDeg1Lift.commute_nat_addₓ'. -/
theorem commute_nat_add (n : ℕ) : Function.Commute f ((· + ·) n) := by
  simpa only [nsmul_one, add_left_iterate] using Function.Commute.iterate_right f.map_one_add n
#align circle_deg1_lift.commute_nat_add CircleDeg1Lift.commute_nat_add

/- warning: circle_deg1_lift.commute_add_nat -> CircleDeg1Lift.commute_add_nat is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Nat), Function.Commute.{0} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (fun (x : Real) => HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Nat), Function.Commute.{0} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (fun (x : Real) => HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Nat.cast.{0} Real Real.natCast n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.commute_add_nat CircleDeg1Lift.commute_add_natₓ'. -/
theorem commute_add_nat (n : ℕ) : Function.Commute f fun x => x + n := by
  simp only [add_comm _ (n : ℝ), f.commute_nat_add n]
#align circle_deg1_lift.commute_add_nat CircleDeg1Lift.commute_add_nat

/- warning: circle_deg1_lift.commute_sub_nat -> CircleDeg1Lift.commute_sub_nat is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Nat), Function.Commute.{0} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (fun (x : Real) => HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Nat), Function.Commute.{0} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (fun (x : Real) => HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Nat.cast.{0} Real Real.natCast n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.commute_sub_nat CircleDeg1Lift.commute_sub_natₓ'. -/
theorem commute_sub_nat (n : ℕ) : Function.Commute f fun x => x - n := by
  simpa only [sub_eq_add_neg] using
    (f.commute_add_nat n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv
#align circle_deg1_lift.commute_sub_nat CircleDeg1Lift.commute_sub_nat

/- warning: circle_deg1_lift.commute_add_int -> CircleDeg1Lift.commute_add_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Int), Function.Commute.{0} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (fun (x : Real) => HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Int), Function.Commute.{0} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (fun (x : Real) => HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.commute_add_int CircleDeg1Lift.commute_add_intₓ'. -/
theorem commute_add_int : ∀ n : ℤ, Function.Commute f fun x => x + n
  | (n : ℕ) => f.commute_add_nat n
  | -[n+1] => by simpa [sub_eq_add_neg] using f.commute_sub_nat (n + 1)
#align circle_deg1_lift.commute_add_int CircleDeg1Lift.commute_add_int

/- warning: circle_deg1_lift.commute_int_add -> CircleDeg1Lift.commute_int_add is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Int), Function.Commute.{0} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Int), Function.Commute.{0} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (fun (x._@.Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber._hyg.1714 : Real) => HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Int.cast.{0} Real Real.intCast n) x._@.Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber._hyg.1714)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.commute_int_add CircleDeg1Lift.commute_int_addₓ'. -/
theorem commute_int_add (n : ℤ) : Function.Commute f ((· + ·) n) := by
  simpa only [add_comm _ (n : ℝ)] using f.commute_add_int n
#align circle_deg1_lift.commute_int_add CircleDeg1Lift.commute_int_add

/- warning: circle_deg1_lift.commute_sub_int -> CircleDeg1Lift.commute_sub_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Int), Function.Commute.{0} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (fun (x : Real) => HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Int), Function.Commute.{0} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (fun (x : Real) => HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Int.cast.{0} Real Real.intCast n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.commute_sub_int CircleDeg1Lift.commute_sub_intₓ'. -/
theorem commute_sub_int (n : ℤ) : Function.Commute f fun x => x - n := by
  simpa only [sub_eq_add_neg] using
    (f.commute_add_int n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv
#align circle_deg1_lift.commute_sub_int CircleDeg1Lift.commute_sub_int

/- warning: circle_deg1_lift.map_int_add -> CircleDeg1Lift.map_int_add is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (m : Int) (x : Real), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m) x)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x))
but is expected to have type
  forall (f : CircleDeg1Lift) (m : Int) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Int.cast.{0} Real Real.intCast m) x)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Int.cast.{0} Real Real.intCast m) x)) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Int.cast.{0} Real Real.intCast m) x)) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Int.cast.{0} Real Real.intCast m) x)) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Int.cast.{0} Real Real.intCast m) x)) Real.instAddReal) (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Int.cast.{0} Real Real.intCast m) x)) Real.intCast m) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_int_add CircleDeg1Lift.map_int_addₓ'. -/
@[simp]
theorem map_int_add (m : ℤ) (x : ℝ) : f (m + x) = m + f x :=
  f.commute_int_add m x
#align circle_deg1_lift.map_int_add CircleDeg1Lift.map_int_add

/- warning: circle_deg1_lift.map_add_int -> CircleDeg1Lift.map_add_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real) (m : Int), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real) (m : Int), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast m))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast m))) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast m))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast m))) Real.intCast m))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_add_int CircleDeg1Lift.map_add_intₓ'. -/
@[simp]
theorem map_add_int (x : ℝ) (m : ℤ) : f (x + m) = f x + m :=
  f.commute_add_int m x
#align circle_deg1_lift.map_add_int CircleDeg1Lift.map_add_int

/- warning: circle_deg1_lift.map_sub_int -> CircleDeg1Lift.map_sub_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real) (n : Int), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n))) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real) (n : Int), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Int.cast.{0} Real Real.intCast n))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Int.cast.{0} Real Real.intCast n))) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Int.cast.{0} Real Real.intCast n))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Int.cast.{0} Real Real.intCast n))) Real.intCast n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_sub_int CircleDeg1Lift.map_sub_intₓ'. -/
@[simp]
theorem map_sub_int (x : ℝ) (n : ℤ) : f (x - n) = f x - n :=
  f.commute_sub_int n x
#align circle_deg1_lift.map_sub_int CircleDeg1Lift.map_sub_int

/- warning: circle_deg1_lift.map_add_nat -> CircleDeg1Lift.map_add_nat is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real) (n : Nat), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real) (n : Nat), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Nat.cast.{0} Real Real.natCast n))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Nat.cast.{0} Real Real.natCast n))) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Nat.cast.{0} Real Real.natCast n))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (Nat.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Nat.cast.{0} Real Real.natCast n))) Real.natCast n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_add_nat CircleDeg1Lift.map_add_natₓ'. -/
@[simp]
theorem map_add_nat (x : ℝ) (n : ℕ) : f (x + n) = f x + n :=
  f.map_add_int x n
#align circle_deg1_lift.map_add_nat CircleDeg1Lift.map_add_nat

/- warning: circle_deg1_lift.map_nat_add -> CircleDeg1Lift.map_nat_add is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Nat) (x : Real), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) x)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Nat) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) x)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) x)) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) x)) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) x)) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) x)) Real.instAddReal) (Nat.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) x)) Real.natCast n) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_nat_add CircleDeg1Lift.map_nat_addₓ'. -/
@[simp]
theorem map_nat_add (n : ℕ) (x : ℝ) : f (n + x) = n + f x :=
  f.map_int_add n x
#align circle_deg1_lift.map_nat_add CircleDeg1Lift.map_nat_add

/- warning: circle_deg1_lift.map_sub_nat -> CircleDeg1Lift.map_sub_nat is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real) (n : Nat), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real) (n : Nat), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Nat.cast.{0} Real Real.natCast n))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Nat.cast.{0} Real Real.natCast n))) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Nat.cast.{0} Real Real.natCast n))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (Nat.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) x (Nat.cast.{0} Real Real.natCast n))) Real.natCast n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_sub_nat CircleDeg1Lift.map_sub_natₓ'. -/
@[simp]
theorem map_sub_nat (x : ℝ) (n : ℕ) : f (x - n) = f x - n :=
  f.map_sub_int x n
#align circle_deg1_lift.map_sub_nat CircleDeg1Lift.map_sub_nat

/- warning: circle_deg1_lift.map_int_of_map_zero -> CircleDeg1Lift.map_int_of_map_zero is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Int), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Int), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (Int.cast.{0} Real Real.intCast n)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (Int.cast.{0} Real Real.intCast n)) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (Int.cast.{0} Real Real.intCast n)) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (Int.cast.{0} Real Real.intCast n)) Real.intCast n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_int_of_map_zero CircleDeg1Lift.map_int_of_map_zeroₓ'. -/
theorem map_int_of_map_zero (n : ℤ) : f n = f 0 + n := by rw [← f.map_add_int, zero_add]
#align circle_deg1_lift.map_int_of_map_zero CircleDeg1Lift.map_int_of_map_zero

/- warning: circle_deg1_lift.map_fract_sub_fract_eq -> CircleDeg1Lift.map_fract_sub_fract_eq is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), Eq.{1} Real (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (Int.fract.{0} Real Real.linearOrderedRing Real.floorRing x)) (Int.fract.{0} Real Real.linearOrderedRing Real.floorRing x)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) x)
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (Int.fract.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal x)) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (Int.fract.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal x)) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (Int.fract.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal x)) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (Int.fract.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal x)) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (Int.fract.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal x)) (Int.fract.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal x)) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) x)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_fract_sub_fract_eq CircleDeg1Lift.map_fract_sub_fract_eqₓ'. -/
@[simp]
theorem map_fract_sub_fract_eq (x : ℝ) : f (fract x) - fract x = f x - x := by
  rw [Int.fract, f.map_sub_int, sub_sub_sub_cancel_right]
#align circle_deg1_lift.map_fract_sub_fract_eq CircleDeg1Lift.map_fract_sub_fract_eq

/-!
### Pointwise order on circle maps
-/


/-- Monotone circle maps form a lattice with respect to the pointwise order -/
noncomputable instance : Lattice CircleDeg1Lift
    where
  sup f g :=
    { toFun := fun x => max (f x) (g x)
      monotone' := fun x y h => max_le_max (f.mono h) (g.mono h)
      -- TODO: generalize to `monotone.max`
      map_add_one' := fun x => by simp [max_add_add_right] }
  le f g := ∀ x, f x ≤ g x
  le_refl f x := le_refl (f x)
  le_trans f₁ f₂ f₃ h₁₂ h₂₃ x := le_trans (h₁₂ x) (h₂₃ x)
  le_antisymm f₁ f₂ h₁₂ h₂₁ := ext fun x => le_antisymm (h₁₂ x) (h₂₁ x)
  le_sup_left f g x := le_max_left (f x) (g x)
  le_sup_right f g x := le_max_right (f x) (g x)
  sup_le f₁ f₂ f₃ h₁ h₂ x := max_le (h₁ x) (h₂ x)
  inf f g :=
    { toFun := fun x => min (f x) (g x)
      monotone' := fun x y h => min_le_min (f.mono h) (g.mono h)
      map_add_one' := fun x => by simp [min_add_add_right] }
  inf_le_left f g x := min_le_left (f x) (g x)
  inf_le_right f g x := min_le_right (f x) (g x)
  le_inf f₁ f₂ f₃ h₂ h₃ x := le_min (h₂ x) (h₃ x)

/- warning: circle_deg1_lift.sup_apply -> CircleDeg1Lift.sup_apply is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift) (x : Real), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (Sup.sup.{0} CircleDeg1Lift (SemilatticeSup.toHasSup.{0} CircleDeg1Lift (Lattice.toSemilatticeSup.{0} CircleDeg1Lift CircleDeg1Lift.lattice)) f g) x) (LinearOrder.max.{0} Real Real.linearOrder (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g x))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Sup.sup.{0} CircleDeg1Lift (SemilatticeSup.toSup.{0} CircleDeg1Lift (Lattice.toSemilatticeSup.{0} CircleDeg1Lift CircleDeg1Lift.instLatticeCircleDeg1Lift)) f g) x) (Max.max.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (LinearOrderedRing.toMax.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLinearOrderedRingReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.sup_apply CircleDeg1Lift.sup_applyₓ'. -/
@[simp]
theorem sup_apply (x : ℝ) : (f ⊔ g) x = max (f x) (g x) :=
  rfl
#align circle_deg1_lift.sup_apply CircleDeg1Lift.sup_apply

/- warning: circle_deg1_lift.inf_apply -> CircleDeg1Lift.inf_apply is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift) (x : Real), Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (Inf.inf.{0} CircleDeg1Lift (SemilatticeInf.toHasInf.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.lattice)) f g) x) (LinearOrder.min.{0} Real Real.linearOrder (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g x))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift) (x : Real), Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Inf.inf.{0} CircleDeg1Lift (Lattice.toInf.{0} CircleDeg1Lift CircleDeg1Lift.instLatticeCircleDeg1Lift) f g) x) (Min.min.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (LinearOrderedRing.toMin.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLinearOrderedRingReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.inf_apply CircleDeg1Lift.inf_applyₓ'. -/
@[simp]
theorem inf_apply (x : ℝ) : (f ⊓ g) x = min (f x) (g x) :=
  rfl
#align circle_deg1_lift.inf_apply CircleDeg1Lift.inf_apply

/- warning: circle_deg1_lift.iterate_monotone -> CircleDeg1Lift.iterate_monotone is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Monotone.{0, 0} CircleDeg1Lift (Real -> Real) (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.lattice))) (Pi.preorder.{0, 0} Real (fun (ᾰ : Real) => Real) (fun (i : Real) => Real.preorder)) (fun (f : CircleDeg1Lift) => Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n)
but is expected to have type
  forall (n : Nat), Monotone.{0, 0} CircleDeg1Lift (Real -> Real) (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.instLatticeCircleDeg1Lift))) (Pi.preorder.{0, 0} Real (fun (ᾰ : Real) => Real) (fun (i : Real) => Real.instPreorderReal)) (fun (f : CircleDeg1Lift) => Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.iterate_monotone CircleDeg1Lift.iterate_monotoneₓ'. -/
theorem iterate_monotone (n : ℕ) : Monotone fun f : CircleDeg1Lift => f^[n] := fun f g h =>
  f.Monotone.iterate_le_of_le h _
#align circle_deg1_lift.iterate_monotone CircleDeg1Lift.iterate_monotone

/- warning: circle_deg1_lift.iterate_mono -> CircleDeg1Lift.iterate_mono is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, (LE.le.{0} CircleDeg1Lift (Preorder.toLE.{0} CircleDeg1Lift (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.lattice)))) f g) -> (forall (n : Nat), LE.le.{0} (Real -> Real) (Pi.hasLe.{0, 0} Real (fun (ᾰ : Real) => Real) (fun (i : Real) => Real.hasLe)) (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n) (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g) n))
but is expected to have type
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, (LE.le.{0} CircleDeg1Lift (Preorder.toLE.{0} CircleDeg1Lift (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.instLatticeCircleDeg1Lift)))) f g) -> (forall (n : Nat), LE.le.{0} (Real -> Real) (Pi.hasLe.{0, 0} Real (fun (ᾰ : Real) => Real) (fun (i : Real) => Real.instLEReal)) (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n) (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g) n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.iterate_mono CircleDeg1Lift.iterate_monoₓ'. -/
theorem iterate_mono {f g : CircleDeg1Lift} (h : f ≤ g) (n : ℕ) : f^[n] ≤ g^[n] :=
  iterate_monotone n h
#align circle_deg1_lift.iterate_mono CircleDeg1Lift.iterate_mono

/- warning: circle_deg1_lift.pow_mono -> CircleDeg1Lift.pow_mono is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, (LE.le.{0} CircleDeg1Lift (Preorder.toLE.{0} CircleDeg1Lift (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.lattice)))) f g) -> (forall (n : Nat), LE.le.{0} CircleDeg1Lift (Preorder.toLE.{0} CircleDeg1Lift (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.lattice)))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) g n))
but is expected to have type
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, (LE.le.{0} CircleDeg1Lift (Preorder.toLE.{0} CircleDeg1Lift (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.instLatticeCircleDeg1Lift)))) f g) -> (forall (n : Nat), LE.le.{0} CircleDeg1Lift (Preorder.toLE.{0} CircleDeg1Lift (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.instLatticeCircleDeg1Lift)))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) g n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.pow_mono CircleDeg1Lift.pow_monoₓ'. -/
theorem pow_mono {f g : CircleDeg1Lift} (h : f ≤ g) (n : ℕ) : f ^ n ≤ g ^ n := fun x => by
  simp only [coe_pow, iterate_mono h n x]
#align circle_deg1_lift.pow_mono CircleDeg1Lift.pow_mono

/- warning: circle_deg1_lift.pow_monotone -> CircleDeg1Lift.pow_monotone is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Monotone.{0, 0} CircleDeg1Lift CircleDeg1Lift (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.lattice))) (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.lattice))) (fun (f : CircleDeg1Lift) => HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n)
but is expected to have type
  forall (n : Nat), Monotone.{0, 0} CircleDeg1Lift CircleDeg1Lift (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.instLatticeCircleDeg1Lift))) (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.instLatticeCircleDeg1Lift))) (fun (f : CircleDeg1Lift) => HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.pow_monotone CircleDeg1Lift.pow_monotoneₓ'. -/
theorem pow_monotone (n : ℕ) : Monotone fun f : CircleDeg1Lift => f ^ n := fun f g h => pow_mono h n
#align circle_deg1_lift.pow_monotone CircleDeg1Lift.pow_monotone

/-!
### Estimates on `(f * g) 0`

We prove the estimates `f 0 + ⌊g 0⌋ ≤ f (g 0) ≤ f 0 + ⌈g 0⌉` and some corollaries with added/removed
floors and ceils.

We also prove that for two semiconjugate maps `g₁`, `g₂`, the distance between `g₁ 0` and `g₂ 0`
is less than two.
-/


/- warning: circle_deg1_lift.map_le_of_map_zero -> CircleDeg1Lift.map_le_of_map_zero is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), LE.le.{0} Real Real.hasLe (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (Int.ceil.{0} Real Real.linearOrderedRing Real.floorRing x)))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLEReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast (Int.ceil.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal x)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_le_of_map_zero CircleDeg1Lift.map_le_of_map_zeroₓ'. -/
theorem map_le_of_map_zero (x : ℝ) : f x ≤ f 0 + ⌈x⌉ :=
  calc
    f x ≤ f ⌈x⌉ := f.Monotone <| le_ceil _
    _ = f 0 + ⌈x⌉ := f.map_int_of_map_zero _
    
#align circle_deg1_lift.map_le_of_map_zero CircleDeg1Lift.map_le_of_map_zero

/- warning: circle_deg1_lift.map_map_zero_le -> CircleDeg1Lift.map_map_zero_le is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Real Real.hasLe (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (Int.ceil.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) Real.instLEReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) Real.intCast (Int.ceil.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_map_zero_le CircleDeg1Lift.map_map_zero_leₓ'. -/
theorem map_map_zero_le : f (g 0) ≤ f 0 + ⌈g 0⌉ :=
  f.map_le_of_map_zero (g 0)
#align circle_deg1_lift.map_map_zero_le CircleDeg1Lift.map_map_zero_le

/- warning: circle_deg1_lift.floor_map_map_zero_le -> CircleDeg1Lift.floor_map_map_zero_le is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Int Int.hasLe (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))) (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (Int.ceil.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Int Int.instLEInt (Int.floor.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))) (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) (Int.floor.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (Int.ceil.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.floor_map_map_zero_le CircleDeg1Lift.floor_map_map_zero_leₓ'. -/
theorem floor_map_map_zero_le : ⌊f (g 0)⌋ ≤ ⌊f 0⌋ + ⌈g 0⌉ :=
  calc
    ⌊f (g 0)⌋ ≤ ⌊f 0 + ⌈g 0⌉⌋ := floor_mono <| f.map_map_zero_le g
    _ = ⌊f 0⌋ + ⌈g 0⌉ := floor_add_int _ _
    
#align circle_deg1_lift.floor_map_map_zero_le CircleDeg1Lift.floor_map_map_zero_le

/- warning: circle_deg1_lift.ceil_map_map_zero_le -> CircleDeg1Lift.ceil_map_map_zero_le is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Int Int.hasLe (Int.ceil.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))) (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) (Int.ceil.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (Int.ceil.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Int Int.instLEInt (Int.ceil.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))) (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) (Int.ceil.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (Int.ceil.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.ceil_map_map_zero_le CircleDeg1Lift.ceil_map_map_zero_leₓ'. -/
theorem ceil_map_map_zero_le : ⌈f (g 0)⌉ ≤ ⌈f 0⌉ + ⌈g 0⌉ :=
  calc
    ⌈f (g 0)⌉ ≤ ⌈f 0 + ⌈g 0⌉⌉ := ceil_mono <| f.map_map_zero_le g
    _ = ⌈f 0⌉ + ⌈g 0⌉ := ceil_add_int _ _
    
#align circle_deg1_lift.ceil_map_map_zero_le CircleDeg1Lift.ceil_map_map_zero_le

/- warning: circle_deg1_lift.map_map_zero_lt -> CircleDeg1Lift.map_map_zero_lt is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LT.lt.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) Real.instLTReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instAddReal) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_map_zero_lt CircleDeg1Lift.map_map_zero_ltₓ'. -/
theorem map_map_zero_lt : f (g 0) < f 0 + g 0 + 1 :=
  calc
    f (g 0) ≤ f 0 + ⌈g 0⌉ := f.map_map_zero_le g
    _ < f 0 + (g 0 + 1) := (add_lt_add_left (ceil_lt_add_one _) _)
    _ = f 0 + g 0 + 1 := (add_assoc _ _ _).symm
    
#align circle_deg1_lift.map_map_zero_lt CircleDeg1Lift.map_map_zero_lt

/- warning: circle_deg1_lift.le_map_of_map_zero -> CircleDeg1Lift.le_map_of_map_zero is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing x))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x)
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLEReal (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.intCast (Int.floor.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal x))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.le_map_of_map_zero CircleDeg1Lift.le_map_of_map_zeroₓ'. -/
theorem le_map_of_map_zero (x : ℝ) : f 0 + ⌊x⌋ ≤ f x :=
  calc
    f 0 + ⌊x⌋ = f ⌊x⌋ := (f.map_int_of_map_zero _).symm
    _ ≤ f x := f.Monotone <| floor_le _
    
#align circle_deg1_lift.le_map_of_map_zero CircleDeg1Lift.le_map_of_map_zero

/- warning: circle_deg1_lift.le_map_map_zero -> CircleDeg1Lift.le_map_map_zero is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLEReal (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.intCast (Int.floor.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.le_map_map_zero CircleDeg1Lift.le_map_map_zeroₓ'. -/
theorem le_map_map_zero : f 0 + ⌊g 0⌋ ≤ f (g 0) :=
  f.le_map_of_map_zero (g 0)
#align circle_deg1_lift.le_map_map_zero CircleDeg1Lift.le_map_map_zero

/- warning: circle_deg1_lift.le_floor_map_map_zero -> CircleDeg1Lift.le_floor_map_map_zero is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Int Int.hasLe (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Int Int.instLEInt (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) (Int.floor.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (Int.floor.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))) (Int.floor.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (a : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) a) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.le_floor_map_map_zero CircleDeg1Lift.le_floor_map_map_zeroₓ'. -/
theorem le_floor_map_map_zero : ⌊f 0⌋ + ⌊g 0⌋ ≤ ⌊f (g 0)⌋ :=
  calc
    ⌊f 0⌋ + ⌊g 0⌋ = ⌊f 0 + ⌊g 0⌋⌋ := (floor_add_int _ _).symm
    _ ≤ ⌊f (g 0)⌋ := floor_mono <| f.le_map_map_zero g
    
#align circle_deg1_lift.le_floor_map_map_zero CircleDeg1Lift.le_floor_map_map_zero

/- warning: circle_deg1_lift.le_ceil_map_map_zero -> CircleDeg1Lift.le_ceil_map_map_zero is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Int Int.hasLe (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) (Int.ceil.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))) (Int.ceil.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid))) f g) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LE.le.{0} Int Int.instLEInt (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) (Int.ceil.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (Int.floor.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))) (Int.ceil.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift))) f g) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.le_ceil_map_map_zero CircleDeg1Lift.le_ceil_map_map_zeroₓ'. -/
theorem le_ceil_map_map_zero : ⌈f 0⌉ + ⌊g 0⌋ ≤ ⌈(f * g) 0⌉ :=
  calc
    ⌈f 0⌉ + ⌊g 0⌋ = ⌈f 0 + ⌊g 0⌋⌉ := (ceil_add_int _ _).symm
    _ ≤ ⌈f (g 0)⌉ := ceil_mono <| f.le_map_map_zero g
    
#align circle_deg1_lift.le_ceil_map_map_zero CircleDeg1Lift.le_ceil_map_map_zero

/- warning: circle_deg1_lift.lt_map_map_zero -> CircleDeg1Lift.lt_map_map_zero is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LT.lt.{0} Real Real.hasLt (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LT.lt.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLTReal (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instSubReal) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instOneReal))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.lt_map_map_zero CircleDeg1Lift.lt_map_map_zeroₓ'. -/
theorem lt_map_map_zero : f 0 + g 0 - 1 < f (g 0) :=
  calc
    f 0 + g 0 - 1 = f 0 + (g 0 - 1) := add_sub_assoc _ _ _
    _ < f 0 + ⌊g 0⌋ := (add_lt_add_left (sub_one_lt_floor _) _)
    _ ≤ f (g 0) := f.le_map_map_zero g
    
#align circle_deg1_lift.lt_map_map_zero CircleDeg1Lift.lt_map_map_zero

/- warning: circle_deg1_lift.dist_map_map_zero_lt -> CircleDeg1Lift.dist_map_map_zero_lt is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LT.lt.{0} Real Real.hasLt (Dist.dist.{0} Real (PseudoMetricSpace.toHasDist.{0} Real Real.pseudoMetricSpace) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall (f : CircleDeg1Lift) (g : CircleDeg1Lift), LT.lt.{0} Real Real.instLTReal (Dist.dist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (PseudoMetricSpace.toDist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.pseudoMetricSpace) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instAddReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.dist_map_map_zero_lt CircleDeg1Lift.dist_map_map_zero_ltₓ'. -/
theorem dist_map_map_zero_lt : dist (f 0 + g 0) (f (g 0)) < 1 :=
  by
  rw [dist_comm, Real.dist_eq, abs_lt, lt_sub_iff_add_lt', sub_lt_iff_lt_add', ← sub_eq_add_neg]
  exact ⟨f.lt_map_map_zero g, f.map_map_zero_lt g⟩
#align circle_deg1_lift.dist_map_map_zero_lt CircleDeg1Lift.dist_map_map_zero_lt

/- warning: circle_deg1_lift.dist_map_zero_lt_of_semiconj -> CircleDeg1Lift.dist_map_zero_lt_of_semiconj is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, (Function.Semiconj.{0, 0} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₁) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₂)) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{0} Real (PseudoMetricSpace.toHasDist.{0} Real Real.pseudoMetricSpace) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₁ (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₂ (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))
but is expected to have type
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, (Function.Semiconj.{0, 0} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₁) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₂)) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (PseudoMetricSpace.toDist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.pseudoMetricSpace) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₁ (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₂ (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.dist_map_zero_lt_of_semiconj CircleDeg1Lift.dist_map_zero_lt_of_semiconjₓ'. -/
theorem dist_map_zero_lt_of_semiconj {f g₁ g₂ : CircleDeg1Lift} (h : Function.Semiconj f g₁ g₂) :
    dist (g₁ 0) (g₂ 0) < 2 :=
  calc
    dist (g₁ 0) (g₂ 0) ≤ dist (g₁ 0) (f (g₁ 0) - f 0) + dist _ (g₂ 0) := dist_triangle _ _ _
    _ = dist (f 0 + g₁ 0) (f (g₁ 0)) + dist (g₂ 0 + f 0) (g₂ (f 0)) := by
      simp only [h.eq, Real.dist_eq, sub_sub, add_comm (f 0), sub_sub_eq_add_sub,
        abs_sub_comm (g₂ (f 0))]
    _ < 2 := add_lt_add (f.dist_map_map_zero_lt g₁) (g₂.dist_map_map_zero_lt f)
    
#align circle_deg1_lift.dist_map_zero_lt_of_semiconj CircleDeg1Lift.dist_map_zero_lt_of_semiconj

/- warning: circle_deg1_lift.dist_map_zero_lt_of_semiconj_by -> CircleDeg1Lift.dist_map_zero_lt_of_semiconjBy is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, (SemiconjBy.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f g₁ g₂) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{0} Real (PseudoMetricSpace.toHasDist.{0} Real Real.pseudoMetricSpace) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₁ (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₂ (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))
but is expected to have type
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, (SemiconjBy.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f g₁ g₂) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (PseudoMetricSpace.toDist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.pseudoMetricSpace) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₁ (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₂ (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.dist_map_zero_lt_of_semiconj_by CircleDeg1Lift.dist_map_zero_lt_of_semiconjByₓ'. -/
theorem dist_map_zero_lt_of_semiconjBy {f g₁ g₂ : CircleDeg1Lift} (h : SemiconjBy f g₁ g₂) :
    dist (g₁ 0) (g₂ 0) < 2 :=
  dist_map_zero_lt_of_semiconj <| semiconjBy_iff_semiconj.1 h
#align circle_deg1_lift.dist_map_zero_lt_of_semiconj_by CircleDeg1Lift.dist_map_zero_lt_of_semiconjBy

/-!
### Limits at infinities and continuity
-/


/- warning: circle_deg1_lift.tendsto_at_bot -> CircleDeg1Lift.tendsto_atBot is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), Filter.Tendsto.{0, 0} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (Filter.atBot.{0} Real Real.preorder) (Filter.atBot.{0} Real Real.preorder)
but is expected to have type
  forall (f : CircleDeg1Lift), Filter.Tendsto.{0, 0} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (Filter.atBot.{0} Real Real.instPreorderReal) (Filter.atBot.{0} Real Real.instPreorderReal)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.tendsto_at_bot CircleDeg1Lift.tendsto_atBotₓ'. -/
protected theorem tendsto_atBot : Tendsto f atBot atBot :=
  tendsto_atBot_mono f.map_le_of_map_zero <|
    tendsto_atBot_add_const_left _ _ <|
      (tendsto_atBot_mono fun x => (ceil_lt_add_one x).le) <|
        tendsto_atBot_add_const_right _ _ tendsto_id
#align circle_deg1_lift.tendsto_at_bot CircleDeg1Lift.tendsto_atBot

/- warning: circle_deg1_lift.tendsto_at_top -> CircleDeg1Lift.tendsto_atTop is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), Filter.Tendsto.{0, 0} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (Filter.atTop.{0} Real Real.preorder) (Filter.atTop.{0} Real Real.preorder)
but is expected to have type
  forall (f : CircleDeg1Lift), Filter.Tendsto.{0, 0} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (Filter.atTop.{0} Real Real.instPreorderReal) (Filter.atTop.{0} Real Real.instPreorderReal)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.tendsto_at_top CircleDeg1Lift.tendsto_atTopₓ'. -/
protected theorem tendsto_atTop : Tendsto f atTop atTop :=
  tendsto_atTop_mono f.le_map_of_map_zero <|
    tendsto_atTop_add_const_left _ _ <|
      (tendsto_atTop_mono fun x => (sub_one_lt_floor x).le) <| by
        simpa [sub_eq_add_neg] using tendsto_at_top_add_const_right _ _ tendsto_id
#align circle_deg1_lift.tendsto_at_top CircleDeg1Lift.tendsto_atTop

/- warning: circle_deg1_lift.continuous_iff_surjective -> CircleDeg1Lift.continuous_iff_surjective is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), Iff (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f)) (Function.Surjective.{1, 1} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f))
but is expected to have type
  forall (f : CircleDeg1Lift), Iff (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f)) (Function.Surjective.{1, 1} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.continuous_iff_surjective CircleDeg1Lift.continuous_iff_surjectiveₓ'. -/
theorem continuous_iff_surjective : Continuous f ↔ Function.Surjective f :=
  ⟨fun h => h.Surjective f.tendsto_atTop f.tendsto_atBot, f.Monotone.continuous_of_surjective⟩
#align circle_deg1_lift.continuous_iff_surjective CircleDeg1Lift.continuous_iff_surjective

/-!
### Estimates on `(f^n) x`

If we know that `f x` is `≤`/`<`/`≥`/`>`/`=` to `x + m`, then we have a similar estimate on
`f^[n] x` and `x + n * m`.

For `≤`, `≥`, and `=` we formulate both `of` (implication) and `iff` versions because implications
work for `n = 0`. For `<` and `>` we formulate only `iff` versions.
-/


/- warning: circle_deg1_lift.iterate_le_of_map_le_add_int -> CircleDeg1Lift.iterate_le_of_map_le_add_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (LE.le.{0} Real Real.hasLe (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))) -> (forall (n : Nat), LE.le.{0} Real Real.hasLe (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLEReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m))) -> (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) (Int.cast.{0} Real Real.intCast m))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.iterate_le_of_map_le_add_int CircleDeg1Lift.iterate_le_of_map_le_add_intₓ'. -/
theorem iterate_le_of_map_le_add_int {x : ℝ} {m : ℤ} (h : f x ≤ x + m) (n : ℕ) :
    (f^[n]) x ≤ x + n * m := by
  simpa only [nsmul_eq_mul, add_right_iterate] using
    (f.commute_add_int m).iterate_le_of_map_le f.monotone (monotone_id.add_const m) h n
#align circle_deg1_lift.iterate_le_of_map_le_add_int CircleDeg1Lift.iterate_le_of_map_le_add_int

/- warning: circle_deg1_lift.le_iterate_of_add_int_le_map -> CircleDeg1Lift.le_iterate_of_add_int_le_map is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x)) -> (forall (n : Nat), LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))) (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n x))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast m)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x)) -> (forall (n : Nat), LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) (Int.cast.{0} Real Real.intCast m))) (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.le_iterate_of_add_int_le_map CircleDeg1Lift.le_iterate_of_add_int_le_mapₓ'. -/
theorem le_iterate_of_add_int_le_map {x : ℝ} {m : ℤ} (h : x + m ≤ f x) (n : ℕ) :
    x + n * m ≤ (f^[n]) x := by
  simpa only [nsmul_eq_mul, add_right_iterate] using
    (f.commute_add_int m).symm.iterate_le_of_map_le (monotone_id.add_const m) f.monotone h n
#align circle_deg1_lift.le_iterate_of_add_int_le_map CircleDeg1Lift.le_iterate_of_add_int_le_map

/- warning: circle_deg1_lift.iterate_eq_of_map_eq_add_int -> CircleDeg1Lift.iterate_eq_of_map_eq_add_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))) -> (forall (n : Nat), Eq.{1} Real (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m))) -> (forall (n : Nat), Eq.{1} Real (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) (Int.cast.{0} Real Real.intCast m))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.iterate_eq_of_map_eq_add_int CircleDeg1Lift.iterate_eq_of_map_eq_add_intₓ'. -/
theorem iterate_eq_of_map_eq_add_int {x : ℝ} {m : ℤ} (h : f x = x + m) (n : ℕ) :
    (f^[n]) x = x + n * m := by
  simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_eq_of_map_eq n h
#align circle_deg1_lift.iterate_eq_of_map_eq_add_int CircleDeg1Lift.iterate_eq_of_map_eq_add_int

/- warning: circle_deg1_lift.iterate_pos_le_iff -> CircleDeg1Lift.iterate_pos_le_iff is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Iff (LE.le.{0} Real Real.hasLe (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m)))) (LE.le.{0} Real Real.hasLe (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Iff (LE.le.{0} Real Real.instLEReal (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) (Int.cast.{0} Real Real.intCast m)))) (LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLEReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.iterate_pos_le_iff CircleDeg1Lift.iterate_pos_le_iffₓ'. -/
theorem iterate_pos_le_iff {x : ℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) :
    (f^[n]) x ≤ x + n * m ↔ f x ≤ x + m := by
  simpa only [nsmul_eq_mul, add_right_iterate] using
    (f.commute_add_int m).iterate_pos_le_iff_map_le f.monotone (strict_mono_id.add_const m) hn
#align circle_deg1_lift.iterate_pos_le_iff CircleDeg1Lift.iterate_pos_le_iff

/- warning: circle_deg1_lift.iterate_pos_lt_iff -> CircleDeg1Lift.iterate_pos_lt_iff is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Iff (LT.lt.{0} Real Real.hasLt (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m)))) (LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Iff (LT.lt.{0} Real Real.instLTReal (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) (Int.cast.{0} Real Real.intCast m)))) (LT.lt.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLTReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.iterate_pos_lt_iff CircleDeg1Lift.iterate_pos_lt_iffₓ'. -/
theorem iterate_pos_lt_iff {x : ℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) :
    (f^[n]) x < x + n * m ↔ f x < x + m := by
  simpa only [nsmul_eq_mul, add_right_iterate] using
    (f.commute_add_int m).iterate_pos_lt_iff_map_lt f.monotone (strict_mono_id.add_const m) hn
#align circle_deg1_lift.iterate_pos_lt_iff CircleDeg1Lift.iterate_pos_lt_iff

/- warning: circle_deg1_lift.iterate_pos_eq_iff -> CircleDeg1Lift.iterate_pos_eq_iff is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Iff (Eq.{1} Real (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m)))) (Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Iff (Eq.{1} Real (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) (Int.cast.{0} Real Real.intCast m)))) (Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.iterate_pos_eq_iff CircleDeg1Lift.iterate_pos_eq_iffₓ'. -/
theorem iterate_pos_eq_iff {x : ℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) :
    (f^[n]) x = x + n * m ↔ f x = x + m := by
  simpa only [nsmul_eq_mul, add_right_iterate] using
    (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strict_mono_id.add_const m) hn
#align circle_deg1_lift.iterate_pos_eq_iff CircleDeg1Lift.iterate_pos_eq_iff

/- warning: circle_deg1_lift.le_iterate_pos_iff -> CircleDeg1Lift.le_iterate_pos_iff is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Iff (LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))) (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n x)) (LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x)))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Iff (LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) (Int.cast.{0} Real Real.intCast m))) (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n x)) (LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast m)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.le_iterate_pos_iff CircleDeg1Lift.le_iterate_pos_iffₓ'. -/
theorem le_iterate_pos_iff {x : ℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) :
    x + n * m ≤ (f^[n]) x ↔ x + m ≤ f x := by
  simpa only [not_lt] using not_congr (f.iterate_pos_lt_iff hn)
#align circle_deg1_lift.le_iterate_pos_iff CircleDeg1Lift.le_iterate_pos_iff

/- warning: circle_deg1_lift.lt_iterate_pos_iff -> CircleDeg1Lift.lt_iterate_pos_iff is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Iff (LT.lt.{0} Real Real.hasLt (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))) (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n x)) (LT.lt.{0} Real Real.hasLt (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x)))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int} {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Iff (LT.lt.{0} Real Real.instLTReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) (Int.cast.{0} Real Real.intCast m))) (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n x)) (LT.lt.{0} Real Real.instLTReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast m)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.lt_iterate_pos_iff CircleDeg1Lift.lt_iterate_pos_iffₓ'. -/
theorem lt_iterate_pos_iff {x : ℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) :
    x + n * m < (f^[n]) x ↔ x + m < f x := by
  simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)
#align circle_deg1_lift.lt_iterate_pos_iff CircleDeg1Lift.lt_iterate_pos_iff

/- warning: circle_deg1_lift.mul_floor_map_zero_le_floor_iterate_zero -> CircleDeg1Lift.mul_floor_map_zero_le_floor_iterate_zero is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Nat), LE.le.{0} Int Int.hasLe (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) n) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Nat), LE.le.{0} Int Int.instLEInt (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.instMulInt) (Nat.cast.{0} Int instNatCastInt n) (Int.floor.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))) (Int.floor.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.mul_floor_map_zero_le_floor_iterate_zero CircleDeg1Lift.mul_floor_map_zero_le_floor_iterate_zeroₓ'. -/
theorem mul_floor_map_zero_le_floor_iterate_zero (n : ℕ) : ↑n * ⌊f 0⌋ ≤ ⌊(f^[n]) 0⌋ :=
  by
  rw [le_floor, Int.cast_mul, Int.cast_ofNat, ← zero_add ((n : ℝ) * _)]
  apply le_iterate_of_add_int_le_map
  simp [floor_le]
#align circle_deg1_lift.mul_floor_map_zero_le_floor_iterate_zero CircleDeg1Lift.mul_floor_map_zero_le_floor_iterate_zero

/-!
### Definition of translation number
-/


noncomputable section

#print CircleDeg1Lift.transnumAuxSeq /-
/-- An auxiliary sequence used to define the translation number. -/
def transnumAuxSeq (n : ℕ) : ℝ :=
  (f ^ 2 ^ n) 0 / 2 ^ n
#align circle_deg1_lift.transnum_aux_seq CircleDeg1Lift.transnumAuxSeq
-/

#print CircleDeg1Lift.translationNumber /-
/-- The translation number of a `circle_deg1_lift`, $τ(f)=\lim_{n→∞}\frac{f^n(x)-x}{n}$. We use
an auxiliary sequence `\frac{f^{2^n}(0)}{2^n}` to define `τ(f)` because some proofs are simpler
this way. -/
def translationNumber : ℝ :=
  limUnder atTop f.transnumAuxSeq
#align circle_deg1_lift.translation_number CircleDeg1Lift.translationNumber
-/

-- mathport name: exprτ
-- TODO: choose two different symbols for `circle_deg1_lift.translation_number` and the future
-- `circle_mono_homeo.rotation_number`, then make them `localized notation`s
local notation "τ" => translationNumber

/- warning: circle_deg1_lift.transnum_aux_seq_def -> CircleDeg1Lift.transnumAuxSeq_def is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), Eq.{1} (Nat -> Real) (CircleDeg1Lift.transnumAuxSeq f) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) n)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n))
but is expected to have type
  forall (f : CircleDeg1Lift), Eq.{1} (Nat -> Real) (CircleDeg1Lift.transnumAuxSeq f) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real (instHDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (LinearOrderedField.toDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedFieldReal)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) n)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Nat ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHPow.{0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Nat (Monoid.Pow.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instMonoidReal)) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) 2 (instOfNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.transnum_aux_seq_def CircleDeg1Lift.transnumAuxSeq_defₓ'. -/
theorem transnumAuxSeq_def : f.transnumAuxSeq = fun n : ℕ => (f ^ 2 ^ n) 0 / 2 ^ n :=
  rfl
#align circle_deg1_lift.transnum_aux_seq_def CircleDeg1Lift.transnumAuxSeq_def

#print CircleDeg1Lift.translationNumber_eq_of_tendsto_aux /-
theorem translationNumber_eq_of_tendsto_aux {τ' : ℝ} (h : Tendsto f.transnumAuxSeq atTop (𝓝 τ')) :
    τ f = τ' :=
  h.limUnder_eq
#align circle_deg1_lift.translation_number_eq_of_tendsto_aux CircleDeg1Lift.translationNumber_eq_of_tendsto_aux
-/

/- warning: circle_deg1_lift.translation_number_eq_of_tendsto₀ -> CircleDeg1Lift.translationNumber_eq_of_tendsto₀ is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {τ' : Real}, (Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) n (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) τ')) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) τ')
but is expected to have type
  forall (f : CircleDeg1Lift) {τ' : Real}, (Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) n (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Nat.cast.{0} Real Real.natCast n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) τ')) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) τ')
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_eq_of_tendsto₀ CircleDeg1Lift.translationNumber_eq_of_tendsto₀ₓ'. -/
theorem translationNumber_eq_of_tendsto₀ {τ' : ℝ}
    (h : Tendsto (fun n : ℕ => (f^[n]) 0 / n) atTop (𝓝 τ')) : τ f = τ' :=
  f.translationNumber_eq_of_tendsto_aux <| by
    simpa [(· ∘ ·), transnum_aux_seq_def, coe_pow] using
      h.comp (Nat.tendsto_pow_atTop_atTop_of_one_lt one_lt_two)
#align circle_deg1_lift.translation_number_eq_of_tendsto₀ CircleDeg1Lift.translationNumber_eq_of_tendsto₀

/- warning: circle_deg1_lift.translation_number_eq_of_tendsto₀' -> CircleDeg1Lift.translationNumber_eq_of_tendsto₀' is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {τ' : Real}, (Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Nat.iterate.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) τ')) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) τ')
but is expected to have type
  forall (f : CircleDeg1Lift) {τ' : Real}, (Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Nat.iterate.{1} Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) τ')) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) τ')
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_eq_of_tendsto₀' CircleDeg1Lift.translationNumber_eq_of_tendsto₀'ₓ'. -/
theorem translationNumber_eq_of_tendsto₀' {τ' : ℝ}
    (h : Tendsto (fun n : ℕ => (f^[n + 1]) 0 / (n + 1)) atTop (𝓝 τ')) : τ f = τ' :=
  f.translationNumber_eq_of_tendsto₀ <| (tendsto_add_atTop_iff_nat 1).1 (by exact_mod_cast h)
#align circle_deg1_lift.translation_number_eq_of_tendsto₀' CircleDeg1Lift.translationNumber_eq_of_tendsto₀'

/- warning: circle_deg1_lift.transnum_aux_seq_zero -> CircleDeg1Lift.transnumAuxSeq_zero is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), Eq.{1} Real (CircleDeg1Lift.transnumAuxSeq f (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall (f : CircleDeg1Lift), Eq.{1} Real (CircleDeg1Lift.transnumAuxSeq f (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.transnum_aux_seq_zero CircleDeg1Lift.transnumAuxSeq_zeroₓ'. -/
theorem transnumAuxSeq_zero : f.transnumAuxSeq 0 = f 0 := by simp [transnum_aux_seq]
#align circle_deg1_lift.transnum_aux_seq_zero CircleDeg1Lift.transnumAuxSeq_zero

/- warning: circle_deg1_lift.transnum_aux_seq_dist_lt -> CircleDeg1Lift.transnumAuxSeq_dist_lt is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Nat), LT.lt.{0} Real Real.hasLt (Dist.dist.{0} Real (PseudoMetricSpace.toHasDist.{0} Real Real.pseudoMetricSpace) (CircleDeg1Lift.transnumAuxSeq f n) (CircleDeg1Lift.transnumAuxSeq f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Nat), LT.lt.{0} Real Real.instLTReal (Dist.dist.{0} Real (PseudoMetricSpace.toDist.{0} Real Real.pseudoMetricSpace) (CircleDeg1Lift.transnumAuxSeq f n) (CircleDeg1Lift.transnumAuxSeq f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.transnum_aux_seq_dist_lt CircleDeg1Lift.transnumAuxSeq_dist_ltₓ'. -/
theorem transnumAuxSeq_dist_lt (n : ℕ) :
    dist (f.transnumAuxSeq n) (f.transnumAuxSeq (n + 1)) < 1 / 2 / 2 ^ n :=
  by
  have : 0 < (2 ^ (n + 1) : ℝ) := pow_pos zero_lt_two _
  rw [div_div, ← pow_succ, ← abs_of_pos this]
  replace := abs_pos.2 (ne_of_gt this)
  convert(div_lt_div_right this).2 ((f ^ 2 ^ n).dist_map_map_zero_lt (f ^ 2 ^ n))
  simp_rw [transnum_aux_seq, Real.dist_eq]
  rw [← abs_div, sub_div, pow_succ', pow_succ, ← two_mul, mul_div_mul_left _ _ (two_ne_zero' ℝ),
    pow_mul, sq, mul_apply]
#align circle_deg1_lift.transnum_aux_seq_dist_lt CircleDeg1Lift.transnumAuxSeq_dist_lt

#print CircleDeg1Lift.tendsto_translationNumber_aux /-
theorem tendsto_translationNumber_aux : Tendsto f.transnumAuxSeq atTop (𝓝 <| τ f) :=
  (cauchySeq_of_le_geometric_two 1 fun n => le_of_lt <| f.transnumAuxSeq_dist_lt n).tendsto_limUnder
#align circle_deg1_lift.tendsto_translation_number_aux CircleDeg1Lift.tendsto_translationNumber_aux
-/

/- warning: circle_deg1_lift.dist_map_zero_translation_number_le -> CircleDeg1Lift.dist_map_zero_translationNumber_le is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), LE.le.{0} Real Real.hasLe (Dist.dist.{0} Real (PseudoMetricSpace.toHasDist.{0} Real Real.pseudoMetricSpace) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (CircleDeg1Lift.translationNumber f)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall (f : CircleDeg1Lift), LE.le.{0} Real Real.instLEReal (Dist.dist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (PseudoMetricSpace.toDist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.pseudoMetricSpace) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (CircleDeg1Lift.translationNumber f)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.dist_map_zero_translation_number_le CircleDeg1Lift.dist_map_zero_translationNumber_leₓ'. -/
theorem dist_map_zero_translationNumber_le : dist (f 0) (τ f) ≤ 1 :=
  f.transnumAuxSeq_zero ▸
    dist_le_of_le_geometric_two_of_tendsto₀ 1 (fun n => le_of_lt <| f.transnumAuxSeq_dist_lt n)
      f.tendsto_translationNumber_aux
#align circle_deg1_lift.dist_map_zero_translation_number_le CircleDeg1Lift.dist_map_zero_translationNumber_le

/- warning: circle_deg1_lift.tendsto_translation_number_of_dist_bounded_aux -> CircleDeg1Lift.tendsto_translationNumber_of_dist_bounded_aux is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Nat -> Real) (C : Real), (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{0} Real (PseudoMetricSpace.toHasDist.{0} Real Real.pseudoMetricSpace) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (x n)) C) -> (Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (x (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) n)) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f)))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Nat -> Real) (C : Real), (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (PseudoMetricSpace.toDist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.pseudoMetricSpace) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (x n)) C) -> (Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (x (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) n)) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.tendsto_translation_number_of_dist_bounded_aux CircleDeg1Lift.tendsto_translationNumber_of_dist_bounded_auxₓ'. -/
theorem tendsto_translationNumber_of_dist_bounded_aux (x : ℕ → ℝ) (C : ℝ)
    (H : ∀ n : ℕ, dist ((f ^ n) 0) (x n) ≤ C) :
    Tendsto (fun n : ℕ => x (2 ^ n) / 2 ^ n) atTop (𝓝 <| τ f) :=
  by
  refine' f.tendsto_translation_number_aux.congr_dist (squeeze_zero (fun _ => dist_nonneg) _ _)
  · exact fun n => C / 2 ^ n
  · intro n
    have : 0 < (2 ^ n : ℝ) := pow_pos zero_lt_two _
    convert(div_le_div_right this).2 (H (2 ^ n))
    rw [transnum_aux_seq, Real.dist_eq, ← sub_div, abs_div, abs_of_pos this, Real.dist_eq]
  ·
    exact
      MulZeroClass.mul_zero C ▸
        tendsto_const_nhds.mul
          (tendsto_inv_at_top_zero.comp <| tendsto_pow_atTop_atTop_of_one_lt one_lt_two)
#align circle_deg1_lift.tendsto_translation_number_of_dist_bounded_aux CircleDeg1Lift.tendsto_translationNumber_of_dist_bounded_aux

/- warning: circle_deg1_lift.translation_number_eq_of_dist_bounded -> CircleDeg1Lift.translationNumber_eq_of_dist_bounded is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift} (C : Real), (forall (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{0} Real (PseudoMetricSpace.toHasDist.{0} Real Real.pseudoMetricSpace) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) g n) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))) C) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) (CircleDeg1Lift.translationNumber g))
but is expected to have type
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift} (C : Real), (forall (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (PseudoMetricSpace.toDist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.pseudoMetricSpace) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) g n) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))) C) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) (CircleDeg1Lift.translationNumber g))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_eq_of_dist_bounded CircleDeg1Lift.translationNumber_eq_of_dist_boundedₓ'. -/
theorem translationNumber_eq_of_dist_bounded {f g : CircleDeg1Lift} (C : ℝ)
    (H : ∀ n : ℕ, dist ((f ^ n) 0) ((g ^ n) 0) ≤ C) : τ f = τ g :=
  Eq.symm <|
    g.translationNumber_eq_of_tendsto_aux <| f.tendsto_translationNumber_of_dist_bounded_aux _ C H
#align circle_deg1_lift.translation_number_eq_of_dist_bounded CircleDeg1Lift.translationNumber_eq_of_dist_bounded

/- warning: circle_deg1_lift.translation_number_one -> CircleDeg1Lift.translationNumber_one is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (CircleDeg1Lift.translationNumber (OfNat.ofNat.{0} CircleDeg1Lift 1 (OfNat.mk.{0} CircleDeg1Lift 1 (One.one.{0} CircleDeg1Lift (MulOneClass.toHasOne.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  Eq.{1} Real (CircleDeg1Lift.translationNumber (OfNat.ofNat.{0} CircleDeg1Lift 1 (One.toOfNat1.{0} CircleDeg1Lift (Monoid.toOne.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_one CircleDeg1Lift.translationNumber_oneₓ'. -/
@[simp]
theorem translationNumber_one : τ 1 = 0 :=
  translationNumber_eq_of_tendsto₀ _ <| by simp [tendsto_const_nhds]
#align circle_deg1_lift.translation_number_one CircleDeg1Lift.translationNumber_one

/- warning: circle_deg1_lift.translation_number_eq_of_semiconj_by -> CircleDeg1Lift.translationNumber_eq_of_semiconjBy is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, (SemiconjBy.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f g₁ g₂) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber g₁) (CircleDeg1Lift.translationNumber g₂))
but is expected to have type
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, (SemiconjBy.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f g₁ g₂) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber g₁) (CircleDeg1Lift.translationNumber g₂))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_eq_of_semiconj_by CircleDeg1Lift.translationNumber_eq_of_semiconjByₓ'. -/
theorem translationNumber_eq_of_semiconjBy {f g₁ g₂ : CircleDeg1Lift} (H : SemiconjBy f g₁ g₂) :
    τ g₁ = τ g₂ :=
  translationNumber_eq_of_dist_bounded 2 fun n =>
    le_of_lt <| dist_map_zero_lt_of_semiconjBy <| H.pow_right n
#align circle_deg1_lift.translation_number_eq_of_semiconj_by CircleDeg1Lift.translationNumber_eq_of_semiconjBy

/- warning: circle_deg1_lift.translation_number_eq_of_semiconj -> CircleDeg1Lift.translationNumber_eq_of_semiconj is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, (Function.Semiconj.{0, 0} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₁) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun g₂)) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber g₁) (CircleDeg1Lift.translationNumber g₂))
but is expected to have type
  forall {f : CircleDeg1Lift} {g₁ : CircleDeg1Lift} {g₂ : CircleDeg1Lift}, (Function.Semiconj.{0, 0} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₁) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) g₂)) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber g₁) (CircleDeg1Lift.translationNumber g₂))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_eq_of_semiconj CircleDeg1Lift.translationNumber_eq_of_semiconjₓ'. -/
theorem translationNumber_eq_of_semiconj {f g₁ g₂ : CircleDeg1Lift}
    (H : Function.Semiconj f g₁ g₂) : τ g₁ = τ g₂ :=
  translationNumber_eq_of_semiconjBy <| semiconjBy_iff_semiconj.2 H
#align circle_deg1_lift.translation_number_eq_of_semiconj CircleDeg1Lift.translationNumber_eq_of_semiconj

/- warning: circle_deg1_lift.translation_number_mul_of_commute -> CircleDeg1Lift.translationNumber_mul_of_commute is a dubious translation:
lean 3 declaration is
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, (Commute.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f g) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid))) f g)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (CircleDeg1Lift.translationNumber f) (CircleDeg1Lift.translationNumber g)))
but is expected to have type
  forall {f : CircleDeg1Lift} {g : CircleDeg1Lift}, (Commute.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f g) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift))) f g)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (CircleDeg1Lift.translationNumber f) (CircleDeg1Lift.translationNumber g)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_mul_of_commute CircleDeg1Lift.translationNumber_mul_of_commuteₓ'. -/
theorem translationNumber_mul_of_commute {f g : CircleDeg1Lift} (h : Commute f g) :
    τ (f * g) = τ f + τ g :=
  by
  have :
    tendsto (fun n : ℕ => (fun k => (f ^ k) 0 + (g ^ k) 0) (2 ^ n) / 2 ^ n) at_top
      (𝓝 <| τ f + τ g) :=
    (f.tendsto_translation_number_aux.add g.tendsto_translation_number_aux).congr fun n =>
      (add_div ((f ^ 2 ^ n) 0) ((g ^ 2 ^ n) 0) ((2 : ℝ) ^ n)).symm
  refine'
    tendsto_nhds_unique ((f * g).tendsto_translationNumber_of_dist_bounded_aux _ 1 fun n => _) this
  rw [h.mul_pow, dist_comm]
  exact le_of_lt ((f ^ n).dist_map_map_zero_lt (g ^ n))
#align circle_deg1_lift.translation_number_mul_of_commute CircleDeg1Lift.translationNumber_mul_of_commute

/- warning: circle_deg1_lift.translation_number_units_inv -> CircleDeg1Lift.translationNumber_units_inv is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid), Eq.{1} Real (CircleDeg1Lift.translationNumber ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.hasInv.{0} CircleDeg1Lift CircleDeg1Lift.monoid) f))) (Neg.neg.{0} Real Real.hasNeg (CircleDeg1Lift.translationNumber ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) f)))
but is expected to have type
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift), Eq.{1} Real (CircleDeg1Lift.translationNumber (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instInvUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) f))) (Neg.neg.{0} Real Real.instNegReal (CircleDeg1Lift.translationNumber (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_units_inv CircleDeg1Lift.translationNumber_units_invₓ'. -/
@[simp]
theorem translationNumber_units_inv (f : CircleDeg1Liftˣ) : τ ↑f⁻¹ = -τ f :=
  eq_neg_iff_add_eq_zero.2 <| by
    simp [← translation_number_mul_of_commute (Commute.refl _).units_inv_left]
#align circle_deg1_lift.translation_number_units_inv CircleDeg1Lift.translationNumber_units_inv

/- warning: circle_deg1_lift.translation_number_pow -> CircleDeg1Lift.translationNumber_pow is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Nat), Eq.{1} Real (CircleDeg1Lift.translationNumber (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) (CircleDeg1Lift.translationNumber f))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Nat), Eq.{1} Real (CircleDeg1Lift.translationNumber (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Nat.cast.{0} Real Real.natCast n) (CircleDeg1Lift.translationNumber f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_pow CircleDeg1Lift.translationNumber_powₓ'. -/
@[simp]
theorem translationNumber_pow : ∀ n : ℕ, τ (f ^ n) = n * τ f
  | 0 => by simp
  | n + 1 => by
    rw [pow_succ', translation_number_mul_of_commute (Commute.pow_self f n),
      translation_number_pow n, Nat.cast_add_one, add_mul, one_mul]
#align circle_deg1_lift.translation_number_pow CircleDeg1Lift.translationNumber_pow

/- warning: circle_deg1_lift.translation_number_zpow -> CircleDeg1Lift.translationNumber_zpow is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (n : Int), Eq.{1} Real (CircleDeg1Lift.translationNumber ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) (HPow.hPow.{0, 0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) Int (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (instHPow.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) Int (DivInvMonoid.Pow.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Group.toDivInvMonoid.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.group.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) f n))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n) (CircleDeg1Lift.translationNumber ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) f)))
but is expected to have type
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (n : Int), Eq.{1} Real (CircleDeg1Lift.translationNumber (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (HPow.hPow.{0, 0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) Int (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (instHPow.{0, 0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) Int (DivInvMonoid.Pow.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Group.toDivInvMonoid.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instGroupUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) f n))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Int.cast.{0} Real Real.intCast n) (CircleDeg1Lift.translationNumber (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_zpow CircleDeg1Lift.translationNumber_zpowₓ'. -/
@[simp]
theorem translationNumber_zpow (f : CircleDeg1Liftˣ) : ∀ n : ℤ, τ (f ^ n : Units _) = n * τ f
  | (n : ℕ) => by simp [translation_number_pow f n]
  | -[n+1] => by
    simp
    ring
#align circle_deg1_lift.translation_number_zpow CircleDeg1Lift.translationNumber_zpow

/- warning: circle_deg1_lift.translation_number_conj_eq -> CircleDeg1Lift.translationNumber_conj_eq is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (g : CircleDeg1Lift), Eq.{1} Real (CircleDeg1Lift.translationNumber (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid))) (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) f) g) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.hasInv.{0} CircleDeg1Lift CircleDeg1Lift.monoid) f)))) (CircleDeg1Lift.translationNumber g)
but is expected to have type
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (g : CircleDeg1Lift), Eq.{1} Real (CircleDeg1Lift.translationNumber (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift))) (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f) g) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instInvUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) f)))) (CircleDeg1Lift.translationNumber g)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_conj_eq CircleDeg1Lift.translationNumber_conj_eqₓ'. -/
@[simp]
theorem translationNumber_conj_eq (f : CircleDeg1Liftˣ) (g : CircleDeg1Lift) :
    τ (↑f * g * ↑f⁻¹) = τ g :=
  (translationNumber_eq_of_semiconjBy (f.mk_semiconjBy g)).symm
#align circle_deg1_lift.translation_number_conj_eq CircleDeg1Lift.translationNumber_conj_eq

/- warning: circle_deg1_lift.translation_number_conj_eq' -> CircleDeg1Lift.translationNumber_conj_eq' is a dubious translation:
lean 3 declaration is
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (g : CircleDeg1Lift), Eq.{1} Real (CircleDeg1Lift.translationNumber (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid))) (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toHasMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Units.hasInv.{0} CircleDeg1Lift CircleDeg1Lift.monoid) f)) g) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) f))) (CircleDeg1Lift.translationNumber g)
but is expected to have type
  forall (f : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (g : CircleDeg1Lift), Eq.{1} Real (CircleDeg1Lift.translationNumber (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift))) (HMul.hMul.{0, 0, 0} CircleDeg1Lift CircleDeg1Lift CircleDeg1Lift (instHMul.{0} CircleDeg1Lift (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (Inv.inv.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instInvUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) f)) g) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f))) (CircleDeg1Lift.translationNumber g)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_conj_eq' CircleDeg1Lift.translationNumber_conj_eq'ₓ'. -/
@[simp]
theorem translationNumber_conj_eq' (f : CircleDeg1Liftˣ) (g : CircleDeg1Lift) :
    τ (↑f⁻¹ * g * f) = τ g :=
  translationNumber_conj_eq f⁻¹ g
#align circle_deg1_lift.translation_number_conj_eq' CircleDeg1Lift.translationNumber_conj_eq'

/- warning: circle_deg1_lift.dist_pow_map_zero_mul_translation_number_le -> CircleDeg1Lift.dist_pow_map_zero_mul_translationNumber_le is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (n : Nat), LE.le.{0} Real Real.hasLe (Dist.dist.{0} Real (PseudoMetricSpace.toHasDist.{0} Real Real.pseudoMetricSpace) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) (CircleDeg1Lift.translationNumber f))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall (f : CircleDeg1Lift) (n : Nat), LE.le.{0} Real Real.instLEReal (Dist.dist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (PseudoMetricSpace.toDist.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.pseudoMetricSpace) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHMul.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instMulReal) (Nat.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.natCast n) (CircleDeg1Lift.translationNumber f))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.dist_pow_map_zero_mul_translation_number_le CircleDeg1Lift.dist_pow_map_zero_mul_translationNumber_leₓ'. -/
theorem dist_pow_map_zero_mul_translationNumber_le (n : ℕ) :
    dist ((f ^ n) 0) (n * f.translationNumber) ≤ 1 :=
  f.translationNumber_pow n ▸ (f ^ n).dist_map_zero_translationNumber_le
#align circle_deg1_lift.dist_pow_map_zero_mul_translation_number_le CircleDeg1Lift.dist_pow_map_zero_mul_translationNumber_le

/- warning: circle_deg1_lift.tendsto_translation_number₀' -> CircleDeg1Lift.tendsto_translation_number₀' is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f))
but is expected to have type
  forall (f : CircleDeg1Lift), Filter.Tendsto.{0, 0} Nat ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (LinearOrderedField.toDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedFieldReal)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real (instHAdd.{0} Real Real.instAddReal) (Nat.cast.{0} Real Real.natCast n) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instOneReal)))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (UniformSpace.toTopologicalSpace.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (PseudoMetricSpace.toUniformSpace.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.tendsto_translation_number₀' CircleDeg1Lift.tendsto_translation_number₀'ₓ'. -/
theorem tendsto_translation_number₀' :
    Tendsto (fun n : ℕ => (f ^ (n + 1)) 0 / (n + 1)) atTop (𝓝 <| τ f) :=
  by
  refine'
    tendsto_iff_dist_tendsto_zero.2 <|
      squeeze_zero (fun _ => dist_nonneg) (fun n => _)
        ((tendsto_const_div_atTop_nhds_0_nat 1).comp (tendsto_add_at_top_nat 1))
  dsimp
  have : (0 : ℝ) < n + 1 := n.cast_add_one_pos
  rw [Real.dist_eq, div_sub' _ _ _ (ne_of_gt this), abs_div, ← Real.dist_eq, abs_of_pos this,
    Nat.cast_add_one, div_le_div_right this, ← Nat.cast_add_one]
  apply dist_pow_map_zero_mul_translation_number_le
#align circle_deg1_lift.tendsto_translation_number₀' CircleDeg1Lift.tendsto_translation_number₀'

/- warning: circle_deg1_lift.tendsto_translation_number₀ -> CircleDeg1Lift.tendsto_translation_number₀ is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f))
but is expected to have type
  forall (f : CircleDeg1Lift), Filter.Tendsto.{0, 0} Nat ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (instHDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (LinearOrderedField.toDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.instLinearOrderedFieldReal)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (Nat.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.natCast n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (UniformSpace.toTopologicalSpace.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (PseudoMetricSpace.toUniformSpace.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.tendsto_translation_number₀ CircleDeg1Lift.tendsto_translation_number₀ₓ'. -/
theorem tendsto_translation_number₀ : Tendsto (fun n : ℕ => (f ^ n) 0 / n) atTop (𝓝 <| τ f) :=
  (tendsto_add_atTop_iff_nat 1).1 (by exact_mod_cast f.tendsto_translation_number₀')
#align circle_deg1_lift.tendsto_translation_number₀ CircleDeg1Lift.tendsto_translation_number₀

/- warning: circle_deg1_lift.tendsto_translation_number -> CircleDeg1Lift.tendsto_translationNumber is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n) x) x) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), Filter.Tendsto.{0, 0} Nat ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (LinearOrderedField.toDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLinearOrderedFieldReal)) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n) x) x) (Nat.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.natCast n)) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (UniformSpace.toTopologicalSpace.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (PseudoMetricSpace.toUniformSpace.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.tendsto_translation_number CircleDeg1Lift.tendsto_translationNumberₓ'. -/
/-- For any `x : ℝ` the sequence $\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.
In particular, this limit does not depend on `x`. -/
theorem tendsto_translationNumber (x : ℝ) :
    Tendsto (fun n : ℕ => ((f ^ n) x - x) / n) atTop (𝓝 <| τ f) :=
  by
  rw [← translation_number_conj_eq' (translate <| Multiplicative.ofAdd x)]
  convert tendsto_translation_number₀ _
  ext n
  simp [sub_eq_neg_add, Units.conj_pow']
#align circle_deg1_lift.tendsto_translation_number CircleDeg1Lift.tendsto_translationNumber

/- warning: circle_deg1_lift.tendsto_translation_number' -> CircleDeg1Lift.tendsto_translation_number' is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), Filter.Tendsto.{0, 0} Nat Real (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) x) x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), Filter.Tendsto.{0, 0} Nat ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (fun (n : Nat) => HDiv.hDiv.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (LinearOrderedField.toDiv.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLinearOrderedFieldReal)) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) x) x) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHAdd.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instAddReal) (Nat.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.natCast n) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instOneReal)))) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (UniformSpace.toTopologicalSpace.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (PseudoMetricSpace.toUniformSpace.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.pseudoMetricSpace)) (CircleDeg1Lift.translationNumber f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.tendsto_translation_number' CircleDeg1Lift.tendsto_translation_number'ₓ'. -/
theorem tendsto_translation_number' (x : ℝ) :
    Tendsto (fun n : ℕ => ((f ^ (n + 1)) x - x) / (n + 1)) atTop (𝓝 <| τ f) := by
  exact_mod_cast (tendsto_add_at_top_iff_nat 1).2 (f.tendsto_translation_number x)
#align circle_deg1_lift.tendsto_translation_number' CircleDeg1Lift.tendsto_translation_number'

/- warning: circle_deg1_lift.translation_number_mono -> CircleDeg1Lift.translationNumber_mono is a dubious translation:
lean 3 declaration is
  Monotone.{0, 0} CircleDeg1Lift Real (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.lattice))) Real.preorder CircleDeg1Lift.translationNumber
but is expected to have type
  Monotone.{0, 0} CircleDeg1Lift Real (PartialOrder.toPreorder.{0} CircleDeg1Lift (SemilatticeInf.toPartialOrder.{0} CircleDeg1Lift (Lattice.toSemilatticeInf.{0} CircleDeg1Lift CircleDeg1Lift.instLatticeCircleDeg1Lift))) Real.instPreorderReal CircleDeg1Lift.translationNumber
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_mono CircleDeg1Lift.translationNumber_monoₓ'. -/
theorem translationNumber_mono : Monotone τ := fun f g h =>
  le_of_tendsto_of_tendsto' f.tendsto_translation_number₀ g.tendsto_translation_number₀ fun n =>
    div_le_div_of_le_of_nonneg (pow_mono h n 0) n.cast_nonneg
#align circle_deg1_lift.translation_number_mono CircleDeg1Lift.translationNumber_mono

/- warning: circle_deg1_lift.translation_number_translate -> CircleDeg1Lift.translationNumber_translate is a dubious translation:
lean 3 declaration is
  forall (x : Real), Eq.{1} Real (CircleDeg1Lift.translationNumber ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) (coeFn.{1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => (Multiplicative.{0} Real) -> (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (Units.mulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) CircleDeg1Lift.translate (coeFn.{1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) (fun (_x : Equiv.{1, 1} Real (Multiplicative.{0} Real)) => Real -> (Multiplicative.{0} Real)) (Equiv.hasCoeToFun.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)))) x
but is expected to have type
  forall (x : Real), Eq.{1} Real (CircleDeg1Lift.translationNumber (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (fun (_x : Multiplicative.{0} Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Real) => Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MulOneClass.toMul.{0} (Multiplicative.{0} Real) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal))) (MulOneClass.toMul.{0} (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{0, 0} (Multiplicative.{0} Real) (Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (Multiplicative.mulOneClass.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (Units.instMulOneClassUnits.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) CircleDeg1Lift.translate (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Real (Multiplicative.{0} Real)) Real (fun (_x : Real) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Real) => Multiplicative.{0} Real) _x) (Equiv.instFunLikeEquiv.{1, 1} Real (Multiplicative.{0} Real)) (Multiplicative.ofAdd.{0} Real) x)))) x
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_translate CircleDeg1Lift.translationNumber_translateₓ'. -/
theorem translationNumber_translate (x : ℝ) : τ (translate <| Multiplicative.ofAdd x) = x :=
  translationNumber_eq_of_tendsto₀' _ <| by
    simp [Nat.cast_add_one_ne_zero, mul_div_cancel_left, tendsto_const_nhds]
#align circle_deg1_lift.translation_number_translate CircleDeg1Lift.translationNumber_translate

/- warning: circle_deg1_lift.translation_number_le_of_le_add -> CircleDeg1Lift.translationNumber_le_of_le_add is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {z : Real}, (forall (x : Real), LE.le.{0} Real Real.hasLe (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x z)) -> (LE.le.{0} Real Real.hasLe (CircleDeg1Lift.translationNumber f) z)
but is expected to have type
  forall (f : CircleDeg1Lift) {z : Real}, (forall (x : Real), LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLEReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x z)) -> (LE.le.{0} Real Real.instLEReal (CircleDeg1Lift.translationNumber f) z)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_le_of_le_add CircleDeg1Lift.translationNumber_le_of_le_addₓ'. -/
theorem translationNumber_le_of_le_add {z : ℝ} (hz : ∀ x, f x ≤ x + z) : τ f ≤ z :=
  translationNumber_translate z ▸
    translationNumber_mono fun x => trans_rel_left _ (hz x) (add_comm _ _)
#align circle_deg1_lift.translation_number_le_of_le_add CircleDeg1Lift.translationNumber_le_of_le_add

/- warning: circle_deg1_lift.le_translation_number_of_add_le -> CircleDeg1Lift.le_translationNumber_of_add_le is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {z : Real}, (forall (x : Real), LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x z) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x)) -> (LE.le.{0} Real Real.hasLe z (CircleDeg1Lift.translationNumber f))
but is expected to have type
  forall (f : CircleDeg1Lift) {z : Real}, (forall (x : Real), LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x z) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x)) -> (LE.le.{0} Real Real.instLEReal z (CircleDeg1Lift.translationNumber f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.le_translation_number_of_add_le CircleDeg1Lift.le_translationNumber_of_add_leₓ'. -/
theorem le_translationNumber_of_add_le {z : ℝ} (hz : ∀ x, x + z ≤ f x) : z ≤ τ f :=
  translationNumber_translate z ▸
    translationNumber_mono fun x => trans_rel_right _ (add_comm _ _) (hz x)
#align circle_deg1_lift.le_translation_number_of_add_le CircleDeg1Lift.le_translationNumber_of_add_le

/- warning: circle_deg1_lift.translation_number_le_of_le_add_int -> CircleDeg1Lift.translationNumber_le_of_le_add_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (LE.le.{0} Real Real.hasLe (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))) -> (LE.le.{0} Real Real.hasLe (CircleDeg1Lift.translationNumber f) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLEReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m))) -> (LE.le.{0} Real Real.instLEReal (CircleDeg1Lift.translationNumber f) (Int.cast.{0} Real Real.intCast m))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_le_of_le_add_int CircleDeg1Lift.translationNumber_le_of_le_add_intₓ'. -/
theorem translationNumber_le_of_le_add_int {x : ℝ} {m : ℤ} (h : f x ≤ x + m) : τ f ≤ m :=
  le_of_tendsto' (f.tendsto_translation_number' x) fun n =>
    (div_le_iff' (n.cast_add_one_pos : (0 : ℝ) < _)).mpr <|
      sub_le_iff_le_add'.2 <|
        (coe_pow f (n + 1)).symm ▸
          @Nat.cast_add_one ℝ _ n ▸ f.iterate_le_of_map_le_add_int h (n + 1)
#align circle_deg1_lift.translation_number_le_of_le_add_int CircleDeg1Lift.translationNumber_le_of_le_add_int

/- warning: circle_deg1_lift.translation_number_le_of_le_add_nat -> CircleDeg1Lift.translationNumber_le_of_le_add_nat is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Nat}, (LE.le.{0} Real Real.hasLe (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) m))) -> (LE.le.{0} Real Real.hasLe (CircleDeg1Lift.translationNumber f) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) m))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Nat}, (LE.le.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLEReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Nat.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.natCast m))) -> (LE.le.{0} Real Real.instLEReal (CircleDeg1Lift.translationNumber f) (Nat.cast.{0} Real Real.natCast m))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_le_of_le_add_nat CircleDeg1Lift.translationNumber_le_of_le_add_natₓ'. -/
theorem translationNumber_le_of_le_add_nat {x : ℝ} {m : ℕ} (h : f x ≤ x + m) : τ f ≤ m :=
  @translationNumber_le_of_le_add_int f x m h
#align circle_deg1_lift.translation_number_le_of_le_add_nat CircleDeg1Lift.translationNumber_le_of_le_add_nat

/- warning: circle_deg1_lift.le_translation_number_of_add_int_le -> CircleDeg1Lift.le_translationNumber_of_add_int_le is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x)) -> (LE.le.{0} Real Real.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m) (CircleDeg1Lift.translationNumber f))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast m)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x)) -> (LE.le.{0} Real Real.instLEReal (Int.cast.{0} Real Real.intCast m) (CircleDeg1Lift.translationNumber f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.le_translation_number_of_add_int_le CircleDeg1Lift.le_translationNumber_of_add_int_leₓ'. -/
theorem le_translationNumber_of_add_int_le {x : ℝ} {m : ℤ} (h : x + m ≤ f x) : ↑m ≤ τ f :=
  ge_of_tendsto' (f.tendsto_translation_number' x) fun n =>
    (le_div_iff (n.cast_add_one_pos : (0 : ℝ) < _)).mpr <|
      le_sub_iff_add_le'.2 <| by
        simp only [coe_pow, mul_comm (m : ℝ), ← Nat.cast_add_one, f.le_iterate_of_add_int_le_map h]
#align circle_deg1_lift.le_translation_number_of_add_int_le CircleDeg1Lift.le_translationNumber_of_add_int_le

/- warning: circle_deg1_lift.le_translation_number_of_add_nat_le -> CircleDeg1Lift.le_translationNumber_of_add_nat_le is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Nat}, (LE.le.{0} Real Real.hasLe (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) m)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x)) -> (LE.le.{0} Real Real.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) m) (CircleDeg1Lift.translationNumber f))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Nat}, (LE.le.{0} Real Real.instLEReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Nat.cast.{0} Real Real.natCast m)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x)) -> (LE.le.{0} Real Real.instLEReal (Nat.cast.{0} Real Real.natCast m) (CircleDeg1Lift.translationNumber f))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.le_translation_number_of_add_nat_le CircleDeg1Lift.le_translationNumber_of_add_nat_leₓ'. -/
theorem le_translationNumber_of_add_nat_le {x : ℝ} {m : ℕ} (h : x + m ≤ f x) : ↑m ≤ τ f :=
  @le_translationNumber_of_add_int_le f x m h
#align circle_deg1_lift.le_translation_number_of_add_nat_le CircleDeg1Lift.le_translationNumber_of_add_nat_le

/- warning: circle_deg1_lift.translation_number_of_eq_add_int -> CircleDeg1Lift.translationNumber_of_eq_add_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {m : Int}, (Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m))) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) (Int.cast.{0} Real Real.intCast m))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_of_eq_add_int CircleDeg1Lift.translationNumber_of_eq_add_intₓ'. -/
/-- If `f x - x` is an integer number `m` for some point `x`, then `τ f = m`.
On the circle this means that a map with a fixed point has rotation number zero. -/
theorem translationNumber_of_eq_add_int {x : ℝ} {m : ℤ} (h : f x = x + m) : τ f = m :=
  le_antisymm (translationNumber_le_of_le_add_int f <| le_of_eq h)
    (le_translationNumber_of_add_int_le f <| le_of_eq h.symm)
#align circle_deg1_lift.translation_number_of_eq_add_int CircleDeg1Lift.translationNumber_of_eq_add_int

/- warning: circle_deg1_lift.floor_sub_le_translation_number -> CircleDeg1Lift.floor_sub_le_translationNumber is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), LE.le.{0} Real Real.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) x))) (CircleDeg1Lift.translationNumber f)
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), LE.le.{0} Real Real.instLEReal (Int.cast.{0} Real Real.intCast (Int.floor.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) x))) (CircleDeg1Lift.translationNumber f)
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.floor_sub_le_translation_number CircleDeg1Lift.floor_sub_le_translationNumberₓ'. -/
theorem floor_sub_le_translationNumber (x : ℝ) : ↑⌊f x - x⌋ ≤ τ f :=
  le_translationNumber_of_add_int_le f <| le_sub_iff_add_le'.1 (floor_le <| f x - x)
#align circle_deg1_lift.floor_sub_le_translation_number CircleDeg1Lift.floor_sub_le_translationNumber

/- warning: circle_deg1_lift.translation_number_le_ceil_sub -> CircleDeg1Lift.translationNumber_le_ceil_sub is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), LE.le.{0} Real Real.hasLe (CircleDeg1Lift.translationNumber f) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (Int.ceil.{0} Real Real.linearOrderedRing Real.floorRing (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) x)))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), LE.le.{0} Real Real.instLEReal (CircleDeg1Lift.translationNumber f) (Int.cast.{0} Real Real.intCast (Int.ceil.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) x)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_le_ceil_sub CircleDeg1Lift.translationNumber_le_ceil_subₓ'. -/
theorem translationNumber_le_ceil_sub (x : ℝ) : τ f ≤ ⌈f x - x⌉ :=
  translationNumber_le_of_le_add_int f <| sub_le_iff_le_add'.1 (le_ceil <| f x - x)
#align circle_deg1_lift.translation_number_le_ceil_sub CircleDeg1Lift.translationNumber_le_ceil_sub

/- warning: circle_deg1_lift.map_lt_of_translation_number_lt_int -> CircleDeg1Lift.map_lt_of_translationNumber_lt_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {n : Int}, (LT.lt.{0} Real Real.hasLt (CircleDeg1Lift.translationNumber f) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n)) -> (forall (x : Real), LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n)))
but is expected to have type
  forall (f : CircleDeg1Lift) {n : Int}, (LT.lt.{0} Real Real.instLTReal (CircleDeg1Lift.translationNumber f) (Int.cast.{0} Real Real.intCast n)) -> (forall (x : Real), LT.lt.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLTReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast n)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_lt_of_translation_number_lt_int CircleDeg1Lift.map_lt_of_translationNumber_lt_intₓ'. -/
theorem map_lt_of_translationNumber_lt_int {n : ℤ} (h : τ f < n) (x : ℝ) : f x < x + n :=
  not_le.1 <| mt f.le_translationNumber_of_add_int_le <| not_le.2 h
#align circle_deg1_lift.map_lt_of_translation_number_lt_int CircleDeg1Lift.map_lt_of_translationNumber_lt_int

/- warning: circle_deg1_lift.map_lt_of_translation_number_lt_nat -> CircleDeg1Lift.map_lt_of_translationNumber_lt_nat is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {n : Nat}, (LT.lt.{0} Real Real.hasLt (CircleDeg1Lift.translationNumber f) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)) -> (forall (x : Real), LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)))
but is expected to have type
  forall (f : CircleDeg1Lift) {n : Nat}, (LT.lt.{0} Real Real.instLTReal (CircleDeg1Lift.translationNumber f) (Nat.cast.{0} Real Real.natCast n)) -> (forall (x : Real), LT.lt.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLTReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Nat.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.natCast n)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_lt_of_translation_number_lt_nat CircleDeg1Lift.map_lt_of_translationNumber_lt_natₓ'. -/
theorem map_lt_of_translationNumber_lt_nat {n : ℕ} (h : τ f < n) (x : ℝ) : f x < x + n :=
  @map_lt_of_translationNumber_lt_int f n h x
#align circle_deg1_lift.map_lt_of_translation_number_lt_nat CircleDeg1Lift.map_lt_of_translationNumber_lt_nat

/- warning: circle_deg1_lift.map_lt_add_floor_translation_number_add_one -> CircleDeg1Lift.map_lt_add_floor_translationNumber_add_one is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (Int.floor.{0} Real Real.linearOrderedRing Real.floorRing (CircleDeg1Lift.translationNumber f)))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), LT.lt.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLTReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast (Int.floor.{0} Real Real.instLinearOrderedRingReal Real.instFloorRingRealInstLinearOrderedRingReal (CircleDeg1Lift.translationNumber f)))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_lt_add_floor_translation_number_add_one CircleDeg1Lift.map_lt_add_floor_translationNumber_add_oneₓ'. -/
theorem map_lt_add_floor_translationNumber_add_one (x : ℝ) : f x < x + ⌊τ f⌋ + 1 :=
  by
  rw [add_assoc]
  norm_cast
  refine' map_lt_of_translation_number_lt_int _ _ _
  push_cast
  exact lt_floor_add_one _
#align circle_deg1_lift.map_lt_add_floor_translation_number_add_one CircleDeg1Lift.map_lt_add_floor_translationNumber_add_one

/- warning: circle_deg1_lift.map_lt_add_translation_number_add_one -> CircleDeg1Lift.map_lt_add_translationNumber_add_one is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (x : Real), LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (CircleDeg1Lift.translationNumber f)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall (f : CircleDeg1Lift) (x : Real), LT.lt.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLTReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (CircleDeg1Lift.translationNumber f)) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.map_lt_add_translation_number_add_one CircleDeg1Lift.map_lt_add_translationNumber_add_oneₓ'. -/
theorem map_lt_add_translationNumber_add_one (x : ℝ) : f x < x + τ f + 1 :=
  calc
    f x < x + ⌊τ f⌋ + 1 := f.map_lt_add_floor_translationNumber_add_one x
    _ ≤ x + τ f + 1 := by
      mono*
      exact floor_le (τ f)
    
#align circle_deg1_lift.map_lt_add_translation_number_add_one CircleDeg1Lift.map_lt_add_translationNumber_add_one

/- warning: circle_deg1_lift.lt_map_of_int_lt_translation_number -> CircleDeg1Lift.lt_map_of_int_lt_translationNumber is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {n : Int}, (LT.lt.{0} Real Real.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n) (CircleDeg1Lift.translationNumber f)) -> (forall (x : Real), LT.lt.{0} Real Real.hasLt (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x))
but is expected to have type
  forall (f : CircleDeg1Lift) {n : Int}, (LT.lt.{0} Real Real.instLTReal (Int.cast.{0} Real Real.intCast n) (CircleDeg1Lift.translationNumber f)) -> (forall (x : Real), LT.lt.{0} Real Real.instLTReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} Real Real.intCast n)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.lt_map_of_int_lt_translation_number CircleDeg1Lift.lt_map_of_int_lt_translationNumberₓ'. -/
theorem lt_map_of_int_lt_translationNumber {n : ℤ} (h : ↑n < τ f) (x : ℝ) : x + n < f x :=
  not_le.1 <| mt f.translationNumber_le_of_le_add_int <| not_le.2 h
#align circle_deg1_lift.lt_map_of_int_lt_translation_number CircleDeg1Lift.lt_map_of_int_lt_translationNumber

/- warning: circle_deg1_lift.lt_map_of_nat_lt_translation_number -> CircleDeg1Lift.lt_map_of_nat_lt_translationNumber is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {n : Nat}, (LT.lt.{0} Real Real.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n) (CircleDeg1Lift.translationNumber f)) -> (forall (x : Real), LT.lt.{0} Real Real.hasLt (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x))
but is expected to have type
  forall (f : CircleDeg1Lift) {n : Nat}, (LT.lt.{0} Real Real.instLTReal (Nat.cast.{0} Real Real.natCast n) (CircleDeg1Lift.translationNumber f)) -> (forall (x : Real), LT.lt.{0} Real Real.instLTReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (Nat.cast.{0} Real Real.natCast n)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.lt_map_of_nat_lt_translation_number CircleDeg1Lift.lt_map_of_nat_lt_translationNumberₓ'. -/
theorem lt_map_of_nat_lt_translationNumber {n : ℕ} (h : ↑n < τ f) (x : ℝ) : x + n < f x :=
  @lt_map_of_int_lt_translationNumber f n h x
#align circle_deg1_lift.lt_map_of_nat_lt_translation_number CircleDeg1Lift.lt_map_of_nat_lt_translationNumber

/- warning: circle_deg1_lift.translation_number_of_map_pow_eq_add_int -> CircleDeg1Lift.translationNumber_of_map_pow_eq_add_int is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) {x : Real} {n : Nat} {m : Int}, (Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n) x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))) -> (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)))
but is expected to have type
  forall (f : CircleDeg1Lift) {x : Real} {n : Nat} {m : Int}, (Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n) x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m))) -> (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Int.cast.{0} Real Real.intCast m) (Nat.cast.{0} Real Real.natCast n)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_of_map_pow_eq_add_int CircleDeg1Lift.translationNumber_of_map_pow_eq_add_intₓ'. -/
/-- If `f^n x - x`, `n > 0`, is an integer number `m` for some point `x`, then
`τ f = m / n`. On the circle this means that a map with a periodic orbit has
a rational rotation number. -/
theorem translationNumber_of_map_pow_eq_add_int {x : ℝ} {n : ℕ} {m : ℤ} (h : (f ^ n) x = x + m)
    (hn : 0 < n) : τ f = m / n :=
  by
  have := (f ^ n).translationNumber_of_eq_add_int h
  rwa [translation_number_pow, mul_comm, ← eq_div_iff] at this
  exact Nat.cast_ne_zero.2 (ne_of_gt hn)
#align circle_deg1_lift.translation_number_of_map_pow_eq_add_int CircleDeg1Lift.translationNumber_of_map_pow_eq_add_int

/- warning: circle_deg1_lift.forall_map_sub_of_Icc -> CircleDeg1Lift.forall_map_sub_of_Icc is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift) (P : Real -> Prop), (forall (x : Real), (Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x (Set.Icc.{0} Real Real.preorder (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) -> (P (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) x))) -> (forall (x : Real), P (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) x))
but is expected to have type
  forall (f : CircleDeg1Lift) (P : Real -> Prop), (forall (x : Real), (Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x (Set.Icc.{0} Real Real.instPreorderReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) -> (P (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) x))) -> (forall (x : Real), P (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instSubReal) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) x))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.forall_map_sub_of_Icc CircleDeg1Lift.forall_map_sub_of_Iccₓ'. -/
/-- If a predicate depends only on `f x - x` and holds for all `0 ≤ x ≤ 1`,
then it holds for all `x`. -/
theorem forall_map_sub_of_Icc (P : ℝ → Prop) (h : ∀ x ∈ Icc (0 : ℝ) 1, P (f x - x)) (x : ℝ) :
    P (f x - x) :=
  f.map_fract_sub_fract_eq x ▸ h _ ⟨fract_nonneg _, le_of_lt (fract_lt_one _)⟩
#align circle_deg1_lift.forall_map_sub_of_Icc CircleDeg1Lift.forall_map_sub_of_Icc

/- warning: circle_deg1_lift.translation_number_lt_of_forall_lt_add -> CircleDeg1Lift.translationNumber_lt_of_forall_lt_add is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f)) -> (forall {z : Real}, (forall (x : Real), LT.lt.{0} Real Real.hasLt (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x z)) -> (LT.lt.{0} Real Real.hasLt (CircleDeg1Lift.translationNumber f) z))
but is expected to have type
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f)) -> (forall {z : Real}, (forall (x : Real), LT.lt.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.instLTReal (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x z)) -> (LT.lt.{0} Real Real.instLTReal (CircleDeg1Lift.translationNumber f) z))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_lt_of_forall_lt_add CircleDeg1Lift.translationNumber_lt_of_forall_lt_addₓ'. -/
theorem translationNumber_lt_of_forall_lt_add (hf : Continuous f) {z : ℝ} (hz : ∀ x, f x < x + z) :
    τ f < z :=
  by
  obtain ⟨x, xmem, hx⟩ : ∃ x ∈ Icc (0 : ℝ) 1, ∀ y ∈ Icc (0 : ℝ) 1, f y - y ≤ f x - x
  exact
    is_compact_Icc.exists_forall_ge (nonempty_Icc.2 zero_le_one) (hf.sub continuous_id).ContinuousOn
  refine' lt_of_le_of_lt _ (sub_lt_iff_lt_add'.2 <| hz x)
  apply translation_number_le_of_le_add
  simp only [← sub_le_iff_le_add']
  exact f.forall_map_sub_of_Icc (fun a => a ≤ f x - x) hx
#align circle_deg1_lift.translation_number_lt_of_forall_lt_add CircleDeg1Lift.translationNumber_lt_of_forall_lt_add

/- warning: circle_deg1_lift.lt_translation_number_of_forall_add_lt -> CircleDeg1Lift.lt_translationNumber_of_forall_add_lt is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f)) -> (forall {z : Real}, (forall (x : Real), LT.lt.{0} Real Real.hasLt (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x z) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x)) -> (LT.lt.{0} Real Real.hasLt z (CircleDeg1Lift.translationNumber f)))
but is expected to have type
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f)) -> (forall {z : Real}, (forall (x : Real), LT.lt.{0} Real Real.instLTReal (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x z) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x)) -> (LT.lt.{0} Real Real.instLTReal z (CircleDeg1Lift.translationNumber f)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.lt_translation_number_of_forall_add_lt CircleDeg1Lift.lt_translationNumber_of_forall_add_ltₓ'. -/
theorem lt_translationNumber_of_forall_add_lt (hf : Continuous f) {z : ℝ} (hz : ∀ x, x + z < f x) :
    z < τ f :=
  by
  obtain ⟨x, xmem, hx⟩ : ∃ x ∈ Icc (0 : ℝ) 1, ∀ y ∈ Icc (0 : ℝ) 1, f x - x ≤ f y - y
  exact
    is_compact_Icc.exists_forall_le (nonempty_Icc.2 zero_le_one) (hf.sub continuous_id).ContinuousOn
  refine' lt_of_lt_of_le (lt_sub_iff_add_lt'.2 <| hz x) _
  apply le_translation_number_of_add_le
  simp only [← le_sub_iff_add_le']
  exact f.forall_map_sub_of_Icc _ hx
#align circle_deg1_lift.lt_translation_number_of_forall_add_lt CircleDeg1Lift.lt_translationNumber_of_forall_add_lt

/- warning: circle_deg1_lift.exists_eq_add_translation_number -> CircleDeg1Lift.exists_eq_add_translationNumber is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f)) -> (Exists.{1} Real (fun (x : Real) => Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x (CircleDeg1Lift.translationNumber f))))
but is expected to have type
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f)) -> (Exists.{1} Real (fun (x : Real) => Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) x (CircleDeg1Lift.translationNumber f))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.exists_eq_add_translation_number CircleDeg1Lift.exists_eq_add_translationNumberₓ'. -/
/-- If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`
such that `f x = x + τ f`. -/
theorem exists_eq_add_translationNumber (hf : Continuous f) : ∃ x, f x = x + τ f :=
  by
  obtain ⟨a, ha⟩ : ∃ x, f x ≤ x + f.translation_number :=
    by
    by_contra' H
    exact lt_irrefl _ (f.lt_translation_number_of_forall_add_lt hf H)
  obtain ⟨b, hb⟩ : ∃ x, x + τ f ≤ f x := by
    by_contra' H
    exact lt_irrefl _ (f.translation_number_lt_of_forall_lt_add hf H)
  exact intermediate_value_univ₂ hf (continuous_id.add continuous_const) ha hb
#align circle_deg1_lift.exists_eq_add_translation_number CircleDeg1Lift.exists_eq_add_translationNumber

/- warning: circle_deg1_lift.translation_number_eq_int_iff -> CircleDeg1Lift.translationNumber_eq_int_iff is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f)) -> (forall {m : Int}, Iff (Eq.{1} Real (CircleDeg1Lift.translationNumber f) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m)) (Exists.{1} Real (fun (x : Real) => Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m)))))
but is expected to have type
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f)) -> (forall {m : Int}, Iff (Eq.{1} Real (CircleDeg1Lift.translationNumber f) (Int.cast.{0} Real Real.intCast m)) (Exists.{1} Real (fun (x : Real) => Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m)))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_eq_int_iff CircleDeg1Lift.translationNumber_eq_int_iffₓ'. -/
theorem translationNumber_eq_int_iff (hf : Continuous f) {m : ℤ} : τ f = m ↔ ∃ x, f x = x + m :=
  by
  refine' ⟨fun h => h ▸ f.exists_eq_add_translation_number hf, _⟩
  rintro ⟨x, hx⟩
  exact f.translation_number_of_eq_add_int hx
#align circle_deg1_lift.translation_number_eq_int_iff CircleDeg1Lift.translationNumber_eq_int_iff

/- warning: circle_deg1_lift.continuous_pow -> CircleDeg1Lift.continuous_pow is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f)) -> (forall (n : Nat), Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n)))
but is expected to have type
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f)) -> (forall (n : Nat), Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.continuous_pow CircleDeg1Lift.continuous_powₓ'. -/
theorem continuous_pow (hf : Continuous f) (n : ℕ) : Continuous ⇑(f ^ n : CircleDeg1Lift) :=
  by
  rw [coe_pow]
  exact hf.iterate n
#align circle_deg1_lift.continuous_pow CircleDeg1Lift.continuous_pow

/- warning: circle_deg1_lift.translation_number_eq_rat_iff -> CircleDeg1Lift.translationNumber_eq_rat_iff is a dubious translation:
lean 3 declaration is
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f)) -> (forall {m : Int} {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Iff (Eq.{1} Real (CircleDeg1Lift.translationNumber f) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n))) (Exists.{1} Real (fun (x : Real) => Eq.{1} Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f n) x) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) x ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) m))))))
but is expected to have type
  forall (f : CircleDeg1Lift), (Continuous.{0, 0} Real Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f)) -> (forall {m : Int} {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Iff (Eq.{1} Real (CircleDeg1Lift.translationNumber f) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Int.cast.{0} Real Real.intCast m) (Nat.cast.{0} Real Real.natCast n))) (Exists.{1} Real (fun (x : Real) => Eq.{1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (HPow.hPow.{0, 0, 0} CircleDeg1Lift Nat CircleDeg1Lift (instHPow.{0, 0} CircleDeg1Lift Nat (Monoid.Pow.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) f n) x) (HAdd.hAdd.{0, 0, 0} Real ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real (instHAdd.{0} Real Real.instAddReal) x (Int.cast.{0} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) x) Real.intCast m))))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.translation_number_eq_rat_iff CircleDeg1Lift.translationNumber_eq_rat_iffₓ'. -/
theorem translationNumber_eq_rat_iff (hf : Continuous f) {m : ℤ} {n : ℕ} (hn : 0 < n) :
    τ f = m / n ↔ ∃ x, (f ^ n) x = x + m :=
  by
  rw [eq_div_iff, mul_comm, ← translation_number_pow] <;> [skip, exact ne_of_gt (Nat.cast_pos.2 hn)]
  exact (f ^ n).translationNumber_eq_int_iff (f.continuous_pow hf n)
#align circle_deg1_lift.translation_number_eq_rat_iff CircleDeg1Lift.translationNumber_eq_rat_iff

/- warning: circle_deg1_lift.semiconj_of_group_action_of_forall_translation_number_eq -> CircleDeg1Lift.semiconj_of_group_action_of_forall_translationNumber_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (f₁ : MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (f₂ : MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)), (forall (g : G), Eq.{1} Real (CircleDeg1Lift.translationNumber (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => G -> CircleDeg1Lift) (MonoidHom.hasCoeToFun.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f₁ g)) (CircleDeg1Lift.translationNumber (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => G -> CircleDeg1Lift) (MonoidHom.hasCoeToFun.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f₂ g))) -> (Exists.{1} CircleDeg1Lift (fun (F : CircleDeg1Lift) => forall (g : G), Function.Semiconj.{0, 0} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun F) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => G -> CircleDeg1Lift) (MonoidHom.hasCoeToFun.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f₁ g)) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) (fun (_x : MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) => G -> CircleDeg1Lift) (MonoidHom.hasCoeToFun.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.monoid)) f₂ g))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (f₁ : MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (f₂ : MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)), (forall (g : G), Eq.{1} Real (CircleDeg1Lift.translationNumber (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G CircleDeg1Lift (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) f₁ g)) (CircleDeg1Lift.translationNumber (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G CircleDeg1Lift (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) f₂ g))) -> (Exists.{1} CircleDeg1Lift (fun (F : CircleDeg1Lift) => forall (g : G), Function.Semiconj.{0, 0} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) F) (FunLike.coe.{1, 1, 1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) g) Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) g) Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) g) Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) g) Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G CircleDeg1Lift (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) f₁ g)) (FunLike.coe.{1, 1, 1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) g) Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) g) Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) g) Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) g) Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => CircleDeg1Lift) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G CircleDeg1Lift (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{0} CircleDeg1Lift (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)) G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift) (MonoidHom.monoidHomClass.{u1, 0} G CircleDeg1Lift (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift)))) f₂ g))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.semiconj_of_group_action_of_forall_translation_number_eq CircleDeg1Lift.semiconj_of_group_action_of_forall_translationNumber_eqₓ'. -/
/-- Consider two actions `f₁ f₂ : G →* circle_deg1_lift` of a group on the real line by lifts of
orientation preserving circle homeomorphisms. Suppose that for each `g : G` the homeomorphisms
`f₁ g` and `f₂ g` have equal rotation numbers. Then there exists `F : circle_deg1_lift`  such that
`F * f₁ g = f₂ g * F` for all `g : G`.

This is a version of Proposition 5.4 from [Étienne Ghys, Groupes d'homeomorphismes du cercle et
cohomologie bornee][ghys87:groupes]. -/
theorem semiconj_of_group_action_of_forall_translationNumber_eq {G : Type _} [Group G]
    (f₁ f₂ : G →* CircleDeg1Lift) (h : ∀ g, τ (f₁ g) = τ (f₂ g)) :
    ∃ F : CircleDeg1Lift, ∀ g, Semiconj F (f₁ g) (f₂ g) :=
  by
  -- Equality of translation number guarantees that for each `x`
  -- the set `{f₂ g⁻¹ (f₁ g x) | g : G}` is bounded above.
  have : ∀ x, BddAbove (range fun g => f₂ g⁻¹ (f₁ g x)) :=
    by
    refine' fun x => ⟨x + 2, _⟩
    rintro _ ⟨g, rfl⟩
    have : τ (f₂ g⁻¹) = -τ (f₂ g) := by
      rw [← MonoidHom.coe_toHomUnits, MonoidHom.map_inv, translation_number_units_inv,
        MonoidHom.coe_toHomUnits]
    calc
      f₂ g⁻¹ (f₁ g x) ≤ f₂ g⁻¹ (x + τ (f₁ g) + 1) :=
        mono _ (map_lt_add_translation_number_add_one _ _).le
      _ = f₂ g⁻¹ (x + τ (f₂ g)) + 1 := by rw [h, map_add_one]
      _ ≤ x + τ (f₂ g) + τ (f₂ g⁻¹) + 1 + 1 := by
        mono
        exact (map_lt_add_translation_number_add_one _ _).le
      _ = x + 2 := by simp [this, bit0, add_assoc]
      
  -- We have a theorem about actions by `order_iso`, so we introduce auxiliary maps
  -- to `ℝ ≃o ℝ`.
  set F₁ := to_order_iso.comp f₁.to_hom_units
  set F₂ := to_order_iso.comp f₂.to_hom_units
  have hF₁ : ∀ g, ⇑(F₁ g) = f₁ g := fun _ => rfl
  have hF₂ : ∀ g, ⇑(F₂ g) = f₂ g := fun _ => rfl
  simp only [← hF₁, ← hF₂]
  -- Now we apply `cSup_div_semiconj` and go back to `f₁` and `f₂`.
    refine' ⟨⟨_, fun x y hxy => _, fun x => _⟩, cSup_div_semiconj F₂ F₁ fun x => _⟩ <;>
    simp only [hF₁, hF₂, ← MonoidHom.map_inv, coe_mk]
  · refine' csupᵢ_mono (this y) fun g => _
    exact mono _ (mono _ hxy)
  · simp only [map_add_one]
    exact
      (Monotone.map_csupr_of_continuousAt (continuous_at_id.add continuousAt_const)
          (monotone_id.add_const (1 : ℝ)) (this x)).symm
  · exact this x
#align circle_deg1_lift.semiconj_of_group_action_of_forall_translation_number_eq CircleDeg1Lift.semiconj_of_group_action_of_forall_translationNumber_eq

/- warning: circle_deg1_lift.units_semiconj_of_translation_number_eq -> CircleDeg1Lift.units_semiconj_of_translationNumber_eq is a dubious translation:
lean 3 declaration is
  forall {f₁ : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid} {f₂ : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid}, (Eq.{1} Real (CircleDeg1Lift.translationNumber ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) f₁)) (CircleDeg1Lift.translationNumber ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (HasLiftT.mk.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (CoeTCₓ.coe.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (coeBase.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) CircleDeg1Lift (Units.hasCoe.{0} CircleDeg1Lift CircleDeg1Lift.monoid)))) f₂))) -> (Exists.{1} CircleDeg1Lift (fun (F : CircleDeg1Lift) => Function.Semiconj.{0, 0} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun F) (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun f₁) (coeFn.{1, 1} (Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) (fun (_x : Units.{0} CircleDeg1Lift CircleDeg1Lift.monoid) => Real -> Real) CircleDeg1Lift.unitsHasCoeToFun f₂)))
but is expected to have type
  forall {f₁ : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift} {f₂ : Units.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift}, (Eq.{1} Real (CircleDeg1Lift.translationNumber (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f₁)) (CircleDeg1Lift.translationNumber (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f₂))) -> (Exists.{1} CircleDeg1Lift (fun (F : CircleDeg1Lift) => Function.Semiconj.{0, 0} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) F) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f₁)) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) (Units.val.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f₂))))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.units_semiconj_of_translation_number_eq CircleDeg1Lift.units_semiconj_of_translationNumber_eqₓ'. -/
/-- If two lifts of circle homeomorphisms have the same translation number, then they are
semiconjugate by a `circle_deg1_lift`. This version uses arguments `f₁ f₂ : circle_deg1_liftˣ`
to assume that `f₁` and `f₂` are homeomorphisms. -/
theorem units_semiconj_of_translationNumber_eq {f₁ f₂ : CircleDeg1Liftˣ} (h : τ f₁ = τ f₂) :
    ∃ F : CircleDeg1Lift, Semiconj F f₁ f₂ :=
  haveI :
    ∀ n : Multiplicative ℤ,
      τ ((Units.coeHom _).comp (zpowersHom _ f₁) n) =
        τ ((Units.coeHom _).comp (zpowersHom _ f₂) n) :=
    by
    intro n
    simp [h]
  (semiconj_of_group_action_of_forall_translation_number_eq _ _ this).imp fun F hF =>
    hF (Multiplicative.ofAdd 1)
#align circle_deg1_lift.units_semiconj_of_translation_number_eq CircleDeg1Lift.units_semiconj_of_translationNumber_eq

/- warning: circle_deg1_lift.semiconj_of_is_unit_of_translation_number_eq -> CircleDeg1Lift.semiconj_of_isUnit_of_translationNumber_eq is a dubious translation:
lean 3 declaration is
  forall {f₁ : CircleDeg1Lift} {f₂ : CircleDeg1Lift}, (IsUnit.{0} CircleDeg1Lift CircleDeg1Lift.monoid f₁) -> (IsUnit.{0} CircleDeg1Lift CircleDeg1Lift.monoid f₂) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f₁) (CircleDeg1Lift.translationNumber f₂)) -> (Exists.{1} CircleDeg1Lift (fun (F : CircleDeg1Lift) => Function.Semiconj.{0, 0} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun F) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f₁) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f₂)))
but is expected to have type
  forall {f₁ : CircleDeg1Lift} {f₂ : CircleDeg1Lift}, (IsUnit.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f₁) -> (IsUnit.{0} CircleDeg1Lift CircleDeg1Lift.instMonoidCircleDeg1Lift f₂) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f₁) (CircleDeg1Lift.translationNumber f₂)) -> (Exists.{1} CircleDeg1Lift (fun (F : CircleDeg1Lift) => Function.Semiconj.{0, 0} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) F) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f₁) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f₂)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.semiconj_of_is_unit_of_translation_number_eq CircleDeg1Lift.semiconj_of_isUnit_of_translationNumber_eqₓ'. -/
/-- If two lifts of circle homeomorphisms have the same translation number, then they are
semiconjugate by a `circle_deg1_lift`. This version uses assumptions `is_unit f₁` and `is_unit f₂`
to assume that `f₁` and `f₂` are homeomorphisms. -/
theorem semiconj_of_isUnit_of_translationNumber_eq {f₁ f₂ : CircleDeg1Lift} (h₁ : IsUnit f₁)
    (h₂ : IsUnit f₂) (h : τ f₁ = τ f₂) : ∃ F : CircleDeg1Lift, Semiconj F f₁ f₂ :=
  by
  rcases h₁, h₂ with ⟨⟨f₁, rfl⟩, ⟨f₂, rfl⟩⟩
  exact units_semiconj_of_translation_number_eq h
#align circle_deg1_lift.semiconj_of_is_unit_of_translation_number_eq CircleDeg1Lift.semiconj_of_isUnit_of_translationNumber_eq

/- warning: circle_deg1_lift.semiconj_of_bijective_of_translation_number_eq -> CircleDeg1Lift.semiconj_of_bijective_of_translationNumber_eq is a dubious translation:
lean 3 declaration is
  forall {f₁ : CircleDeg1Lift} {f₂ : CircleDeg1Lift}, (Function.Bijective.{1, 1} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f₁)) -> (Function.Bijective.{1, 1} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f₂)) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f₁) (CircleDeg1Lift.translationNumber f₂)) -> (Exists.{1} CircleDeg1Lift (fun (F : CircleDeg1Lift) => Function.Semiconj.{0, 0} Real Real (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun F) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f₁) (coeFn.{1, 1} CircleDeg1Lift (fun (_x : CircleDeg1Lift) => Real -> Real) CircleDeg1Lift.hasCoeToFun f₂)))
but is expected to have type
  forall {f₁ : CircleDeg1Lift} {f₂ : CircleDeg1Lift}, (Function.Bijective.{1, 1} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f₁)) -> (Function.Bijective.{1, 1} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f₂)) -> (Eq.{1} Real (CircleDeg1Lift.translationNumber f₁) (CircleDeg1Lift.translationNumber f₂)) -> (Exists.{1} CircleDeg1Lift (fun (F : CircleDeg1Lift) => Function.Semiconj.{0, 0} Real Real (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) F) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f₁) (FunLike.coe.{1, 1, 1} CircleDeg1Lift Real (fun (_x : Real) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Real) => Real) _x) (InfHomClass.toFunLike.{0, 0, 0} CircleDeg1Lift Real Real (Lattice.toInf.{0} Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder))) (Lattice.toInf.{0} Real Real.lattice) (LatticeHomClass.toInfHomClass.{0, 0, 0} CircleDeg1Lift Real Real (DistribLattice.toLattice.{0} Real (instDistribLattice.{0} Real Real.linearOrder)) Real.lattice (OrderHomClass.toLatticeHomClass.{0, 0, 0} CircleDeg1Lift Real Real Real.linearOrder Real.lattice CircleDeg1Lift.instOrderHomClassCircleDeg1LiftRealInstLEReal))) f₂)))
Case conversion may be inaccurate. Consider using '#align circle_deg1_lift.semiconj_of_bijective_of_translation_number_eq CircleDeg1Lift.semiconj_of_bijective_of_translationNumber_eqₓ'. -/
/-- If two lifts of circle homeomorphisms have the same translation number, then they are
semiconjugate by a `circle_deg1_lift`. This version uses assumptions `bijective f₁` and
`bijective f₂` to assume that `f₁` and `f₂` are homeomorphisms. -/
theorem semiconj_of_bijective_of_translationNumber_eq {f₁ f₂ : CircleDeg1Lift} (h₁ : Bijective f₁)
    (h₂ : Bijective f₂) (h : τ f₁ = τ f₂) : ∃ F : CircleDeg1Lift, Semiconj F f₁ f₂ :=
  semiconj_of_isUnit_of_translationNumber_eq (isUnit_iff_bijective.2 h₁) (isUnit_iff_bijective.2 h₂)
    h
#align circle_deg1_lift.semiconj_of_bijective_of_translation_number_eq CircleDeg1Lift.semiconj_of_bijective_of_translationNumber_eq

end CircleDeg1Lift

