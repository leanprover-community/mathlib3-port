/-
Copyright (c) 2017 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Buzzard, Mario Carneiro

! This file was ported from Lean 3 source module data.complex.basic
! leanprover-community/mathlib commit 92ca63f0fb391a9ca5f22d2409a6080e786d99f7
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Real.Sqrt

/-!
# The complex numbers

The complex numbers are modelled as ℝ^2 in the obvious way and it is shown that they form a field
of characteristic zero. The result that the complex numbers are algebraically closed, see
`field_theory.algebraic_closure`.
-/


open BigOperators

open Set Function

/-! ### Definition and basic arithmmetic -/


#print Complex /-
/-- Complex numbers consist of two `real`s: a real part `re` and an imaginary part `im`. -/
structure Complex : Type where
  re : ℝ
  im : ℝ
#align complex Complex
-/

-- mathport name: exprℂ
notation "ℂ" => Complex

namespace Complex

open ComplexConjugate

noncomputable instance : DecidableEq ℂ :=
  Classical.decEq _

#print Complex.equivRealProd /-
/-- The equivalence between the complex numbers and `ℝ × ℝ`. -/
@[simps apply]
def equivRealProd : ℂ ≃ ℝ × ℝ where
  toFun z := ⟨z.re, z.im⟩
  invFun p := ⟨p.1, p.2⟩
  left_inv := fun ⟨x, y⟩ => rfl
  right_inv := fun ⟨x, y⟩ => rfl
#align complex.equiv_real_prod Complex.equivRealProd
-/

#print Complex.eta /-
@[simp]
theorem eta : ∀ z : ℂ, Complex.mk z.re z.im = z
  | ⟨a, b⟩ => rfl
#align complex.eta Complex.eta
-/

#print Complex.ext /-
@[ext]
theorem ext : ∀ {z w : ℂ}, z.re = w.re → z.im = w.im → z = w
  | ⟨zr, zi⟩, ⟨_, _⟩, rfl, rfl => rfl
#align complex.ext Complex.ext
-/

#print Complex.ext_iff /-
theorem ext_iff {z w : ℂ} : z = w ↔ z.re = w.re ∧ z.im = w.im :=
  ⟨fun H => by simp [H], fun h => ext h.1 h.2⟩
#align complex.ext_iff Complex.ext_iff
-/

#print Complex.re_surjective /-
theorem re_surjective : Surjective re := fun x => ⟨⟨x, 0⟩, rfl⟩
#align complex.re_surjective Complex.re_surjective
-/

#print Complex.im_surjective /-
theorem im_surjective : Surjective im := fun y => ⟨⟨0, y⟩, rfl⟩
#align complex.im_surjective Complex.im_surjective
-/

#print Complex.range_re /-
@[simp]
theorem range_re : range re = univ :=
  re_surjective.range_eq
#align complex.range_re Complex.range_re
-/

#print Complex.range_im /-
@[simp]
theorem range_im : range im = univ :=
  im_surjective.range_eq
#align complex.range_im Complex.range_im
-/

instance : Coe ℝ ℂ :=
  ⟨fun r => ⟨r, 0⟩⟩

#print Complex.ofReal_re /-
@[simp, norm_cast]
theorem ofReal_re (r : ℝ) : (r : ℂ).re = r :=
  rfl
#align complex.of_real_re Complex.ofReal_re
-/

/- warning: complex.of_real_im -> Complex.ofReal_im is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Real (Complex.im ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  forall (r : Real), Eq.{1} Real (Complex.im (Complex.ofReal' r)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align complex.of_real_im Complex.ofReal_imₓ'. -/
@[simp, norm_cast]
theorem ofReal_im (r : ℝ) : (r : ℂ).im = 0 :=
  rfl
#align complex.of_real_im Complex.ofReal_im

/- warning: complex.of_real_def -> Complex.ofReal_def is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) (Complex.mk r (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall (r : Real), Eq.{1} Complex (Complex.ofReal' r) (Complex.mk r (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align complex.of_real_def Complex.ofReal_defₓ'. -/
theorem ofReal_def (r : ℝ) : (r : ℂ) = ⟨r, 0⟩ :=
  rfl
#align complex.of_real_def Complex.ofReal_def

/- warning: complex.of_real_inj -> Complex.ofReal_inj is a dubious translation:
lean 3 declaration is
  forall {z : Real} {w : Real}, Iff (Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) z) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) w)) (Eq.{1} Real z w)
but is expected to have type
  forall {z : Real} {w : Real}, Iff (Eq.{1} Complex (Complex.ofReal' z) (Complex.ofReal' w)) (Eq.{1} Real z w)
Case conversion may be inaccurate. Consider using '#align complex.of_real_inj Complex.ofReal_injₓ'. -/
@[simp, norm_cast]
theorem ofReal_inj {z w : ℝ} : (z : ℂ) = w ↔ z = w :=
  ⟨congr_arg re, congr_arg _⟩
#align complex.of_real_inj Complex.ofReal_inj

/- warning: complex.of_real_injective -> Complex.ofReal_injective is a dubious translation:
lean 3 declaration is
  Function.Injective.{1, 1} Real Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))))
but is expected to have type
  Function.Injective.{1, 1} Real Complex Complex.ofReal'
Case conversion may be inaccurate. Consider using '#align complex.of_real_injective Complex.ofReal_injectiveₓ'. -/
theorem ofReal_injective : Function.Injective (coe : ℝ → ℂ) := fun z w => congr_arg re
#align complex.of_real_injective Complex.ofReal_injective

/- warning: complex.can_lift -> Complex.canLift is a dubious translation:
lean 3 declaration is
  CanLift.{1, 1} Complex Real ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe)))) (fun (z : Complex) => Eq.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  CanLift.{1, 1} Complex Real Complex.ofReal' (fun (z : Complex) => Eq.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align complex.can_lift Complex.canLiftₓ'. -/
instance canLift : CanLift ℂ ℝ coe fun z => z.im = 0 where prf z hz := ⟨z.re, ext rfl hz.symm⟩
#align complex.can_lift Complex.canLift

#print Complex.Set.reProdIm /-
/-- The product of a set on the real axis and a set on the imaginary axis of the complex plane,
denoted by `s ×ℂ t`. -/
def Complex.Set.reProdIm (s t : Set ℝ) : Set ℂ :=
  re ⁻¹' s ∩ im ⁻¹' t
#align set.re_prod_im Complex.Set.reProdIm
-/

-- mathport name: «expr ×ℂ »
infixl:72 " ×ℂ " => Complex.Set.reProdIm

#print Complex.mem_reProdIm /-
theorem mem_reProdIm {z : ℂ} {s t : Set ℝ} : z ∈ s ×ℂ t ↔ z.re ∈ s ∧ z.im ∈ t :=
  Iff.rfl
#align complex.mem_re_prod_im Complex.mem_reProdIm
-/

instance : Zero ℂ :=
  ⟨(0 : ℝ)⟩

instance : Inhabited ℂ :=
  ⟨0⟩

/- warning: complex.zero_re -> Complex.zero_re is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (Complex.re (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  Eq.{1} Real (Complex.re (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align complex.zero_re Complex.zero_reₓ'. -/
@[simp]
theorem zero_re : (0 : ℂ).re = 0 :=
  rfl
#align complex.zero_re Complex.zero_re

/- warning: complex.zero_im -> Complex.zero_im is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (Complex.im (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  Eq.{1} Real (Complex.im (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align complex.zero_im Complex.zero_imₓ'. -/
@[simp]
theorem zero_im : (0 : ℂ).im = 0 :=
  rfl
#align complex.zero_im Complex.zero_im

/- warning: complex.of_real_zero -> Complex.ofReal_zero is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))
but is expected to have type
  Eq.{1} Complex (Complex.ofReal' (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))
Case conversion may be inaccurate. Consider using '#align complex.of_real_zero Complex.ofReal_zeroₓ'. -/
@[simp, norm_cast]
theorem ofReal_zero : ((0 : ℝ) : ℂ) = 0 :=
  rfl
#align complex.of_real_zero Complex.ofReal_zero

/- warning: complex.of_real_eq_zero -> Complex.ofReal_eq_zero is a dubious translation:
lean 3 declaration is
  forall {z : Real}, Iff (Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) z) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))) (Eq.{1} Real z (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall {z : Real}, Iff (Eq.{1} Complex (Complex.ofReal' z) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) (Eq.{1} Real z (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align complex.of_real_eq_zero Complex.ofReal_eq_zeroₓ'. -/
@[simp]
theorem ofReal_eq_zero {z : ℝ} : (z : ℂ) = 0 ↔ z = 0 :=
  ofReal_inj
#align complex.of_real_eq_zero Complex.ofReal_eq_zero

/- warning: complex.of_real_ne_zero -> Complex.ofReal_ne_zero is a dubious translation:
lean 3 declaration is
  forall {z : Real}, Iff (Ne.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) z) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))) (Ne.{1} Real z (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall {z : Real}, Iff (Ne.{1} Complex (Complex.ofReal' z) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) (Ne.{1} Real z (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align complex.of_real_ne_zero Complex.ofReal_ne_zeroₓ'. -/
theorem ofReal_ne_zero {z : ℝ} : (z : ℂ) ≠ 0 ↔ z ≠ 0 :=
  not_congr ofReal_eq_zero
#align complex.of_real_ne_zero Complex.ofReal_ne_zero

instance : One ℂ :=
  ⟨(1 : ℝ)⟩

/- warning: complex.one_re -> Complex.one_re is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (Complex.re (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  Eq.{1} Real (Complex.re (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.one_re Complex.one_reₓ'. -/
@[simp]
theorem one_re : (1 : ℂ).re = 1 :=
  rfl
#align complex.one_re Complex.one_re

/- warning: complex.one_im -> Complex.one_im is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (Complex.im (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  Eq.{1} Real (Complex.im (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align complex.one_im Complex.one_imₓ'. -/
@[simp]
theorem one_im : (1 : ℂ).im = 0 :=
  rfl
#align complex.one_im Complex.one_im

/- warning: complex.of_real_one -> Complex.ofReal_one is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))
but is expected to have type
  Eq.{1} Complex (Complex.ofReal' (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))
Case conversion may be inaccurate. Consider using '#align complex.of_real_one Complex.ofReal_oneₓ'. -/
@[simp, norm_cast]
theorem ofReal_one : ((1 : ℝ) : ℂ) = 1 :=
  rfl
#align complex.of_real_one Complex.ofReal_one

/- warning: complex.of_real_eq_one -> Complex.ofReal_eq_one is a dubious translation:
lean 3 declaration is
  forall {z : Real}, Iff (Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) z) (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))) (Eq.{1} Real z (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall {z : Real}, Iff (Eq.{1} Complex (Complex.ofReal' z) (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) (Eq.{1} Real z (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align complex.of_real_eq_one Complex.ofReal_eq_oneₓ'. -/
@[simp]
theorem ofReal_eq_one {z : ℝ} : (z : ℂ) = 1 ↔ z = 1 :=
  ofReal_inj
#align complex.of_real_eq_one Complex.ofReal_eq_one

/- warning: complex.of_real_ne_one -> Complex.ofReal_ne_one is a dubious translation:
lean 3 declaration is
  forall {z : Real}, Iff (Ne.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) z) (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))) (Ne.{1} Real z (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall {z : Real}, Iff (Ne.{1} Complex (Complex.ofReal' z) (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) (Ne.{1} Real z (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align complex.of_real_ne_one Complex.ofReal_ne_oneₓ'. -/
theorem ofReal_ne_one {z : ℝ} : (z : ℂ) ≠ 1 ↔ z ≠ 1 :=
  not_congr ofReal_eq_one
#align complex.of_real_ne_one Complex.ofReal_ne_one

instance : Add ℂ :=
  ⟨fun z w => ⟨z.re + w.re, z.im + w.im⟩⟩

/- warning: complex.add_re -> Complex.add_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.re (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) z w)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Complex.re z) (Complex.re w))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.re (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Complex.re z) (Complex.re w))
Case conversion may be inaccurate. Consider using '#align complex.add_re Complex.add_reₓ'. -/
@[simp]
theorem add_re (z w : ℂ) : (z + w).re = z.re + w.re :=
  rfl
#align complex.add_re Complex.add_re

/- warning: complex.add_im -> Complex.add_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.im (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) z w)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Complex.im z) (Complex.im w))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.im (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Complex.im z) (Complex.im w))
Case conversion may be inaccurate. Consider using '#align complex.add_im Complex.add_imₓ'. -/
@[simp]
theorem add_im (z w : ℂ) : (z + w).im = z.im + w.im :=
  rfl
#align complex.add_im Complex.add_im

/- warning: complex.bit0_re -> Complex.bit0_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.re (bit0.{0} Complex Complex.hasAdd z)) (bit0.{0} Real Real.hasAdd (Complex.re z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.re (bit0.{0} Complex Complex.instAddComplex z)) (bit0.{0} Real Real.instAddReal (Complex.re z))
Case conversion may be inaccurate. Consider using '#align complex.bit0_re Complex.bit0_reₓ'. -/
@[simp]
theorem bit0_re (z : ℂ) : (bit0 z).re = bit0 z.re :=
  rfl
#align complex.bit0_re Complex.bit0_re

/- warning: complex.bit1_re -> Complex.bit1_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.re (bit1.{0} Complex Complex.hasOne Complex.hasAdd z)) (bit1.{0} Real Real.hasOne Real.hasAdd (Complex.re z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.re (bit1.{0} Complex Complex.instOneComplex Complex.instAddComplex z)) (bit1.{0} Real Real.instOneReal Real.instAddReal (Complex.re z))
Case conversion may be inaccurate. Consider using '#align complex.bit1_re Complex.bit1_reₓ'. -/
@[simp]
theorem bit1_re (z : ℂ) : (bit1 z).re = bit1 z.re :=
  rfl
#align complex.bit1_re Complex.bit1_re

/- warning: complex.bit0_im -> Complex.bit0_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.im (bit0.{0} Complex Complex.hasAdd z)) (bit0.{0} Real Real.hasAdd (Complex.im z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.im (bit0.{0} Complex Complex.instAddComplex z)) (bit0.{0} Real Real.instAddReal (Complex.im z))
Case conversion may be inaccurate. Consider using '#align complex.bit0_im Complex.bit0_imₓ'. -/
@[simp]
theorem bit0_im (z : ℂ) : (bit0 z).im = bit0 z.im :=
  Eq.refl _
#align complex.bit0_im Complex.bit0_im

/- warning: complex.bit1_im -> Complex.bit1_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.im (bit1.{0} Complex Complex.hasOne Complex.hasAdd z)) (bit0.{0} Real Real.hasAdd (Complex.im z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.im (bit1.{0} Complex Complex.instOneComplex Complex.instAddComplex z)) (bit0.{0} Real Real.instAddReal (Complex.im z))
Case conversion may be inaccurate. Consider using '#align complex.bit1_im Complex.bit1_imₓ'. -/
@[simp]
theorem bit1_im (z : ℂ) : (bit1 z).im = bit0 z.im :=
  add_zero _
#align complex.bit1_im Complex.bit1_im

/- warning: complex.of_real_add -> Complex.ofReal_add is a dubious translation:
lean 3 declaration is
  forall (r : Real) (s : Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) r s)) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) s))
but is expected to have type
  forall (r : Real) (s : Real), Eq.{1} Complex (Complex.ofReal' (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) r s)) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) (Complex.ofReal' r) (Complex.ofReal' s))
Case conversion may be inaccurate. Consider using '#align complex.of_real_add Complex.ofReal_addₓ'. -/
@[simp, norm_cast]
theorem ofReal_add (r s : ℝ) : ((r + s : ℝ) : ℂ) = r + s :=
  ext_iff.2 <| by simp
#align complex.of_real_add Complex.ofReal_add

/- warning: complex.of_real_bit0 -> Complex.ofReal_bit0 is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (bit0.{0} Real Real.hasAdd r)) (bit0.{0} Complex Complex.hasAdd ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r))
but is expected to have type
  forall (r : Real), Eq.{1} Complex (Complex.ofReal' (bit0.{0} Real Real.instAddReal r)) (bit0.{0} Complex Complex.instAddComplex (Complex.ofReal' r))
Case conversion may be inaccurate. Consider using '#align complex.of_real_bit0 Complex.ofReal_bit0ₓ'. -/
@[simp, norm_cast]
theorem ofReal_bit0 (r : ℝ) : ((bit0 r : ℝ) : ℂ) = bit0 r :=
  ext_iff.2 <| by simp [bit0]
#align complex.of_real_bit0 Complex.ofReal_bit0

/- warning: complex.of_real_bit1 -> Complex.ofReal_bit1 is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (bit1.{0} Real Real.hasOne Real.hasAdd r)) (bit1.{0} Complex Complex.hasOne Complex.hasAdd ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r))
but is expected to have type
  forall (r : Real), Eq.{1} Complex (Complex.ofReal' (bit1.{0} Real Real.instOneReal Real.instAddReal r)) (bit1.{0} Complex Complex.instOneComplex Complex.instAddComplex (Complex.ofReal' r))
Case conversion may be inaccurate. Consider using '#align complex.of_real_bit1 Complex.ofReal_bit1ₓ'. -/
@[simp, norm_cast]
theorem ofReal_bit1 (r : ℝ) : ((bit1 r : ℝ) : ℂ) = bit1 r :=
  ext_iff.2 <| by simp [bit1]
#align complex.of_real_bit1 Complex.ofReal_bit1

instance : Neg ℂ :=
  ⟨fun z => ⟨-z.re, -z.im⟩⟩

/- warning: complex.neg_re -> Complex.neg_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.re (Neg.neg.{0} Complex Complex.hasNeg z)) (Neg.neg.{0} Real Real.hasNeg (Complex.re z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.re (Neg.neg.{0} Complex Complex.instNegComplex z)) (Neg.neg.{0} Real Real.instNegReal (Complex.re z))
Case conversion may be inaccurate. Consider using '#align complex.neg_re Complex.neg_reₓ'. -/
@[simp]
theorem neg_re (z : ℂ) : (-z).re = -z.re :=
  rfl
#align complex.neg_re Complex.neg_re

/- warning: complex.neg_im -> Complex.neg_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.im (Neg.neg.{0} Complex Complex.hasNeg z)) (Neg.neg.{0} Real Real.hasNeg (Complex.im z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.im (Neg.neg.{0} Complex Complex.instNegComplex z)) (Neg.neg.{0} Real Real.instNegReal (Complex.im z))
Case conversion may be inaccurate. Consider using '#align complex.neg_im Complex.neg_imₓ'. -/
@[simp]
theorem neg_im (z : ℂ) : (-z).im = -z.im :=
  rfl
#align complex.neg_im Complex.neg_im

/- warning: complex.of_real_neg -> Complex.ofReal_neg is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Neg.neg.{0} Real Real.hasNeg r)) (Neg.neg.{0} Complex Complex.hasNeg ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r))
but is expected to have type
  forall (r : Real), Eq.{1} Complex (Complex.ofReal' (Neg.neg.{0} Real Real.instNegReal r)) (Neg.neg.{0} Complex Complex.instNegComplex (Complex.ofReal' r))
Case conversion may be inaccurate. Consider using '#align complex.of_real_neg Complex.ofReal_negₓ'. -/
@[simp, norm_cast]
theorem ofReal_neg (r : ℝ) : ((-r : ℝ) : ℂ) = -r :=
  ext_iff.2 <| by simp
#align complex.of_real_neg Complex.ofReal_neg

instance : Sub ℂ :=
  ⟨fun z w => ⟨z.re - w.re, z.im - w.im⟩⟩

instance : Mul ℂ :=
  ⟨fun z w => ⟨z.re * w.re - z.im * w.im, z.re * w.im + z.im * w.re⟩⟩

/- warning: complex.mul_re -> Complex.mul_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z w)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.re z) (Complex.re w)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.im z) (Complex.im w)))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) z w)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.re z) (Complex.re w)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.im z) (Complex.im w)))
Case conversion may be inaccurate. Consider using '#align complex.mul_re Complex.mul_reₓ'. -/
@[simp]
theorem mul_re (z w : ℂ) : (z * w).re = z.re * w.re - z.im * w.im :=
  rfl
#align complex.mul_re Complex.mul_re

/- warning: complex.mul_im -> Complex.mul_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.im (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z w)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.re z) (Complex.im w)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.im z) (Complex.re w)))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.im (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) z w)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.re z) (Complex.im w)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.im z) (Complex.re w)))
Case conversion may be inaccurate. Consider using '#align complex.mul_im Complex.mul_imₓ'. -/
@[simp]
theorem mul_im (z w : ℂ) : (z * w).im = z.re * w.im + z.im * w.re :=
  rfl
#align complex.mul_im Complex.mul_im

/- warning: complex.of_real_mul -> Complex.ofReal_mul is a dubious translation:
lean 3 declaration is
  forall (r : Real) (s : Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) r s)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) s))
but is expected to have type
  forall (r : Real) (s : Real), Eq.{1} Complex (Complex.ofReal' (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) r s)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' r) (Complex.ofReal' s))
Case conversion may be inaccurate. Consider using '#align complex.of_real_mul Complex.ofReal_mulₓ'. -/
@[simp, norm_cast]
theorem ofReal_mul (r s : ℝ) : ((r * s : ℝ) : ℂ) = r * s :=
  ext_iff.2 <| by simp
#align complex.of_real_mul Complex.ofReal_mul

/- warning: complex.of_real_mul_re -> Complex.ofReal_mul_re is a dubious translation:
lean 3 declaration is
  forall (r : Real) (z : Complex), Eq.{1} Real (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) z)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) r (Complex.re z))
but is expected to have type
  forall (r : Real) (z : Complex), Eq.{1} Real (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' r) z)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) r (Complex.re z))
Case conversion may be inaccurate. Consider using '#align complex.of_real_mul_re Complex.ofReal_mul_reₓ'. -/
theorem ofReal_mul_re (r : ℝ) (z : ℂ) : (↑r * z).re = r * z.re := by simp
#align complex.of_real_mul_re Complex.ofReal_mul_re

/- warning: complex.of_real_mul_im -> Complex.ofReal_mul_im is a dubious translation:
lean 3 declaration is
  forall (r : Real) (z : Complex), Eq.{1} Real (Complex.im (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) z)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) r (Complex.im z))
but is expected to have type
  forall (r : Real) (z : Complex), Eq.{1} Real (Complex.im (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' r) z)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) r (Complex.im z))
Case conversion may be inaccurate. Consider using '#align complex.of_real_mul_im Complex.ofReal_mul_imₓ'. -/
theorem ofReal_mul_im (r : ℝ) (z : ℂ) : (↑r * z).im = r * z.im := by simp
#align complex.of_real_mul_im Complex.ofReal_mul_im

/- warning: complex.of_real_mul' -> Complex.ofReal_mul' is a dubious translation:
lean 3 declaration is
  forall (r : Real) (z : Complex), Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) z) (Complex.mk (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) r (Complex.re z)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) r (Complex.im z)))
but is expected to have type
  forall (r : Real) (z : Complex), Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' r) z) (Complex.mk (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) r (Complex.re z)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) r (Complex.im z)))
Case conversion may be inaccurate. Consider using '#align complex.of_real_mul' Complex.ofReal_mul'ₓ'. -/
theorem ofReal_mul' (r : ℝ) (z : ℂ) : ↑r * z = ⟨r * z.re, r * z.im⟩ :=
  ext (ofReal_mul_re _ _) (ofReal_mul_im _ _)
#align complex.of_real_mul' Complex.ofReal_mul'

/-! ### The imaginary unit, `I` -/


#print Complex.I /-
/-- The imaginary unit. -/
def I : ℂ :=
  ⟨0, 1⟩
#align complex.I Complex.I
-/

/- warning: complex.I_re -> Complex.i_re is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (Complex.re Complex.I) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  Eq.{1} Real (Complex.re Complex.I) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align complex.I_re Complex.i_reₓ'. -/
@[simp]
theorem i_re : I.re = 0 :=
  rfl
#align complex.I_re Complex.i_re

/- warning: complex.I_im -> Complex.i_im is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (Complex.im Complex.I) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  Eq.{1} Real (Complex.im Complex.I) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.I_im Complex.i_imₓ'. -/
@[simp]
theorem i_im : I.im = 1 :=
  rfl
#align complex.I_im Complex.i_im

/- warning: complex.I_mul_I -> Complex.i_mul_I is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) Complex.I Complex.I) (Neg.neg.{0} Complex Complex.hasNeg (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne))))
but is expected to have type
  Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) Complex.I Complex.I) (Neg.neg.{0} Complex Complex.instNegComplex (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex)))
Case conversion may be inaccurate. Consider using '#align complex.I_mul_I Complex.i_mul_Iₓ'. -/
@[simp]
theorem i_mul_I : I * I = -1 :=
  ext_iff.2 <| by simp
#align complex.I_mul_I Complex.i_mul_I

/- warning: complex.I_mul -> Complex.i_mul is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) Complex.I z) (Complex.mk (Neg.neg.{0} Real Real.hasNeg (Complex.im z)) (Complex.re z))
but is expected to have type
  forall (z : Complex), Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) Complex.I z) (Complex.mk (Neg.neg.{0} Real Real.instNegReal (Complex.im z)) (Complex.re z))
Case conversion may be inaccurate. Consider using '#align complex.I_mul Complex.i_mulₓ'. -/
theorem i_mul (z : ℂ) : I * z = ⟨-z.im, z.re⟩ :=
  ext_iff.2 <| by simp
#align complex.I_mul Complex.i_mul

/- warning: complex.I_ne_zero -> Complex.i_ne_zero is a dubious translation:
lean 3 declaration is
  Ne.{1} Complex Complex.I (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))
but is expected to have type
  Ne.{1} Complex Complex.I (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))
Case conversion may be inaccurate. Consider using '#align complex.I_ne_zero Complex.i_ne_zeroₓ'. -/
theorem i_ne_zero : (I : ℂ) ≠ 0 :=
  mt (congr_arg im) zero_ne_one.symm
#align complex.I_ne_zero Complex.i_ne_zero

/- warning: complex.mk_eq_add_mul_I -> Complex.mk_eq_add_mul_I is a dubious translation:
lean 3 declaration is
  forall (a : Real) (b : Real), Eq.{1} Complex (Complex.mk a b) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) a) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) b) Complex.I))
but is expected to have type
  forall (a : Real) (b : Real), Eq.{1} Complex (Complex.mk a b) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) (Complex.ofReal' a) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' b) Complex.I))
Case conversion may be inaccurate. Consider using '#align complex.mk_eq_add_mul_I Complex.mk_eq_add_mul_Iₓ'. -/
theorem mk_eq_add_mul_I (a b : ℝ) : Complex.mk a b = a + b * I :=
  ext_iff.2 <| by simp
#align complex.mk_eq_add_mul_I Complex.mk_eq_add_mul_I

/- warning: complex.re_add_im -> Complex.re_add_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Complex.re z)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Complex.im z)) Complex.I)) z
but is expected to have type
  forall (z : Complex), Eq.{1} Complex (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) (Complex.ofReal' (Complex.re z)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' (Complex.im z)) Complex.I)) z
Case conversion may be inaccurate. Consider using '#align complex.re_add_im Complex.re_add_imₓ'. -/
@[simp]
theorem re_add_im (z : ℂ) : (z.re : ℂ) + z.im * I = z :=
  ext_iff.2 <| by simp
#align complex.re_add_im Complex.re_add_im

/- warning: complex.mul_I_re -> Complex.mul_I_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z Complex.I)) (Neg.neg.{0} Real Real.hasNeg (Complex.im z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) z Complex.I)) (Neg.neg.{0} Real Real.instNegReal (Complex.im z))
Case conversion may be inaccurate. Consider using '#align complex.mul_I_re Complex.mul_I_reₓ'. -/
theorem mul_I_re (z : ℂ) : (z * I).re = -z.im := by simp
#align complex.mul_I_re Complex.mul_I_re

/- warning: complex.mul_I_im -> Complex.mul_I_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.im (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z Complex.I)) (Complex.re z)
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.im (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) z Complex.I)) (Complex.re z)
Case conversion may be inaccurate. Consider using '#align complex.mul_I_im Complex.mul_I_imₓ'. -/
theorem mul_I_im (z : ℂ) : (z * I).im = z.re := by simp
#align complex.mul_I_im Complex.mul_I_im

/- warning: complex.I_mul_re -> Complex.i_mul_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) Complex.I z)) (Neg.neg.{0} Real Real.hasNeg (Complex.im z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) Complex.I z)) (Neg.neg.{0} Real Real.instNegReal (Complex.im z))
Case conversion may be inaccurate. Consider using '#align complex.I_mul_re Complex.i_mul_reₓ'. -/
theorem i_mul_re (z : ℂ) : (I * z).re = -z.im := by simp
#align complex.I_mul_re Complex.i_mul_re

/- warning: complex.I_mul_im -> Complex.i_mul_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.im (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) Complex.I z)) (Complex.re z)
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.im (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) Complex.I z)) (Complex.re z)
Case conversion may be inaccurate. Consider using '#align complex.I_mul_im Complex.i_mul_imₓ'. -/
theorem i_mul_im (z : ℂ) : (I * z).im = z.re := by simp
#align complex.I_mul_im Complex.i_mul_im

#print Complex.equivRealProd_symm_apply /-
@[simp]
theorem equivRealProd_symm_apply (p : ℝ × ℝ) : equivRealProd.symm p = p.1 + p.2 * I := by
  ext <;> simp [equiv_real_prod]
#align complex.equiv_real_prod_symm_apply Complex.equivRealProd_symm_apply
-/

/-! ### Commutative ring instance and lemmas -/


/- We use a nonstandard formula for the `ℕ` and `ℤ` actions to make sure there is no
diamond from the other actions they inherit through the `ℝ`-action on `ℂ` and action transitivity
defined in `data.complex.module.lean`. -/
instance : Nontrivial ℂ :=
  pullback_nonzero re rfl rfl

instance : AddCommGroup ℂ := by
  refine_struct { zero := (0 : ℂ)
                  add := (· + ·)
                  neg := Neg.neg
                  sub := Sub.sub
                  nsmul := fun n z => ⟨n • z.re - 0 * z.im, n • z.im + 0 * z.re⟩
                  zsmul := fun n z => ⟨n • z.re - 0 * z.im, n • z.im + 0 * z.re⟩ } <;> intros <;>
            try rfl <;> apply ext_iff.2 <;> constructor <;> simp <;> · first |ring1|ring_nf

instance : AddGroupWithOne ℂ :=
  { Complex.addCommGroup with
    natCast := fun n => ⟨n, 0⟩
    natCast_zero := by ext <;> simp [Nat.cast]
    natCast_succ := fun _ => by ext <;> simp [Nat.cast]
    intCast := fun n => ⟨n, 0⟩
    intCast_ofNat := fun _ => by ext <;> simp [fun n => show @coe ℕ ℂ ⟨_⟩ n = ⟨n, 0⟩ from rfl]
    intCast_negSucc := fun _ => by ext <;> simp [fun n => show @coe ℕ ℂ ⟨_⟩ n = ⟨n, 0⟩ from rfl]
    one := 1 }

instance : CommRing ℂ := by
  refine_struct
                { Complex.addGroupWithOne with
                  zero := (0 : ℂ)
                  add := (· + ·)
                  one := 1
                  mul := (· * ·)
                  npow := @npowRec _ ⟨(1 : ℂ)⟩ ⟨(· * ·)⟩ } <;>
              intros <;>
            try rfl <;>
          apply ext_iff.2 <;>
        constructor <;>
      simp <;>
    · first |ring1|ring_nf

/-- This shortcut instance ensures we do not find `ring` via the noncomputable `complex.field`
instance. -/
instance : Ring ℂ := by infer_instance

/-- This shortcut instance ensures we do not find `comm_semiring` via the noncomputable
`complex.field` instance. -/
instance : CommSemiring ℂ :=
  inferInstance

/- warning: complex.re_add_group_hom -> Complex.reAddGroupHom is a dubious translation:
lean 3 declaration is
  AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)
but is expected to have type
  AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)
Case conversion may be inaccurate. Consider using '#align complex.re_add_group_hom Complex.reAddGroupHomₓ'. -/
/-- The "real part" map, considered as an additive group homomorphism. -/
def reAddGroupHom : ℂ →+ ℝ where
  toFun := re
  map_zero' := zero_re
  map_add' := add_re
#align complex.re_add_group_hom Complex.reAddGroupHom

/- warning: complex.coe_re_add_group_hom -> Complex.coe_reAddGroupHom is a dubious translation:
lean 3 declaration is
  Eq.{1} ((fun (_x : AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) => Complex -> Real) Complex.reAddGroupHom) (coeFn.{1, 1} (AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (fun (_x : AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) => Complex -> Real) (AddMonoidHom.hasCoeToFun.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) Complex.reAddGroupHom) Complex.re
but is expected to have type
  Eq.{1} (forall (a : Complex), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Complex) => Real) a) (FunLike.coe.{1, 1, 1} (AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Complex) => Real) _x) (AddHomClass.toFunLike.{0, 0, 0} (AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) Complex Real (AddZeroClass.toAdd.{0} Complex (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne)))) (AddZeroClass.toAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (AddMonoidHomClass.toAddHomClass.{0, 0, 0} (AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal) (AddMonoidHom.addMonoidHomClass.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)))) Complex.reAddGroupHom) Complex.re
Case conversion may be inaccurate. Consider using '#align complex.coe_re_add_group_hom Complex.coe_reAddGroupHomₓ'. -/
@[simp]
theorem coe_reAddGroupHom : (reAddGroupHom : ℂ → ℝ) = re :=
  rfl
#align complex.coe_re_add_group_hom Complex.coe_reAddGroupHom

/- warning: complex.im_add_group_hom -> Complex.imAddGroupHom is a dubious translation:
lean 3 declaration is
  AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)
but is expected to have type
  AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)
Case conversion may be inaccurate. Consider using '#align complex.im_add_group_hom Complex.imAddGroupHomₓ'. -/
/-- The "imaginary part" map, considered as an additive group homomorphism. -/
def imAddGroupHom : ℂ →+ ℝ where
  toFun := im
  map_zero' := zero_im
  map_add' := add_im
#align complex.im_add_group_hom Complex.imAddGroupHom

/- warning: complex.coe_im_add_group_hom -> Complex.coe_imAddGroupHom is a dubious translation:
lean 3 declaration is
  Eq.{1} ((fun (_x : AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) => Complex -> Real) Complex.imAddGroupHom) (coeFn.{1, 1} (AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) (fun (_x : AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) => Complex -> Real) (AddMonoidHom.hasCoeToFun.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.addMonoid)) Complex.imAddGroupHom) Complex.im
but is expected to have type
  Eq.{1} (forall (a : Complex), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Complex) => Real) a) (FunLike.coe.{1, 1, 1} (AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Complex) => Real) _x) (AddHomClass.toFunLike.{0, 0, 0} (AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) Complex Real (AddZeroClass.toAdd.{0} Complex (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne)))) (AddZeroClass.toAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) (AddMonoidHomClass.toAddHomClass.{0, 0, 0} (AddMonoidHom.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)) Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal) (AddMonoidHom.addMonoidHomClass.{0, 0} Complex Real (AddMonoid.toAddZeroClass.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne))) (AddMonoid.toAddZeroClass.{0} Real Real.instAddMonoidReal)))) Complex.imAddGroupHom) Complex.im
Case conversion may be inaccurate. Consider using '#align complex.coe_im_add_group_hom Complex.coe_imAddGroupHomₓ'. -/
@[simp]
theorem coe_imAddGroupHom : (imAddGroupHom : ℂ → ℝ) = im :=
  rfl
#align complex.coe_im_add_group_hom Complex.coe_imAddGroupHom

/- warning: complex.I_pow_bit0 -> Complex.i_pow_bit0 is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring))) Complex.I (bit0.{0} Nat Nat.hasAdd n)) (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring))) (Neg.neg.{0} Complex Complex.hasNeg (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))) n)
but is expected to have type
  forall (n : Nat), Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex))))) Complex.I (bit0.{0} Nat instAddNat n)) (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex))))) (Neg.neg.{0} Complex Complex.instNegComplex (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) n)
Case conversion may be inaccurate. Consider using '#align complex.I_pow_bit0 Complex.i_pow_bit0ₓ'. -/
@[simp]
theorem i_pow_bit0 (n : ℕ) : I ^ bit0 n = (-1) ^ n := by rw [pow_bit0', I_mul_I]
#align complex.I_pow_bit0 Complex.i_pow_bit0

/- warning: complex.I_pow_bit1 -> Complex.i_pow_bit1 is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring))) Complex.I (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring))) (Neg.neg.{0} Complex Complex.hasNeg (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))) n) Complex.I)
but is expected to have type
  forall (n : Nat), Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex))))) Complex.I (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex))))) (Neg.neg.{0} Complex Complex.instNegComplex (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) n) Complex.I)
Case conversion may be inaccurate. Consider using '#align complex.I_pow_bit1 Complex.i_pow_bit1ₓ'. -/
@[simp]
theorem i_pow_bit1 (n : ℕ) : I ^ bit1 n = (-1) ^ n * I := by rw [pow_bit1', I_mul_I]
#align complex.I_pow_bit1 Complex.i_pow_bit1

/-! ### Complex conjugation -/


/-- This defines the complex conjugate as the `star` operation of the `star_ring ℂ`. It
is recommended to use the ring endomorphism version `star_ring_end`, available under the
notation `conj` in the locale `complex_conjugate`. -/
instance : StarRing ℂ where
  unit z := ⟨z.re, -z.im⟩
  star_involutive x := by simp only [eta, neg_neg]
  star_mul a b := by ext <;> simp [add_comm] <;> ring
  star_add a b := by ext <;> simp [add_comm]

/- warning: complex.conj_re -> Complex.conj_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.re (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z)) (Complex.re z)
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.re (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (Complex.re z)
Case conversion may be inaccurate. Consider using '#align complex.conj_re Complex.conj_reₓ'. -/
@[simp]
theorem conj_re (z : ℂ) : (conj z).re = z.re :=
  rfl
#align complex.conj_re Complex.conj_re

/- warning: complex.conj_im -> Complex.conj_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.im (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z)) (Neg.neg.{0} Real Real.hasNeg (Complex.im z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.im (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (Neg.neg.{0} Real Real.instNegReal (Complex.im z))
Case conversion may be inaccurate. Consider using '#align complex.conj_im Complex.conj_imₓ'. -/
@[simp]
theorem conj_im (z : ℂ) : (conj z).im = -z.im :=
  rfl
#align complex.conj_im Complex.conj_im

/- warning: complex.conj_of_real -> Complex.conj_ofReal is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r)
but is expected to have type
  forall (r : Real), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) (Complex.ofReal' r)) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) (Complex.ofReal' r)) (Complex.ofReal' r)
Case conversion may be inaccurate. Consider using '#align complex.conj_of_real Complex.conj_ofRealₓ'. -/
theorem conj_ofReal (r : ℝ) : conj (r : ℂ) = r :=
  ext_iff.2 <| by simp [conj]
#align complex.conj_of_real Complex.conj_ofReal

/- warning: complex.conj_I -> Complex.conj_I is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) Complex.I) (Neg.neg.{0} Complex Complex.hasNeg Complex.I)
but is expected to have type
  Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) Complex.I) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) Complex.I) (Neg.neg.{0} Complex Complex.instNegComplex Complex.I)
Case conversion may be inaccurate. Consider using '#align complex.conj_I Complex.conj_Iₓ'. -/
@[simp]
theorem conj_I : conj I = -I :=
  ext_iff.2 <| by simp
#align complex.conj_I Complex.conj_I

/- warning: complex.conj_bit0 -> Complex.conj_bit0 is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) (bit0.{0} Complex Complex.hasAdd z)) (bit0.{0} Complex Complex.hasAdd (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z))
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) (bit0.{0} Complex Complex.instAddComplex z)) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) (bit0.{0} Complex Complex.instAddComplex z)) (bit0.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex.instAddComplex (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z))
Case conversion may be inaccurate. Consider using '#align complex.conj_bit0 Complex.conj_bit0ₓ'. -/
theorem conj_bit0 (z : ℂ) : conj (bit0 z) = bit0 (conj z) :=
  ext_iff.2 <| by simp [bit0]
#align complex.conj_bit0 Complex.conj_bit0

/- warning: complex.conj_bit1 -> Complex.conj_bit1 is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) (bit1.{0} Complex Complex.hasOne Complex.hasAdd z)) (bit1.{0} Complex Complex.hasOne Complex.hasAdd (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z))
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) (bit1.{0} Complex Complex.instOneComplex Complex.instAddComplex z)) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) (bit1.{0} Complex Complex.instOneComplex Complex.instAddComplex z)) (bit1.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex.instOneComplex Complex.instAddComplex (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z))
Case conversion may be inaccurate. Consider using '#align complex.conj_bit1 Complex.conj_bit1ₓ'. -/
theorem conj_bit1 (z : ℂ) : conj (bit1 z) = bit1 (conj z) :=
  ext_iff.2 <| by simp [bit0]
#align complex.conj_bit1 Complex.conj_bit1

/- warning: complex.conj_neg_I -> Complex.conj_neg_I is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) (Neg.neg.{0} Complex Complex.hasNeg Complex.I)) Complex.I
but is expected to have type
  Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) (Neg.neg.{0} Complex Complex.instNegComplex Complex.I)) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) (Neg.neg.{0} Complex Complex.instNegComplex Complex.I)) Complex.I
Case conversion may be inaccurate. Consider using '#align complex.conj_neg_I Complex.conj_neg_Iₓ'. -/
@[simp]
theorem conj_neg_I : conj (-I) = I :=
  ext_iff.2 <| by simp
#align complex.conj_neg_I Complex.conj_neg_I

/- warning: complex.eq_conj_iff_real -> Complex.eq_conj_iff_real is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Iff (Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z) z) (Exists.{1} Real (fun (r : Real) => Eq.{1} Complex z ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r)))
but is expected to have type
  forall {z : Complex}, Iff (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z) z) (Exists.{1} Real (fun (r : Real) => Eq.{1} Complex z (Complex.ofReal' r)))
Case conversion may be inaccurate. Consider using '#align complex.eq_conj_iff_real Complex.eq_conj_iff_realₓ'. -/
theorem eq_conj_iff_real {z : ℂ} : conj z = z ↔ ∃ r : ℝ, z = r :=
  ⟨fun h => ⟨z.re, ext rfl <| eq_zero_of_neg_eq (congr_arg im h)⟩, fun ⟨h, e⟩ => by
    rw [e, conj_of_real]⟩
#align complex.eq_conj_iff_real Complex.eq_conj_iff_real

/- warning: complex.eq_conj_iff_re -> Complex.eq_conj_iff_re is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Iff (Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z) z) (Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Complex.re z)) z)
but is expected to have type
  forall {z : Complex}, Iff (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z) z) (Eq.{1} Complex (Complex.ofReal' (Complex.re z)) z)
Case conversion may be inaccurate. Consider using '#align complex.eq_conj_iff_re Complex.eq_conj_iff_reₓ'. -/
theorem eq_conj_iff_re {z : ℂ} : conj z = z ↔ (z.re : ℂ) = z :=
  eq_conj_iff_real.trans ⟨by rintro ⟨r, rfl⟩ <;> simp, fun h => ⟨_, h.symm⟩⟩
#align complex.eq_conj_iff_re Complex.eq_conj_iff_re

/- warning: complex.eq_conj_iff_im -> Complex.eq_conj_iff_im is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Iff (Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z) z) (Eq.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall {z : Complex}, Iff (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z) z) (Eq.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align complex.eq_conj_iff_im Complex.eq_conj_iff_imₓ'. -/
theorem eq_conj_iff_im {z : ℂ} : conj z = z ↔ z.im = 0 :=
  ⟨fun h => add_self_eq_zero.mp (neg_eq_iff_add_eq_zero.mp (congr_arg im h)), fun h =>
    ext rfl (neg_eq_iff_add_eq_zero.mpr (add_self_eq_zero.mpr h))⟩
#align complex.eq_conj_iff_im Complex.eq_conj_iff_im

/- warning: complex.star_def -> Complex.star_def is a dubious translation:
lean 3 declaration is
  Eq.{1} (Complex -> Complex) (Star.star.{0} Complex (InvolutiveStar.toHasStar.{0} Complex (StarAddMonoid.toHasInvolutiveStar.{0} Complex (AddCommMonoid.toAddMonoid.{0} Complex (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} Complex (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{0} Complex (NonUnitalRing.toNonUnitalSemiring.{0} Complex (NonUnitalCommRing.toNonUnitalRing.{0} Complex (CommRing.toNonUnitalCommRing.{0} Complex Complex.commRing)))))) (StarRing.toStarAddMonoid.{0} Complex (NonUnitalRing.toNonUnitalSemiring.{0} Complex (NonUnitalCommRing.toNonUnitalRing.{0} Complex (CommRing.toNonUnitalCommRing.{0} Complex Complex.commRing))) Complex.starRing)))) (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing))
but is expected to have type
  Eq.{1} (Complex -> Complex) (Star.star.{0} Complex (InvolutiveStar.toStar.{0} Complex (StarAddMonoid.toInvolutiveStar.{0} Complex (AddMonoidWithOne.toAddMonoid.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne)) (StarRing.toStarAddMonoid.{0} Complex (NonUnitalRing.toNonUnitalSemiring.{0} Complex (NonUnitalCommRing.toNonUnitalRing.{0} Complex (CommRing.toNonUnitalCommRing.{0} Complex Complex.commRing))) Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing)))) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing))
Case conversion may be inaccurate. Consider using '#align complex.star_def Complex.star_defₓ'. -/
-- `simp_nf` complains about this being provable by `is_R_or_C.star_def` even
-- though it's not imported by this file.
@[simp, nolint simp_nf]
theorem star_def : (Star.star : ℂ → ℂ) = conj :=
  rfl
#align complex.star_def Complex.star_def

/-! ### Norm squared -/


#print Complex.normSq /-
/-- The norm squared function. -/
@[pp_nodot]
def normSq : ℂ →*₀ ℝ where
  toFun z := z.re * z.re + z.im * z.im
  map_zero' := by simp
  map_one' := by simp
  map_mul' z w := by
    dsimp
    ring
#align complex.norm_sq Complex.normSq
-/

/- warning: complex.norm_sq_apply -> Complex.normSq_apply is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.re z) (Complex.re z)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.im z) (Complex.im z)))
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.re z) (Complex.re z)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.im z) (Complex.im z)))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_apply Complex.normSq_applyₓ'. -/
theorem normSq_apply (z : ℂ) : normSq z = z.re * z.re + z.im * z.im :=
  rfl
#align complex.norm_sq_apply Complex.normSq_apply

/- warning: complex.norm_sq_of_real -> Complex.normSq_ofReal is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) r r)
but is expected to have type
  forall (r : Real), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (Complex.ofReal' r)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (Complex.ofReal' r)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) r r)
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_of_real Complex.normSq_ofRealₓ'. -/
@[simp]
theorem normSq_ofReal (r : ℝ) : normSq r = r * r := by simp [norm_sq]
#align complex.norm_sq_of_real Complex.normSq_ofReal

/- warning: complex.norm_sq_mk -> Complex.normSq_mk is a dubious translation:
lean 3 declaration is
  forall (x : Real) (y : Real), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (Complex.mk x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) x x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) y y))
but is expected to have type
  forall (x : Real) (y : Real), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (Complex.mk x y)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (Complex.mk x y)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) x x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) y y))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_mk Complex.normSq_mkₓ'. -/
@[simp]
theorem normSq_mk (x y : ℝ) : normSq ⟨x, y⟩ = x * x + y * y :=
  rfl
#align complex.norm_sq_mk Complex.normSq_mk

/- warning: complex.norm_sq_add_mul_I -> Complex.normSq_add_mul_I is a dubious translation:
lean 3 declaration is
  forall (x : Real) (y : Real), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) x) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) y) Complex.I))) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) x (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) y (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall (x : Real) (y : Real), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) (Complex.ofReal' x) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' y) Complex.I))) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) (Complex.ofReal' x) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' y) Complex.I))) (HAdd.hAdd.{0, 0, 0} Real Real ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) (Complex.ofReal' x) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' y) Complex.I))) (instHAdd.{0} Real Real.instAddReal) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) x (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) y (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_add_mul_I Complex.normSq_add_mul_Iₓ'. -/
theorem normSq_add_mul_I (x y : ℝ) : normSq (x + y * I) = x ^ 2 + y ^ 2 := by
  rw [← mk_eq_add_mul_I, norm_sq_mk, sq, sq]
#align complex.norm_sq_add_mul_I Complex.normSq_add_mul_I

/- warning: complex.norm_sq_eq_conj_mul_self -> Complex.normSq_eq_conj_mul_self is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z) z)
but is expected to have type
  forall {z : Complex}, Eq.{1} Complex (Complex.ofReal' (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z)) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) (instHMul.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex.instMulComplex) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z) z)
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_eq_conj_mul_self Complex.normSq_eq_conj_mul_selfₓ'. -/
theorem normSq_eq_conj_mul_self {z : ℂ} : (normSq z : ℂ) = conj z * z := by
  ext <;> simp [norm_sq, mul_comm]
#align complex.norm_sq_eq_conj_mul_self Complex.normSq_eq_conj_mul_self

/- warning: complex.norm_sq_zero -> Complex.normSq_zero is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_zero Complex.normSq_zeroₓ'. -/
@[simp]
theorem normSq_zero : normSq 0 = 0 :=
  normSq.map_zero
#align complex.norm_sq_zero Complex.normSq_zero

/- warning: complex.norm_sq_one -> Complex.normSq_one is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_one Complex.normSq_oneₓ'. -/
@[simp]
theorem normSq_one : normSq 1 = 1 :=
  normSq.map_one
#align complex.norm_sq_one Complex.normSq_one

/- warning: complex.norm_sq_I -> Complex.normSq_I is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq Complex.I) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) Complex.I) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq Complex.I) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) Complex.I) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) Complex.I) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_I Complex.normSq_Iₓ'. -/
@[simp]
theorem normSq_I : normSq I = 1 := by simp [norm_sq]
#align complex.norm_sq_I Complex.normSq_I

/- warning: complex.norm_sq_nonneg -> Complex.normSq_nonneg is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z)
but is expected to have type
  forall (z : Complex), LE.le.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instLEReal (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instZeroReal)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z)
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_nonneg Complex.normSq_nonnegₓ'. -/
theorem normSq_nonneg (z : ℂ) : 0 ≤ normSq z :=
  add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)
#align complex.norm_sq_nonneg Complex.normSq_nonneg

/- warning: complex.range_norm_sq -> Complex.range_normSq is a dubious translation:
lean 3 declaration is
  Eq.{1} (Set.{0} Real) (Set.range.{0, 1} Real Complex (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq)) (Set.Ici.{0} Real Real.preorder (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  Eq.{1} (Set.{0} Real) (Set.range.{0, 1} Real Complex (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq)) (Set.Ici.{0} Real Real.instPreorderReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align complex.range_norm_sq Complex.range_normSqₓ'. -/
@[simp]
theorem range_normSq : range normSq = Ici 0 :=
  Subset.antisymm (range_subset_iff.2 normSq_nonneg) fun x hx =>
    ⟨Real.sqrt x, by rw [norm_sq_of_real, Real.mul_self_sqrt hx]⟩
#align complex.range_norm_sq Complex.range_normSq

/- warning: complex.norm_sq_eq_zero -> Complex.normSq_eq_zero is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Iff (Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) (Eq.{1} Complex z (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))))
but is expected to have type
  forall {z : Complex}, Iff (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instZeroReal))) (Eq.{1} Complex z (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_eq_zero Complex.normSq_eq_zeroₓ'. -/
theorem normSq_eq_zero {z : ℂ} : normSq z = 0 ↔ z = 0 :=
  ⟨fun h =>
    ext (eq_zero_of_mul_self_add_mul_self_eq_zero h)
      (eq_zero_of_mul_self_add_mul_self_eq_zero <| (add_comm _ _).trans h),
    fun h => h.symm ▸ normSq_zero⟩
#align complex.norm_sq_eq_zero Complex.normSq_eq_zero

/- warning: complex.norm_sq_pos -> Complex.normSq_pos is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Iff (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z)) (Ne.{1} Complex z (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))))
but is expected to have type
  forall {z : Complex}, Iff (LT.lt.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instLTReal (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instZeroReal)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z)) (Ne.{1} Complex z (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_pos Complex.normSq_posₓ'. -/
@[simp]
theorem normSq_pos {z : ℂ} : 0 < normSq z ↔ z ≠ 0 :=
  (normSq_nonneg z).lt_iff_ne.trans <| not_congr (eq_comm.trans normSq_eq_zero)
#align complex.norm_sq_pos Complex.normSq_pos

/- warning: complex.norm_sq_neg -> Complex.normSq_neg is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (Neg.neg.{0} Complex Complex.hasNeg z)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z)
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (Neg.neg.{0} Complex Complex.instNegComplex z)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (Neg.neg.{0} Complex Complex.instNegComplex z)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z)
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_neg Complex.normSq_negₓ'. -/
@[simp]
theorem normSq_neg (z : ℂ) : normSq (-z) = normSq z := by simp [norm_sq]
#align complex.norm_sq_neg Complex.normSq_neg

/- warning: complex.norm_sq_conj -> Complex.normSq_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z)
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (a : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) a) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z)
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_conj Complex.normSq_conjₓ'. -/
@[simp]
theorem normSq_conj (z : ℂ) : normSq (conj z) = normSq z := by simp [norm_sq]
#align complex.norm_sq_conj Complex.normSq_conj

/- warning: complex.norm_sq_mul -> Complex.normSq_mul is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z w)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq w))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) z w)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) z w)) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) w) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (instHMul.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instMulReal) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq w))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_mul Complex.normSq_mulₓ'. -/
theorem normSq_mul (z w : ℂ) : normSq (z * w) = normSq z * normSq w :=
  normSq.map_mul z w
#align complex.norm_sq_mul Complex.normSq_mul

/- warning: complex.norm_sq_add -> Complex.normSq_add is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) z w)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq w)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) w)))))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (instHAdd.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instAddReal) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) w) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (instHAdd.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instAddReal) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq w)) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) Real ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) (instHMul.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) Real.instMulReal) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) 2 (instOfNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) z w)) 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Complex.re (HMul.hMul.{0, 0, 0} Complex ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) w) Complex (instHMul.{0} Complex Complex.instMulComplex) z (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) w)))))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_add Complex.normSq_addₓ'. -/
theorem normSq_add (z w : ℂ) : normSq (z + w) = normSq z + normSq w + 2 * (z * conj w).re := by
  dsimp [norm_sq] <;> ring
#align complex.norm_sq_add Complex.normSq_add

/- warning: complex.re_sq_le_norm_sq -> Complex.re_sq_le_normSq is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.re z) (Complex.re z)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z)
but is expected to have type
  forall (z : Complex), LE.le.{0} Real Real.instLEReal (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.re z) (Complex.re z)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z)
Case conversion may be inaccurate. Consider using '#align complex.re_sq_le_norm_sq Complex.re_sq_le_normSqₓ'. -/
theorem re_sq_le_normSq (z : ℂ) : z.re * z.re ≤ normSq z :=
  le_add_of_nonneg_right (mul_self_nonneg _)
#align complex.re_sq_le_norm_sq Complex.re_sq_le_normSq

/- warning: complex.im_sq_le_norm_sq -> Complex.im_sq_le_normSq is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.im z) (Complex.im z)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z)
but is expected to have type
  forall (z : Complex), LE.le.{0} Real Real.instLEReal (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.im z) (Complex.im z)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z)
Case conversion may be inaccurate. Consider using '#align complex.im_sq_le_norm_sq Complex.im_sq_le_normSqₓ'. -/
theorem im_sq_le_normSq (z : ℂ) : z.im * z.im ≤ normSq z :=
  le_add_of_nonneg_left (mul_self_nonneg _)
#align complex.im_sq_le_norm_sq Complex.im_sq_le_normSq

/- warning: complex.mul_conj -> Complex.mul_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z))
but is expected to have type
  forall (z : Complex), Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex (instHMul.{0} Complex Complex.instMulComplex) z (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (Complex.ofReal' (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z))
Case conversion may be inaccurate. Consider using '#align complex.mul_conj Complex.mul_conjₓ'. -/
theorem mul_conj (z : ℂ) : z * conj z = normSq z :=
  ext_iff.2 <| by simp [norm_sq, mul_comm, sub_eq_neg_add, add_comm]
#align complex.mul_conj Complex.mul_conj

/- warning: complex.add_conj -> Complex.add_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) z (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (Complex.re z)))
but is expected to have type
  forall (z : Complex), Eq.{1} Complex (HAdd.hAdd.{0, 0, 0} Complex ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex (instHAdd.{0} Complex Complex.instAddComplex) z (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (Complex.ofReal' (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Complex.re z)))
Case conversion may be inaccurate. Consider using '#align complex.add_conj Complex.add_conjₓ'. -/
theorem add_conj (z : ℂ) : z + conj z = (2 * z.re : ℝ) :=
  ext_iff.2 <| by simp [two_mul]
#align complex.add_conj Complex.add_conj

#print Complex.ofReal /-
/-- The coercion `ℝ → ℂ` as a `ring_hom`. -/
def ofReal : ℝ →+* ℂ :=
  ⟨coe, ofReal_one, ofReal_mul, ofReal_zero, ofReal_add⟩
#align complex.of_real Complex.ofReal
-/

/- warning: complex.of_real_eq_coe -> Complex.ofReal_eq_coe is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Real Complex (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)) (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (fun (_x : RingHom.{0, 0} Real Complex (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)) (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) => Real -> Complex) (RingHom.hasCoeToFun.{0, 0} Real Complex (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)) (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) Complex.ofReal r) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r)
but is expected to have type
  forall (r : Real), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Real) => Complex) r) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Real Complex (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)) (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) Real (fun (_x : Real) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Real) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Real Complex (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)) (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) Real Complex (NonUnitalNonAssocSemiring.toMul.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Real Complex (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)) (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) Real Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Real Complex (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)) (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) Real Complex (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)) (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Real Complex (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)) (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))))) Complex.ofReal r) (Complex.ofReal' r)
Case conversion may be inaccurate. Consider using '#align complex.of_real_eq_coe Complex.ofReal_eq_coeₓ'. -/
@[simp]
theorem ofReal_eq_coe (r : ℝ) : ofReal r = r :=
  rfl
#align complex.of_real_eq_coe Complex.ofReal_eq_coe

/- warning: complex.I_sq -> Complex.i_sq is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring))) Complex.I (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Neg.neg.{0} Complex Complex.hasNeg (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne))))
but is expected to have type
  Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex))))) Complex.I (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Neg.neg.{0} Complex Complex.instNegComplex (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex)))
Case conversion may be inaccurate. Consider using '#align complex.I_sq Complex.i_sqₓ'. -/
@[simp]
theorem i_sq : I ^ 2 = -1 := by rw [sq, I_mul_I]
#align complex.I_sq Complex.i_sq

/- warning: complex.sub_re -> Complex.sub_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.re (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.hasSub) z w)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (Complex.re z) (Complex.re w))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.re (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (Complex.re z) (Complex.re w))
Case conversion may be inaccurate. Consider using '#align complex.sub_re Complex.sub_reₓ'. -/
@[simp]
theorem sub_re (z w : ℂ) : (z - w).re = z.re - w.re :=
  rfl
#align complex.sub_re Complex.sub_re

/- warning: complex.sub_im -> Complex.sub_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.im (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.hasSub) z w)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (Complex.im z) (Complex.im w))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.im (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (Complex.im z) (Complex.im w))
Case conversion may be inaccurate. Consider using '#align complex.sub_im Complex.sub_imₓ'. -/
@[simp]
theorem sub_im (z w : ℂ) : (z - w).im = z.im - w.im :=
  rfl
#align complex.sub_im Complex.sub_im

/- warning: complex.of_real_sub -> Complex.ofReal_sub is a dubious translation:
lean 3 declaration is
  forall (r : Real) (s : Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) r s)) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.hasSub) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) s))
but is expected to have type
  forall (r : Real) (s : Real), Eq.{1} Complex (Complex.ofReal' (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) r s)) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) (Complex.ofReal' r) (Complex.ofReal' s))
Case conversion may be inaccurate. Consider using '#align complex.of_real_sub Complex.ofReal_subₓ'. -/
@[simp, norm_cast]
theorem ofReal_sub (r s : ℝ) : ((r - s : ℝ) : ℂ) = r - s :=
  ext_iff.2 <| by simp
#align complex.of_real_sub Complex.ofReal_sub

/- warning: complex.of_real_pow -> Complex.ofReal_pow is a dubious translation:
lean 3 declaration is
  forall (r : Real) (n : Nat), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) r n)) (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) n)
but is expected to have type
  forall (r : Real) (n : Nat), Eq.{1} Complex (Complex.ofReal' (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) r n)) (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex))))) (Complex.ofReal' r) n)
Case conversion may be inaccurate. Consider using '#align complex.of_real_pow Complex.ofReal_powₓ'. -/
@[simp, norm_cast]
theorem ofReal_pow (r : ℝ) (n : ℕ) : ((r ^ n : ℝ) : ℂ) = r ^ n := by
  induction n <;> simp [*, of_real_mul, pow_succ]
#align complex.of_real_pow Complex.ofReal_pow

/- warning: complex.sub_conj -> Complex.sub_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.hasSub) z (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (Complex.im z))) Complex.I)
but is expected to have type
  forall (z : Complex), Eq.{1} Complex (HSub.hSub.{0, 0, 0} Complex ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex (instHSub.{0} Complex Complex.instSubComplex) z (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Complex.im z))) Complex.I)
Case conversion may be inaccurate. Consider using '#align complex.sub_conj Complex.sub_conjₓ'. -/
theorem sub_conj (z : ℂ) : z - conj z = (2 * z.im : ℝ) * I :=
  ext_iff.2 <| by simp [two_mul, sub_eq_add_neg]
#align complex.sub_conj Complex.sub_conj

/- warning: complex.norm_sq_sub -> Complex.normSq_sub is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.hasSub) z w)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq w)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (Complex.re (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) w)))))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (instHSub.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instSubReal) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) w) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (instHAdd.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instAddReal) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq w)) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) Real ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) (instHMul.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) Real.instMulReal) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) 2 (instOfNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.instSubComplex) z w)) 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Complex.re (HMul.hMul.{0, 0, 0} Complex ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) w) Complex (instHMul.{0} Complex Complex.instMulComplex) z (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) w)))))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_sub Complex.normSq_subₓ'. -/
theorem normSq_sub (z w : ℂ) : normSq (z - w) = normSq z + normSq w - 2 * (z * conj w).re :=
  by
  rw [sub_eq_add_neg, norm_sq_add]
  simp only [RingHom.map_neg, mul_neg, neg_re, Tactic.Ring.add_neg_eq_sub, norm_sq_neg]
#align complex.norm_sq_sub Complex.normSq_sub

/-! ### Inversion -/


noncomputable instance : Inv ℂ :=
  ⟨fun z => conj z * ((normSq z)⁻¹ : ℝ)⟩

/- warning: complex.inv_def -> Complex.inv_def is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex (Inv.inv.{0} Complex Complex.hasInv z) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Inv.inv.{0} Real Real.hasInv (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z))))
but is expected to have type
  forall (z : Complex), Eq.{1} Complex (Inv.inv.{0} Complex Complex.instInvComplex z) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) (instHMul.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex.instMulComplex) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z) (Complex.ofReal' (Inv.inv.{0} Real Real.instInvReal (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z))))
Case conversion may be inaccurate. Consider using '#align complex.inv_def Complex.inv_defₓ'. -/
theorem inv_def (z : ℂ) : z⁻¹ = conj z * ((normSq z)⁻¹ : ℝ) :=
  rfl
#align complex.inv_def Complex.inv_def

/- warning: complex.inv_re -> Complex.inv_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.re (Inv.inv.{0} Complex Complex.hasInv z)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Complex.re z) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.re (Inv.inv.{0} Complex Complex.instInvComplex z)) (HDiv.hDiv.{0, 0, 0} Real ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Complex.re z) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z))
Case conversion may be inaccurate. Consider using '#align complex.inv_re Complex.inv_reₓ'. -/
@[simp]
theorem inv_re (z : ℂ) : z⁻¹.re = z.re / normSq z := by simp [inv_def, division_def]
#align complex.inv_re Complex.inv_re

/- warning: complex.inv_im -> Complex.inv_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Complex.im (Inv.inv.{0} Complex Complex.hasInv z)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Neg.neg.{0} Real Real.hasNeg (Complex.im z)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Complex.im (Inv.inv.{0} Complex Complex.instInvComplex z)) (HDiv.hDiv.{0, 0, 0} Real ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Neg.neg.{0} Real Real.instNegReal (Complex.im z)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z))
Case conversion may be inaccurate. Consider using '#align complex.inv_im Complex.inv_imₓ'. -/
@[simp]
theorem inv_im (z : ℂ) : z⁻¹.im = -z.im / normSq z := by simp [inv_def, division_def]
#align complex.inv_im Complex.inv_im

/- warning: complex.of_real_inv -> Complex.ofReal_inv is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Inv.inv.{0} Real Real.hasInv r)) (Inv.inv.{0} Complex Complex.hasInv ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r))
but is expected to have type
  forall (r : Real), Eq.{1} Complex (Complex.ofReal' (Inv.inv.{0} Real Real.instInvReal r)) (Inv.inv.{0} Complex Complex.instInvComplex (Complex.ofReal' r))
Case conversion may be inaccurate. Consider using '#align complex.of_real_inv Complex.ofReal_invₓ'. -/
@[simp, norm_cast]
theorem ofReal_inv (r : ℝ) : ((r⁻¹ : ℝ) : ℂ) = r⁻¹ :=
  ext_iff.2 <| by simp
#align complex.of_real_inv Complex.ofReal_inv

/- warning: complex.inv_zero -> Complex.inv_zero is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex (Inv.inv.{0} Complex Complex.hasInv (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))
but is expected to have type
  Eq.{1} Complex (Inv.inv.{0} Complex Complex.instInvComplex (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))
Case conversion may be inaccurate. Consider using '#align complex.inv_zero Complex.inv_zeroₓ'. -/
protected theorem inv_zero : (0⁻¹ : ℂ) = 0 := by rw [← of_real_zero, ← of_real_inv, inv_zero]
#align complex.inv_zero Complex.inv_zero

/- warning: complex.mul_inv_cancel -> Complex.mul_inv_cancel is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, (Ne.{1} Complex z (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero)))) -> (Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z (Inv.inv.{0} Complex Complex.hasInv z)) (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne))))
but is expected to have type
  forall {z : Complex}, (Ne.{1} Complex z (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex))) -> (Eq.{1} Complex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) z (Inv.inv.{0} Complex Complex.instInvComplex z)) (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex)))
Case conversion may be inaccurate. Consider using '#align complex.mul_inv_cancel Complex.mul_inv_cancelₓ'. -/
protected theorem mul_inv_cancel {z : ℂ} (h : z ≠ 0) : z * z⁻¹ = 1 := by
  rw [inv_def, ← mul_assoc, mul_conj, ← of_real_mul, mul_inv_cancel (mt norm_sq_eq_zero.1 h),
    of_real_one]
#align complex.mul_inv_cancel Complex.mul_inv_cancel

/-! ### Field instance and lemmas -/


noncomputable instance : Field ℂ :=
  { Complex.commRing, Complex.nontrivial with
    inv := Inv.inv
    mul_inv_cancel := @Complex.mul_inv_cancel
    inv_zero := Complex.inv_zero }

/- warning: complex.I_zpow_bit0 -> Complex.i_zpow_bit0 is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) Complex.I (bit0.{0} Int Int.hasAdd n)) (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) (Neg.neg.{0} Complex Complex.hasNeg (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))) n)
but is expected to have type
  forall (n : Int), Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.instFieldComplex)))) Complex.I (bit0.{0} Int Int.instAddInt n)) (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.instFieldComplex)))) (Neg.neg.{0} Complex Complex.instNegComplex (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) n)
Case conversion may be inaccurate. Consider using '#align complex.I_zpow_bit0 Complex.i_zpow_bit0ₓ'. -/
@[simp]
theorem i_zpow_bit0 (n : ℤ) : I ^ bit0 n = (-1) ^ n := by rw [zpow_bit0', I_mul_I]
#align complex.I_zpow_bit0 Complex.i_zpow_bit0

/- warning: complex.I_zpow_bit1 -> Complex.i_zpow_bit1 is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) Complex.I (bit1.{0} Int Int.hasOne Int.hasAdd n)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) (Neg.neg.{0} Complex Complex.hasNeg (OfNat.ofNat.{0} Complex 1 (OfNat.mk.{0} Complex 1 (One.one.{0} Complex Complex.hasOne)))) n) Complex.I)
but is expected to have type
  forall (n : Int), Eq.{1} Complex (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.instFieldComplex)))) Complex.I (bit1.{0} Int (NonAssocRing.toOne.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt)) Int.instAddInt n)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.instFieldComplex)))) (Neg.neg.{0} Complex Complex.instNegComplex (OfNat.ofNat.{0} Complex 1 (One.toOfNat1.{0} Complex Complex.instOneComplex))) n) Complex.I)
Case conversion may be inaccurate. Consider using '#align complex.I_zpow_bit1 Complex.i_zpow_bit1ₓ'. -/
@[simp]
theorem i_zpow_bit1 (n : ℤ) : I ^ bit1 n = (-1) ^ n * I := by rw [zpow_bit1', I_mul_I]
#align complex.I_zpow_bit1 Complex.i_zpow_bit1

/- warning: complex.div_re -> Complex.div_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.re (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (DivInvMonoid.toHasDiv.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) z w)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.re z) (Complex.re w)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq w)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.im z) (Complex.im w)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq w)))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.re (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (Field.toDiv.{0} Complex Complex.instFieldComplex)) z w)) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (HDiv.hDiv.{0, 0, 0} Real ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) w) Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.re z) (Complex.re w)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq w)) (HDiv.hDiv.{0, 0, 0} Real ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) w) Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.im z) (Complex.im w)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq w)))
Case conversion may be inaccurate. Consider using '#align complex.div_re Complex.div_reₓ'. -/
theorem div_re (z w : ℂ) : (z / w).re = z.re * w.re / normSq w + z.im * w.im / normSq w := by
  simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]
#align complex.div_re Complex.div_re

/- warning: complex.div_im -> Complex.div_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.im (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (DivInvMonoid.toHasDiv.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) z w)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.im z) (Complex.re w)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq w)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Complex.re z) (Complex.im w)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq w)))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} Real (Complex.im (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (Field.toDiv.{0} Complex Complex.instFieldComplex)) z w)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (HDiv.hDiv.{0, 0, 0} Real ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) w) Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.im z) (Complex.re w)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq w)) (HDiv.hDiv.{0, 0, 0} Real ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) w) Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Complex.re z) (Complex.im w)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq w)))
Case conversion may be inaccurate. Consider using '#align complex.div_im Complex.div_imₓ'. -/
theorem div_im (z w : ℂ) : (z / w).im = z.im * w.re / normSq w - z.re * w.im / normSq w := by
  simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm]
#align complex.div_im Complex.div_im

/- warning: complex.conj_inv -> Complex.conj_inv is a dubious translation:
lean 3 declaration is
  forall (x : Complex), Eq.{1} Complex (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) (Inv.inv.{0} Complex Complex.hasInv x)) (Inv.inv.{0} Complex Complex.hasInv (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) x))
but is expected to have type
  forall (x : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) (Inv.inv.{0} Complex Complex.instInvComplex x)) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) (Inv.inv.{0} Complex Complex.instInvComplex x)) (Inv.inv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) x) Complex.instInvComplex (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) x))
Case conversion may be inaccurate. Consider using '#align complex.conj_inv Complex.conj_invₓ'. -/
theorem conj_inv (x : ℂ) : conj x⁻¹ = (conj x)⁻¹ :=
  star_inv' _
#align complex.conj_inv Complex.conj_inv

/- warning: complex.of_real_div -> Complex.ofReal_div is a dubious translation:
lean 3 declaration is
  forall (r : Real) (s : Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) r s)) (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (DivInvMonoid.toHasDiv.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) s))
but is expected to have type
  forall (r : Real) (s : Real), Eq.{1} Complex (Complex.ofReal' (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) r s)) (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (Field.toDiv.{0} Complex Complex.instFieldComplex)) (Complex.ofReal' r) (Complex.ofReal' s))
Case conversion may be inaccurate. Consider using '#align complex.of_real_div Complex.ofReal_divₓ'. -/
@[simp, norm_cast]
theorem ofReal_div (r s : ℝ) : ((r / s : ℝ) : ℂ) = r / s :=
  map_div₀ ofReal r s
#align complex.of_real_div Complex.ofReal_div

/- warning: complex.of_real_zpow -> Complex.ofReal_zpow is a dubious translation:
lean 3 declaration is
  forall (r : Real) (n : Int), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (HPow.hPow.{0, 0, 0} Real Int Real (instHPow.{0, 0} Real Int (DivInvMonoid.Pow.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) r n)) (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) n)
but is expected to have type
  forall (r : Real) (n : Int), Eq.{1} Complex (Complex.ofReal' (HPow.hPow.{0, 0, 0} Real Int Real (instHPow.{0, 0} Real Int (DivInvMonoid.Pow.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.instDivisionRingReal))) r n)) (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.instFieldComplex)))) (Complex.ofReal' r) n)
Case conversion may be inaccurate. Consider using '#align complex.of_real_zpow Complex.ofReal_zpowₓ'. -/
@[simp, norm_cast]
theorem ofReal_zpow (r : ℝ) (n : ℤ) : ((r ^ n : ℝ) : ℂ) = (r : ℂ) ^ n :=
  map_zpow₀ ofReal r n
#align complex.of_real_zpow Complex.ofReal_zpow

/- warning: complex.div_I -> Complex.div_I is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (DivInvMonoid.toHasDiv.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) z Complex.I) (Neg.neg.{0} Complex Complex.hasNeg (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) z Complex.I))
but is expected to have type
  forall (z : Complex), Eq.{1} Complex (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (Field.toDiv.{0} Complex Complex.instFieldComplex)) z Complex.I) (Neg.neg.{0} Complex Complex.instNegComplex (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) z Complex.I))
Case conversion may be inaccurate. Consider using '#align complex.div_I Complex.div_Iₓ'. -/
@[simp]
theorem div_I (z : ℂ) : z / I = -(z * I) :=
  (div_eq_iff_mul_eq i_ne_zero).2 <| by simp [mul_assoc]
#align complex.div_I Complex.div_I

/- warning: complex.inv_I -> Complex.inv_I is a dubious translation:
lean 3 declaration is
  Eq.{1} Complex (Inv.inv.{0} Complex Complex.hasInv Complex.I) (Neg.neg.{0} Complex Complex.hasNeg Complex.I)
but is expected to have type
  Eq.{1} Complex (Inv.inv.{0} Complex Complex.instInvComplex Complex.I) (Neg.neg.{0} Complex Complex.instNegComplex Complex.I)
Case conversion may be inaccurate. Consider using '#align complex.inv_I Complex.inv_Iₓ'. -/
@[simp]
theorem inv_I : I⁻¹ = -I := by simp [inv_eq_one_div]
#align complex.inv_I Complex.inv_I

/- warning: complex.norm_sq_inv -> Complex.normSq_inv is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (Inv.inv.{0} Complex Complex.hasInv z)) (Inv.inv.{0} Real Real.hasInv (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z))
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (Inv.inv.{0} Complex Complex.instInvComplex z)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (Inv.inv.{0} Complex Complex.instInvComplex z)) (Inv.inv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instInvReal (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_inv Complex.normSq_invₓ'. -/
@[simp]
theorem normSq_inv (z : ℂ) : normSq z⁻¹ = (normSq z)⁻¹ :=
  map_inv₀ normSq z
#align complex.norm_sq_inv Complex.normSq_inv

/- warning: complex.norm_sq_div -> Complex.normSq_div is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (w : Complex), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (DivInvMonoid.toHasDiv.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) z w)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq w))
but is expected to have type
  forall (z : Complex) (w : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (Field.toDiv.{0} Complex Complex.instFieldComplex)) z w)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (Field.toDiv.{0} Complex Complex.instFieldComplex)) z w)) (HDiv.hDiv.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) w) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (instHDiv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (LinearOrderedField.toDiv.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) Real.instLinearOrderedFieldReal)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq w))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_div Complex.normSq_divₓ'. -/
@[simp]
theorem normSq_div (z w : ℂ) : normSq (z / w) = normSq z / normSq w :=
  map_div₀ normSq z w
#align complex.norm_sq_div Complex.normSq_div

/-! ### Cast lemmas -/


/- warning: complex.of_real_nat_cast -> Complex.ofReal_nat_cast is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Complex (HasLiftT.mk.{1, 1} Nat Complex (CoeTCₓ.coe.{1, 1} Nat Complex (Nat.castCoe.{0} Complex (AddMonoidWithOne.toNatCast.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))))) n)
but is expected to have type
  forall (n : Nat), Eq.{1} Complex (Complex.ofReal' (Nat.cast.{0} Real Real.natCast n)) (Nat.cast.{0} Complex (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) n)
Case conversion may be inaccurate. Consider using '#align complex.of_real_nat_cast Complex.ofReal_nat_castₓ'. -/
@[simp, norm_cast]
theorem ofReal_nat_cast (n : ℕ) : ((n : ℝ) : ℂ) = n :=
  map_natCast ofReal n
#align complex.of_real_nat_cast Complex.ofReal_nat_cast

/- warning: complex.nat_cast_re -> Complex.nat_cast_re is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Real (Complex.re ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Complex (HasLiftT.mk.{1, 1} Nat Complex (CoeTCₓ.coe.{1, 1} Nat Complex (Nat.castCoe.{0} Complex (AddMonoidWithOne.toNatCast.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)
but is expected to have type
  forall (n : Nat), Eq.{1} Real (Complex.re (Nat.cast.{0} Complex (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) n)) (Nat.cast.{0} Real Real.natCast n)
Case conversion may be inaccurate. Consider using '#align complex.nat_cast_re Complex.nat_cast_reₓ'. -/
@[simp, norm_cast]
theorem nat_cast_re (n : ℕ) : (n : ℂ).re = n := by rw [← of_real_nat_cast, of_real_re]
#align complex.nat_cast_re Complex.nat_cast_re

/- warning: complex.nat_cast_im -> Complex.nat_cast_im is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Real (Complex.im ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Complex (HasLiftT.mk.{1, 1} Nat Complex (CoeTCₓ.coe.{1, 1} Nat Complex (Nat.castCoe.{0} Complex (AddMonoidWithOne.toNatCast.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))))) n)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  forall (n : Nat), Eq.{1} Real (Complex.im (Nat.cast.{0} Complex (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) n)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align complex.nat_cast_im Complex.nat_cast_imₓ'. -/
@[simp, norm_cast]
theorem nat_cast_im (n : ℕ) : (n : ℂ).im = 0 := by rw [← of_real_nat_cast, of_real_im]
#align complex.nat_cast_im Complex.nat_cast_im

/- warning: complex.of_real_int_cast -> Complex.ofReal_int_cast is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Complex (HasLiftT.mk.{1, 1} Int Complex (CoeTCₓ.coe.{1, 1} Int Complex (Int.castCoe.{0} Complex (AddGroupWithOne.toHasIntCast.{0} Complex Complex.addGroupWithOne)))) n)
but is expected to have type
  forall (n : Int), Eq.{1} Complex (Complex.ofReal' (Int.cast.{0} Real Real.intCast n)) (Int.cast.{0} Complex (Ring.toIntCast.{0} Complex Complex.instRingComplex) n)
Case conversion may be inaccurate. Consider using '#align complex.of_real_int_cast Complex.ofReal_int_castₓ'. -/
@[simp, norm_cast]
theorem ofReal_int_cast (n : ℤ) : ((n : ℝ) : ℂ) = n :=
  map_intCast ofReal n
#align complex.of_real_int_cast Complex.ofReal_int_cast

/- warning: complex.int_cast_re -> Complex.int_cast_re is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Real (Complex.re ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Complex (HasLiftT.mk.{1, 1} Int Complex (CoeTCₓ.coe.{1, 1} Int Complex (Int.castCoe.{0} Complex (AddGroupWithOne.toHasIntCast.{0} Complex Complex.addGroupWithOne)))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) n)
but is expected to have type
  forall (n : Int), Eq.{1} Real (Complex.re (Int.cast.{0} Complex (Ring.toIntCast.{0} Complex Complex.instRingComplex) n)) (Int.cast.{0} Real Real.intCast n)
Case conversion may be inaccurate. Consider using '#align complex.int_cast_re Complex.int_cast_reₓ'. -/
@[simp, norm_cast]
theorem int_cast_re (n : ℤ) : (n : ℂ).re = n := by rw [← of_real_int_cast, of_real_re]
#align complex.int_cast_re Complex.int_cast_re

/- warning: complex.int_cast_im -> Complex.int_cast_im is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Real (Complex.im ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Complex (HasLiftT.mk.{1, 1} Int Complex (CoeTCₓ.coe.{1, 1} Int Complex (Int.castCoe.{0} Complex (AddGroupWithOne.toHasIntCast.{0} Complex Complex.addGroupWithOne)))) n)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  forall (n : Int), Eq.{1} Real (Complex.im (Int.cast.{0} Complex (Ring.toIntCast.{0} Complex Complex.instRingComplex) n)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))
Case conversion may be inaccurate. Consider using '#align complex.int_cast_im Complex.int_cast_imₓ'. -/
@[simp, norm_cast]
theorem int_cast_im (n : ℤ) : (n : ℂ).im = 0 := by rw [← of_real_int_cast, of_real_im]
#align complex.int_cast_im Complex.int_cast_im

/- warning: complex.of_real_rat_cast -> Complex.ofReal_rat_cast is a dubious translation:
lean 3 declaration is
  forall (n : Rat), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTCₓ.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Complex (HasLiftT.mk.{1, 1} Rat Complex (CoeTCₓ.coe.{1, 1} Rat Complex (Rat.castCoe.{0} Complex (DivisionRing.toHasRatCast.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field))))) n)
but is expected to have type
  forall (n : Rat), Eq.{1} Complex (Complex.ofReal' (Rat.cast.{0} Real Real.ratCast n)) (RatCast.ratCast.{0} Complex (Field.toRatCast.{0} Complex Complex.instFieldComplex) n)
Case conversion may be inaccurate. Consider using '#align complex.of_real_rat_cast Complex.ofReal_rat_castₓ'. -/
@[simp, norm_cast]
theorem ofReal_rat_cast (n : ℚ) : ((n : ℝ) : ℂ) = n :=
  map_ratCast ofReal n
#align complex.of_real_rat_cast Complex.ofReal_rat_cast

/- warning: complex.rat_cast_re -> Complex.rat_cast_re is a dubious translation:
lean 3 declaration is
  forall (q : Rat), Eq.{1} Real (Complex.re ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Complex (HasLiftT.mk.{1, 1} Rat Complex (CoeTCₓ.coe.{1, 1} Rat Complex (Rat.castCoe.{0} Complex (DivisionRing.toHasRatCast.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field))))) q)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Real (HasLiftT.mk.{1, 1} Rat Real (CoeTCₓ.coe.{1, 1} Rat Real (Rat.castCoe.{0} Real Real.hasRatCast))) q)
but is expected to have type
  forall (q : Rat), Eq.{1} Complex (Complex.ofReal' (Complex.re (RatCast.ratCast.{0} Complex (Field.toRatCast.{0} Complex Complex.instFieldComplex) q))) (RatCast.ratCast.{0} Complex (Field.toRatCast.{0} Complex Complex.instFieldComplex) q)
Case conversion may be inaccurate. Consider using '#align complex.rat_cast_re Complex.rat_cast_reₓ'. -/
@[simp, norm_cast]
theorem rat_cast_re (q : ℚ) : (q : ℂ).re = q := by rw [← of_real_rat_cast, of_real_re]
#align complex.rat_cast_re Complex.rat_cast_re

/- warning: complex.rat_cast_im -> Complex.rat_cast_im is a dubious translation:
lean 3 declaration is
  forall (q : Rat), Eq.{1} Real (Complex.im ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Rat Complex (HasLiftT.mk.{1, 1} Rat Complex (CoeTCₓ.coe.{1, 1} Rat Complex (Rat.castCoe.{0} Complex (DivisionRing.toHasRatCast.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field))))) q)) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))
but is expected to have type
  forall (q : Rat), Eq.{1} Complex (Complex.ofReal' (Complex.im (RatCast.ratCast.{0} Complex (Field.toRatCast.{0} Complex Complex.instFieldComplex) q))) (RatCast.ratCast.{0} Complex (Field.toRatCast.{0} Complex Complex.instFieldComplex) (OfNat.ofNat.{0} Rat 0 (Rat.instOfNatRat 0)))
Case conversion may be inaccurate. Consider using '#align complex.rat_cast_im Complex.rat_cast_imₓ'. -/
@[simp, norm_cast]
theorem rat_cast_im (q : ℚ) : (q : ℂ).im = 0 := by rw [← of_real_rat_cast, of_real_im]
#align complex.rat_cast_im Complex.rat_cast_im

/-! ### Characteristic zero -/


/- warning: complex.char_zero_complex -> Complex.charZero_complex is a dubious translation:
lean 3 declaration is
  CharZero.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne)
but is expected to have type
  CharZero.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.Complex.addGroupWithOne)
Case conversion may be inaccurate. Consider using '#align complex.char_zero_complex Complex.charZero_complexₓ'. -/
instance charZero_complex : CharZero ℂ :=
  charZero_of_inj_zero fun n h => by
    rwa [← of_real_nat_cast, of_real_eq_zero, Nat.cast_eq_zero] at h
#align complex.char_zero_complex Complex.charZero_complex

/- warning: complex.re_eq_add_conj -> Complex.re_eq_add_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Complex.re z)) (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (DivInvMonoid.toHasDiv.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) z (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z)) (OfNat.ofNat.{0} Complex 2 (OfNat.mk.{0} Complex 2 (bit0.{0} Complex Complex.hasAdd (One.one.{0} Complex Complex.hasOne)))))
but is expected to have type
  forall (z : Complex), Eq.{1} Complex (Complex.ofReal' (Complex.re z)) (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (Field.toDiv.{0} Complex Complex.instFieldComplex)) (HAdd.hAdd.{0, 0, 0} Complex ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex (instHAdd.{0} Complex Complex.instAddComplex) z (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (OfNat.ofNat.{0} Complex 2 (instOfNat.{0} Complex 2 (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align complex.re_eq_add_conj Complex.re_eq_add_conjₓ'. -/
/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/
theorem re_eq_add_conj (z : ℂ) : (z.re : ℂ) = (z + conj z) / 2 := by
  simp only [add_conj, of_real_mul, of_real_one, of_real_bit0,
    mul_div_cancel_left (z.re : ℂ) two_ne_zero]
#align complex.re_eq_add_conj Complex.re_eq_add_conj

/- warning: complex.im_eq_sub_conj -> Complex.im_eq_sub_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Complex.im z)) (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (DivInvMonoid.toHasDiv.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) (HSub.hSub.{0, 0, 0} Complex Complex Complex (instHSub.{0} Complex Complex.hasSub) z (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) (OfNat.ofNat.{0} Complex 2 (OfNat.mk.{0} Complex 2 (bit0.{0} Complex Complex.hasAdd (One.one.{0} Complex Complex.hasOne)))) Complex.I))
but is expected to have type
  forall (z : Complex), Eq.{1} Complex (Complex.ofReal' (Complex.im z)) (HDiv.hDiv.{0, 0, 0} Complex Complex Complex (instHDiv.{0} Complex (Field.toDiv.{0} Complex Complex.instFieldComplex)) (HSub.hSub.{0, 0, 0} Complex ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) z) Complex (instHSub.{0} Complex Complex.instSubComplex) z (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (OfNat.ofNat.{0} Complex 2 (instOfNat.{0} Complex 2 (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) Complex.I))
Case conversion may be inaccurate. Consider using '#align complex.im_eq_sub_conj Complex.im_eq_sub_conjₓ'. -/
/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/
theorem im_eq_sub_conj (z : ℂ) : (z.im : ℂ) = (z - conj z) / (2 * I) := by
  simp only [sub_conj, of_real_mul, of_real_one, of_real_bit0, mul_right_comm,
    mul_div_cancel_left _ (mul_ne_zero two_ne_zero I_ne_zero : 2 * I ≠ 0)]
#align complex.im_eq_sub_conj Complex.im_eq_sub_conj

/-! ### Absolute value -/


namespace AbsTheory

-- mathport name: abs
-- We develop enough theory to bundle `abs` into an `absolute_value` before making things public;
-- this is so there's not two versions of it hanging around.
local notation "abs" z => (normSq z).sqrt

private theorem mul_self_abs (z : ℂ) : ((abs z) * abs z) = normSq z :=
  Real.mul_self_sqrt (normSq_nonneg _)
#align complex.abs_theory.mul_self_abs complex.abs_theory.mul_self_abs

private theorem abs_nonneg' (z : ℂ) : 0 ≤ abs z :=
  Real.sqrt_nonneg _
#align complex.abs_theory.abs_nonneg' complex.abs_theory.abs_nonneg'

/- warning: complex.abs_theory.abs_conj -> Complex.AbsTheory.abs_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Real.sqrt (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z))) (Real.sqrt (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z))
but is expected to have type
  forall (z : Complex), Eq.{1} Real (Real.sqrt (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z))) (Real.sqrt (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z))
Case conversion may be inaccurate. Consider using '#align complex.abs_theory.abs_conj Complex.AbsTheory.abs_conjₓ'. -/
theorem abs_conj (z : ℂ) : (abs conj z) = abs z := by simp
#align complex.abs_theory.abs_conj Complex.AbsTheory.abs_conj

private theorem abs_re_le_abs (z : ℂ) : |z.re| ≤ abs z :=
  by
  rw [mul_self_le_mul_self_iff (abs_nonneg z.re) (abs_nonneg' _), abs_mul_abs_self, mul_self_abs]
  apply re_sq_le_norm_sq
#align complex.abs_theory.abs_re_le_abs complex.abs_theory.abs_re_le_abs

private theorem re_le_abs (z : ℂ) : z.re ≤ abs z :=
  (abs_le.1 (abs_re_le_abs _)).2
#align complex.abs_theory.re_le_abs complex.abs_theory.re_le_abs

private theorem abs_mul (z w : ℂ) : (abs z * w) = (abs z) * abs w := by
  rw [norm_sq_mul, Real.sqrt_mul (norm_sq_nonneg _)]
#align complex.abs_theory.abs_mul complex.abs_theory.abs_mul

private theorem abs_add (z w : ℂ) : (abs z + w) ≤ (abs z) + abs w :=
  (mul_self_le_mul_self_iff (abs_nonneg' (z + w)) (add_nonneg (abs_nonneg' z) (abs_nonneg' w))).2 <|
    by
    rw [mul_self_abs, add_mul_self_eq, mul_self_abs, mul_self_abs, add_right_comm, norm_sq_add,
      add_le_add_iff_left, mul_assoc, mul_le_mul_left (zero_lt_two' ℝ), ←
      Real.sqrt_mul <| norm_sq_nonneg z, ← norm_sq_conj w, ← map_mul]
    exact re_le_abs (z * conj w)
#align complex.abs_theory.abs_add complex.abs_theory.abs_add

#print Complex.AbsTheory.Complex.abs /-
/-- The complex absolute value function, defined as the square root of the norm squared. -/
noncomputable def Complex.AbsTheory.Complex.abs : AbsoluteValue ℂ ℝ
    where
  toFun x := abs x
  map_mul' := abs_mul
  nonneg' := abs_nonneg'
  eq_zero' _ := (Real.sqrt_eq_zero <| normSq_nonneg _).trans normSq_eq_zero
  add_le' := abs_add
#align complex.abs Complex.AbsTheory.Complex.abs
-/

end AbsTheory

/- warning: complex.abs_def -> Complex.abs_def is a dubious translation:
lean 3 declaration is
  Eq.{1} ((fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) Complex.AbsTheory.Complex.abs) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (fun (z : Complex) => Real.sqrt (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z))
but is expected to have type
  Eq.{1} (forall (a : Complex), (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) a) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (fun (z : Complex) => Real.sqrt (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z))
Case conversion may be inaccurate. Consider using '#align complex.abs_def Complex.abs_defₓ'. -/
theorem abs_def : (Complex.AbsTheory.Complex.abs : ℂ → ℝ) = fun z => (normSq z).sqrt :=
  rfl
#align complex.abs_def Complex.abs_def

/- warning: complex.abs_apply -> Complex.abs_apply is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z) (Real.sqrt (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z))
but is expected to have type
  forall {z : Complex}, Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z) (Real.sqrt (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z))
Case conversion may be inaccurate. Consider using '#align complex.abs_apply Complex.abs_applyₓ'. -/
theorem abs_apply {z : ℂ} : Complex.AbsTheory.Complex.abs z = (normSq z).sqrt :=
  rfl
#align complex.abs_apply Complex.abs_apply

/- warning: complex.abs_of_real -> Complex.abs_ofReal is a dubious translation:
lean 3 declaration is
  forall (r : Real), Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) r)
but is expected to have type
  forall (r : Real), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Complex.ofReal' r)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (Complex.ofReal' r)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) r)
Case conversion may be inaccurate. Consider using '#align complex.abs_of_real Complex.abs_ofRealₓ'. -/
@[simp, norm_cast]
theorem abs_ofReal (r : ℝ) : Complex.AbsTheory.Complex.abs r = |r| := by
  simp [abs, norm_sq_of_real, Real.sqrt_mul_self_eq_abs]
#align complex.abs_of_real Complex.abs_ofReal

/- warning: complex.abs_of_nonneg -> Complex.abs_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {r : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) r) -> (Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r)) r)
but is expected to have type
  forall {r : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) r) -> (Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Complex.ofReal' r)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (Complex.ofReal' r)) r)
Case conversion may be inaccurate. Consider using '#align complex.abs_of_nonneg Complex.abs_of_nonnegₓ'. -/
theorem abs_of_nonneg {r : ℝ} (h : 0 ≤ r) : Complex.AbsTheory.Complex.abs r = r :=
  (abs_ofReal _).trans (abs_of_nonneg h)
#align complex.abs_of_nonneg Complex.abs_of_nonneg

/- warning: complex.abs_of_nat -> Complex.abs_of_nat is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Complex (HasLiftT.mk.{1, 1} Nat Complex (CoeTCₓ.coe.{1, 1} Nat Complex (Nat.castCoe.{0} Complex (AddMonoidWithOne.toNatCast.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)
but is expected to have type
  forall (n : Nat), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Nat.cast.{0} Complex (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) n)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (Nat.cast.{0} Complex (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) n)) (Nat.cast.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Nat.cast.{0} Complex (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) n)) Real.natCast n)
Case conversion may be inaccurate. Consider using '#align complex.abs_of_nat Complex.abs_of_natₓ'. -/
theorem abs_of_nat (n : ℕ) : Complex.AbsTheory.Complex.abs n = n :=
  calc
    Complex.AbsTheory.Complex.abs n = Complex.AbsTheory.Complex.abs (n : ℝ) := by
      rw [of_real_nat_cast]
    _ = _ := abs_of_nonneg (Nat.cast_nonneg n)
    
#align complex.abs_of_nat Complex.abs_of_nat

/- warning: complex.mul_self_abs -> Complex.mul_self_abs is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z)
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (instHMul.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instMulReal) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z)
Case conversion may be inaccurate. Consider using '#align complex.mul_self_abs Complex.mul_self_absₓ'. -/
theorem mul_self_abs (z : ℂ) :
    Complex.AbsTheory.Complex.abs z * Complex.AbsTheory.Complex.abs z = normSq z :=
  Real.mul_self_sqrt (normSq_nonneg _)
#align complex.mul_self_abs Complex.mul_self_abs

/- warning: complex.sq_abs -> Complex.sq_abs is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq z)
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) z) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Nat (Monoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instMonoidReal)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq z)
Case conversion may be inaccurate. Consider using '#align complex.sq_abs Complex.sq_absₓ'. -/
theorem sq_abs (z : ℂ) : Complex.AbsTheory.Complex.abs z ^ 2 = normSq z :=
  Real.sq_sqrt (normSq_nonneg _)
#align complex.sq_abs Complex.sq_abs

/- warning: complex.sq_abs_sub_sq_re -> Complex.sq_abs_sub_sq_re is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Complex.re z) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Complex.im z) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (instHSub.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instSubReal) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Nat ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Nat (Monoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instMonoidReal)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Complex.re z) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (HPow.hPow.{0, 0, 0} Real Nat ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Complex.im z) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align complex.sq_abs_sub_sq_re Complex.sq_abs_sub_sq_reₓ'. -/
@[simp]
theorem sq_abs_sub_sq_re (z : ℂ) : Complex.AbsTheory.Complex.abs z ^ 2 - z.re ^ 2 = z.im ^ 2 := by
  rw [sq_abs, norm_sq_apply, ← sq, ← sq, add_sub_cancel']
#align complex.sq_abs_sub_sq_re Complex.sq_abs_sub_sq_re

/- warning: complex.sq_abs_sub_sq_im -> Complex.sq_abs_sub_sq_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Complex.im z) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (Complex.re z) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (instHSub.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instSubReal) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Nat ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Nat (Monoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instMonoidReal)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Complex.im z) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (HPow.hPow.{0, 0, 0} Real Nat ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Complex.re z) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align complex.sq_abs_sub_sq_im Complex.sq_abs_sub_sq_imₓ'. -/
@[simp]
theorem sq_abs_sub_sq_im (z : ℂ) : Complex.AbsTheory.Complex.abs z ^ 2 - z.im ^ 2 = z.re ^ 2 := by
  rw [← sq_abs_sub_sq_re, sub_sub_cancel]
#align complex.sq_abs_sub_sq_im Complex.sq_abs_sub_sq_im

/- warning: complex.abs_I -> Complex.abs_I is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs Complex.I) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) Complex.I) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs Complex.I) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) Complex.I) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) Complex.I) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.abs_I Complex.abs_Iₓ'. -/
@[simp]
theorem abs_I : Complex.AbsTheory.Complex.abs I = 1 := by simp [abs]
#align complex.abs_I Complex.abs_I

/- warning: complex.abs_two -> Complex.abs_two is a dubious translation:
lean 3 declaration is
  Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs (OfNat.ofNat.{0} Complex 2 (OfNat.mk.{0} Complex 2 (bit0.{0} Complex Complex.hasAdd (One.one.{0} Complex Complex.hasOne))))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))
but is expected to have type
  Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (OfNat.ofNat.{0} Complex 2 (instOfNat.{0} Complex 2 (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (OfNat.ofNat.{0} Complex 2 (instOfNat.{0} Complex 2 (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (OfNat.ofNat.{0} Complex 2 (instOfNat.{0} Complex 2 (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) 2 (instOfNat.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (OfNat.ofNat.{0} Complex 2 (instOfNat.{0} Complex 2 (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align complex.abs_two Complex.abs_twoₓ'. -/
@[simp]
theorem abs_two : Complex.AbsTheory.Complex.abs 2 = 2 :=
  calc
    Complex.AbsTheory.Complex.abs 2 = Complex.AbsTheory.Complex.abs (2 : ℝ) := by
      rw [of_real_bit0, of_real_one]
    _ = (2 : ℝ) := abs_of_nonneg (by norm_num)
    
#align complex.abs_two Complex.abs_two

/- warning: complex.range_abs -> Complex.range_abs is a dubious translation:
lean 3 declaration is
  Eq.{1} (Set.{0} Real) (Set.range.{0, 1} Real Complex (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) (Set.Ici.{0} Real Real.preorder (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  Eq.{1} (Set.{0} Real) (Set.range.{0, 1} Real Complex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)) (Set.Ici.{0} Real Real.instPreorderReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align complex.range_abs Complex.range_absₓ'. -/
@[simp]
theorem range_abs : range Complex.AbsTheory.Complex.abs = Ici 0 :=
  Subset.antisymm (range_subset_iff.2 Complex.AbsTheory.Complex.abs.NonNeg) fun x hx =>
    ⟨x, abs_of_nonneg hx⟩
#align complex.range_abs Complex.range_abs

/- warning: complex.abs_conj -> Complex.abs_conj is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) z)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (a : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) a) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) z)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)
Case conversion may be inaccurate. Consider using '#align complex.abs_conj Complex.abs_conjₓ'. -/
@[simp]
theorem abs_conj (z : ℂ) :
    Complex.AbsTheory.Complex.abs (conj z) = Complex.AbsTheory.Complex.abs z :=
  AbsTheory.abs_conj z
#align complex.abs_conj Complex.abs_conj

/- warning: complex.abs_prod -> Complex.abs_prod is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (s : Finset.{u1} ι) (f : ι -> Complex), Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs (Finset.prod.{0, u1} Complex ι (CommRing.toCommMonoid.{0} Complex Complex.commRing) s f)) (Finset.prod.{0, u1} Real ι Real.commMonoid s (fun (i : ι) => coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs (f i)))
but is expected to have type
  forall {ι : Type.{u1}} (s : Finset.{u1} ι) (f : ι -> Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Finset.prod.{0, u1} Complex ι (CommRing.toCommMonoid.{0} Complex Complex.commRing) s f)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (Finset.prod.{0, u1} Complex ι (CommRing.toCommMonoid.{0} Complex Complex.commRing) s f)) (Finset.prod.{0, u1} Real ι Real.instCommMonoidReal s (fun (i : ι) => FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (f i)))
Case conversion may be inaccurate. Consider using '#align complex.abs_prod Complex.abs_prodₓ'. -/
@[simp]
theorem abs_prod {ι : Type _} (s : Finset ι) (f : ι → ℂ) :
    Complex.AbsTheory.Complex.abs (s.Prod f) =
      s.Prod fun i => Complex.AbsTheory.Complex.abs (f i) :=
  map_prod Complex.AbsTheory.Complex.abs _ _
#align complex.abs_prod Complex.abs_prod

/- warning: complex.abs_pow -> Complex.abs_pow is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (n : Nat), Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (Ring.toMonoid.{0} Complex Complex.ring))) z n)) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z) n)
but is expected to have type
  forall (z : Complex) (n : Nat), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) z n)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (HPow.hPow.{0, 0, 0} Complex Nat Complex (instHPow.{0, 0} Complex Nat (Monoid.Pow.{0} Complex (MonoidWithZero.toMonoid.{0} Complex (Semiring.toMonoidWithZero.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) z n)) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Nat ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Nat (Monoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instMonoidReal)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z) n)
Case conversion may be inaccurate. Consider using '#align complex.abs_pow Complex.abs_powₓ'. -/
@[simp]
theorem abs_pow (z : ℂ) (n : ℕ) :
    Complex.AbsTheory.Complex.abs (z ^ n) = Complex.AbsTheory.Complex.abs z ^ n :=
  map_pow Complex.AbsTheory.Complex.abs z n
#align complex.abs_pow Complex.abs_pow

/- warning: complex.abs_zpow -> Complex.abs_zpow is a dubious translation:
lean 3 declaration is
  forall (z : Complex) (n : Int), Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.field)))) z n)) (HPow.hPow.{0, 0, 0} Real Int Real (instHPow.{0, 0} Real Int (DivInvMonoid.Pow.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z) n)
but is expected to have type
  forall (z : Complex) (n : Int), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.instFieldComplex)))) z n)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (HPow.hPow.{0, 0, 0} Complex Int Complex (instHPow.{0, 0} Complex Int (DivInvMonoid.Pow.{0} Complex (DivisionRing.toDivInvMonoid.{0} Complex (Field.toDivisionRing.{0} Complex Complex.instFieldComplex)))) z n)) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Int ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Int (DivInvMonoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (DivisionRing.toDivInvMonoid.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instDivisionRingReal))) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z) n)
Case conversion may be inaccurate. Consider using '#align complex.abs_zpow Complex.abs_zpowₓ'. -/
@[simp]
theorem abs_zpow (z : ℂ) (n : ℤ) :
    Complex.AbsTheory.Complex.abs (z ^ n) = Complex.AbsTheory.Complex.abs z ^ n :=
  map_zpow₀ Complex.AbsTheory.Complex.abs z n
#align complex.abs_zpow Complex.abs_zpow

/- warning: complex.abs_re_le_abs -> Complex.abs_re_le_abs is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (Complex.re z)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)
but is expected to have type
  forall (z : Complex), LE.le.{0} Real Real.instLEReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (Complex.re z)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)
Case conversion may be inaccurate. Consider using '#align complex.abs_re_le_abs Complex.abs_re_le_absₓ'. -/
theorem abs_re_le_abs (z : ℂ) : |z.re| ≤ Complex.AbsTheory.Complex.abs z :=
  Real.abs_le_sqrt <| by
    rw [norm_sq_apply, ← sq]
    exact le_add_of_nonneg_right (mul_self_nonneg _)
#align complex.abs_re_le_abs Complex.abs_re_le_abs

/- warning: complex.abs_im_le_abs -> Complex.abs_im_le_abs is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (Complex.im z)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)
but is expected to have type
  forall (z : Complex), LE.le.{0} Real Real.instLEReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (Complex.im z)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)
Case conversion may be inaccurate. Consider using '#align complex.abs_im_le_abs Complex.abs_im_le_absₓ'. -/
theorem abs_im_le_abs (z : ℂ) : |z.im| ≤ Complex.AbsTheory.Complex.abs z :=
  Real.abs_le_sqrt <| by
    rw [norm_sq_apply, ← sq, ← sq]
    exact le_add_of_nonneg_left (sq_nonneg _)
#align complex.abs_im_le_abs Complex.abs_im_le_abs

/- warning: complex.re_le_abs -> Complex.re_le_abs is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (Complex.re z) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)
but is expected to have type
  forall (z : Complex), LE.le.{0} Real Real.instLEReal (Complex.re z) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)
Case conversion may be inaccurate. Consider using '#align complex.re_le_abs Complex.re_le_absₓ'. -/
theorem re_le_abs (z : ℂ) : z.re ≤ Complex.AbsTheory.Complex.abs z :=
  (abs_le.1 (abs_re_le_abs _)).2
#align complex.re_le_abs Complex.re_le_abs

/- warning: complex.im_le_abs -> Complex.im_le_abs is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (Complex.im z) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)
but is expected to have type
  forall (z : Complex), LE.le.{0} Real Real.instLEReal (Complex.im z) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)
Case conversion may be inaccurate. Consider using '#align complex.im_le_abs Complex.im_le_absₓ'. -/
theorem im_le_abs (z : ℂ) : z.im ≤ Complex.AbsTheory.Complex.abs z :=
  (abs_le.1 (abs_im_le_abs _)).2
#align complex.im_le_abs Complex.im_le_abs

/- warning: complex.abs_re_lt_abs -> Complex.abs_re_lt_abs is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Iff (LT.lt.{0} Real Real.hasLt (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (Complex.re z)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)) (Ne.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall {z : Complex}, Iff (LT.lt.{0} Real Real.instLTReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (Complex.re z)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)) (Ne.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align complex.abs_re_lt_abs Complex.abs_re_lt_absₓ'. -/
@[simp]
theorem abs_re_lt_abs {z : ℂ} : |z.re| < Complex.AbsTheory.Complex.abs z ↔ z.im ≠ 0 := by
  rw [abs, AbsoluteValue.coe_mk, MulHom.coe_mk, Real.lt_sqrt (abs_nonneg _), norm_sq_apply,
    _root_.sq_abs, ← sq, lt_add_iff_pos_right, mul_self_pos]
#align complex.abs_re_lt_abs Complex.abs_re_lt_abs

/- warning: complex.abs_im_lt_abs -> Complex.abs_im_lt_abs is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Iff (LT.lt.{0} Real Real.hasLt (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (Complex.im z)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)) (Ne.{1} Real (Complex.re z) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall {z : Complex}, Iff (LT.lt.{0} Real Real.instLTReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (Complex.im z)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)) (Ne.{1} Real (Complex.re z) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align complex.abs_im_lt_abs Complex.abs_im_lt_absₓ'. -/
@[simp]
theorem abs_im_lt_abs {z : ℂ} : |z.im| < Complex.AbsTheory.Complex.abs z ↔ z.re ≠ 0 := by
  simpa using @abs_re_lt_abs (z * I)
#align complex.abs_im_lt_abs Complex.abs_im_lt_abs

/- warning: complex.abs_abs -> Complex.abs_abs is a dubious translation:
lean 3 declaration is
  forall (z : Complex), Eq.{1} Real (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z)
but is expected to have type
  forall (z : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (Abs.abs.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) (Neg.toHasAbs.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instNegReal Real.instSupReal) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z)
Case conversion may be inaccurate. Consider using '#align complex.abs_abs Complex.abs_absₓ'. -/
@[simp]
theorem abs_abs (z : ℂ) : |Complex.AbsTheory.Complex.abs z| = Complex.AbsTheory.Complex.abs z :=
  abs_of_nonneg (Complex.AbsTheory.Complex.abs.NonNeg _)
#align complex.abs_abs Complex.abs_abs

/- warning: complex.abs_le_abs_re_add_abs_im -> Complex.abs_le_abs_re_add_abs_im is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.hasAdd) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (Complex.re z)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (Complex.im z)))
but is expected to have type
  forall (z : Complex), LE.le.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instLEReal (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z) (HAdd.hAdd.{0, 0, 0} Real Real Real (instHAdd.{0} Real Real.instAddReal) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (Complex.re z)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (Complex.im z)))
Case conversion may be inaccurate. Consider using '#align complex.abs_le_abs_re_add_abs_im Complex.abs_le_abs_re_add_abs_imₓ'. -/
theorem abs_le_abs_re_add_abs_im (z : ℂ) : Complex.AbsTheory.Complex.abs z ≤ |z.re| + |z.im| := by
  simpa [re_add_im] using abs.add_le z.re (z.im * I)
#align complex.abs_le_abs_re_add_abs_im Complex.abs_le_abs_re_add_abs_im

/- warning: complex.abs_le_sqrt_two_mul_max -> Complex.abs_le_sqrt_two_mul_max is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (Real.sqrt (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (LinearOrder.max.{0} Real Real.linearOrder (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (Complex.re z)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (Complex.im z))))
but is expected to have type
  forall (z : Complex), LE.le.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real.instLEReal (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (Real.sqrt (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Max.max.{0} Real (LinearOrderedRing.toMax.{0} Real Real.instLinearOrderedRingReal) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (Complex.re z)) (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (Complex.im z))))
Case conversion may be inaccurate. Consider using '#align complex.abs_le_sqrt_two_mul_max Complex.abs_le_sqrt_two_mul_maxₓ'. -/
theorem abs_le_sqrt_two_mul_max (z : ℂ) :
    Complex.AbsTheory.Complex.abs z ≤ Real.sqrt 2 * max (|z.re|) (|z.im|) :=
  by
  cases' z with x y
  simp only [abs_apply, norm_sq_mk, ← sq]
  wlog hle : |x| ≤ |y|
  · rw [add_comm, max_comm]
    exact this _ _ (le_of_not_le hle)
  calc
    Real.sqrt (x ^ 2 + y ^ 2) ≤ Real.sqrt (y ^ 2 + y ^ 2) :=
      Real.sqrt_le_sqrt (add_le_add_right (sq_le_sq.2 hle) _)
    _ = Real.sqrt 2 * max (|x|) (|y|) := by
      rw [max_eq_right hle, ← two_mul, Real.sqrt_mul two_pos.le, Real.sqrt_sq_eq_abs]
    
#align complex.abs_le_sqrt_two_mul_max Complex.abs_le_sqrt_two_mul_max

/- warning: complex.abs_re_div_abs_le_one -> Complex.abs_re_div_abs_le_one is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Complex.re z) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall (z : Complex), LE.le.{0} Real Real.instLEReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (HDiv.hDiv.{0, 0, 0} Real ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Complex.re z) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.abs_re_div_abs_le_one Complex.abs_re_div_abs_le_oneₓ'. -/
theorem abs_re_div_abs_le_one (z : ℂ) : |z.re / z.abs| ≤ 1 :=
  if hz : z = 0 then by simp [hz, zero_le_one]
  else by simp_rw [_root_.abs_div, abs_abs, div_le_iff (abs.pos hz), one_mul, abs_re_le_abs]
#align complex.abs_re_div_abs_le_one Complex.abs_re_div_abs_le_one

/- warning: complex.abs_im_div_abs_le_one -> Complex.abs_im_div_abs_le_one is a dubious translation:
lean 3 declaration is
  forall (z : Complex), LE.le.{0} Real Real.hasLe (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (Complex.im z) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs z))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall (z : Complex), LE.le.{0} Real Real.instLEReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal) (HDiv.hDiv.{0, 0, 0} Real ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) z) Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (Complex.im z) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs z))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align complex.abs_im_div_abs_le_one Complex.abs_im_div_abs_le_oneₓ'. -/
theorem abs_im_div_abs_le_one (z : ℂ) : |z.im / z.abs| ≤ 1 :=
  if hz : z = 0 then by simp [hz, zero_le_one]
  else by simp_rw [_root_.abs_div, abs_abs, div_le_iff (abs.pos hz), one_mul, abs_im_le_abs]
#align complex.abs_im_div_abs_le_one Complex.abs_im_div_abs_le_one

/- warning: complex.abs_cast_nat -> Complex.abs_cast_nat is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Complex (HasLiftT.mk.{1, 1} Nat Complex (CoeTCₓ.coe.{1, 1} Nat Complex (Nat.castCoe.{0} Complex (AddMonoidWithOne.toNatCast.{0} Complex (AddGroupWithOne.toAddMonoidWithOne.{0} Complex Complex.addGroupWithOne))))) n)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) n)
but is expected to have type
  forall (n : Nat), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Nat.cast.{0} Complex (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) n)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (Nat.cast.{0} Complex (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) n)) (Nat.cast.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Nat.cast.{0} Complex (NonAssocRing.toNatCast.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)) n)) Real.natCast n)
Case conversion may be inaccurate. Consider using '#align complex.abs_cast_nat Complex.abs_cast_natₓ'. -/
@[simp, norm_cast]
theorem abs_cast_nat (n : ℕ) : Complex.AbsTheory.Complex.abs (n : ℂ) = n := by
  rw [← of_real_nat_cast, abs_of_nonneg (Nat.cast_nonneg n)]
#align complex.abs_cast_nat Complex.abs_cast_nat

/- warning: complex.int_cast_abs -> Complex.int_cast_abs is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Real ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Real (HasLiftT.mk.{1, 1} Int Real (CoeTCₓ.coe.{1, 1} Int Real (Int.castCoe.{0} Real Real.hasIntCast))) (Abs.abs.{0} Int (Neg.toHasAbs.{0} Int Int.hasNeg (SemilatticeSup.toHasSup.{0} Int (Lattice.toSemilatticeSup.{0} Int (LinearOrder.toLattice.{0} Int Int.linearOrder)))) n)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Int Complex (HasLiftT.mk.{1, 1} Int Complex (CoeTCₓ.coe.{1, 1} Int Complex (Int.castCoe.{0} Complex (AddGroupWithOne.toHasIntCast.{0} Complex Complex.addGroupWithOne)))) n))
but is expected to have type
  forall (n : Int), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Int.cast.{0} Complex (Ring.toIntCast.{0} Complex Complex.instRingComplex) n)) (Abs.abs.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Int.cast.{0} Complex (Ring.toIntCast.{0} Complex Complex.instRingComplex) n)) (Neg.toHasAbs.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Int.cast.{0} Complex (Ring.toIntCast.{0} Complex Complex.instRingComplex) n)) Real.instNegReal Real.instSupReal) (Int.cast.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) (Int.cast.{0} Complex (Ring.toIntCast.{0} Complex Complex.instRingComplex) n)) Real.intCast n)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (Int.cast.{0} Complex (Ring.toIntCast.{0} Complex Complex.instRingComplex) n))
Case conversion may be inaccurate. Consider using '#align complex.int_cast_abs Complex.int_cast_absₓ'. -/
@[simp, norm_cast]
theorem int_cast_abs (n : ℤ) : ↑(|n|) = Complex.AbsTheory.Complex.abs n := by
  rw [← of_real_int_cast, abs_of_real, Int.cast_abs]
#align complex.int_cast_abs Complex.int_cast_abs

/- warning: complex.norm_sq_eq_abs -> Complex.normSq_eq_abs is a dubious translation:
lean 3 declaration is
  forall (x : Complex), Eq.{1} Real (coeFn.{1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (fun (_x : MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) => Complex -> Real) (MonoidWithZeroHom.hasCoeToFun.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.ring))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) Complex.normSq x) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs x) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall (x : Complex), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) x) (FunLike.coe.{1, 1, 1} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulOneClass.toMul.{0} Complex (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))))) (MulOneClass.toMul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (MulZeroOneClass.toMulOneClass.{0} Complex (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) (MonoidWithZeroHomClass.toMonoidHomClass.{0, 0, 0} (MonoidWithZeroHom.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)))) Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (MonoidWithZeroHom.monoidWithZeroHomClass.{0, 0} Complex Real (NonAssocSemiring.toMulZeroOneClass.{0} Complex (NonAssocRing.toNonAssocSemiring.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex))) (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))))))) Complex.normSq x) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) x) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Real) x) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) x) Nat (Monoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) x) Real.instMonoidReal)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs x) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align complex.norm_sq_eq_abs Complex.normSq_eq_absₓ'. -/
theorem normSq_eq_abs (x : ℂ) : normSq x = Complex.AbsTheory.Complex.abs x ^ 2 := by
  simp [abs, sq, Real.mul_self_sqrt (norm_sq_nonneg _)]
#align complex.norm_sq_eq_abs Complex.normSq_eq_abs

#print Complex.partialOrder /-
/-- We put a partial order on ℂ so that `z ≤ w` exactly if `w - z` is real and nonnegative.
Complex numbers with different imaginary parts are incomparable.
-/
protected def partialOrder : PartialOrder ℂ
    where
  le z w := z.re ≤ w.re ∧ z.im = w.im
  lt z w := z.re < w.re ∧ z.im = w.im
  lt_iff_le_not_le z w := by
    dsimp
    rw [lt_iff_le_not_le]
    tauto
  le_refl x := ⟨le_rfl, rfl⟩
  le_trans x y z h₁ h₂ := ⟨h₁.1.trans h₂.1, h₁.2.trans h₂.2⟩
  le_antisymm z w h₁ h₂ := ext (h₁.1.antisymm h₂.1) h₁.2
#align complex.partial_order Complex.partialOrder
-/

section ComplexOrder

scoped[ComplexOrder] attribute [instance] Complex.partialOrder

/- warning: complex.le_def -> Complex.ComplexOrder.le_def is a dubious translation:
lean 3 declaration is
  forall {z : Complex} {w : Complex}, Iff (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z w) (And (LE.le.{0} Real Real.hasLe (Complex.re z) (Complex.re w)) (Eq.{1} Real (Complex.im z) (Complex.im w)))
but is expected to have type
  forall {z : Complex} {w : Complex}, Iff (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z w) (And (LE.le.{0} Real Real.instLEReal (Complex.re z) (Complex.re w)) (Eq.{1} Real (Complex.im z) (Complex.im w)))
Case conversion may be inaccurate. Consider using '#align complex.le_def Complex.ComplexOrder.le_defₓ'. -/
theorem Complex.ComplexOrder.le_def {z w : ℂ} : z ≤ w ↔ z.re ≤ w.re ∧ z.im = w.im :=
  Iff.rfl
#align complex.le_def Complex.ComplexOrder.le_def

/- warning: complex.lt_def -> Complex.ComplexOrder.lt_def is a dubious translation:
lean 3 declaration is
  forall {z : Complex} {w : Complex}, Iff (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z w) (And (LT.lt.{0} Real Real.hasLt (Complex.re z) (Complex.re w)) (Eq.{1} Real (Complex.im z) (Complex.im w)))
but is expected to have type
  forall {z : Complex} {w : Complex}, Iff (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z w) (And (LT.lt.{0} Real Real.instLTReal (Complex.re z) (Complex.re w)) (Eq.{1} Real (Complex.im z) (Complex.im w)))
Case conversion may be inaccurate. Consider using '#align complex.lt_def Complex.ComplexOrder.lt_defₓ'. -/
theorem Complex.ComplexOrder.lt_def {z w : ℂ} : z < w ↔ z.re < w.re ∧ z.im = w.im :=
  Iff.rfl
#align complex.lt_def Complex.ComplexOrder.lt_def

/- warning: complex.real_le_real -> Complex.ComplexOrder.real_le_real is a dubious translation:
lean 3 declaration is
  forall {x : Real} {y : Real}, Iff (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) x) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) y)) (LE.le.{0} Real Real.hasLe x y)
but is expected to have type
  forall {x : Real} {y : Real}, Iff (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) (Complex.ofReal' x) (Complex.ofReal' y)) (LE.le.{0} Real Real.instLEReal x y)
Case conversion may be inaccurate. Consider using '#align complex.real_le_real Complex.ComplexOrder.real_le_realₓ'. -/
@[simp, norm_cast]
theorem Complex.ComplexOrder.real_le_real {x y : ℝ} : (x : ℂ) ≤ (y : ℂ) ↔ x ≤ y := by simp [le_def]
#align complex.real_le_real Complex.ComplexOrder.real_le_real

/- warning: complex.real_lt_real -> Complex.ComplexOrder.real_lt_real is a dubious translation:
lean 3 declaration is
  forall {x : Real} {y : Real}, Iff (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) x) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) y)) (LT.lt.{0} Real Real.hasLt x y)
but is expected to have type
  forall {x : Real} {y : Real}, Iff (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) (Complex.ofReal' x) (Complex.ofReal' y)) (LT.lt.{0} Real Real.instLTReal x y)
Case conversion may be inaccurate. Consider using '#align complex.real_lt_real Complex.ComplexOrder.real_lt_realₓ'. -/
@[simp, norm_cast]
theorem Complex.ComplexOrder.real_lt_real {x y : ℝ} : (x : ℂ) < (y : ℂ) ↔ x < y := by simp [lt_def]
#align complex.real_lt_real Complex.ComplexOrder.real_lt_real

/- warning: complex.zero_le_real -> Complex.ComplexOrder.zero_le_real is a dubious translation:
lean 3 declaration is
  forall {x : Real}, Iff (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) x)) (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) x)
but is expected to have type
  forall {x : Real}, Iff (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (Complex.ofReal' x)) (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) x)
Case conversion may be inaccurate. Consider using '#align complex.zero_le_real Complex.ComplexOrder.zero_le_realₓ'. -/
@[simp, norm_cast]
theorem Complex.ComplexOrder.zero_le_real {x : ℝ} : (0 : ℂ) ≤ (x : ℂ) ↔ 0 ≤ x :=
  Complex.ComplexOrder.real_le_real
#align complex.zero_le_real Complex.ComplexOrder.zero_le_real

/- warning: complex.zero_lt_real -> Complex.ComplexOrder.zero_lt_real is a dubious translation:
lean 3 declaration is
  forall {x : Real}, Iff (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) x)) (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) x)
but is expected to have type
  forall {x : Real}, Iff (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)) (Complex.ofReal' x)) (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) x)
Case conversion may be inaccurate. Consider using '#align complex.zero_lt_real Complex.ComplexOrder.zero_lt_realₓ'. -/
@[simp, norm_cast]
theorem Complex.ComplexOrder.zero_lt_real {x : ℝ} : (0 : ℂ) < (x : ℂ) ↔ 0 < x :=
  Complex.ComplexOrder.real_lt_real
#align complex.zero_lt_real Complex.ComplexOrder.zero_lt_real

/- warning: complex.not_le_iff -> Complex.ComplexOrder.not_le_iff is a dubious translation:
lean 3 declaration is
  forall {z : Complex} {w : Complex}, Iff (Not (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z w)) (Or (LT.lt.{0} Real Real.hasLt (Complex.re w) (Complex.re z)) (Ne.{1} Real (Complex.im z) (Complex.im w)))
but is expected to have type
  forall {z : Complex} {w : Complex}, Iff (Not (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z w)) (Or (LT.lt.{0} Real Real.instLTReal (Complex.re w) (Complex.re z)) (Ne.{1} Real (Complex.im z) (Complex.im w)))
Case conversion may be inaccurate. Consider using '#align complex.not_le_iff Complex.ComplexOrder.not_le_iffₓ'. -/
theorem Complex.ComplexOrder.not_le_iff {z w : ℂ} : ¬z ≤ w ↔ w.re < z.re ∨ z.im ≠ w.im := by
  rw [le_def, not_and_or, not_le]
#align complex.not_le_iff Complex.ComplexOrder.not_le_iff

/- warning: complex.not_lt_iff -> Complex.ComplexOrder.not_lt_iff is a dubious translation:
lean 3 declaration is
  forall {z : Complex} {w : Complex}, Iff (Not (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z w)) (Or (LE.le.{0} Real Real.hasLe (Complex.re w) (Complex.re z)) (Ne.{1} Real (Complex.im z) (Complex.im w)))
but is expected to have type
  forall {z : Complex} {w : Complex}, Iff (Not (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z w)) (Or (LE.le.{0} Real Real.instLEReal (Complex.re w) (Complex.re z)) (Ne.{1} Real (Complex.im z) (Complex.im w)))
Case conversion may be inaccurate. Consider using '#align complex.not_lt_iff Complex.ComplexOrder.not_lt_iffₓ'. -/
theorem Complex.ComplexOrder.not_lt_iff {z w : ℂ} : ¬z < w ↔ w.re ≤ z.re ∨ z.im ≠ w.im := by
  rw [lt_def, not_and_or, not_lt]
#align complex.not_lt_iff Complex.ComplexOrder.not_lt_iff

/- warning: complex.not_le_zero_iff -> Complex.ComplexOrder.not_le_zero_iff is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Iff (Not (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))))) (Or (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Complex.re z)) (Ne.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))
but is expected to have type
  forall {z : Complex}, Iff (Not (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)))) (Or (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Complex.re z)) (Ne.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))
Case conversion may be inaccurate. Consider using '#align complex.not_le_zero_iff Complex.ComplexOrder.not_le_zero_iffₓ'. -/
theorem Complex.ComplexOrder.not_le_zero_iff {z : ℂ} : ¬z ≤ 0 ↔ 0 < z.re ∨ z.im ≠ 0 :=
  Complex.ComplexOrder.not_le_iff
#align complex.not_le_zero_iff Complex.ComplexOrder.not_le_zero_iff

/- warning: complex.not_lt_zero_iff -> Complex.ComplexOrder.not_lt_zero_iff is a dubious translation:
lean 3 declaration is
  forall {z : Complex}, Iff (Not (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z (OfNat.ofNat.{0} Complex 0 (OfNat.mk.{0} Complex 0 (Zero.zero.{0} Complex Complex.hasZero))))) (Or (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Complex.re z)) (Ne.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))
but is expected to have type
  forall {z : Complex}, Iff (Not (LT.lt.{0} Complex (Preorder.toLT.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) z (OfNat.ofNat.{0} Complex 0 (Zero.toOfNat0.{0} Complex Complex.instZeroComplex)))) (Or (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Complex.re z)) (Ne.{1} Real (Complex.im z) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))))
Case conversion may be inaccurate. Consider using '#align complex.not_lt_zero_iff Complex.ComplexOrder.not_lt_zero_iffₓ'. -/
theorem Complex.ComplexOrder.not_lt_zero_iff {z : ℂ} : ¬z < 0 ↔ 0 ≤ z.re ∨ z.im ≠ 0 :=
  Complex.ComplexOrder.not_lt_iff
#align complex.not_lt_zero_iff Complex.ComplexOrder.not_lt_zero_iff

/- warning: complex.eq_re_of_real_le -> Complex.ComplexOrder.eq_re_ofReal_le is a dubious translation:
lean 3 declaration is
  forall {r : Real} {z : Complex}, (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) r) z) -> (Eq.{1} Complex z ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Complex.re z)))
but is expected to have type
  forall {r : Real} {z : Complex}, (LE.le.{0} Complex (Preorder.toLE.{0} Complex (PartialOrder.toPreorder.{0} Complex Complex.partialOrder)) (Complex.ofReal' r) z) -> (Eq.{1} Complex z (Complex.ofReal' (Complex.re z)))
Case conversion may be inaccurate. Consider using '#align complex.eq_re_of_real_le Complex.ComplexOrder.eq_re_ofReal_leₓ'. -/
theorem Complex.ComplexOrder.eq_re_ofReal_le {r : ℝ} {z : ℂ} (hz : (r : ℂ) ≤ z) : z = z.re :=
  by
  ext
  rfl
  simp only [← (Complex.ComplexOrder.le_def.1 hz).2, Complex.zero_im, Complex.ofReal_im]
#align complex.eq_re_of_real_le Complex.ComplexOrder.eq_re_ofReal_le

#print Complex.ComplexOrder.strictOrderedCommRing /-
/-- With `z ≤ w` iff `w - z` is real and nonnegative, `ℂ` is a strictly ordered ring.
-/
protected def Complex.ComplexOrder.strictOrderedCommRing : StrictOrderedCommRing ℂ :=
  { Complex.partialOrder, Complex.commRing,
    Complex.nontrivial with
    zero_le_one := ⟨zero_le_one, rfl⟩
    add_le_add_left := fun w z h y => ⟨add_le_add_left h.1 _, congr_arg₂ (· + ·) rfl h.2⟩
    mul_pos := fun z w hz hw => by
      simp [lt_def, mul_re, mul_im, ← hz.2, ← hw.2, mul_pos hz.1 hw.1] }
#align complex.strict_ordered_comm_ring Complex.ComplexOrder.strictOrderedCommRing
-/

scoped[ComplexOrder] attribute [instance] Complex.ComplexOrder.strictOrderedCommRing

#print Complex.ComplexOrder.starOrderedRing /-
/-- With `z ≤ w` iff `w - z` is real and nonnegative, `ℂ` is a star ordered ring.
(That is, a star ring in which the nonnegative elements are those of the form `star z * z`.)
-/
protected def Complex.ComplexOrder.starOrderedRing : StarOrderedRing ℂ :=
  { Complex.ComplexOrder.strictOrderedCommRing with
    nonneg_iff := fun r =>
      by
      refine' ⟨fun hr => ⟨Real.sqrt r.re, _⟩, fun h => _⟩
      · have h₁ : 0 ≤ r.re := by
          rw [le_def] at hr
          exact hr.1
        have h₂ : r.im = 0 := by
          rw [le_def] at hr
          exact hr.2.symm
        ext
        ·
          simp only [of_real_im, star_def, of_real_re, sub_zero, conj_re, mul_re,
            MulZeroClass.mul_zero, ← Real.sqrt_mul h₁ r.re, Real.sqrt_mul_self h₁]
        ·
          simp only [h₂, add_zero, of_real_im, star_def, MulZeroClass.zero_mul, conj_im, mul_im,
            MulZeroClass.mul_zero, neg_zero]
      · obtain ⟨s, rfl⟩ := h
        simp only [← norm_sq_eq_conj_mul_self, norm_sq_nonneg, zero_le_real, star_def] }
#align complex.star_ordered_ring Complex.ComplexOrder.starOrderedRing
-/

scoped[ComplexOrder] attribute [instance] Complex.ComplexOrder.starOrderedRing

end ComplexOrder

/-! ### Cauchy sequences -/


-- mathport name: exprabs'
local notation "abs'" => Abs.abs

/- warning: complex.is_cau_seq_re -> Complex.isCauSeq_re is a dubious translation:
lean 3 declaration is
  forall (f : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)), IsCauSeq.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)) (fun (n : Nat) => Complex.re (coeFn.{1, 1} (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) (fun (_x : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) => Nat -> Complex) (CauSeq.hasCoeToFun.{0, 0} Real Complex Real.linearOrderedField Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) f n))
but is expected to have type
  forall (f : CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)), IsCauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)) (fun (n : Nat) => Complex.re (Subtype.val.{1} (Nat -> Complex) (fun (f : Nat -> Complex) => IsCauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (a : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) a) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) f) f n))
Case conversion may be inaccurate. Consider using '#align complex.is_cau_seq_re Complex.isCauSeq_reₓ'. -/
theorem isCauSeq_re (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    IsCauSeq abs' fun n => (f n).re := fun ε ε0 =>
  (f.Cauchy ε0).imp fun i H j ij =>
    lt_of_le_of_lt (by simpa using abs_re_le_abs (f j - f i)) (H _ ij)
#align complex.is_cau_seq_re Complex.isCauSeq_re

/- warning: complex.is_cau_seq_im -> Complex.isCauSeq_im is a dubious translation:
lean 3 declaration is
  forall (f : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)), IsCauSeq.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)) (fun (n : Nat) => Complex.im (coeFn.{1, 1} (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) (fun (_x : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) => Nat -> Complex) (CauSeq.hasCoeToFun.{0, 0} Real Complex Real.linearOrderedField Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) f n))
but is expected to have type
  forall (f : CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)), IsCauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)) (fun (n : Nat) => Complex.im (Subtype.val.{1} (Nat -> Complex) (fun (f : Nat -> Complex) => IsCauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (a : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) a) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) f) f n))
Case conversion may be inaccurate. Consider using '#align complex.is_cau_seq_im Complex.isCauSeq_imₓ'. -/
theorem isCauSeq_im (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    IsCauSeq abs' fun n => (f n).im := fun ε ε0 =>
  (f.Cauchy ε0).imp fun i H j ij =>
    lt_of_le_of_lt (by simpa using abs_im_le_abs (f j - f i)) (H _ ij)
#align complex.is_cau_seq_im Complex.isCauSeq_im

/- warning: complex.cau_seq_re -> Complex.cauSeqRe is a dubious translation:
lean 3 declaration is
  (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) -> (CauSeq.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)))
but is expected to have type
  (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)) -> (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)))
Case conversion may be inaccurate. Consider using '#align complex.cau_seq_re Complex.cauSeqReₓ'. -/
/-- The real part of a complex Cauchy sequence, as a real Cauchy sequence. -/
noncomputable def cauSeqRe (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) : CauSeq ℝ abs' :=
  ⟨_, isCauSeq_re f⟩
#align complex.cau_seq_re Complex.cauSeqRe

/- warning: complex.cau_seq_im -> Complex.cauSeqIm is a dubious translation:
lean 3 declaration is
  (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) -> (CauSeq.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)))
but is expected to have type
  (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)) -> (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)))
Case conversion may be inaccurate. Consider using '#align complex.cau_seq_im Complex.cauSeqImₓ'. -/
/-- The imaginary part of a complex Cauchy sequence, as a real Cauchy sequence. -/
noncomputable def cauSeqIm (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) : CauSeq ℝ abs' :=
  ⟨_, isCauSeq_im f⟩
#align complex.cau_seq_im Complex.cauSeqIm

/- warning: complex.is_cau_seq_abs -> Complex.isCauSeq_abs is a dubious translation:
lean 3 declaration is
  forall {f : Nat -> Complex}, (IsCauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) f) -> (IsCauSeq.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)) (Function.comp.{1, 1, 1} Nat Complex Real (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) f))
but is expected to have type
  forall {f : Nat -> Complex}, (IsCauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) f) -> (IsCauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)) (Function.comp.{1, 1, 1} Nat Complex Real (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) f))
Case conversion may be inaccurate. Consider using '#align complex.is_cau_seq_abs Complex.isCauSeq_absₓ'. -/
theorem isCauSeq_abs {f : ℕ → ℂ} (hf : IsCauSeq Complex.AbsTheory.Complex.abs f) :
    IsCauSeq abs' (Complex.AbsTheory.Complex.abs ∘ f) := fun ε ε0 =>
  let ⟨i, hi⟩ := hf ε ε0
  ⟨i, fun j hj =>
    lt_of_le_of_lt (Complex.AbsTheory.Complex.abs.abs_abv_sub_le_abv_sub _ _) (hi j hj)⟩
#align complex.is_cau_seq_abs Complex.isCauSeq_abs

/- warning: complex.lim_aux -> Complex.limAux is a dubious translation:
lean 3 declaration is
  (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) -> Complex
but is expected to have type
  (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)) -> Complex
Case conversion may be inaccurate. Consider using '#align complex.lim_aux Complex.limAuxₓ'. -/
/-- The limit of a Cauchy sequence of complex numbers. -/
noncomputable def limAux (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) : ℂ :=
  ⟨CauSeq.lim (cauSeqRe f), CauSeq.lim (cauSeqIm f)⟩
#align complex.lim_aux Complex.limAux

/- warning: complex.equiv_lim_aux -> Complex.equiv_limAux is a dubious translation:
lean 3 declaration is
  forall (f : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)), HasEquivₓ.Equiv.{1} (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) (setoidHasEquiv.{1} (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) (CauSeq.equiv.{0, 0} Real Complex Real.linearOrderedField Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (StrictOrderedSemiring.toOrderedSemiring.{0} Real (StrictOrderedRing.toStrictOrderedSemiring.{0} Real (LinearOrderedRing.toStrictOrderedRing.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.linearOrderedField))))) Complex (Ring.toSemiring.{0} Complex Complex.ring) Complex.AbsTheory.Complex.abs))) f (CauSeq.const.{0, 0} Real Complex Real.linearOrderedField Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (StrictOrderedSemiring.toOrderedSemiring.{0} Real (StrictOrderedRing.toStrictOrderedSemiring.{0} Real (LinearOrderedRing.toStrictOrderedRing.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.linearOrderedField))))) Complex (Ring.toSemiring.{0} Complex Complex.ring) Complex.AbsTheory.Complex.abs) (Complex.limAux f))
but is expected to have type
  forall (f : CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)), HasEquiv.Equiv.{1, 0} (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)) (instHasEquiv.{1} (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)) (CauSeq.equiv.{0, 0} Real Complex Real.instLinearOrderedFieldReal Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (OrderedCommSemiring.toOrderedSemiring.{0} Real (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Real (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Real (LinearOrderedSemifield.toLinearOrderedCommSemiring.{0} Real (LinearOrderedField.toLinearOrderedSemifield.{0} Real Real.instLinearOrderedFieldReal))))) Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex) Complex.AbsTheory.Complex.abs))) f (CauSeq.const.{0, 0} Real Complex Real.instLinearOrderedFieldReal Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (OrderedCommSemiring.toOrderedSemiring.{0} Real (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Real (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Real (LinearOrderedSemifield.toLinearOrderedCommSemiring.{0} Real (LinearOrderedField.toLinearOrderedSemifield.{0} Real Real.instLinearOrderedFieldReal))))) Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex) Complex.AbsTheory.Complex.abs) (Complex.limAux f))
Case conversion may be inaccurate. Consider using '#align complex.equiv_lim_aux Complex.equiv_limAuxₓ'. -/
theorem equiv_limAux (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    f ≈ CauSeq.const Complex.AbsTheory.Complex.abs (limAux f) := fun ε ε0 =>
  (exists_forall_ge_and (CauSeq.equiv_lim ⟨_, isCauSeq_re f⟩ _ (half_pos ε0))
        (CauSeq.equiv_lim ⟨_, isCauSeq_im f⟩ _ (half_pos ε0))).imp
    fun i H j ij => by
    cases' H _ ij with H₁ H₂
    apply lt_of_le_of_lt (abs_le_abs_re_add_abs_im _)
    dsimp [lim_aux] at *
    have := add_lt_add H₁ H₂
    rwa [add_halves] at this
#align complex.equiv_lim_aux Complex.equiv_limAux

instance : CauSeq.IsComplete ℂ Complex.AbsTheory.Complex.abs :=
  ⟨fun f => ⟨limAux f, equiv_limAux f⟩⟩

open CauSeq

/- warning: complex.lim_eq_lim_im_add_lim_re -> Complex.lim_eq_lim_im_add_lim_re is a dubious translation:
lean 3 declaration is
  forall (f : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)), Eq.{1} Complex (CauSeq.lim.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (StrictOrderedSemiring.toOrderedSemiring.{0} Real (StrictOrderedRing.toStrictOrderedSemiring.{0} Real (LinearOrderedRing.toStrictOrderedRing.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.linearOrderedField))))) Complex (Ring.toSemiring.{0} Complex Complex.ring) Complex.AbsTheory.Complex.abs) Complex.AbsTheory.Complex.abs.CauSeq.isComplete f) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (CauSeq.lim.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.linearOrderedRing) Real.HasAbs.Abs.CauSeq.isComplete (Complex.cauSeqRe f))) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.hasMul) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (CauSeq.lim.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.linearOrderedRing) Real.HasAbs.Abs.CauSeq.isComplete (Complex.cauSeqIm f))) Complex.I))
but is expected to have type
  forall (f : CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)), Eq.{1} Complex (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (OrderedCommSemiring.toOrderedSemiring.{0} Real (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Real (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Real (LinearOrderedSemifield.toLinearOrderedCommSemiring.{0} Real (LinearOrderedField.toLinearOrderedSemifield.{0} Real Real.instLinearOrderedFieldReal))))) Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex) Complex.AbsTheory.Complex.abs) Complex.instIsCompleteRealInstLinearOrderedFieldRealComplexInstRingComplexCoeAbsoluteValueToSemiringToDivisionSemiringToSemifieldInstFieldComplexOrderedSemiringToFunLikeToAddToDistribToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToLEToPreorderToPartialOrderSubadditiveHomClassAbsIsAbsoluteValueToOrderedSemiringToOrderedCommSemiringToStrictOrderedCommSemiringToLinearOrderedCommSemiringToLinearOrderedSemifieldToSemiring f) (HAdd.hAdd.{0, 0, 0} Complex Complex Complex (instHAdd.{0} Complex Complex.instAddComplex) (Complex.ofReal' (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.instLinearOrderedRingReal) Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal (Complex.cauSeqRe f))) (HMul.hMul.{0, 0, 0} Complex Complex Complex (instHMul.{0} Complex Complex.instMulComplex) (Complex.ofReal' (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.instLinearOrderedRingReal) Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal (Complex.cauSeqIm f))) Complex.I))
Case conversion may be inaccurate. Consider using '#align complex.lim_eq_lim_im_add_lim_re Complex.lim_eq_lim_im_add_lim_reₓ'. -/
theorem lim_eq_lim_im_add_lim_re (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    limUnder f = ↑(limUnder (cauSeqRe f)) + ↑(limUnder (cauSeqIm f)) * I :=
  lim_eq_of_equiv_const <|
    calc
      f ≈ _ := equiv_limAux f
      _ =
          CauSeq.const Complex.AbsTheory.Complex.abs
            (↑(limUnder (cauSeqRe f)) + ↑(limUnder (cauSeqIm f)) * I) :=
        CauSeq.ext fun _ =>
          Complex.ext (by simp [lim_aux, cau_seq_re]) (by simp [lim_aux, cau_seq_im])
      
#align complex.lim_eq_lim_im_add_lim_re Complex.lim_eq_lim_im_add_lim_re

/- warning: complex.lim_re -> Complex.lim_re is a dubious translation:
lean 3 declaration is
  forall (f : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)), Eq.{1} Real (CauSeq.lim.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.linearOrderedRing) Real.HasAbs.Abs.CauSeq.isComplete (Complex.cauSeqRe f)) (Complex.re (CauSeq.lim.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (StrictOrderedSemiring.toOrderedSemiring.{0} Real (StrictOrderedRing.toStrictOrderedSemiring.{0} Real (LinearOrderedRing.toStrictOrderedRing.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.linearOrderedField))))) Complex (Ring.toSemiring.{0} Complex Complex.ring) Complex.AbsTheory.Complex.abs) Complex.AbsTheory.Complex.abs.CauSeq.isComplete f))
but is expected to have type
  forall (f : CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)), Eq.{1} Real (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.instLinearOrderedRingReal) Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal (Complex.cauSeqRe f)) (Complex.re (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (OrderedCommSemiring.toOrderedSemiring.{0} Real (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Real (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Real (LinearOrderedSemifield.toLinearOrderedCommSemiring.{0} Real (LinearOrderedField.toLinearOrderedSemifield.{0} Real Real.instLinearOrderedFieldReal))))) Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex) Complex.AbsTheory.Complex.abs) Complex.instIsCompleteRealInstLinearOrderedFieldRealComplexInstRingComplexCoeAbsoluteValueToSemiringToDivisionSemiringToSemifieldInstFieldComplexOrderedSemiringToFunLikeToAddToDistribToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToLEToPreorderToPartialOrderSubadditiveHomClassAbsIsAbsoluteValueToOrderedSemiringToOrderedCommSemiringToStrictOrderedCommSemiringToLinearOrderedCommSemiringToLinearOrderedSemifieldToSemiring f))
Case conversion may be inaccurate. Consider using '#align complex.lim_re Complex.lim_reₓ'. -/
theorem lim_re (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    limUnder (cauSeqRe f) = (limUnder f).re := by rw [lim_eq_lim_im_add_lim_re] <;> simp
#align complex.lim_re Complex.lim_re

/- warning: complex.lim_im -> Complex.lim_im is a dubious translation:
lean 3 declaration is
  forall (f : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)), Eq.{1} Real (CauSeq.lim.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.linearOrderedRing) Real.HasAbs.Abs.CauSeq.isComplete (Complex.cauSeqIm f)) (Complex.im (CauSeq.lim.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (StrictOrderedSemiring.toOrderedSemiring.{0} Real (StrictOrderedRing.toStrictOrderedSemiring.{0} Real (LinearOrderedRing.toStrictOrderedRing.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.linearOrderedField))))) Complex (Ring.toSemiring.{0} Complex Complex.ring) Complex.AbsTheory.Complex.abs) Complex.AbsTheory.Complex.abs.CauSeq.isComplete f))
but is expected to have type
  forall (f : CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)), Eq.{1} Real (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.instLinearOrderedRingReal) Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal (Complex.cauSeqIm f)) (Complex.im (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (OrderedCommSemiring.toOrderedSemiring.{0} Real (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Real (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Real (LinearOrderedSemifield.toLinearOrderedCommSemiring.{0} Real (LinearOrderedField.toLinearOrderedSemifield.{0} Real Real.instLinearOrderedFieldReal))))) Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex) Complex.AbsTheory.Complex.abs) Complex.instIsCompleteRealInstLinearOrderedFieldRealComplexInstRingComplexCoeAbsoluteValueToSemiringToDivisionSemiringToSemifieldInstFieldComplexOrderedSemiringToFunLikeToAddToDistribToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToLEToPreorderToPartialOrderSubadditiveHomClassAbsIsAbsoluteValueToOrderedSemiringToOrderedCommSemiringToStrictOrderedCommSemiringToLinearOrderedCommSemiringToLinearOrderedSemifieldToSemiring f))
Case conversion may be inaccurate. Consider using '#align complex.lim_im Complex.lim_imₓ'. -/
theorem lim_im (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    limUnder (cauSeqIm f) = (limUnder f).im := by rw [lim_eq_lim_im_add_lim_re] <;> simp
#align complex.lim_im Complex.lim_im

/- warning: complex.is_cau_seq_conj -> Complex.isCauSeq_conj is a dubious translation:
lean 3 declaration is
  forall (f : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)), IsCauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (fun (n : Nat) => coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) (coeFn.{1, 1} (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) (fun (_x : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) => Nat -> Complex) (CauSeq.hasCoeToFun.{0, 0} Real Complex Real.linearOrderedField Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) f n))
but is expected to have type
  forall (f : CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)), IsCauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (fun (n : Nat) => FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) (Subtype.val.{1} (Nat -> Complex) (fun (f : Nat -> Complex) => IsCauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (a : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) a) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) f) f n))
Case conversion may be inaccurate. Consider using '#align complex.is_cau_seq_conj Complex.isCauSeq_conjₓ'. -/
theorem isCauSeq_conj (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    IsCauSeq Complex.AbsTheory.Complex.abs fun n => conj (f n) := fun ε ε0 =>
  let ⟨i, hi⟩ := f.2 ε ε0
  ⟨i, fun j hj => by rw [← RingHom.map_sub, abs_conj] <;> exact hi j hj⟩
#align complex.is_cau_seq_conj Complex.isCauSeq_conj

/- warning: complex.cau_seq_conj -> Complex.cauSeqConj is a dubious translation:
lean 3 declaration is
  (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) -> (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs))
but is expected to have type
  (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)) -> (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs))
Case conversion may be inaccurate. Consider using '#align complex.cau_seq_conj Complex.cauSeqConjₓ'. -/
/-- The complex conjugate of a complex Cauchy sequence, as a complex Cauchy sequence. -/
noncomputable def cauSeqConj (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    CauSeq ℂ Complex.AbsTheory.Complex.abs :=
  ⟨_, isCauSeq_conj f⟩
#align complex.cau_seq_conj Complex.cauSeqConj

/- warning: complex.lim_conj -> Complex.lim_conj is a dubious translation:
lean 3 declaration is
  forall (f : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)), Eq.{1} Complex (CauSeq.lim.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (StrictOrderedSemiring.toOrderedSemiring.{0} Real (StrictOrderedRing.toStrictOrderedSemiring.{0} Real (LinearOrderedRing.toStrictOrderedRing.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.linearOrderedField))))) Complex (Ring.toSemiring.{0} Complex Complex.ring) Complex.AbsTheory.Complex.abs) Complex.AbsTheory.Complex.abs.CauSeq.isComplete (Complex.cauSeqConj f)) (coeFn.{1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (fun (_x : RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) => Complex -> Complex) (RingHom.hasCoeToFun.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.commSemiring))) (starRingEnd.{0} Complex Complex.commSemiring Complex.starRing) (CauSeq.lim.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (StrictOrderedSemiring.toOrderedSemiring.{0} Real (StrictOrderedRing.toStrictOrderedSemiring.{0} Real (LinearOrderedRing.toStrictOrderedRing.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.linearOrderedField))))) Complex (Ring.toSemiring.{0} Complex Complex.ring) Complex.AbsTheory.Complex.abs) Complex.AbsTheory.Complex.abs.CauSeq.isComplete f))
but is expected to have type
  forall (f : CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)), Eq.{1} Complex (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (OrderedCommSemiring.toOrderedSemiring.{0} Real (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Real (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Real (LinearOrderedSemifield.toLinearOrderedCommSemiring.{0} Real (LinearOrderedField.toLinearOrderedSemifield.{0} Real Real.instLinearOrderedFieldReal))))) Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex) Complex.AbsTheory.Complex.abs) Complex.instIsCompleteRealInstLinearOrderedFieldRealComplexInstRingComplexCoeAbsoluteValueToSemiringToDivisionSemiringToSemifieldInstFieldComplexOrderedSemiringToFunLikeToAddToDistribToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToLEToPreorderToPartialOrderSubadditiveHomClassAbsIsAbsoluteValueToOrderedSemiringToOrderedCommSemiringToStrictOrderedCommSemiringToLinearOrderedCommSemiringToLinearOrderedSemifieldToSemiring (Complex.cauSeqConj f)) (FunLike.coe.{1, 1, 1} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex (fun (_x : Complex) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Complex) => Complex) _x) (MulHomClass.toFunLike.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalNonAssocSemiring.toMul.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))) (NonUnitalRingHomClass.toMulHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) (RingHomClass.toNonUnitalRingHomClass.{0, 0, 0} (RingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex))) Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (RingHom.instRingHomClassRingHom.{0, 0} Complex Complex (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)) (Semiring.toNonAssocSemiring.{0} Complex (CommSemiring.toSemiring.{0} Complex Complex.instCommSemiringComplex)))))) (starRingEnd.{0} Complex Complex.instCommSemiringComplex Complex.instStarRingComplexToNonUnitalSemiringToNonUnitalRingToNonUnitalCommRingCommRing) (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (OrderedCommSemiring.toOrderedSemiring.{0} Real (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Real (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Real (LinearOrderedSemifield.toLinearOrderedCommSemiring.{0} Real (LinearOrderedField.toLinearOrderedSemifield.{0} Real Real.instLinearOrderedFieldReal))))) Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex) Complex.AbsTheory.Complex.abs) Complex.instIsCompleteRealInstLinearOrderedFieldRealComplexInstRingComplexCoeAbsoluteValueToSemiringToDivisionSemiringToSemifieldInstFieldComplexOrderedSemiringToFunLikeToAddToDistribToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToLEToPreorderToPartialOrderSubadditiveHomClassAbsIsAbsoluteValueToOrderedSemiringToOrderedCommSemiringToStrictOrderedCommSemiringToLinearOrderedCommSemiringToLinearOrderedSemifieldToSemiring f))
Case conversion may be inaccurate. Consider using '#align complex.lim_conj Complex.lim_conjₓ'. -/
theorem lim_conj (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    limUnder (cauSeqConj f) = conj (limUnder f) :=
  Complex.ext (by simp [cau_seq_conj, (lim_re _).symm, cau_seq_re])
    (by simp [cau_seq_conj, (lim_im _).symm, cau_seq_im, (lim_neg _).symm] <;> rfl)
#align complex.lim_conj Complex.lim_conj

/- warning: complex.cau_seq_abs -> Complex.cauSeqAbs is a dubious translation:
lean 3 declaration is
  (CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)) -> (CauSeq.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)))
but is expected to have type
  (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)) -> (CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)))
Case conversion may be inaccurate. Consider using '#align complex.cau_seq_abs Complex.cauSeqAbsₓ'. -/
/-- The absolute value of a complex Cauchy sequence, as a real Cauchy sequence. -/
noncomputable def cauSeqAbs (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) : CauSeq ℝ abs' :=
  ⟨_, isCauSeq_abs f.2⟩
#align complex.cau_seq_abs Complex.cauSeqAbs

/- warning: complex.lim_abs -> Complex.lim_abs is a dubious translation:
lean 3 declaration is
  forall (f : CauSeq.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs)), Eq.{1} Real (CauSeq.lim.{0, 0} Real Real.linearOrderedField Real Real.ring (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.hasNeg Real.hasSup)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.linearOrderedRing) Real.HasAbs.Abs.CauSeq.isComplete (Complex.cauSeqAbs f)) (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs (CauSeq.lim.{0, 0} Real Real.linearOrderedField Complex Complex.ring (coeFn.{1, 1} (AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) (fun (f : AbsoluteValue.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) => Complex -> Real) (AbsoluteValue.hasCoeToFun.{0, 0} Complex Real (Ring.toSemiring.{0} Complex Complex.ring) Real.orderedSemiring) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (StrictOrderedSemiring.toOrderedSemiring.{0} Real (StrictOrderedRing.toStrictOrderedSemiring.{0} Real (LinearOrderedRing.toStrictOrderedRing.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.linearOrderedField))))) Complex (Ring.toSemiring.{0} Complex Complex.ring) Complex.AbsTheory.Complex.abs) Complex.AbsTheory.Complex.abs.CauSeq.isComplete f))
but is expected to have type
  forall (f : CauSeq.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs)), Eq.{1} Real (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Real Real.instRingReal (Abs.abs.{0} Real (Neg.toHasAbs.{0} Real Real.instNegReal Real.instSupReal)) (IsAbsoluteValue.abs_isAbsoluteValue.{0} Real Real.instLinearOrderedRingReal) Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal (Complex.cauSeqAbs f)) (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs (CauSeq.lim.{0, 0} Real Real.instLinearOrderedFieldReal Complex Complex.instRingComplex (FunLike.coe.{1, 1, 1} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex (fun (f : Complex) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Complex) => Real) f) (SubadditiveHomClass.toFunLike.{0, 0, 0} (AbsoluteValue.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring) Complex Real (Distrib.toAdd.{0} Complex (NonUnitalNonAssocSemiring.toDistrib.{0} Complex (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Complex (Semiring.toNonAssocSemiring.{0} Complex (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))))))) (Distrib.toAdd.{0} Real (NonUnitalNonAssocSemiring.toDistrib.{0} Real (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Real (Semiring.toNonAssocSemiring.{0} Real (OrderedSemiring.toSemiring.{0} Real Real.orderedSemiring))))) (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedSemiring.toPartialOrder.{0} Real Real.orderedSemiring))) (AbsoluteValue.subadditiveHomClass.{0, 0} Complex Real (DivisionSemiring.toSemiring.{0} Complex (Semifield.toDivisionSemiring.{0} Complex (Field.toSemifield.{0} Complex Complex.instFieldComplex))) Real.orderedSemiring)) Complex.AbsTheory.Complex.abs) (AbsoluteValue.isAbsoluteValue.{0, 0} Real (OrderedCommSemiring.toOrderedSemiring.{0} Real (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Real (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Real (LinearOrderedSemifield.toLinearOrderedCommSemiring.{0} Real (LinearOrderedField.toLinearOrderedSemifield.{0} Real Real.instLinearOrderedFieldReal))))) Complex (Ring.toSemiring.{0} Complex Complex.instRingComplex) Complex.AbsTheory.Complex.abs) Complex.instIsCompleteRealInstLinearOrderedFieldRealComplexInstRingComplexCoeAbsoluteValueToSemiringToDivisionSemiringToSemifieldInstFieldComplexOrderedSemiringToFunLikeToAddToDistribToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToLEToPreorderToPartialOrderSubadditiveHomClassAbsIsAbsoluteValueToOrderedSemiringToOrderedCommSemiringToStrictOrderedCommSemiringToLinearOrderedCommSemiringToLinearOrderedSemifieldToSemiring f))
Case conversion may be inaccurate. Consider using '#align complex.lim_abs Complex.lim_absₓ'. -/
theorem lim_abs (f : CauSeq ℂ Complex.AbsTheory.Complex.abs) :
    limUnder (cauSeqAbs f) = Complex.AbsTheory.Complex.abs (limUnder f) :=
  lim_eq_of_equiv_const fun ε ε0 =>
    let ⟨i, hi⟩ := equiv_lim f ε ε0
    ⟨i, fun j hj =>
      lt_of_le_of_lt (Complex.AbsTheory.Complex.abs.abs_abv_sub_le_abv_sub _ _) (hi j hj)⟩
#align complex.lim_abs Complex.lim_abs

variable {α : Type _} (s : Finset α)

/- warning: complex.of_real_prod -> Complex.ofReal_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (s : Finset.{u1} α) (f : α -> Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Finset.prod.{0, u1} Real α Real.commMonoid s (fun (i : α) => f i))) (Finset.prod.{0, u1} Complex α (CommRing.toCommMonoid.{0} Complex Complex.commRing) s (fun (i : α) => (fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (f i)))
but is expected to have type
  forall {α : Type.{u1}} (s : Finset.{u1} α) (f : α -> Real), Eq.{1} Complex (Complex.ofReal' (Finset.prod.{0, u1} Real α Real.instCommMonoidReal s (fun (i : α) => f i))) (Finset.prod.{0, u1} Complex α (CommRing.toCommMonoid.{0} Complex Complex.commRing) s (fun (i : α) => Complex.ofReal' (f i)))
Case conversion may be inaccurate. Consider using '#align complex.of_real_prod Complex.ofReal_prodₓ'. -/
@[simp, norm_cast]
theorem ofReal_prod (f : α → ℝ) : ((∏ i in s, f i : ℝ) : ℂ) = ∏ i in s, (f i : ℂ) :=
  RingHom.map_prod ofReal _ _
#align complex.of_real_prod Complex.ofReal_prod

/- warning: complex.of_real_sum -> Complex.ofReal_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (s : Finset.{u1} α) (f : α -> Real), Eq.{1} Complex ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (Finset.sum.{0, u1} Real α Real.addCommMonoid s (fun (i : α) => f i))) (Finset.sum.{0, u1} Complex α (AddCommGroup.toAddCommMonoid.{0} Complex Complex.addCommGroup) s (fun (i : α) => (fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Real Complex (HasLiftT.mk.{1, 1} Real Complex (CoeTCₓ.coe.{1, 1} Real Complex (coeBase.{1, 1} Real Complex Complex.hasCoe))) (f i)))
but is expected to have type
  forall {α : Type.{u1}} (s : Finset.{u1} α) (f : α -> Real), Eq.{1} Complex (Complex.ofReal' (Finset.sum.{0, u1} Real α Real.instAddCommMonoidReal s (fun (i : α) => f i))) (Finset.sum.{0, u1} Complex α (NonUnitalNonAssocSemiring.toAddCommMonoid.{0} Complex (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} Complex (NonAssocRing.toNonUnitalNonAssocRing.{0} Complex (Ring.toNonAssocRing.{0} Complex Complex.instRingComplex)))) s (fun (i : α) => Complex.ofReal' (f i)))
Case conversion may be inaccurate. Consider using '#align complex.of_real_sum Complex.ofReal_sumₓ'. -/
@[simp, norm_cast]
theorem ofReal_sum (f : α → ℝ) : ((∑ i in s, f i : ℝ) : ℂ) = ∑ i in s, (f i : ℂ) :=
  RingHom.map_sum ofReal _ _
#align complex.of_real_sum Complex.ofReal_sum

#print Complex.re_sum /-
@[simp]
theorem re_sum (f : α → ℂ) : (∑ i in s, f i).re = ∑ i in s, (f i).re :=
  reAddGroupHom.map_sum f s
#align complex.re_sum Complex.re_sum
-/

#print Complex.im_sum /-
@[simp]
theorem im_sum (f : α → ℂ) : (∑ i in s, f i).im = ∑ i in s, (f i).im :=
  imAddGroupHom.map_sum f s
#align complex.im_sum Complex.im_sum
-/

end Complex

