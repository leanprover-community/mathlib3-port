/-
Copyright (c) 2017 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro

! This file was ported from Lean 3 source module data.finset.sort
! leanprover-community/mathlib commit d6fad0e5bf2d6f48da9175d25c3dc5706b3834ce
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Order.RelIso.Set
import Mathbin.Data.Fintype.Lattice
import Mathbin.Data.Multiset.Sort
import Mathbin.Data.List.NodupEquivFin

/-!
# Construct a sorted list from a finset.
-/


namespace Finset

open Multiset Nat

variable {α β : Type _}

/-! ### sort -/


section Sort

variable (r : α → α → Prop) [DecidableRel r] [IsTrans α r] [IsAntisymm α r] [IsTotal α r]

#print Finset.sort /-
/-- `sort s` constructs a sorted list from the unordered set `s`.
  (Uses merge sort algorithm.) -/
def sort (s : Finset α) : List α :=
  sort r s.1
#align finset.sort Finset.sort
-/

#print Finset.sort_sorted /-
@[simp]
theorem sort_sorted (s : Finset α) : List.Sorted r (sort r s) :=
  sort_sorted _ _
#align finset.sort_sorted Finset.sort_sorted
-/

#print Finset.sort_eq /-
@[simp]
theorem sort_eq (s : Finset α) : ↑(sort r s) = s.1 :=
  sort_eq _ _
#align finset.sort_eq Finset.sort_eq
-/

#print Finset.sort_nodup /-
@[simp]
theorem sort_nodup (s : Finset α) : (sort r s).Nodup :=
  (by rw [sort_eq] <;> exact s.2 : @Multiset.Nodup α (sort r s))
#align finset.sort_nodup Finset.sort_nodup
-/

#print Finset.sort_toFinset /-
@[simp]
theorem sort_toFinset [DecidableEq α] (s : Finset α) : (sort r s).toFinset = s :=
  List.toFinset_eq (sort_nodup r s) ▸ eq_of_veq (sort_eq r s)
#align finset.sort_to_finset Finset.sort_toFinset
-/

#print Finset.mem_sort /-
@[simp]
theorem mem_sort {s : Finset α} {a : α} : a ∈ sort r s ↔ a ∈ s :=
  Multiset.mem_sort _
#align finset.mem_sort Finset.mem_sort
-/

#print Finset.length_sort /-
@[simp]
theorem length_sort {s : Finset α} : (sort r s).length = s.card :=
  Multiset.length_sort _
#align finset.length_sort Finset.length_sort
-/

#print Finset.sort_empty /-
@[simp]
theorem sort_empty : sort r ∅ = [] :=
  Multiset.sort_zero r
#align finset.sort_empty Finset.sort_empty
-/

#print Finset.sort_singleton /-
@[simp]
theorem sort_singleton (a : α) : sort r {a} = [a] :=
  Multiset.sort_singleton r a
#align finset.sort_singleton Finset.sort_singleton
-/

#print Finset.sort_perm_toList /-
theorem sort_perm_toList (s : Finset α) : sort r s ~ s.toList :=
  by
  rw [← Multiset.coe_eq_coe]
  simp only [coe_to_list, sort_eq]
#align finset.sort_perm_to_list Finset.sort_perm_toList
-/

end Sort

section SortLinearOrder

variable [LinearOrder α]

#print Finset.sort_sorted_lt /-
theorem sort_sorted_lt (s : Finset α) : List.Sorted (· < ·) (sort (· ≤ ·) s) :=
  (sort_sorted _ _).imp₂ (@lt_of_le_of_ne _ _) (sort_nodup _ _)
#align finset.sort_sorted_lt Finset.sort_sorted_lt
-/

#print Finset.sorted_zero_eq_min'_aux /-
theorem sorted_zero_eq_min'_aux (s : Finset α) (h : 0 < (s.sort (· ≤ ·)).length) (H : s.Nonempty) :
    (s.sort (· ≤ ·)).nthLe 0 h = s.min' H :=
  by
  let l := s.sort (· ≤ ·)
  apply le_antisymm
  · have : s.min' H ∈ l := (Finset.mem_sort (· ≤ ·)).mpr (s.min'_mem H)
    obtain ⟨i, i_lt, hi⟩ : ∃ (i : _)(hi : i < l.length), l.nth_le i hi = s.min' H :=
      List.mem_iff_nthLe.1 this
    rw [← hi]
    exact (s.sort_sorted (· ≤ ·)).rel_nth_le_of_le _ _ (Nat.zero_le i)
  · have : l.nth_le 0 h ∈ s := (Finset.mem_sort (· ≤ ·)).1 (List.nthLe_mem l 0 h)
    exact s.min'_le _ this
#align finset.sorted_zero_eq_min'_aux Finset.sorted_zero_eq_min'_aux
-/

#print Finset.sorted_zero_eq_min' /-
theorem sorted_zero_eq_min' {s : Finset α} {h : 0 < (s.sort (· ≤ ·)).length} :
    (s.sort (· ≤ ·)).nthLe 0 h = s.min' (card_pos.1 <| by rwa [length_sort] at h) :=
  sorted_zero_eq_min'_aux _ _ _
#align finset.sorted_zero_eq_min' Finset.sorted_zero_eq_min'
-/

#print Finset.min'_eq_sorted_zero /-
theorem min'_eq_sorted_zero {s : Finset α} {h : s.Nonempty} :
    s.min' h =
      (s.sort (· ≤ ·)).nthLe 0
        (by
          rw [length_sort]
          exact card_pos.2 h) :=
  (sorted_zero_eq_min'_aux _ _ _).symm
#align finset.min'_eq_sorted_zero Finset.min'_eq_sorted_zero
-/

#print Finset.sorted_last_eq_max'_aux /-
theorem sorted_last_eq_max'_aux (s : Finset α)
    (h : (s.sort (· ≤ ·)).length - 1 < (s.sort (· ≤ ·)).length) (H : s.Nonempty) :
    (s.sort (· ≤ ·)).nthLe ((s.sort (· ≤ ·)).length - 1) h = s.max' H :=
  by
  let l := s.sort (· ≤ ·)
  apply le_antisymm
  · have : l.nth_le ((s.sort (· ≤ ·)).length - 1) h ∈ s :=
      (Finset.mem_sort (· ≤ ·)).1 (List.nthLe_mem l _ h)
    exact s.le_max' _ this
  · have : s.max' H ∈ l := (Finset.mem_sort (· ≤ ·)).mpr (s.max'_mem H)
    obtain ⟨i, i_lt, hi⟩ : ∃ (i : _)(hi : i < l.length), l.nth_le i hi = s.max' H :=
      List.mem_iff_nthLe.1 this
    rw [← hi]
    have : i ≤ l.length - 1 := Nat.le_pred_of_lt i_lt
    exact (s.sort_sorted (· ≤ ·)).rel_nth_le_of_le _ _ (Nat.le_pred_of_lt i_lt)
#align finset.sorted_last_eq_max'_aux Finset.sorted_last_eq_max'_aux
-/

#print Finset.sorted_last_eq_max' /-
theorem sorted_last_eq_max' {s : Finset α}
    {h : (s.sort (· ≤ ·)).length - 1 < (s.sort (· ≤ ·)).length} :
    (s.sort (· ≤ ·)).nthLe ((s.sort (· ≤ ·)).length - 1) h =
      s.max'
        (by
          rw [length_sort] at h
          exact card_pos.1 (lt_of_le_of_lt bot_le h)) :=
  sorted_last_eq_max'_aux _ _ _
#align finset.sorted_last_eq_max' Finset.sorted_last_eq_max'
-/

#print Finset.max'_eq_sorted_last /-
theorem max'_eq_sorted_last {s : Finset α} {h : s.Nonempty} :
    s.max' h =
      (s.sort (· ≤ ·)).nthLe ((s.sort (· ≤ ·)).length - 1)
        (by simpa using Nat.sub_lt (card_pos.mpr h) zero_lt_one) :=
  (sorted_last_eq_max'_aux _ _ _).symm
#align finset.max'_eq_sorted_last Finset.max'_eq_sorted_last
-/

#print Finset.orderIsoOfFin /-
/-- Given a finset `s` of cardinality `k` in a linear order `α`, the map `order_iso_of_fin s h`
is the increasing bijection between `fin k` and `s` as an `order_iso`. Here, `h` is a proof that
the cardinality of `s` is `k`. We use this instead of an iso `fin s.card ≃o s` to avoid
casting issues in further uses of this function. -/
def orderIsoOfFin (s : Finset α) {k : ℕ} (h : s.card = k) : Fin k ≃o s :=
  OrderIso.trans (Fin.cast ((length_sort (· ≤ ·)).trans h).symm) <|
    (s.sort_sorted_lt.nthLeIso _).trans <| OrderIso.setCongr _ _ <| Set.ext fun x => mem_sort _
#align finset.order_iso_of_fin Finset.orderIsoOfFin
-/

/- warning: finset.order_emb_of_fin clashes with finset.orderEmbOfFin -> Finset.orderEmbOfFin
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_fin Finset.orderEmbOfFinₓ'. -/
#print Finset.orderEmbOfFin /-
/-- Given a finset `s` of cardinality `k` in a linear order `α`, the map `order_emb_of_fin s h` is
the increasing bijection between `fin k` and `s` as an order embedding into `α`. Here, `h` is a
proof that the cardinality of `s` is `k`. We use this instead of an embedding `fin s.card ↪o α` to
avoid casting issues in further uses of this function. -/
def orderEmbOfFin (s : Finset α) {k : ℕ} (h : s.card = k) : Fin k ↪o α :=
  (orderIsoOfFin s h).toOrderEmbedding.trans (OrderEmbedding.subtype _)
#align finset.order_emb_of_fin Finset.orderEmbOfFin
-/

/- warning: finset.coe_order_iso_of_fin_apply -> Finset.coe_orderIsoOfFin_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (i : Fin k), Eq.{succ u1} α ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) α (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) α (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) α (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) α (coeSubtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s))))) (coeFn.{succ u1, succ u1} (OrderIso.{0, u1} (Fin k) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (Fin.hasLe k) (Subtype.hasLe.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s))) (fun (_x : RelIso.{0, u1} (Fin k) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (Subtype.hasLe.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)))) => (Fin k) -> (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s)) (RelIso.hasCoeToFun.{0, u1} (Fin k) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (Subtype.hasLe.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)))) (Finset.orderIsoOfFin.{u1} α _inst_1 s k h) i)) (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h) i)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (i : Fin k), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) i) (Subtype.val.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s))) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s))) (Fin k) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)))) (RelEmbedding.toEmbedding.{0, u1} (Fin k) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) => LE.le.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Subtype.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{0, u1} (Fin k) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) => LE.le.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Subtype.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (Finset.orderIsoOfFin.{u1} α _inst_1 s k h))) i)) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h)) i)
Case conversion may be inaccurate. Consider using '#align finset.coe_order_iso_of_fin_apply Finset.coe_orderIsoOfFin_applyₓ'. -/
@[simp]
theorem coe_orderIsoOfFin_apply (s : Finset α) {k : ℕ} (h : s.card = k) (i : Fin k) :
    ↑(orderIsoOfFin s h i) = orderEmbOfFin s h i :=
  rfl
#align finset.coe_order_iso_of_fin_apply Finset.coe_orderIsoOfFin_apply

/- warning: finset.order_iso_of_fin_symm_apply -> Finset.orderIsoOfFin_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (x : coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s), Eq.{1} Nat ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) (coeFn.{succ u1, succ u1} (OrderIso.{u1, 0} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (Fin k) (Subtype.hasLe.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) (Fin.hasLe k)) (fun (_x : RelIso.{u1, 0} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (Fin k) (LE.le.{u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (Subtype.hasLe.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s))) (LE.le.{0} (Fin k) (Fin.hasLe k))) => (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) -> (Fin k)) (RelIso.hasCoeToFun.{u1, 0} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (Fin k) (LE.le.{u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (Subtype.hasLe.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s))) (LE.le.{0} (Fin k) (Fin.hasLe k))) (OrderIso.symm.{0, u1} (Fin k) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) (Fin.hasLe k) (Subtype.hasLe.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) (Finset.orderIsoOfFin.{u1} α _inst_1 s k h)) x)) (List.indexOfₓ.{u1} α (fun (a : α) (b : α) => Eq.decidable.{u1} α _inst_1 a b) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) α (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) α (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) α (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Finset.{u1} α) Type.{u1} (Finset.hasCoeToSort.{u1} α) s) α (coeSubtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s))))) x) (Finset.sort.{u1} α (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (a : α) (b : α) => LE.le.decidable.{u1} α _inst_1 a b) (LE.le.isTrans.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (LE.le.isAntisymm.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))) (LE.le.isTotal.{u1} α _inst_1) s))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (x : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)), Eq.{1} Nat (Fin.val k (FunLike.coe.{succ u1, succ u1, 1} (Function.Embedding.{succ u1, 1} (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Fin k)) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (fun (_x : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) => Fin k) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, 1} (Function.Embedding.{succ u1, 1} (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Fin k)) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Fin k) (Function.instEmbeddingLikeEmbedding.{succ u1, 1} (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Fin k))) (RelEmbedding.toEmbedding.{u1, 0} (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Fin k) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) => LE.le.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Subtype.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, 0} (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Fin k) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) => LE.le.{u1} (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Subtype.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{0, u1} (Fin k) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (instLEFin k) (Subtype.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Finset.orderIsoOfFin.{u1} α _inst_1 s k h)))) x)) (List.indexOf.{u1} α (instBEq.{u1} α (fun (a : α) (b : α) => instDecidableEq.{u1} α _inst_1 a b)) (Subtype.val.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s) x) (Finset.sort.{u1} α (fun (x._@.Mathlib.Data.Finset.Sort._hyg.1782 : α) (x._@.Mathlib.Data.Finset.Sort._hyg.1784 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Data.Finset.Sort._hyg.1782 x._@.Mathlib.Data.Finset.Sort._hyg.1784) (fun (a : α) (b : α) => instDecidableLeToLEToPreorderToPartialOrder.{u1} α _inst_1 a b) (instIsTransLeToLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (instIsAntisymmLeToLEToPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))) (instIsTotalLeToLEToPreorderToPartialOrder.{u1} α _inst_1) s))
Case conversion may be inaccurate. Consider using '#align finset.order_iso_of_fin_symm_apply Finset.orderIsoOfFin_symm_applyₓ'. -/
theorem orderIsoOfFin_symm_apply (s : Finset α) {k : ℕ} (h : s.card = k) (x : s) :
    ↑((s.orderIsoOfFin h).symm x) = (s.sort (· ≤ ·)).indexOf x :=
  rfl
#align finset.order_iso_of_fin_symm_apply Finset.orderIsoOfFin_symm_apply

/- warning: finset.order_emb_of_fin_apply -> Finset.orderEmbOfFin_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (i : Fin k), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h) i) (List.nthLe.{u1} α (Finset.sort.{u1} α (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (a : α) (b : α) => LE.le.decidable.{u1} α _inst_1 a b) (LE.le.isTrans.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (LE.le.isAntisymm.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))) (LE.le.isTotal.{u1} α _inst_1) s) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (Eq.mpr.{0} (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (List.length.{u1} α (Finset.sort.{u1} α (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (a : α) (b : α) => LE.le.decidable.{u1} α _inst_1 a b) (LE.le.isTrans.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (LE.le.isAntisymm.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))) (LE.le.isTotal.{u1} α _inst_1) s))) (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (Finset.card.{u1} α s)) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (List.length.{u1} α (Finset.sort.{u1} α (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (a : α) (b : α) => LE.le.decidable.{u1} α _inst_1 a b) (LE.le.isTrans.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (LE.le.isAntisymm.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))) (LE.le.isTotal.{u1} α _inst_1) s))) (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (Finset.card.{u1} α s))) (Eq.ndrec.{0, 1} Nat (List.length.{u1} α (Finset.sort.{u1} α (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (a : α) (b : α) => LE.le.decidable.{u1} α _inst_1 a b) (LE.le.isTrans.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (LE.le.isAntisymm.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))) (LE.le.isTotal.{u1} α _inst_1) s)) (fun (_a : Nat) => Eq.{1} Prop (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (List.length.{u1} α (Finset.sort.{u1} α (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (a : α) (b : α) => LE.le.decidable.{u1} α _inst_1 a b) (LE.le.isTrans.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (LE.le.isAntisymm.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))) (LE.le.isTotal.{u1} α _inst_1) s))) (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) _a)) (rfl.{1} Prop (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (List.length.{u1} α (Finset.sort.{u1} α (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (a : α) (b : α) => LE.le.decidable.{u1} α _inst_1 a b) (LE.le.isTrans.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (LE.le.isAntisymm.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))) (LE.le.isTotal.{u1} α _inst_1) s)))) (Finset.card.{u1} α s) (Finset.length_sort.{u1} α (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (a : α) (b : α) => LE.le.decidable.{u1} α _inst_1 a b) (LE.le.isTrans.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))) (LE.le.isAntisymm.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))) (LE.le.isTotal.{u1} α _inst_1) s))) (Eq.mpr.{0} (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (Finset.card.{u1} α s)) (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) k) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (Finset.card.{u1} α s)) (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) k)) (Eq.ndrec.{0, 1} Nat (Finset.card.{u1} α s) (fun (_a : Nat) => Eq.{1} Prop (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (Finset.card.{u1} α s)) (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) _a)) (rfl.{1} Prop (LT.lt.{0} Nat Nat.hasLt ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) (Finset.card.{u1} α s))) k h)) (Fin.property k i))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (i : Fin k), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) i) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h)) i) (List.nthLe.{u1} α (Finset.sort.{u1} α (fun (x._@.Mathlib.Data.Finset.Sort._hyg.1841 : α) (x._@.Mathlib.Data.Finset.Sort._hyg.1843 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Data.Finset.Sort._hyg.1841 x._@.Mathlib.Data.Finset.Sort._hyg.1843) (fun (a : α) (b : α) => instDecidableLeToLEToPreorderToPartialOrder.{u1} α _inst_1 a b) (instIsTransLeToLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (instIsAntisymmLeToLEToPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))) (instIsTotalLeToLEToPreorderToPartialOrder.{u1} α _inst_1) s) (Fin.val k i) (Eq.mpr.{0} (LT.lt.{0} Nat instLTNat (Fin.val k i) (List.length.{u1} α (Finset.sort.{u1} α (fun (x._@.Mathlib.Data.Finset.Sort._hyg.1841 : α) (x._@.Mathlib.Data.Finset.Sort._hyg.1843 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Data.Finset.Sort._hyg.1841 x._@.Mathlib.Data.Finset.Sort._hyg.1843) (fun (a : α) (b : α) => instDecidableLeToLEToPreorderToPartialOrder.{u1} α _inst_1 a b) (instIsTransLeToLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (instIsAntisymmLeToLEToPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))) (instIsTotalLeToLEToPreorderToPartialOrder.{u1} α _inst_1) s))) (LT.lt.{0} Nat instLTNat (Fin.val k i) (Finset.card.{u1} α s)) (id.{0} (Eq.{1} Prop (LT.lt.{0} Nat instLTNat (Fin.val k i) (List.length.{u1} α (Finset.sort.{u1} α (fun (x._@.Mathlib.Data.Finset.Sort._hyg.1841 : α) (x._@.Mathlib.Data.Finset.Sort._hyg.1843 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Data.Finset.Sort._hyg.1841 x._@.Mathlib.Data.Finset.Sort._hyg.1843) (fun (a : α) (b : α) => instDecidableLeToLEToPreorderToPartialOrder.{u1} α _inst_1 a b) (instIsTransLeToLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (instIsAntisymmLeToLEToPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))) (instIsTotalLeToLEToPreorderToPartialOrder.{u1} α _inst_1) s))) (LT.lt.{0} Nat instLTNat (Fin.val k i) (Finset.card.{u1} α s))) (Eq.ndrec.{0, 1} Nat (List.length.{u1} α (Finset.sort.{u1} α (fun (x._@.Mathlib.Data.Finset.Sort._hyg.1841 : α) (x._@.Mathlib.Data.Finset.Sort._hyg.1843 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Data.Finset.Sort._hyg.1841 x._@.Mathlib.Data.Finset.Sort._hyg.1843) (fun (a : α) (b : α) => instDecidableLeToLEToPreorderToPartialOrder.{u1} α _inst_1 a b) (instIsTransLeToLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (instIsAntisymmLeToLEToPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))) (instIsTotalLeToLEToPreorderToPartialOrder.{u1} α _inst_1) s)) (fun (_a : Nat) => Eq.{1} Prop (LT.lt.{0} Nat instLTNat (Fin.val k i) (List.length.{u1} α (Finset.sort.{u1} α (fun (x._@.Mathlib.Data.Finset.Sort._hyg.1841 : α) (x._@.Mathlib.Data.Finset.Sort._hyg.1843 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Data.Finset.Sort._hyg.1841 x._@.Mathlib.Data.Finset.Sort._hyg.1843) (fun (a : α) (b : α) => instDecidableLeToLEToPreorderToPartialOrder.{u1} α _inst_1 a b) (instIsTransLeToLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (instIsAntisymmLeToLEToPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))) (instIsTotalLeToLEToPreorderToPartialOrder.{u1} α _inst_1) s))) (LT.lt.{0} Nat instLTNat (Fin.val k i) _a)) (Eq.refl.{1} Prop (LT.lt.{0} Nat instLTNat (Fin.val k i) (List.length.{u1} α (Finset.sort.{u1} α (fun (x._@.Mathlib.Data.Finset.Sort._hyg.1841 : α) (x._@.Mathlib.Data.Finset.Sort._hyg.1843 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Data.Finset.Sort._hyg.1841 x._@.Mathlib.Data.Finset.Sort._hyg.1843) (fun (a : α) (b : α) => instDecidableLeToLEToPreorderToPartialOrder.{u1} α _inst_1 a b) (instIsTransLeToLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (instIsAntisymmLeToLEToPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))) (instIsTotalLeToLEToPreorderToPartialOrder.{u1} α _inst_1) s)))) (Finset.card.{u1} α s) (Finset.length_sort.{u1} α (fun (x._@.Mathlib.Data.Finset.Sort._hyg.1841 : α) (x._@.Mathlib.Data.Finset.Sort._hyg.1843 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Data.Finset.Sort._hyg.1841 x._@.Mathlib.Data.Finset.Sort._hyg.1843) (fun (a : α) (b : α) => instDecidableLeToLEToPreorderToPartialOrder.{u1} α _inst_1 a b) (instIsTransLeToLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) (instIsAntisymmLeToLEToPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))) (instIsTotalLeToLEToPreorderToPartialOrder.{u1} α _inst_1) s))) (Eq.mpr.{0} (LT.lt.{0} Nat instLTNat (Fin.val k i) (Finset.card.{u1} α s)) (LT.lt.{0} Nat instLTNat (Fin.val k i) k) (id.{0} (Eq.{1} Prop (LT.lt.{0} Nat instLTNat (Fin.val k i) (Finset.card.{u1} α s)) (LT.lt.{0} Nat instLTNat (Fin.val k i) k)) (Eq.ndrec.{0, 1} Nat (Finset.card.{u1} α s) (fun (_a : Nat) => Eq.{1} Prop (LT.lt.{0} Nat instLTNat (Fin.val k i) (Finset.card.{u1} α s)) (LT.lt.{0} Nat instLTNat (Fin.val k i) _a)) (Eq.refl.{1} Prop (LT.lt.{0} Nat instLTNat (Fin.val k i) (Finset.card.{u1} α s))) k h)) (Fin.isLt k i))))
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_fin_apply Finset.orderEmbOfFin_applyₓ'. -/
theorem orderEmbOfFin_apply (s : Finset α) {k : ℕ} (h : s.card = k) (i : Fin k) :
    s.orderEmbOfFin h i =
      (s.sort (· ≤ ·)).nthLe i
        (by
          rw [length_sort, h]
          exact i.2) :=
  rfl
#align finset.order_emb_of_fin_apply Finset.orderEmbOfFin_apply

/- warning: finset.order_emb_of_fin_mem -> Finset.orderEmbOfFin_mem is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (i : Fin k), Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h) i) s
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (i : Fin k), Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) i) (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h)) i) s
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_fin_mem Finset.orderEmbOfFin_memₓ'. -/
@[simp]
theorem orderEmbOfFin_mem (s : Finset α) {k : ℕ} (h : s.card = k) (i : Fin k) :
    s.orderEmbOfFin h i ∈ s :=
  (s.orderIsoOfFin h i).2
#align finset.order_emb_of_fin_mem Finset.orderEmbOfFin_mem

/- warning: finset.range_order_emb_of_fin -> Finset.range_orderEmbOfFin is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k), Eq.{succ u1} (Set.{u1} α) (Set.range.{u1, 1} α (Fin k) (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) s)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k), Eq.{succ u1} (Set.{u1} α) (Set.range.{u1, 1} α (Fin k) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h)))) (Finset.toSet.{u1} α s)
Case conversion may be inaccurate. Consider using '#align finset.range_order_emb_of_fin Finset.range_orderEmbOfFinₓ'. -/
@[simp]
theorem range_orderEmbOfFin (s : Finset α) {k : ℕ} (h : s.card = k) :
    Set.range (s.orderEmbOfFin h) = s := by
  simp only [order_emb_of_fin, Set.range_comp coe (s.order_iso_of_fin h), RelEmbedding.coe_trans,
    Set.image_univ, Finset.orderEmbOfFin.equations._eqn_1, RelIso.range_eq,
    OrderEmbedding.subtype_apply, OrderIso.coe_toOrderEmbedding, eq_self_iff_true,
    Subtype.range_coe_subtype, Finset.setOf_mem, Finset.coe_inj]
#align finset.range_order_emb_of_fin Finset.range_orderEmbOfFin

/- warning: finset.order_emb_of_fin_zero -> Finset.orderEmbOfFin_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {s : Finset.{u1} α} {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (hz : LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) k), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h) (Fin.mk k (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) hz)) (Finset.min'.{u1} α _inst_1 s (Iff.mp (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (Finset.card.{u1} α s)) (Finset.Nonempty.{u1} α s) (Finset.card_pos.{u1} α s) (Eq.subst.{1} Nat (fun (_x : Nat) => LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) _x) k (Finset.card.{u1} α s) (Eq.symm.{1} Nat (Finset.card.{u1} α s) k h) hz)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {s : Finset.{u1} α} {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (hz : LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) k), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) (Fin.mk k (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) hz)) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h)) (Fin.mk k (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) hz)) (Finset.min'.{u1} α _inst_1 s (Iff.mp (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (Finset.card.{u1} α s)) (Finset.Nonempty.{u1} α s) (Finset.card_pos.{u1} α s) (Eq.rec.{0, 1} Nat k (fun (x._@.Mathlib.Data.Finset.Sort._hyg.2007 : Nat) (h._@.Mathlib.Data.Finset.Sort._hyg.2008 : Eq.{1} Nat k x._@.Mathlib.Data.Finset.Sort._hyg.2007) => LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) x._@.Mathlib.Data.Finset.Sort._hyg.2007) hz (Finset.card.{u1} α s) (Eq.symm.{1} Nat (Finset.card.{u1} α s) k h))))
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_fin_zero Finset.orderEmbOfFin_zeroₓ'. -/
/-- The bijection `order_emb_of_fin s h` sends `0` to the minimum of `s`. -/
theorem orderEmbOfFin_zero {s : Finset α} {k : ℕ} (h : s.card = k) (hz : 0 < k) :
    orderEmbOfFin s h ⟨0, hz⟩ = s.min' (card_pos.mp (h.symm ▸ hz)) := by
  simp only [order_emb_of_fin_apply, Fin.val_mk, sorted_zero_eq_min']
#align finset.order_emb_of_fin_zero Finset.orderEmbOfFin_zero

/- warning: finset.order_emb_of_fin_last -> Finset.orderEmbOfFin_last is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {s : Finset.{u1} α} {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (hz : LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) k), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h) (Fin.mk k (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) k (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Buffer.lt_aux_2 k hz))) (Finset.max'.{u1} α _inst_1 s (Iff.mp (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (Finset.card.{u1} α s)) (Finset.Nonempty.{u1} α s) (Finset.card_pos.{u1} α s) (Eq.subst.{1} Nat (fun (_x : Nat) => LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) _x) k (Finset.card.{u1} α s) (Eq.symm.{1} Nat (Finset.card.{u1} α s) k h) hz)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {s : Finset.{u1} α} {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) (hz : LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) k), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) (Fin.mk k (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) k (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Nat.sub_lt k (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) hz (Nat.succ_pos (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h)) (Fin.mk k (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) k (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Nat.sub_lt k (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) hz (Nat.succ_pos (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Finset.max'.{u1} α _inst_1 s (Iff.mp (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (Finset.card.{u1} α s)) (Finset.Nonempty.{u1} α s) (Finset.card_pos.{u1} α s) (Eq.rec.{0, 1} Nat k (fun (x._@.Mathlib.Data.Finset.Sort._hyg.2063 : Nat) (h._@.Mathlib.Data.Finset.Sort._hyg.2064 : Eq.{1} Nat k x._@.Mathlib.Data.Finset.Sort._hyg.2063) => LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) x._@.Mathlib.Data.Finset.Sort._hyg.2063) hz (Finset.card.{u1} α s) (Eq.symm.{1} Nat (Finset.card.{u1} α s) k h))))
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_fin_last Finset.orderEmbOfFin_lastₓ'. -/
/-- The bijection `order_emb_of_fin s h` sends `k-1` to the maximum of `s`. -/
theorem orderEmbOfFin_last {s : Finset α} {k : ℕ} (h : s.card = k) (hz : 0 < k) :
    orderEmbOfFin s h ⟨k - 1, Buffer.lt_aux_2 hz⟩ = s.max' (card_pos.mp (h.symm ▸ hz)) := by
  simp [order_emb_of_fin_apply, max'_eq_sorted_last, h]
#align finset.order_emb_of_fin_last Finset.orderEmbOfFin_last

/- warning: finset.order_emb_of_fin_singleton -> Finset.orderEmbOfFin_singleton is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (a : α) (i : Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) α (Fin.hasLe (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) α (LE.le.{0} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Fin.hasLe (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) α (LE.le.{0} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Fin.hasLe (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 (Singleton.singleton.{u1, u1} α (Finset.{u1} α) (Finset.hasSingleton.{u1} α) a) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) (Finset.card_singleton.{u1} α a)) i) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (a : α) (i : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) => α) i) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α) (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (fun (_x : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α) (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) => LE.le.{0} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (instLEFin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 (Singleton.singleton.{u1, u1} α (Finset.{u1} α) (Finset.instSingletonFinset.{u1} α) a) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) (Finset.card_singleton.{u1} α a))) i) a
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_fin_singleton Finset.orderEmbOfFin_singletonₓ'. -/
/-- `order_emb_of_fin {a} h` sends any argument to `a`. -/
@[simp]
theorem orderEmbOfFin_singleton (a : α) (i : Fin 1) : orderEmbOfFin {a} (card_singleton a) i = a :=
  by rw [Subsingleton.elim i ⟨0, zero_lt_one⟩, order_emb_of_fin_zero _ zero_lt_one, min'_singleton]
#align finset.order_emb_of_fin_singleton Finset.orderEmbOfFin_singleton

/- warning: finset.order_emb_of_fin_unique -> Finset.orderEmbOfFin_unique is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {s : Finset.{u1} α} {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) {f : (Fin k) -> α}, (forall (x : Fin k), Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) (f x) s) -> (StrictMono.{0, u1} (Fin k) α (PartialOrder.toPreorder.{0} (Fin k) (Fin.partialOrder k)) (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))) f) -> (Eq.{succ u1} ((Fin k) -> α) f (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {s : Finset.{u1} α} {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) {f : (Fin k) -> α}, (forall (x : Fin k), Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) (f x) s) -> (StrictMono.{0, u1} (Fin k) α (PartialOrder.toPreorder.{0} (Fin k) (Fin.instPartialOrderFin k)) (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))) f) -> (Eq.{succ u1} ((Fin k) -> α) f (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h))))
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_fin_unique Finset.orderEmbOfFin_uniqueₓ'. -/
/-- Any increasing map `f` from `fin k` to a finset of cardinality `k` has to coincide with
the increasing bijection `order_emb_of_fin s h`. -/
theorem orderEmbOfFin_unique {s : Finset α} {k : ℕ} (h : s.card = k) {f : Fin k → α}
    (hfs : ∀ x, f x ∈ s) (hmono : StrictMono f) : f = s.orderEmbOfFin h :=
  by
  apply Fin.strictMono_unique hmono (s.order_emb_of_fin h).StrictMono
  rw [range_order_emb_of_fin, ← Set.image_univ, ← coe_univ, ← coe_image, coe_inj]
  refine' eq_of_subset_of_card_le (fun x hx => _) _
  · rcases mem_image.1 hx with ⟨x, hx, rfl⟩
    exact hfs x
  · rw [h, card_image_of_injective _ hmono.injective, card_univ, Fintype.card_fin]
#align finset.order_emb_of_fin_unique Finset.orderEmbOfFin_unique

/- warning: finset.order_emb_of_fin_unique' -> Finset.orderEmbOfFin_unique' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {s : Finset.{u1} α} {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) {f : OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))}, (forall (x : Fin k), Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) f x) s) -> (Eq.{succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) f (Finset.orderEmbOfFin.{u1} α _inst_1 s k h))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {s : Finset.{u1} α} {k : Nat} (h : Eq.{1} Nat (Finset.card.{u1} α s) k) {f : OrderEmbedding.{0, u1} (Fin k) α (instLEFin k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))))}, (forall (x : Fin k), Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) x) (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) x) s) -> (Eq.{succ u1} (OrderEmbedding.{0, u1} (Fin k) α (instLEFin k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1))))))) f (Finset.orderEmbOfFin.{u1} α _inst_1 s k h))
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_fin_unique' Finset.orderEmbOfFin_unique'ₓ'. -/
/-- An order embedding `f` from `fin k` to a finset of cardinality `k` has to coincide with
the increasing bijection `order_emb_of_fin s h`. -/
theorem orderEmbOfFin_unique' {s : Finset α} {k : ℕ} (h : s.card = k) {f : Fin k ↪o α}
    (hfs : ∀ x, f x ∈ s) : f = s.orderEmbOfFin h :=
  RelEmbedding.ext <| Function.funext_iff.1 <| orderEmbOfFin_unique h hfs f.StrictMono
#align finset.order_emb_of_fin_unique' Finset.orderEmbOfFin_unique'

/- warning: finset.order_emb_of_fin_eq_order_emb_of_fin_iff -> Finset.orderEmbOfFin_eq_orderEmbOfFin_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {k : Nat} {l : Nat} {s : Finset.{u1} α} {i : Fin k} {j : Fin l} {h : Eq.{1} Nat (Finset.card.{u1} α s) k} {h' : Eq.{1} Nat (Finset.card.{u1} α s) l}, Iff (Eq.{succ u1} α (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h) i) (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin l) α (Fin.hasLe l) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin l) α (LE.le.{0} (Fin l) (Fin.hasLe l)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin l) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin l) α (LE.le.{0} (Fin l) (Fin.hasLe l)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfFin.{u1} α _inst_1 s l h') j)) (Eq.{1} Nat ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin k) Nat (HasLiftT.mk.{1, 1} (Fin k) Nat (CoeTCₓ.coe.{1, 1} (Fin k) Nat (coeBase.{1, 1} (Fin k) Nat (Fin.coeToNat k)))) i) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin l) Nat (HasLiftT.mk.{1, 1} (Fin l) Nat (CoeTCₓ.coe.{1, 1} (Fin l) Nat (coeBase.{1, 1} (Fin l) Nat (Fin.coeToNat l)))) j))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] {k : Nat} {l : Nat} {s : Finset.{u1} α} {i : Fin k} {j : Fin l} {h : Eq.{1} Nat (Finset.card.{u1} α s) k} {h' : Eq.{1} Nat (Finset.card.{u1} α s) l}, Iff (Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) i) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 s k h)) i) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin l) α) (Fin l) (fun (_x : Fin l) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin l) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin l) α) (Fin l) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin l) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin l) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin l) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin l) => LE.le.{0} (Fin l) (instLEFin l) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfFin.{u1} α _inst_1 s l h')) j)) (Eq.{1} Nat (Fin.val k i) (Fin.val l j))
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_fin_eq_order_emb_of_fin_iff Finset.orderEmbOfFin_eq_orderEmbOfFin_iffₓ'. -/
/-- Two parametrizations `order_emb_of_fin` of the same set take the same value on `i` and `j` if
and only if `i = j`. Since they can be defined on a priori not defeq types `fin k` and `fin l`
(although necessarily `k = l`), the conclusion is rather written `(i : ℕ) = (j : ℕ)`. -/
@[simp]
theorem orderEmbOfFin_eq_orderEmbOfFin_iff {k l : ℕ} {s : Finset α} {i : Fin k} {j : Fin l}
    {h : s.card = k} {h' : s.card = l} :
    s.orderEmbOfFin h i = s.orderEmbOfFin h' j ↔ (i : ℕ) = (j : ℕ) :=
  by
  substs k l
  exact (s.order_emb_of_fin rfl).eq_iff_eq.trans Fin.ext_iff
#align finset.order_emb_of_fin_eq_order_emb_of_fin_iff Finset.orderEmbOfFin_eq_orderEmbOfFin_iff

#print Finset.orderEmbOfCardLe /-
/-- Given a finset `s` of size at least `k` in a linear order `α`, the map `order_emb_of_card_le`
is an order embedding from `fin k` to `α` whose image is contained in `s`. Specifically, it maps
`fin k` to an initial segment of `s`. -/
def orderEmbOfCardLe (s : Finset α) {k : ℕ} (h : k ≤ s.card) : Fin k ↪o α :=
  (Fin.castLe h).trans (s.orderEmbOfFin rfl)
#align finset.order_emb_of_card_le Finset.orderEmbOfCardLe
-/

/- warning: finset.order_emb_of_card_le_mem -> Finset.orderEmbOfCardLe_mem is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : LE.le.{0} Nat Nat.hasLe k (Finset.card.{u1} α s)) (a : Fin k), Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) (coeFn.{succ u1, succ u1} (OrderEmbedding.{0, u1} (Fin k) α (Fin.hasLe k) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1)))))) (fun (_x : RelEmbedding.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) => (Fin k) -> α) (RelEmbedding.hasCoeToFun.{0, u1} (Fin k) α (LE.le.{0} (Fin k) (Fin.hasLe k)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_1))))))) (Finset.orderEmbOfCardLe.{u1} α _inst_1 s k h) a) s
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrder.{u1} α] (s : Finset.{u1} α) {k : Nat} (h : LE.le.{0} Nat instLENat k (Finset.card.{u1} α s)) (a : Fin k), Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) a) (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) (FunLike.coe.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) (fun (_x : Fin k) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin k) => α) _x) (EmbeddingLike.toFunLike.{succ u1, 1, succ u1} (Function.Embedding.{1, succ u1} (Fin k) α) (Fin k) α (Function.instEmbeddingLikeEmbedding.{1, succ u1} (Fin k) α)) (RelEmbedding.toEmbedding.{0, u1} (Fin k) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : Fin k) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : Fin k) => LE.le.{0} (Fin k) (instLEFin k) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_1)))))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (Finset.orderEmbOfCardLe.{u1} α _inst_1 s k h)) a) s
Case conversion may be inaccurate. Consider using '#align finset.order_emb_of_card_le_mem Finset.orderEmbOfCardLe_memₓ'. -/
theorem orderEmbOfCardLe_mem (s : Finset α) {k : ℕ} (h : k ≤ s.card) (a) :
    orderEmbOfCardLe s h a ∈ s := by
  simp only [order_emb_of_card_le, RelEmbedding.coe_trans, Finset.orderEmbOfFin_mem]
#align finset.order_emb_of_card_le_mem Finset.orderEmbOfCardLe_mem

end SortLinearOrder

unsafe instance [Repr α] : Repr (Finset α) :=
  ⟨fun s => repr s.1⟩

end Finset

