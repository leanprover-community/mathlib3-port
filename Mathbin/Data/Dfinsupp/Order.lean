/-
Copyright (c) 2021 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies

! This file was ported from Lean 3 source module data.dfinsupp.order
! leanprover-community/mathlib commit 2738d2ca56cbc63be80c3bd48e9ed90ad94e947d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Dfinsupp.Basic

/-!
# Pointwise order on finitely supported dependent functions

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file lifts order structures on the `α i` to `Π₀ i, α i`.

## Main declarations

* `dfinsupp.order_embedding_to_fun`: The order embedding from finitely supported dependent functions
  to functions.

-/


open BigOperators

open Finset

variable {ι : Type _} {α : ι → Type _}

namespace Dfinsupp

/-! ### Order structures -/


section Zero

variable (α) [∀ i, Zero (α i)]

section LE

variable [∀ i, LE (α i)]

instance : LE (Π₀ i, α i) :=
  ⟨fun f g => ∀ i, f i ≤ g i⟩

variable {α}

/- warning: dfinsupp.le_def -> Dfinsupp.le_def is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), LE.{u2} (α i)] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, Iff (LE.le.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i)) f g) (forall (i : ι), LE.le.{u2} (α i) (_inst_2 i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) g i))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u1} (α i)] [_inst_2 : forall (i : ι), LE.{u1} (α i)] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, Iff (LE.le.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instLEDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i)) f g) (forall (i : ι), LE.le.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_2 i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) g i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.le_def Dfinsupp.le_defₓ'. -/
theorem le_def {f g : Π₀ i, α i} : f ≤ g ↔ ∀ i, f i ≤ g i :=
  Iff.rfl
#align dfinsupp.le_def Dfinsupp.le_def

#print Dfinsupp.orderEmbeddingToFun /-
/-- The order on `dfinsupp`s over a partial order embeds into the order on functions -/
def orderEmbeddingToFun : (Π₀ i, α i) ↪o ∀ i, α i
    where
  toFun := coeFn
  inj' := coeFn_injective
  map_rel_iff' a b := (@le_def _ _ _ _ a b).symm
#align dfinsupp.order_embedding_to_fun Dfinsupp.orderEmbeddingToFun
-/

/- warning: dfinsupp.order_embedding_to_fun_apply -> Dfinsupp.orderEmbeddingToFun_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), LE.{u2} (α i)] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {i : ι}, Eq.{succ u2} (α i) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (OrderEmbedding.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i) (Dfinsupp.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i)) (Pi.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) (fun (_x : RelEmbedding.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i) (LE.le.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i))) (LE.le.{max u1 u2} (forall (i : ι), α i) (Pi.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) -> (forall (i : ι), α i)) (RelEmbedding.hasCoeToFun.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i) (LE.le.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i))) (LE.le.{max u1 u2} (forall (i : ι), α i) (Pi.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)))) (Dfinsupp.orderEmbeddingToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) f i)
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u1} (α i)] [_inst_2 : forall (i : ι), LE.{u1} (α i)] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {i : ι}, Eq.{succ u1} (α i) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Function.Embedding.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i)) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Function.Embedding.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i)) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i) (Function.instEmbeddingLikeEmbedding.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i))) (RelEmbedding.toEmbedding.{max u1 u2, max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i) (fun (i : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => LE.le.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instLEDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i)) i x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (i : forall (i : ι), α i) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : forall (i : ι), α i) => LE.le.{max u2 u1} (forall (i : ι), α i) (Pi.hasLe.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) i x._@.Mathlib.Order.Hom.Basic._hyg.697) (Dfinsupp.orderEmbeddingToFun.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i))) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f i)
Case conversion may be inaccurate. Consider using '#align dfinsupp.order_embedding_to_fun_apply Dfinsupp.orderEmbeddingToFun_applyₓ'. -/
@[simp]
theorem orderEmbeddingToFun_apply {f : Π₀ i, α i} {i : ι} : orderEmbeddingToFun f i = f i :=
  rfl
#align dfinsupp.order_embedding_to_fun_apply Dfinsupp.orderEmbeddingToFun_apply

end LE

section Preorder

variable [∀ i, Preorder (α i)]

instance : Preorder (Π₀ i, α i) :=
  { Dfinsupp.hasLe α with
    le_refl := fun f i => le_rfl
    le_trans := fun f g h hfg hgh i => (hfg i).trans (hgh i) }

/- warning: dfinsupp.coe_fn_mono -> Dfinsupp.coeFn_mono is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (α : ι -> Type.{u2}) [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), Preorder.{u2} (α i)], Monotone.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i)) (Pi.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (ᾰ : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))
but is expected to have type
  forall {ι : Type.{u2}} (α : ι -> Type.{u1}) [_inst_1 : forall (i : ι), Zero.{u1} (α i)] [_inst_2 : forall (i : ι), Preorder.{u1} (α i)], Monotone.{max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (forall (i : ι), α i) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i)) (Pi.preorder.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) ι (fun (ᾰ : ι) => α ᾰ) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_fn_mono Dfinsupp.coeFn_monoₓ'. -/
theorem coeFn_mono : Monotone (coeFn : (Π₀ i, α i) → ∀ i, α i) := fun f g => le_def.1
#align dfinsupp.coe_fn_mono Dfinsupp.coeFn_mono

end Preorder

instance [∀ i, PartialOrder (α i)] : PartialOrder (Π₀ i, α i) :=
  { Dfinsupp.preorder α with
    le_antisymm := fun f g hfg hgf => ext fun i => (hfg i).antisymm (hgf i) }

instance [∀ i, SemilatticeInf (α i)] : SemilatticeInf (Π₀ i, α i) :=
  {
    Dfinsupp.partialOrder
      α with
    inf := zipWith (fun _ => (· ⊓ ·)) fun _ => inf_idem
    inf_le_left := fun f g i => by
      rw [zip_with_apply]
      exact inf_le_left
    inf_le_right := fun f g i => by
      rw [zip_with_apply]
      exact inf_le_right
    le_inf := fun f g h hf hg i => by
      rw [zip_with_apply]
      exact le_inf (hf i) (hg i) }

/- warning: dfinsupp.inf_apply -> Dfinsupp.inf_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (α : ι -> Type.{u2}) [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), SemilatticeInf.{u2} (α i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (i : ι), Eq.{succ u2} (α i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (HasInf.inf.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (SemilatticeInf.toHasInf.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.semilatticeInf.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i))) f g) i) (HasInf.inf.{u2} (α i) (SemilatticeInf.toHasInf.{u2} (α i) (_inst_2 i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) g i))
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> Type.{u2}) [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), SemilatticeInf.{u2} (α i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (HasInf.inf.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (SemilatticeInf.toHasInf.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instSemilatticeInfDfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i))) f g) i) (HasInf.inf.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (SemilatticeInf.toHasInf.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_2 i)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) g i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.inf_apply Dfinsupp.inf_applyₓ'. -/
@[simp]
theorem inf_apply [∀ i, SemilatticeInf (α i)] (f g : Π₀ i, α i) (i : ι) : (f ⊓ g) i = f i ⊓ g i :=
  zipWith_apply _ _ _ _ _
#align dfinsupp.inf_apply Dfinsupp.inf_apply

instance [∀ i, SemilatticeSup (α i)] : SemilatticeSup (Π₀ i, α i) :=
  {
    Dfinsupp.partialOrder
      α with
    sup := zipWith (fun _ => (· ⊔ ·)) fun _ => sup_idem
    le_sup_left := fun f g i => by
      rw [zip_with_apply]
      exact le_sup_left
    le_sup_right := fun f g i => by
      rw [zip_with_apply]
      exact le_sup_right
    sup_le := fun f g h hf hg i => by
      rw [zip_with_apply]
      exact sup_le (hf i) (hg i) }

/- warning: dfinsupp.sup_apply -> Dfinsupp.sup_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (α : ι -> Type.{u2}) [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), SemilatticeSup.{u2} (α i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (i : ι), Eq.{succ u2} (α i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (HasSup.sup.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (SemilatticeSup.toHasSup.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.semilatticeSup.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i))) f g) i) (HasSup.sup.{u2} (α i) (SemilatticeSup.toHasSup.{u2} (α i) (_inst_2 i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) g i))
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> Type.{u2}) [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), SemilatticeSup.{u2} (α i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (HasSup.sup.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (SemilatticeSup.toHasSup.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instSemilatticeSupDfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i))) f g) i) (HasSup.sup.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (SemilatticeSup.toHasSup.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_2 i)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) g i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sup_apply Dfinsupp.sup_applyₓ'. -/
@[simp]
theorem sup_apply [∀ i, SemilatticeSup (α i)] (f g : Π₀ i, α i) (i : ι) : (f ⊔ g) i = f i ⊔ g i :=
  zipWith_apply _ _ _ _ _
#align dfinsupp.sup_apply Dfinsupp.sup_apply

#print Dfinsupp.lattice /-
instance lattice [∀ i, Lattice (α i)] : Lattice (Π₀ i, α i) :=
  { Dfinsupp.semilatticeInf α, Dfinsupp.semilatticeSup α with }
#align dfinsupp.lattice Dfinsupp.lattice
-/

end Zero

/-! ### Algebraic order structures -/


instance (α : ι → Type _) [∀ i, OrderedAddCommMonoid (α i)] : OrderedAddCommMonoid (Π₀ i, α i) :=
  { Dfinsupp.addCommMonoid, Dfinsupp.partialOrder α with
    add_le_add_left := fun a b h c i =>
      by
      rw [add_apply, add_apply]
      exact add_le_add_left (h i) (c i) }

instance (α : ι → Type _) [∀ i, OrderedCancelAddCommMonoid (α i)] :
    OrderedCancelAddCommMonoid (Π₀ i, α i) :=
  { Dfinsupp.orderedAddCommMonoid α with
    le_of_add_le_add_left := fun f g h H i =>
      by
      specialize H i
      rw [add_apply, add_apply] at H
      exact le_of_add_le_add_left H }

instance [∀ i, OrderedAddCommMonoid (α i)] [∀ i, ContravariantClass (α i) (α i) (· + ·) (· ≤ ·)] :
    ContravariantClass (Π₀ i, α i) (Π₀ i, α i) (· + ·) (· ≤ ·) :=
  ⟨fun f g h H i => by
    specialize H i
    rw [add_apply, add_apply] at H
    exact le_of_add_le_add_left H⟩

section CanonicallyOrderedAddMonoid

variable (α) [∀ i, CanonicallyOrderedAddMonoid (α i)]

instance : OrderBot (Π₀ i, α i) where
  bot := 0
  bot_le := by simp only [le_def, coe_zero, Pi.zero_apply, imp_true_iff, zero_le]

variable {α}

/- warning: dfinsupp.bot_eq_zero -> Dfinsupp.bot_eq_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)], Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Bot.bot.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (OrderBot.toHasBot.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) => Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (Dfinsupp.orderBot.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))) (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.hasZero.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)], Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Bot.bot.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (OrderBot.toBot.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.instLEDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) => Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (Dfinsupp.instOrderBotDfinsuppToZeroToAddMonoidToAddCommMonoidToOrderedAddCommMonoidInstLEDfinsuppToLEToPreorderToPartialOrder.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))) (OfNat.ofNat.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) 0 (Zero.toOfNat0.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.instZeroDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.bot_eq_zero Dfinsupp.bot_eq_zeroₓ'. -/
protected theorem bot_eq_zero : (⊥ : Π₀ i, α i) = 0 :=
  rfl
#align dfinsupp.bot_eq_zero Dfinsupp.bot_eq_zero

/- warning: dfinsupp.add_eq_zero_iff -> Dfinsupp.add_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))), Iff (Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) f g) (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.hasZero.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))))))) (And (Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) f (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.hasZero.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))))))) (Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) g (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.hasZero.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))))))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))), Iff (Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (instHAdd.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.instAddDfinsuppToZero.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))))) f g) (OfNat.ofNat.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) 0 (Zero.toOfNat0.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.instZeroDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (And (Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) f (OfNat.ofNat.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) 0 (Zero.toOfNat0.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.instZeroDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) g (OfNat.ofNat.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) 0 (Zero.toOfNat0.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.instZeroDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.add_eq_zero_iff Dfinsupp.add_eq_zero_iffₓ'. -/
@[simp]
theorem add_eq_zero_iff (f g : Π₀ i, α i) : f + g = 0 ↔ f = 0 ∧ g = 0 := by
  simp [ext_iff, forall_and]
#align dfinsupp.add_eq_zero_iff Dfinsupp.add_eq_zero_iff

section Le

variable [DecidableEq ι] [∀ (i) (x : α i), Decidable (x ≠ 0)] {f g : Π₀ i, α i} {s : Finset ι}

/- warning: dfinsupp.le_iff' -> Dfinsupp.le_iff' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : forall (i : ι) (x : α i), Decidable (Ne.{succ u2} (α i) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))))))] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))} {s : Finset.{u1} ι}, (HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => _inst_3 i x) f) s) -> (Iff (LE.le.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) => Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) f g) (forall (i : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i s) -> (LE.le.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) g i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_2 : DecidableEq.{succ u2} ι] [_inst_3 : forall (i : ι) (x : α i), Decidable (Ne.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))))))] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))} {s : Finset.{u2} ι}, (HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) (x : α i) => _inst_3 i x) f) s) -> (Iff (LE.le.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.instLEDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) => Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) f g) (forall (i : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (LE.le.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Preorder.toLE.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (OrderedAddCommMonoid.toPartialOrder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_1 i))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) g i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.le_iff' Dfinsupp.le_iff'ₓ'. -/
theorem le_iff' (hf : f.support ⊆ s) : f ≤ g ↔ ∀ i ∈ s, f i ≤ g i :=
  ⟨fun h s hs => h s, fun h s =>
    if H : s ∈ f.support then h s (hf H) else (not_mem_support_iff.1 H).symm ▸ zero_le (g s)⟩
#align dfinsupp.le_iff' Dfinsupp.le_iff'

/- warning: dfinsupp.le_iff -> Dfinsupp.le_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : forall (i : ι) (x : α i), Decidable (Ne.{succ u2} (α i) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))))))] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))}, Iff (LE.le.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) => Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) f g) (forall (i : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => _inst_3 i x) f)) -> (LE.le.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) g i)))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_2 : DecidableEq.{succ u2} ι] [_inst_3 : forall (i : ι) (x : α i), Decidable (Ne.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))))))] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))}, Iff (LE.le.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.instLEDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) => Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) f g) (forall (i : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) (x : α i) => _inst_3 i x) f)) -> (LE.le.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Preorder.toLE.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (OrderedAddCommMonoid.toPartialOrder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_1 i))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) g i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.le_iff Dfinsupp.le_iffₓ'. -/
theorem le_iff : f ≤ g ↔ ∀ i ∈ f.support, f i ≤ g i :=
  le_iff' <| Subset.refl _
#align dfinsupp.le_iff Dfinsupp.le_iff

variable (α)

/- warning: dfinsupp.decidable_le -> Dfinsupp.decidableLe is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (α : ι -> Type.{u2}) [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : forall (i : ι) (x : α i), Decidable (Ne.{succ u2} (α i) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))))))] [_inst_4 : forall (i : ι), DecidableRel.{succ u2} (α i) (LE.le.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))], DecidableRel.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (LE.le.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) => Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))))
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> Type.{u2}) [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : forall (i : ι) (x : α i), Decidable (Ne.{succ u2} (α i) x (OfNat.ofNat.{u2} (α i) 0 (Zero.toOfNat0.{u2} (α i) (AddMonoid.toZero.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))))] [_inst_4 : forall (i : ι), DecidableRel.{succ u2} (α i) (LE.le.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))], DecidableRel.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (LE.le.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.instLEDfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) => Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.decidable_le Dfinsupp.decidableLeₓ'. -/
instance decidableLe [∀ i, DecidableRel (@LE.le (α i) _)] : DecidableRel (@LE.le (Π₀ i, α i) _) :=
  fun f g => decidable_of_iff _ le_iff.symm
#align dfinsupp.decidable_le Dfinsupp.decidableLe

variable {α}

/- warning: dfinsupp.single_le_iff -> Dfinsupp.single_le_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : forall (i : ι) (x : α i), Decidable (Ne.{succ u2} (α i) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))))))] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))} {i : ι} {a : α i}, Iff (LE.le.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.hasLe.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) => Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (Dfinsupp.single.{u1, u2} ι (fun {i : ι} => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) i a) f) (LE.le.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) a (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) f i))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_2 : DecidableEq.{succ u2} ι] [_inst_3 : forall (i : ι) (x : α i), Decidable (Ne.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))))))] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))} {i : ι} {a : α i}, Iff (LE.le.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (Dfinsupp.instLEDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) (fun (i : ι) => Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (Dfinsupp.single.{u2, u1} ι α (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) i a) f) (LE.le.{u1} (α i) (Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) a (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) f i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.single_le_iff Dfinsupp.single_le_iffₓ'. -/
@[simp]
theorem single_le_iff {i : ι} {a : α i} : single i a ≤ f ↔ a ≤ f i :=
  (le_iff' support_single_subset).trans <| by simp
#align dfinsupp.single_le_iff Dfinsupp.single_le_iff

end Le

variable (α) [∀ i, Sub (α i)] [∀ i, OrderedSub (α i)] {f g : Π₀ i, α i} {i : ι} {a b : α i}

/- warning: dfinsupp.tsub -> Dfinsupp.tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (α : ι -> Type.{u2}) [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : forall (i : ι), Sub.{u2} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (_inst_2 i)], Sub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))))
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> Type.{u2}) [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : forall (i : ι), Sub.{u2} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) (AddZeroClass.toAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (_inst_2 i)], Sub.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.tsub Dfinsupp.tsubₓ'. -/
/-- This is called `tsub` for truncated subtraction, to distinguish it with subtraction in an
additive group. -/
instance tsub : Sub (Π₀ i, α i) :=
  ⟨zipWith (fun i m n => m - n) fun i => tsub_self 0⟩
#align dfinsupp.tsub Dfinsupp.tsub

variable {α}

/- warning: dfinsupp.tsub_apply -> Dfinsupp.tsub_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : forall (i : ι), Sub.{u2} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (_inst_2 i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (i : ι), Eq.{succ u2} (α i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.tsub.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) f g) i) (HSub.hSub.{u2, u2, u2} (α i) (α i) (α i) (instHSub.{u2} (α i) (_inst_2 i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) g i))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_2 : forall (i : ι), Sub.{u1} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u1} (α i) (Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) (AddZeroClass.toAdd.{u1} (α i) (AddMonoid.toAddZeroClass.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (_inst_2 i)] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (i : ι), Eq.{succ u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.tsub.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) f g) i) (HSub.hSub.{u1, u1, u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) ((fun (i : ι) => (fun (i : ι) => α i) i) i) ((fun (i : ι) => (fun (i : ι) => α i) i) i) (instHSub.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_2 i)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) g i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.tsub_apply Dfinsupp.tsub_applyₓ'. -/
theorem tsub_apply (f g : Π₀ i, α i) (i : ι) : (f - g) i = f i - g i :=
  zipWith_apply _ _ _ _ _
#align dfinsupp.tsub_apply Dfinsupp.tsub_apply

/- warning: dfinsupp.coe_tsub -> Dfinsupp.coe_tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : forall (i : ι), Sub.{u2} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (_inst_2 i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))), Eq.{succ (max u1 u2)} (forall (i : ι), α i) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.tsub.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (forall (i : ι), α i) (forall (i : ι), α i) (forall (i : ι), α i) (instHSub.{max u1 u2} (forall (i : ι), α i) (Pi.instSub.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) f) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} ((fun (i : ι) => α i) i) (_inst_1 i))))))) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_2 : forall (i : ι), Sub.{u1} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u1} (α i) (Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) (AddZeroClass.toAdd.{u1} (α i) (AddMonoid.toAddZeroClass.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (_inst_2 i)] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))), Eq.{max (succ u2) (succ u1)} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => α i) i) i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.tsub.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) f g)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => α i) i) i) (forall (i : ι), (fun (i : ι) => (fun (i : ι) => α i) i) i) (forall (i : ι), (fun (i : ι) => (fun (i : ι) => α i) i) i) (instHSub.{max u2 u1} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => α i) i) i) (Pi.instSub.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) i) (fun (i : ι) => _inst_2 i))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) i)) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_tsub Dfinsupp.coe_tsubₓ'. -/
@[simp]
theorem coe_tsub (f g : Π₀ i, α i) : ⇑(f - g) = f - g :=
  by
  ext i
  exact tsub_apply f g i
#align dfinsupp.coe_tsub Dfinsupp.coe_tsub

variable (α)

instance : OrderedSub (Π₀ i, α i) :=
  ⟨fun n m k =>
    forall_congr' fun i => by
      rw [add_apply, tsub_apply]
      exact tsub_le_iff_right⟩

instance : CanonicallyOrderedAddMonoid (Π₀ i, α i) :=
  { Dfinsupp.orderBot α,
    Dfinsupp.orderedAddCommMonoid
      α with
    exists_add_of_le := fun f g h =>
      ⟨g - f, by
        ext i
        rw [add_apply, tsub_apply]
        exact (add_tsub_cancel_of_le <| h i).symm⟩
    le_self_add := fun f g i => by
      rw [add_apply]
      exact le_self_add }

variable {α} [DecidableEq ι]

/- warning: dfinsupp.single_tsub -> Dfinsupp.single_tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : forall (i : ι), Sub.{u2} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (_inst_2 i)] {i : ι} {a : α i} {b : α i} [_inst_4 : DecidableEq.{succ u1} ι], Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.single.{u1, u2} ι (fun {i : ι} => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) i (HSub.hSub.{u2, u2, u2} (α i) (α i) (α i) (instHSub.{u2} (α i) (_inst_2 i)) a b)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.tsub.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) i a) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) i b))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_2 : forall (i : ι), Sub.{u1} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u1} (α i) (Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) (AddZeroClass.toAdd.{u1} (α i) (AddMonoid.toAddZeroClass.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (_inst_2 i)] {i : ι} {a : α i} {b : α i} [_inst_4 : DecidableEq.{succ u2} ι], Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (Dfinsupp.single.{u2, u1} ι α (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) i (HSub.hSub.{u1, u1, u1} (α i) (α i) (α i) (instHSub.{u1} (α i) (_inst_2 i)) a b)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (Dfinsupp.tsub.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.single.{u2, u1} ι α (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) i a) (Dfinsupp.single.{u2, u1} ι α (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) i b))
Case conversion may be inaccurate. Consider using '#align dfinsupp.single_tsub Dfinsupp.single_tsubₓ'. -/
@[simp]
theorem single_tsub : single i (a - b) = single i a - single i b :=
  by
  ext j
  obtain rfl | h := eq_or_ne i j
  · rw [tsub_apply, single_eq_same, single_eq_same, single_eq_same]
  · rw [tsub_apply, single_eq_of_ne h, single_eq_of_ne h, single_eq_of_ne h, tsub_self]
#align dfinsupp.single_tsub Dfinsupp.single_tsub

variable [∀ (i) (x : α i), Decidable (x ≠ 0)]

/- warning: dfinsupp.support_tsub -> Dfinsupp.support_tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : forall (i : ι), Sub.{u2} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (_inst_2 i)] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))} [_inst_4 : DecidableEq.{succ u1} ι] [_inst_5 : forall (i : ι) (x : α i), Decidable (Ne.{succ u2} (α i) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))))))], HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => _inst_5 i x) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.tsub.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) f g)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => _inst_5 i x) f)
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_2 : forall (i : ι), Sub.{u1} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u1} (α i) (Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) (AddZeroClass.toAdd.{u1} (α i) (AddMonoid.toAddZeroClass.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (_inst_2 i)] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))} [_inst_4 : DecidableEq.{succ u2} ι] [_inst_5 : forall (i : ι) (x : α i), Decidable (Ne.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))))))], HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) (x : α i) => _inst_5 i x) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.tsub.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) f g)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) (x : α i) => _inst_5 i x) f)
Case conversion may be inaccurate. Consider using '#align dfinsupp.support_tsub Dfinsupp.support_tsubₓ'. -/
theorem support_tsub : (f - g).support ⊆ f.support := by
  simp (config := { contextual := true }) only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,
    Ne.def, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]
#align dfinsupp.support_tsub Dfinsupp.support_tsub

/- warning: dfinsupp.subset_support_tsub -> Dfinsupp.subset_support_tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_2 : forall (i : ι), Sub.{u2} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u2} (α i) (Preorder.toLE.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (_inst_2 i)] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))} [_inst_4 : DecidableEq.{succ u1} ι] [_inst_5 : forall (i : ι) (x : α i), Decidable (Ne.{succ u2} (α i) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))))))], HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (SDiff.sdiff.{u1} (Finset.{u1} ι) (Finset.hasSdiff.{u1} ι (fun (a : ι) (b : ι) => _inst_4 a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => _inst_5 i x) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => _inst_5 i x) g)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => _inst_5 i x) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_1 i))))))) (Dfinsupp.tsub.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) f g))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_2 : forall (i : ι), Sub.{u1} (α i)] [_inst_3 : forall (i : ι), OrderedSub.{u1} (α i) (Preorder.toLE.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))) (AddZeroClass.toAdd.{u1} (α i) (AddMonoid.toAddZeroClass.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i)))))) (_inst_2 i)] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))} [_inst_4 : DecidableEq.{succ u2} ι] [_inst_5 : forall (i : ι) (x : α i), Decidable (Ne.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} (α i) (AddCommMonoid.toAddMonoid.{u1} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_1 i))))))))], HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (SDiff.sdiff.{u2} (Finset.{u2} ι) (Finset.instSDiffFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_4 a b)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) (x : α i) => _inst_5 i x) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) (x : α i) => _inst_5 i x) g)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))) (fun (i : ι) (x : α i) => _inst_5 i x) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (Dfinsupp.tsub.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) f g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subset_support_tsub Dfinsupp.subset_support_tsubₓ'. -/
theorem subset_support_tsub : f.support \ g.support ⊆ (f - g).support := by
  simp (config := { contextual := true }) [subset_iff]
#align dfinsupp.subset_support_tsub Dfinsupp.subset_support_tsub

end CanonicallyOrderedAddMonoid

section CanonicallyLinearOrderedAddMonoid

variable [∀ i, CanonicallyLinearOrderedAddMonoid (α i)] [DecidableEq ι] {f g : Π₀ i, α i}

/- warning: dfinsupp.support_inf -> Dfinsupp.support_inf is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyLinearOrderedAddMonoid.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))}, Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => Eq.decidable.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} (α i) (_inst_1 i)) a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))))))) (HasInf.inf.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))) (SemilatticeInf.toHasInf.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))) (Dfinsupp.semilatticeInf.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) => Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} (α i) (_inst_1 i)))))) f g)) (Inter.inter.{u1} (Finset.{u1} ι) (Finset.hasInter.{u1} ι (fun (a : ι) (b : ι) => _inst_2 a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => Eq.decidable.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} (α i) (_inst_1 i)) a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))))))) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => Eq.decidable.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} (α i) (_inst_1 i)) a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))))))) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyLinearOrderedAddMonoid.{u1} (α i)] [_inst_2 : DecidableEq.{succ u2} ι] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))}, Eq.{succ u2} (Finset.{u2} ι) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (instDecidableEq.{u1} (α i) ((fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i)) i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))))))) (HasInf.inf.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Lattice.toHasInf.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.lattice.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) => DistribLattice.toLattice.{u1} (α i) (instDistribLattice.{u1} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i)))))) f g)) (Inter.inter.{u2} (Finset.{u2} ι) (Finset.instInterFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_2 a b)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (instDecidableEq.{u1} (α i) ((fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i)) i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))))))) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (instDecidableEq.{u1} (α i) ((fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i)) i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))))))) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.support_inf Dfinsupp.support_infₓ'. -/
@[simp]
theorem support_inf : (f ⊓ g).support = f.support ∩ g.support :=
  by
  ext
  simp only [inf_apply, mem_support_iff, Ne.def, Finset.mem_union, Finset.mem_filter,
    Finset.mem_inter]
  simp only [inf_eq_min, ← nonpos_iff_eq_zero, min_le_iff, not_or]
#align dfinsupp.support_inf Dfinsupp.support_inf

/- warning: dfinsupp.support_sup -> Dfinsupp.support_sup is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyLinearOrderedAddMonoid.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))}, Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => Eq.decidable.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} (α i) (_inst_1 i)) a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))))))) (HasSup.sup.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))) (SemilatticeSup.toHasSup.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))) (Dfinsupp.semilatticeSup.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) => CanonicallyLinearOrderedAddMonoid.semilatticeSup.{u2} (α i) (_inst_1 i)))) f g)) (Union.union.{u1} (Finset.{u1} ι) (Finset.hasUnion.{u1} ι (fun (a : ι) (b : ι) => _inst_2 a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => Eq.decidable.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} (α i) (_inst_1 i)) a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))))))) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => Eq.decidable.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} (α i) (_inst_1 i)) a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))))))) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyLinearOrderedAddMonoid.{u1} (α i)] [_inst_2 : DecidableEq.{succ u2} ι] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))}, Eq.{succ u2} (Finset.{u2} ι) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (instDecidableEq.{u1} (α i) ((fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i)) i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))))))) (HasSup.sup.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (SemilatticeSup.toHasSup.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.instSemilatticeSupDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) => Lattice.toSemilatticeSup.{u1} (α i) (DistribLattice.toLattice.{u1} (α i) (instDistribLattice.{u1} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i))))))) f g)) (Union.union.{u2} (Finset.{u2} ι) (Finset.instUnionFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_2 a b)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (instDecidableEq.{u1} (α i) ((fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i)) i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))))))) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (instDecidableEq.{u1} (α i) ((fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i)) i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))))))) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.support_sup Dfinsupp.support_supₓ'. -/
@[simp]
theorem support_sup : (f ⊔ g).support = f.support ∪ g.support :=
  by
  ext
  simp only [Finset.mem_union, mem_support_iff, sup_apply, Ne.def, ← bot_eq_zero]
  rw [_root_.sup_eq_bot_iff, not_and_or]
#align dfinsupp.support_sup Dfinsupp.support_sup

/- warning: dfinsupp.disjoint_iff -> Dfinsupp.disjoint_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), CanonicallyLinearOrderedAddMonoid.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))}, Iff (Disjoint.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i)))))))) (Dfinsupp.partialOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) => OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))) (Dfinsupp.orderBot.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))) f g) (Disjoint.{u1} (Finset.{u1} ι) (Finset.partialOrder.{u1} ι) (Finset.orderBot.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => Eq.decidable.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} (α i) (_inst_1 i)) a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))))))) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => Eq.decidable.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} (α i) (_inst_1 i)) a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} (α i) (_inst_1 i))))))))))) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), CanonicallyLinearOrderedAddMonoid.{u1} (α i)] [_inst_2 : DecidableEq.{succ u2} ι] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))}, Iff (Disjoint.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))) (Dfinsupp.instPartialOrderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) => OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} (α i) (_inst_1 i))))) (Dfinsupp.instOrderBotDfinsuppToZeroToAddMonoidToAddCommMonoidToOrderedAddCommMonoidInstLEDfinsuppToLEToPreorderToPartialOrder.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} (α i) (_inst_1 i))) f g) (Disjoint.{u2} (Finset.{u2} ι) (Finset.partialOrder.{u2} ι) (Finset.instOrderBotFinsetToLEToPreorderPartialOrder.{u2} ι) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (instDecidableEq.{u1} (α i) ((fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i)) i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))))))) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i))))))))) (instDecidableEq.{u1} (α i) ((fun (i : ι) => CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} (α i) (_inst_1 i)) i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_1 i)))))))))) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.disjoint_iff Dfinsupp.disjoint_iffₓ'. -/
theorem disjoint_iff : Disjoint f g ↔ Disjoint f.support g.support :=
  by
  rw [disjoint_iff, disjoint_iff, Dfinsupp.bot_eq_zero, ← Dfinsupp.support_eq_empty,
    Dfinsupp.support_inf]
  rfl
#align dfinsupp.disjoint_iff Dfinsupp.disjoint_iff

end CanonicallyLinearOrderedAddMonoid

end Dfinsupp

