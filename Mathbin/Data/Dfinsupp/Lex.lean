/-
Copyright (c) 2022 Junyan Xu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa, Junyan Xu

! This file was ported from Lean 3 source module data.dfinsupp.lex
! leanprover-community/mathlib commit 28aa996fc6fb4317f0083c4e6daf79878d81be33
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Dfinsupp.Order
import Mathbin.Data.Dfinsupp.NeLocus
import Mathbin.Order.WellFoundedSet

/-!
# Lexicographic order on finitely supported dependent functions

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the lexicographic order on `dfinsupp`.
-/


variable {ι : Type _} {α : ι → Type _}

namespace Dfinsupp

section Zero

variable [∀ i, Zero (α i)]

#print Dfinsupp.Lex /-
/-- `dfinsupp.lex r s` is the lexicographic relation on `Π₀ i, α i`, where `ι` is ordered by `r`,
and `α i` is ordered by `s i`.
The type synonym `lex (Π₀ i, α i)` has an order given by `dfinsupp.lex (<) (λ i, (<))`.
-/
protected def Lex (r : ι → ι → Prop) (s : ∀ i, α i → α i → Prop) (x y : Π₀ i, α i) : Prop :=
  Pi.Lex r s x y
#align dfinsupp.lex Dfinsupp.Lex
-/

/- warning: pi.lex_eq_dfinsupp_lex -> Pi.lex_eq_dfinsupp_lex is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] {r : ι -> ι -> Prop} {s : forall (i : ι), (α i) -> (α i) -> Prop} (a : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (b : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)), Eq.{1} Prop (Pi.Lex.{u1, u2} ι (fun (i : ι) => α i) r s (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) a) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) b)) (Dfinsupp.Lex.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) r s a b)
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u1} (α i)] {r : ι -> ι -> Prop} {s : forall {i : ι}, (α i) -> (α i) -> Prop} (a : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (b : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)), Eq.{1} Prop (Pi.Lex.{u2, u1} ι (fun {i : ι} => α i) r (fun {i._@.Mathlib.Data.Dfinsupp.Lex._hyg.171 : ι} => s i._@.Mathlib.Data.Dfinsupp.Lex._hyg.171) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) b)) (Dfinsupp.Lex.{u2, u1} ι (fun {i : ι} => α i) (fun (i : ι) => _inst_1 i) r (fun {i._@.Mathlib.Data.Dfinsupp.Lex._hyg.184 : ι} => s i._@.Mathlib.Data.Dfinsupp.Lex._hyg.184) a b)
Case conversion may be inaccurate. Consider using '#align pi.lex_eq_dfinsupp_lex Pi.lex_eq_dfinsupp_lexₓ'. -/
theorem Pi.lex_eq_dfinsupp_lex {r : ι → ι → Prop} {s : ∀ i, α i → α i → Prop} (a b : Π₀ i, α i) :
    Pi.Lex r s (a : ∀ i, α i) b = Dfinsupp.Lex r s a b :=
  rfl
#align pi.lex_eq_dfinsupp_lex Pi.lex_eq_dfinsupp_lex

/- warning: dfinsupp.lex_def -> Dfinsupp.lex_def is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] {r : ι -> ι -> Prop} {s : forall (i : ι), (α i) -> (α i) -> Prop} {a : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {b : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, Iff (Dfinsupp.Lex.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) r s a b) (Exists.{succ u1} ι (fun (j : ι) => And (forall (d : ι), (r d j) -> (Eq.{succ u2} (α d) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) a d) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) b d))) (s j (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) a j) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) b j))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u1} (α i)] {r : ι -> ι -> Prop} {s : forall {i : ι}, (α i) -> (α i) -> Prop} {a : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {b : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, Iff (Dfinsupp.Lex.{u2, u1} ι (fun {i : ι} => α i) (fun (i : ι) => _inst_1 i) r (fun {i._@.Mathlib.Data.Dfinsupp.Lex._hyg.260 : ι} => s i._@.Mathlib.Data.Dfinsupp.Lex._hyg.260) a b) (Exists.{succ u2} ι (fun (j : ι) => And (forall (d : ι), (r d j) -> (Eq.{succ u1} ((fun (i : ι) => (fun (i : ι) => α i) i) d) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) a d) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) b d))) (s j (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) a j) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) b j))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.lex_def Dfinsupp.lex_defₓ'. -/
theorem lex_def {r : ι → ι → Prop} {s : ∀ i, α i → α i → Prop} {a b : Π₀ i, α i} :
    Dfinsupp.Lex r s a b ↔ ∃ j, (∀ d, r d j → a d = b d) ∧ s j (a j) (b j) :=
  Iff.rfl
#align dfinsupp.lex_def Dfinsupp.lex_def

instance [LT ι] [∀ i, LT (α i)] : LT (Lex (Π₀ i, α i)) :=
  ⟨fun f g => Dfinsupp.Lex (· < ·) (fun i => (· < ·)) (ofLex f) (ofLex g)⟩

/- warning: dfinsupp.lex_lt_of_lt_of_preorder -> Dfinsupp.lex_lt_of_lt_of_preorder is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), Preorder.{u2} (α i)] (r : ι -> ι -> Prop) [_inst_3 : IsStrictOrder.{u1} ι r] {x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {y : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, (LT.lt.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Preorder.toLT.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i))) x y) -> (Exists.{succ u1} ι (fun (i : ι) => And (forall (j : ι), (r j i) -> (And (LE.le.{u2} (α j) (Preorder.toLE.{u2} (α j) (_inst_2 j)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) x j) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) y j)) (LE.le.{u2} (α j) (Preorder.toLE.{u2} (α j) (_inst_2 j)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) y j) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) x j)))) (LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (_inst_2 i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) x i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) y i))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), Preorder.{u2} (α i)] (r : ι -> ι -> Prop) [_inst_3 : IsStrictOrder.{u1} ι r] {x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {y : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, (LT.lt.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Preorder.toLT.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instPreorderDfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i))) x y) -> (Exists.{succ u1} ι (fun (i : ι) => And (forall (j : ι), (r j i) -> (And (LE.le.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) j) (Preorder.toLE.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) j) (_inst_2 j)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) x j) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) y j)) (LE.le.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) j) (Preorder.toLE.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) j) (_inst_2 j)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) y j) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) x j)))) (LT.lt.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Preorder.toLT.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_2 i)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) x i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) y i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.lex_lt_of_lt_of_preorder Dfinsupp.lex_lt_of_lt_of_preorderₓ'. -/
theorem lex_lt_of_lt_of_preorder [∀ i, Preorder (α i)] (r) [IsStrictOrder ι r] {x y : Π₀ i, α i}
    (hlt : x < y) : ∃ i, (∀ j, r j i → x j ≤ y j ∧ y j ≤ x j) ∧ x i < y i :=
  by
  obtain ⟨hle, j, hlt⟩ := Pi.lt_def.1 hlt
  classical
    have : (x.ne_locus y : Set ι).WellFoundedOn r := (x.ne_locus y).finite_toSet.WellFoundedOn
    obtain ⟨i, hi, hl⟩ := this.has_min { i | x i < y i } ⟨⟨j, mem_ne_locus.2 hlt.ne⟩, hlt⟩
    exact
      ⟨i, fun k hk =>
        ⟨hle k,
          of_not_not fun h =>
            hl ⟨k, mem_ne_locus.2 (ne_of_not_le h).symm⟩ ((hle k).lt_of_not_le h) hk⟩,
        hi⟩
#align dfinsupp.lex_lt_of_lt_of_preorder Dfinsupp.lex_lt_of_lt_of_preorder

/- warning: dfinsupp.lex_lt_of_lt -> Dfinsupp.lex_lt_of_lt is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), PartialOrder.{u2} (α i)] (r : ι -> ι -> Prop) [_inst_3 : IsStrictOrder.{u1} ι r] {x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {y : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, (LT.lt.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Preorder.toLT.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (_inst_2 i)))) x y) -> (Pi.Lex.{u1, u2} ι (fun (i : ι) => α i) r (fun (i : ι) => LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_2 i)))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) y))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), PartialOrder.{u2} (α i)] (r : ι -> ι -> Prop) [_inst_3 : IsStrictOrder.{u1} ι r] {x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {y : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, (LT.lt.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Preorder.toLT.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instPreorderDfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (_inst_2 i)))) x y) -> (Pi.Lex.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) i) r (fun {i : ι} (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.687 : (fun (i : ι) => (fun (i : ι) => α i) i) i) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.689 : (fun (i : ι) => (fun (i : ι) => α i) i) i) => LT.lt.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Preorder.toLT.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u2} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_2 i))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.687 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.689) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) y))
Case conversion may be inaccurate. Consider using '#align dfinsupp.lex_lt_of_lt Dfinsupp.lex_lt_of_ltₓ'. -/
theorem lex_lt_of_lt [∀ i, PartialOrder (α i)] (r) [IsStrictOrder ι r] {x y : Π₀ i, α i}
    (hlt : x < y) : Pi.Lex r (fun i => (· < ·)) x y :=
  by
  simp_rw [Pi.Lex, le_antisymm_iff]
  exact lex_lt_of_lt_of_preorder r hlt
#align dfinsupp.lex_lt_of_lt Dfinsupp.lex_lt_of_lt

/- warning: dfinsupp.lex.is_strict_order -> Dfinsupp.Lex.isStrictOrder is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : LinearOrder.{u1} ι] [_inst_3 : forall (i : ι), PartialOrder.{u2} (α i)], IsStrictOrder.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (LT.lt.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.Lex.hasLt.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (Preorder.toLT.{u1} ι (PartialOrder.toPreorder.{u1} ι (SemilatticeInf.toPartialOrder.{u1} ι (Lattice.toSemilatticeInf.{u1} ι (LinearOrder.toLattice.{u1} ι _inst_2))))) (fun (i : ι) => Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i)))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : LinearOrder.{u1} ι] [_inst_3 : forall (i : ι), PartialOrder.{u2} (α i)], IsStrictOrder.{max u2 u1} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.772 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.774 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) => LT.lt.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.instLTLexDfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (Preorder.toLT.{u1} ι (PartialOrder.toPreorder.{u1} ι (SemilatticeInf.toPartialOrder.{u1} ι (Lattice.toSemilatticeInf.{u1} ι (DistribLattice.toLattice.{u1} ι (instDistribLattice.{u1} ι _inst_2)))))) (fun (i : ι) => Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i)))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.772 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.774)
Case conversion may be inaccurate. Consider using '#align dfinsupp.lex.is_strict_order Dfinsupp.Lex.isStrictOrderₓ'. -/
instance Lex.isStrictOrder [LinearOrder ι] [∀ i, PartialOrder (α i)] :
    IsStrictOrder (Lex (Π₀ i, α i)) (· < ·) :=
  let i : IsStrictOrder (Lex (∀ i, α i)) (· < ·) := Pi.Lex.isStrictOrder
  { irrefl := toLex.Surjective.forall.2 fun a => @irrefl _ _ i.to_isIrrefl a
    trans := toLex.Surjective.forall₃.2 fun a b c => @trans _ _ i.to_isTrans a b c }
#align dfinsupp.lex.is_strict_order Dfinsupp.Lex.isStrictOrder

variable [LinearOrder ι]

#print Dfinsupp.Lex.partialOrder /-
/-- The partial order on `dfinsupp`s obtained by the lexicographic ordering.
See `dfinsupp.lex.linear_order` for a proof that this partial order is in fact linear. -/
instance Lex.partialOrder [∀ i, PartialOrder (α i)] : PartialOrder (Lex (Π₀ i, α i)) :=
  PartialOrder.lift (fun x => toLex ⇑(ofLex x)) Dfinsupp.coeFn_injective
#align dfinsupp.lex.partial_order Dfinsupp.Lex.partialOrder
-/

section LinearOrder

variable [∀ i, LinearOrder (α i)]

/-- Auxiliary helper to case split computably. There is no need for this to be public, as it
can be written with `or.by_cases` on `lt_trichotomy` once the instances below are constructed. -/
private def lt_trichotomy_rec {P : Lex (Π₀ i, α i) → Lex (Π₀ i, α i) → Sort _}
    (h_lt : ∀ {f g}, toLex f < toLex g → P (toLex f) (toLex g))
    (h_eq : ∀ {f g}, toLex f = toLex g → P (toLex f) (toLex g))
    (h_gt : ∀ {f g}, toLex g < toLex f → P (toLex f) (toLex g)) : ∀ f g, P f g :=
  Lex.rec fun f =>
    Lex.rec fun g =>
      match (motive := ∀ y, (f.neLocus g).min = y → _) _, rfl with
      | ⊤, h => h_eq (neLocus_eq_empty.mp <| Finset.min_eq_top.mp h)
      | (wit : ι), h =>
        (mem_neLocus.mp <| Finset.mem_of_min h).lt_or_lt.byCases
          (fun hwit =>
            h_lt ⟨wit, fun j hj => not_mem_neLocus.mp (Finset.not_mem_of_lt_min hj h), hwit⟩)
          fun hwit =>
          h_gt
            ⟨wit, fun j hj =>
              not_mem_neLocus.mp (Finset.not_mem_of_lt_min hj <| by rwa [ne_locus_comm]), hwit⟩
#align dfinsupp.lt_trichotomy_rec dfinsupp.lt_trichotomy_rec

/- ./././Mathport/Syntax/Translate/Command.lean:317:38: unsupported irreducible non-definition -/
#print Dfinsupp.Lex.decidableLE /-
irreducible_def Lex.decidableLE : @DecidableRel (Lex (Π₀ i, α i)) (· ≤ ·) :=
  ltTrichotomyRec (fun f g h => isTrue <| Or.inr h) (fun f g h => isTrue <| Or.inl <| congr_arg _ h)
    fun f g h => isFalse fun h' => (lt_irrefl _ (h.trans_le h')).elim
#align dfinsupp.lex.decidable_le Dfinsupp.Lex.decidableLE
-/

/- warning: dfinsupp.lex.decidable_lt -> Dfinsupp.Lex.decidableLT is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : LinearOrder.{u1} ι] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)], DecidableRel.{succ (max u1 u2)} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (LT.lt.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.Lex.hasLt.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (Preorder.toLT.{u1} ι (PartialOrder.toPreorder.{u1} ι (SemilatticeInf.toPartialOrder.{u1} ι (Lattice.toSemilatticeInf.{u1} ι (LinearOrder.toLattice.{u1} ι _inst_2))))) (fun (i : ι) => Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (_inst_3 i))))))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : LinearOrder.{u1} ι] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)], DecidableRel.{succ (max u2 u1)} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.1669 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.1671 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) => LT.lt.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.instLTLexDfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (Preorder.toLT.{u1} ι (PartialOrder.toPreorder.{u1} ι (SemilatticeInf.toPartialOrder.{u1} ι (Lattice.toSemilatticeInf.{u1} ι (DistribLattice.toLattice.{u1} ι (instDistribLattice.{u1} ι _inst_2)))))) (fun (i : ι) => Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (DistribLattice.toLattice.{u2} (α i) (instDistribLattice.{u2} (α i) (_inst_3 i)))))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.1669 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.1671)
Case conversion may be inaccurate. Consider using '#align dfinsupp.lex.decidable_lt Dfinsupp.Lex.decidableLTₓ'. -/
/- ./././Mathport/Syntax/Translate/Command.lean:317:38: unsupported irreducible non-definition -/
irreducible_def Lex.decidableLT : @DecidableRel (Lex (Π₀ i, α i)) (· < ·) :=
  ltTrichotomyRec (fun f g h => isTrue h) (fun f g h => isFalse h.not_lt) fun f g h =>
    isFalse h.asymm
#align dfinsupp.lex.decidable_lt Dfinsupp.Lex.decidableLT

#print Dfinsupp.Lex.linearOrder /-
/-- The linear order on `dfinsupp`s obtained by the lexicographic ordering. -/
instance Lex.linearOrder : LinearOrder (Lex (Π₀ i, α i)) :=
  {
    Lex.partialOrder with
    le_total :=
      ltTrichotomyRec (fun f g h => Or.inl h.le) (fun f g h => Or.inl h.le) fun f g h => Or.inr h.le
    decidableLt := by infer_instance
    decidableLe := by infer_instance
    DecidableEq := by infer_instance }
#align dfinsupp.lex.linear_order Dfinsupp.Lex.linearOrder
-/

end LinearOrder

variable [∀ i, PartialOrder (α i)]

/- warning: dfinsupp.to_lex_monotone -> Dfinsupp.toLex_monotone is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : LinearOrder.{u1} ι] [_inst_3 : forall (i : ι), PartialOrder.{u2} (α i)], Monotone.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))) (PartialOrder.toPreorder.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.Lex.partialOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) _inst_2 (fun (i : ι) => _inst_3 i))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) -> (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))) (toLex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u1} (α i)] [_inst_2 : LinearOrder.{u2} ι] [_inst_3 : forall (i : ι), PartialOrder.{u1} (α i)], Monotone.{max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Lex.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))) (PartialOrder.toPreorder.{max u2 u1} (Lex.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.Lex.partialOrder.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) _inst_2 (fun (i : ι) => _inst_3 i))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Lex.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => Lex.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Lex.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)))) (toLex.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.to_lex_monotone Dfinsupp.toLex_monotoneₓ'. -/
theorem toLex_monotone : Monotone (@toLex (Π₀ i, α i)) := fun a b h =>
  le_of_lt_or_eq <|
    or_iff_not_imp_right.2 fun hne => by
      classical exact
          ⟨Finset.min' _ (nonempty_ne_locus_iff.2 hne), fun j hj =>
            not_mem_ne_locus.1 fun h => (Finset.min'_le _ _ h).not_lt hj,
            (h _).lt_of_ne (mem_ne_locus.1 <| Finset.min'_mem _ _)⟩
#align dfinsupp.to_lex_monotone Dfinsupp.toLex_monotone

#print Dfinsupp.lt_of_forall_lt_of_lt /-
theorem lt_of_forall_lt_of_lt (a b : Lex (Π₀ i, α i)) (i : ι) :
    (∀ j < i, ofLex a j = ofLex b j) → ofLex a i < ofLex b i → a < b := fun h1 h2 => ⟨i, h1, h2⟩
#align dfinsupp.lt_of_forall_lt_of_lt Dfinsupp.lt_of_forall_lt_of_lt
-/

end Zero

section Covariants

variable [LinearOrder ι] [∀ i, AddMonoid (α i)] [∀ i, LinearOrder (α i)]

/-!  We are about to sneak in a hypothesis that might appear to be too strong.
We assume `covariant_class` with *strict* inequality `<` also when proving the one with the
*weak* inequality `≤`.  This is actually necessary: addition on `lex (Π₀ i, α i)` may fail to be
monotone, when it is "just" monotone on `α i`. -/


section Left

variable [∀ i, CovariantClass (α i) (α i) (· + ·) (· < ·)]

/- warning: dfinsupp.lex.covariant_class_lt_left -> Dfinsupp.Lex.covariantClass_lt_left is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : LinearOrder.{u1} ι] [_inst_2 : forall (i : ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)] [_inst_4 : forall (i : ι), CovariantClass.{u2, u2} (α i) (α i) (HAdd.hAdd.{u2, u2, u2} (α i) (α i) (α i) (instHAdd.{u2} (α i) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (_inst_3 i)))))))], CovariantClass.{max u1 u2, max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (instHAdd.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.hasAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))))) (LT.lt.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Dfinsupp.Lex.hasLt.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))) (Preorder.toLT.{u1} ι (PartialOrder.toPreorder.{u1} ι (SemilatticeInf.toPartialOrder.{u1} ι (Lattice.toSemilatticeInf.{u1} ι (LinearOrder.toLattice.{u1} ι _inst_1))))) (fun (i : ι) => Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (_inst_3 i))))))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : LinearOrder.{u1} ι] [_inst_2 : forall (i : ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)] [_inst_4 : forall (i : ι), CovariantClass.{u2, u2} (α i) (α i) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2592 : α i) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2594 : α i) => HAdd.hAdd.{u2, u2, u2} (α i) (α i) (α i) (instHAdd.{u2} (α i) (AddZeroClass.toAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2592 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2594) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2607 : α i) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2609 : α i) => LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (DistribLattice.toLattice.{u2} (α i) (instDistribLattice.{u2} (α i) (_inst_3 i))))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2607 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2609)], CovariantClass.{max u2 u1, max u2 u1} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2669 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2671 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (instHAdd.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (instAddLex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2669 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2671) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2684 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2686 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => LT.lt.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Dfinsupp.instLTLexDfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)) (Preorder.toLT.{u1} ι (PartialOrder.toPreorder.{u1} ι (SemilatticeInf.toPartialOrder.{u1} ι (Lattice.toSemilatticeInf.{u1} ι (DistribLattice.toLattice.{u1} ι (instDistribLattice.{u1} ι _inst_1)))))) (fun (i : ι) => Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (DistribLattice.toLattice.{u2} (α i) (instDistribLattice.{u2} (α i) (_inst_3 i)))))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2684 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2686)
Case conversion may be inaccurate. Consider using '#align dfinsupp.lex.covariant_class_lt_left Dfinsupp.Lex.covariantClass_lt_leftₓ'. -/
instance Lex.covariantClass_lt_left :
    CovariantClass (Lex (Π₀ i, α i)) (Lex (Π₀ i, α i)) (· + ·) (· < ·) :=
  ⟨fun f g h ⟨a, lta, ha⟩ =>
    ⟨a, fun j ja => congr_arg ((· + ·) _) (lta j ja), add_lt_add_left ha _⟩⟩
#align dfinsupp.lex.covariant_class_lt_left Dfinsupp.Lex.covariantClass_lt_left

/- warning: dfinsupp.lex.covariant_class_le_left -> Dfinsupp.Lex.covariantClass_le_left is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : LinearOrder.{u1} ι] [_inst_2 : forall (i : ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)] [_inst_4 : forall (i : ι), CovariantClass.{u2, u2} (α i) (α i) (HAdd.hAdd.{u2, u2, u2} (α i) (α i) (α i) (instHAdd.{u2} (α i) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (_inst_3 i)))))))], CovariantClass.{max u1 u2, max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (instHAdd.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.hasAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))))) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Preorder.toLE.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (PartialOrder.toPreorder.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Dfinsupp.Lex.partialOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))) _inst_1 (fun (i : ι) => SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (_inst_3 i))))))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : LinearOrder.{u1} ι] [_inst_2 : forall (i : ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)] [_inst_4 : forall (i : ι), CovariantClass.{u2, u2} (α i) (α i) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2796 : α i) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2798 : α i) => HAdd.hAdd.{u2, u2, u2} (α i) (α i) (α i) (instHAdd.{u2} (α i) (AddZeroClass.toAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2796 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2798) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2811 : α i) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2813 : α i) => LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (DistribLattice.toLattice.{u2} (α i) (instDistribLattice.{u2} (α i) (_inst_3 i))))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2811 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2813)], CovariantClass.{max u2 u1, max u2 u1} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2873 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2875 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (instHAdd.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (instAddLex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2873 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2875) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2888 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2890 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => LE.le.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Preorder.toLE.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (PartialOrder.toPreorder.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Dfinsupp.Lex.partialOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)) _inst_1 (fun (i : ι) => SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (DistribLattice.toLattice.{u2} (α i) (instDistribLattice.{u2} (α i) (_inst_3 i)))))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2888 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.2890)
Case conversion may be inaccurate. Consider using '#align dfinsupp.lex.covariant_class_le_left Dfinsupp.Lex.covariantClass_le_leftₓ'. -/
instance Lex.covariantClass_le_left :
    CovariantClass (Lex (Π₀ i, α i)) (Lex (Π₀ i, α i)) (· + ·) (· ≤ ·) :=
  Add.to_covariantClass_left _
#align dfinsupp.lex.covariant_class_le_left Dfinsupp.Lex.covariantClass_le_left

end Left

section Right

variable [∀ i, CovariantClass (α i) (α i) (Function.swap (· + ·)) (· < ·)]

/- warning: dfinsupp.lex.covariant_class_lt_right -> Dfinsupp.Lex.covariantClass_lt_right is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : LinearOrder.{u1} ι] [_inst_2 : forall (i : ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)] [_inst_4 : forall (i : ι), CovariantClass.{u2, u2} (α i) (α i) (Function.swap.{succ u2, succ u2, succ u2} (α i) (α i) (fun (ᾰ : α i) (ᾰ : α i) => α i) (HAdd.hAdd.{u2, u2, u2} (α i) (α i) (α i) (instHAdd.{u2} (α i) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))))) (LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (_inst_3 i)))))))], CovariantClass.{max u1 u2, max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Function.swap.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (fun (ᾰ : Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (ᾰ : Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) => Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (instHAdd.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.hasAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))))) (LT.lt.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Dfinsupp.Lex.hasLt.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))) (Preorder.toLT.{u1} ι (PartialOrder.toPreorder.{u1} ι (SemilatticeInf.toPartialOrder.{u1} ι (Lattice.toSemilatticeInf.{u1} ι (LinearOrder.toLattice.{u1} ι _inst_1))))) (fun (i : ι) => Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (_inst_3 i))))))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : LinearOrder.{u1} ι] [_inst_2 : forall (i : ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)] [_inst_4 : forall (i : ι), CovariantClass.{u2, u2} (α i) (α i) (Function.swap.{succ u2, succ u2, succ u2} (α i) (α i) (fun (ᾰ : α i) (ᾰ : α i) => α i) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3027 : α i) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3029 : α i) => HAdd.hAdd.{u2, u2, u2} (α i) (α i) (α i) (instHAdd.{u2} (α i) (AddZeroClass.toAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3027 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3029)) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3042 : α i) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3044 : α i) => LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (DistribLattice.toLattice.{u2} (α i) (instDistribLattice.{u2} (α i) (_inst_3 i))))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3042 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3044)], CovariantClass.{max u2 u1, max u2 u1} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Function.swap.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (fun (ᾰ : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (ᾰ : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3107 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3109 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (instHAdd.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (instAddLex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3107 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3109)) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3122 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3124 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => LT.lt.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Dfinsupp.instLTLexDfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)) (Preorder.toLT.{u1} ι (PartialOrder.toPreorder.{u1} ι (SemilatticeInf.toPartialOrder.{u1} ι (Lattice.toSemilatticeInf.{u1} ι (DistribLattice.toLattice.{u1} ι (instDistribLattice.{u1} ι _inst_1)))))) (fun (i : ι) => Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (DistribLattice.toLattice.{u2} (α i) (instDistribLattice.{u2} (α i) (_inst_3 i)))))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3122 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3124)
Case conversion may be inaccurate. Consider using '#align dfinsupp.lex.covariant_class_lt_right Dfinsupp.Lex.covariantClass_lt_rightₓ'. -/
instance Lex.covariantClass_lt_right :
    CovariantClass (Lex (Π₀ i, α i)) (Lex (Π₀ i, α i)) (Function.swap (· + ·)) (· < ·) :=
  ⟨fun f g h ⟨a, lta, ha⟩ =>
    ⟨a, fun j ja => congr_arg (· + ofLex f j) (lta j ja), add_lt_add_right ha _⟩⟩
#align dfinsupp.lex.covariant_class_lt_right Dfinsupp.Lex.covariantClass_lt_right

/- warning: dfinsupp.lex.covariant_class_le_right -> Dfinsupp.Lex.covariantClass_le_right is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : LinearOrder.{u1} ι] [_inst_2 : forall (i : ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)] [_inst_4 : forall (i : ι), CovariantClass.{u2, u2} (α i) (α i) (Function.swap.{succ u2, succ u2, succ u2} (α i) (α i) (fun (ᾰ : α i) (ᾰ : α i) => α i) (HAdd.hAdd.{u2, u2, u2} (α i) (α i) (α i) (instHAdd.{u2} (α i) (AddZeroClass.toHasAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))))) (LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (_inst_3 i)))))))], CovariantClass.{max u1 u2, max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Function.swap.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (fun (ᾰ : Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (ᾰ : Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) => Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (instHAdd.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Lex.hasAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))))) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Preorder.toLE.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (PartialOrder.toPreorder.{max u1 u2} (Lex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) (Dfinsupp.Lex.partialOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))) _inst_1 (fun (i : ι) => SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (LinearOrder.toLattice.{u2} (α i) (_inst_3 i))))))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : LinearOrder.{u1} ι] [_inst_2 : forall (i : ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : ι), LinearOrder.{u2} (α i)] [_inst_4 : forall (i : ι), CovariantClass.{u2, u2} (α i) (α i) (Function.swap.{succ u2, succ u2, succ u2} (α i) (α i) (fun (ᾰ : α i) (ᾰ : α i) => α i) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3249 : α i) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3251 : α i) => HAdd.hAdd.{u2, u2, u2} (α i) (α i) (α i) (instHAdd.{u2} (α i) (AddZeroClass.toAdd.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i)))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3249 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3251)) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3264 : α i) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3266 : α i) => LT.lt.{u2} (α i) (Preorder.toLT.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (DistribLattice.toLattice.{u2} (α i) (instDistribLattice.{u2} (α i) (_inst_3 i))))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3264 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3266)], CovariantClass.{max u2 u1, max u2 u1} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Function.swap.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (fun (ᾰ : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (ᾰ : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3329 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3331 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (instHAdd.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (instAddLex.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (α i) (_inst_2 i))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3329 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3331)) (fun (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3344 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3346 : Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) => LE.le.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Preorder.toLE.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (PartialOrder.toPreorder.{max u1 u2} (Lex.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)))) (Dfinsupp.Lex.partialOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)) _inst_1 (fun (i : ι) => SemilatticeInf.toPartialOrder.{u2} (α i) (Lattice.toSemilatticeInf.{u2} (α i) (DistribLattice.toLattice.{u2} (α i) (instDistribLattice.{u2} (α i) (_inst_3 i)))))))) x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3344 x._@.Mathlib.Data.Dfinsupp.Lex._hyg.3346)
Case conversion may be inaccurate. Consider using '#align dfinsupp.lex.covariant_class_le_right Dfinsupp.Lex.covariantClass_le_rightₓ'. -/
instance Lex.covariantClass_le_right :
    CovariantClass (Lex (Π₀ i, α i)) (Lex (Π₀ i, α i)) (Function.swap (· + ·)) (· ≤ ·) :=
  Add.to_covariantClass_right _
#align dfinsupp.lex.covariant_class_le_right Dfinsupp.Lex.covariantClass_le_right

end Right

end Covariants

end Dfinsupp

