/-
Copyright (c) 2021 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies

! This file was ported from Lean 3 source module data.dfinsupp.interval
! leanprover-community/mathlib commit b6da1a0b3e7cd83b1f744c49ce48ef8c6307d2f6
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Finset.LocallyFinite
import Mathbin.Data.Finset.Pointwise
import Mathbin.Data.Fintype.BigOperators
import Mathbin.Data.Dfinsupp.Order

/-!
# Finite intervals of finitely supported functions

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file provides the `locally_finite_order` instance for `Π₀ i, α i` when `α` itself is locally
finite and calculates the cardinality of its finite intervals.
-/


open Dfinsupp Finset

open BigOperators Pointwise

variable {ι : Type _} {α : ι → Type _}

namespace Finset

variable [DecidableEq ι] [∀ i, Zero (α i)] {s : Finset ι} {f : Π₀ i, α i} {t : ∀ i, Finset (α i)}

#print Finset.dfinsupp /-
/-- Finitely supported product of finsets. -/
def dfinsupp (s : Finset ι) (t : ∀ i, Finset (α i)) : Finset (Π₀ i, α i) :=
  (s.pi t).map
    ⟨fun f => Dfinsupp.mk s fun i => f i i.2,
      by
      refine' (mk_injective _).comp fun f g h => _
      ext (i hi)
      convert congr_fun h ⟨i, hi⟩⟩
#align finset.dfinsupp Finset.dfinsupp
-/

/- warning: finset.card_dfinsupp -> Finset.card_dfinsupp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), Zero.{u2} (α i)] (s : Finset.{u1} ι) (t : forall (i : ι), Finset.{u2} (α i)), Eq.{1} Nat (Finset.card.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (Finset.dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) s t)) (Finset.prod.{0, u1} Nat ι Nat.commMonoid s (fun (i : ι) => Finset.card.{u2} (α i) (t i)))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), Zero.{u1} (α i)] (s : Finset.{u2} ι) (t : forall (i : ι), Finset.{u1} (α i)), Eq.{1} Nat (Finset.card.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (Finset.dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) s t)) (Finset.prod.{0, u2} Nat ι Nat.commMonoid s (fun (i : ι) => Finset.card.{u1} (α i) (t i)))
Case conversion may be inaccurate. Consider using '#align finset.card_dfinsupp Finset.card_dfinsuppₓ'. -/
@[simp]
theorem card_dfinsupp (s : Finset ι) (t : ∀ i, Finset (α i)) :
    (s.Dfinsupp t).card = ∏ i in s, (t i).card :=
  (card_map _).trans <| card_pi _ _
#align finset.card_dfinsupp Finset.card_dfinsupp

variable [∀ i, DecidableEq (α i)]

/- warning: finset.mem_dfinsupp_iff -> Finset.mem_dfinsupp_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), Zero.{u2} (α i)] {s : Finset.{u1} ι} {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)} {t : forall (i : ι), Finset.{u2} (α i)} [_inst_3 : forall (i : ι), DecidableEq.{succ u2} (α i)], Iff (Membership.Mem.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (Finset.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) (Finset.hasMem.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) f (Finset.dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) s t)) (And (HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_3 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_2 i))))) f) s) (forall (i : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i s) -> (Membership.Mem.{u2, u2} (α i) (Finset.{u2} (α i)) (Finset.hasMem.{u2} (α i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) f i) (t i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), Zero.{u1} (α i)] {s : Finset.{u2} ι} {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)} {t : forall (i : ι), Finset.{u1} (α i)} [_inst_3 : forall (i : ι), DecidableEq.{succ u1} (α i)], Iff (Membership.mem.{max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (Finset.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) (Finset.instMembershipFinset.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) f (Finset.dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) s t)) (And (HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_2 i)))) (_inst_3 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_2 i))))) f) s) (forall (i : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (Membership.mem.{u1, u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Finset.{u1} (α i)) (Finset.instMembershipFinset.{u1} (α i)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) f i) (t i))))
Case conversion may be inaccurate. Consider using '#align finset.mem_dfinsupp_iff Finset.mem_dfinsupp_iffₓ'. -/
theorem mem_dfinsupp_iff : f ∈ s.Dfinsupp t ↔ f.support ⊆ s ∧ ∀ i ∈ s, f i ∈ t i :=
  by
  refine' mem_map.trans ⟨_, _⟩
  · rintro ⟨f, hf, rfl⟩
    refine' ⟨support_mk_subset, fun i hi => _⟩
    convert mem_pi.1 hf i hi
    exact mk_of_mem hi
  · refine' fun h => ⟨fun i _ => f i, mem_pi.2 h.2, _⟩
    ext i
    dsimp
    exact ite_eq_left_iff.2 fun hi => (not_mem_support_iff.1 fun H => hi <| h.1 H).symm
#align finset.mem_dfinsupp_iff Finset.mem_dfinsupp_iff

/- warning: finset.mem_dfinsupp_iff_of_support_subset -> Finset.mem_dfinsupp_iff_of_support_subset is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), Zero.{u2} (α i)] {s : Finset.{u1} ι} {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)} [_inst_3 : forall (i : ι), DecidableEq.{succ u2} (α i)] {t : Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_2 i))}, (HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_2 i)) (fun (i : ι) (x : Finset.{u2} (α i)) => Ne.decidable.{succ u2} (Finset.{u2} (α i)) (fun (a : Finset.{u2} (α i)) (b : Finset.{u2} (α i)) => Finset.decidableEq.{u2} (α i) (fun (a : α i) (b : α i) => _inst_3 i a b) a b) x (OfNat.ofNat.{u2} (Finset.{u2} (α i)) 0 (OfNat.mk.{u2} (Finset.{u2} (α i)) 0 (Zero.zero.{u2} (Finset.{u2} (α i)) (Finset.zero.{u2} (α i) (_inst_2 i)))))) t) s) -> (Iff (Membership.Mem.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (Finset.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) (Finset.hasMem.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) f (Finset.dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) s (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_2 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_2 i))) => forall (i : ι), Finset.{u2} (α i)) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_2 i))) t))) (forall (i : ι), Membership.Mem.{u2, u2} (α i) (Finset.{u2} (α i)) (Finset.hasMem.{u2} (α i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_2 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_2 i))) => forall (i : ι), Finset.{u2} (α i)) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_2 i))) t i)))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), Zero.{u1} (α i)] {s : Finset.{u2} ι} {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)} [_inst_3 : forall (i : ι), DecidableEq.{succ u1} (α i)] {t : Dfinsupp.{u2, u1} ι (fun (i : ι) => Finset.{u1} (α i)) (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_2 i))}, (HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => Finset.{u1} (α i)) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_2 i)) (fun (i : ι) (x : Finset.{u1} (α i)) => instDecidableNot (Eq.{succ u1} (Finset.{u1} (α i)) x (OfNat.ofNat.{u1} (Finset.{u1} (α i)) 0 (Zero.toOfNat0.{u1} (Finset.{u1} (α i)) (Finset.zero.{u1} (α i) (_inst_2 i))))) (Finset.decidableEq.{u1} (α i) ((fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) i) x (OfNat.ofNat.{u1} (Finset.{u1} (α i)) 0 (Zero.toOfNat0.{u1} (Finset.{u1} (α i)) (Finset.zero.{u1} (α i) (_inst_2 i)))))) t) s) -> (Iff (Membership.mem.{max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i)) (Finset.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) (Finset.instMembershipFinset.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_2 i))) f (Finset.dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) s (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_2 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_2 i)) i)) t))) (forall (i : ι), Membership.mem.{u1, u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) ((fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) i) (Finset.instMembershipFinset.{u1} (α i)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_2 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_2 i)) i)) t i)))
Case conversion may be inaccurate. Consider using '#align finset.mem_dfinsupp_iff_of_support_subset Finset.mem_dfinsupp_iff_of_support_subsetₓ'. -/
/-- When `t` is supported on `s`, `f ∈ s.dfinsupp t` precisely means that `f` is pointwise in `t`.
-/
@[simp]
theorem mem_dfinsupp_iff_of_support_subset {t : Π₀ i, Finset (α i)} (ht : t.support ⊆ s) :
    f ∈ s.Dfinsupp t ↔ ∀ i, f i ∈ t i :=
  by
  refine'
    mem_dfinsupp_iff.trans
      (forall_and_distrib.symm.trans <|
        forall_congr' fun i =>
          ⟨fun h => _, fun h =>
            ⟨fun hi => ht <| mem_support_iff.2 fun H => mem_support_iff.1 hi _, fun _ => h⟩⟩)
  · by_cases hi : i ∈ s
    · exact h.2 hi
    · rw [not_mem_support_iff.1 (mt h.1 hi), not_mem_support_iff.1 (not_mem_mono ht hi)]
      exact zero_mem_zero
  · rwa [H, mem_zero] at h
#align finset.mem_dfinsupp_iff_of_support_subset Finset.mem_dfinsupp_iff_of_support_subset

end Finset

open Finset

namespace Dfinsupp

section BundledSingleton

variable [∀ i, Zero (α i)] {f : Π₀ i, α i} {i : ι} {a : α i}

#print Dfinsupp.singleton /-
/-- Pointwise `finset.singleton` bundled as a `dfinsupp`. -/
def singleton (f : Π₀ i, α i) : Π₀ i, Finset (α i)
    where
  toFun i := {f i}
  support' := f.support'.map fun s => ⟨s, fun i => (s.Prop i).imp id (congr_arg _)⟩
#align dfinsupp.singleton Dfinsupp.singleton
-/

#print Dfinsupp.mem_singleton_apply_iff /-
theorem mem_singleton_apply_iff : a ∈ f.singleton i ↔ a = f i :=
  mem_singleton
#align dfinsupp.mem_singleton_apply_iff Dfinsupp.mem_singleton_apply_iff
-/

end BundledSingleton

section BundledIcc

variable [∀ i, Zero (α i)] [∀ i, PartialOrder (α i)] [∀ i, LocallyFiniteOrder (α i)]
  {f g : Π₀ i, α i} {i : ι} {a : α i}

#print Dfinsupp.rangeIcc /-
/-- Pointwise `finset.Icc` bundled as a `dfinsupp`. -/
def rangeIcc (f g : Π₀ i, α i) : Π₀ i, Finset (α i)
    where
  toFun i := Icc (f i) (g i)
  support' :=
    f.support'.bind fun fs =>
      g.support'.map fun gs =>
        ⟨fs + gs, fun i =>
          or_iff_not_imp_left.2 fun h =>
            by
            have hf : f i = 0 :=
              (fs.prop i).resolve_left
                (Multiset.not_mem_mono (Multiset.Le.subset <| Multiset.le_add_right _ _) h)
            have hg : g i = 0 :=
              (gs.prop i).resolve_left
                (Multiset.not_mem_mono (Multiset.Le.subset <| Multiset.le_add_left _ _) h)
            rw [hf, hg]
            exact Icc_self _⟩
#align dfinsupp.range_Icc Dfinsupp.rangeIcc
-/

/- warning: dfinsupp.range_Icc_apply -> Dfinsupp.rangeIcc_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), PartialOrder.{u2} (α i)] [_inst_3 : forall (i : ι), LocallyFiniteOrder.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_2 i))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (i : ι), Eq.{succ u2} (Finset.{u2} ((fun (i : ι) => α i) i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} ((fun (i : ι) => α i) i)) (fun (i : ι) => Finset.zero.{u2} ((fun (i : ι) => α i) i) ((fun (i : ι) => _inst_1 i) i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} ((fun (i : ι) => α i) i)) (fun (i : ι) => Finset.zero.{u2} ((fun (i : ι) => α i) i) ((fun (i : ι) => _inst_1 i) i))) => forall (i : ι), Finset.{u2} ((fun (i : ι) => α i) i)) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => Finset.{u2} ((fun (i : ι) => α i) i)) (fun (i : ι) => Finset.zero.{u2} ((fun (i : ι) => α i) i) ((fun (i : ι) => _inst_1 i) i))) (Dfinsupp.rangeIcc.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) f g) i) (Finset.Icc.{u2} ((fun (i : ι) => α i) i) (PartialOrder.toPreorder.{u2} ((fun (i : ι) => α i) i) (_inst_2 i)) (_inst_3 i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) g i))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u1} (α i)] [_inst_2 : forall (i : ι), PartialOrder.{u1} (α i)] [_inst_3 : forall (i : ι), LocallyFiniteOrder.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (_inst_2 i))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (i : ι), Eq.{succ u1} ((fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i)) i)) (Dfinsupp.rangeIcc.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) f g) i) (Finset.Icc.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_2 i)) (_inst_3 i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) g i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.range_Icc_apply Dfinsupp.rangeIcc_applyₓ'. -/
@[simp]
theorem rangeIcc_apply (f g : Π₀ i, α i) (i : ι) : f.rangeIcc g i = Icc (f i) (g i) :=
  rfl
#align dfinsupp.range_Icc_apply Dfinsupp.rangeIcc_apply

#print Dfinsupp.mem_rangeIcc_apply_iff /-
theorem mem_rangeIcc_apply_iff : a ∈ f.rangeIcc g i ↔ f i ≤ a ∧ a ≤ g i :=
  mem_Icc
#align dfinsupp.mem_range_Icc_apply_iff Dfinsupp.mem_rangeIcc_apply_iff
-/

/- warning: dfinsupp.support_range_Icc_subset -> Dfinsupp.support_rangeIcc_subset is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : forall (i : ι), PartialOrder.{u2} (α i)] [_inst_3 : forall (i : ι), LocallyFiniteOrder.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_2 i))] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} [_inst_4 : DecidableEq.{succ u1} ι] [_inst_5 : forall (i : ι), DecidableEq.{succ u2} (α i)], HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i)) (fun (i : ι) (x : Finset.{u2} (α i)) => Ne.decidable.{succ u2} (Finset.{u2} (α i)) (fun (a : Finset.{u2} (α i)) (b : Finset.{u2} (α i)) => Finset.decidableEq.{u2} (α i) (fun (a : α i) (b : α i) => _inst_5 i a b) a b) x (OfNat.ofNat.{u2} (Finset.{u2} (α i)) 0 (OfNat.mk.{u2} (Finset.{u2} (α i)) 0 (Zero.zero.{u2} (Finset.{u2} (α i)) (Finset.zero.{u2} (α i) (_inst_1 i)))))) (Dfinsupp.rangeIcc.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) f g)) (Union.union.{u1} (Finset.{u1} ι) (Finset.hasUnion.{u1} ι (fun (a : ι) (b : ι) => _inst_4 a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_5 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_1 i))))) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_5 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_1 i))))) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u1} (α i)] [_inst_2 : forall (i : ι), PartialOrder.{u1} (α i)] [_inst_3 : forall (i : ι), LocallyFiniteOrder.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (_inst_2 i))] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)} [_inst_4 : DecidableEq.{succ u2} ι] [_inst_5 : forall (i : ι), DecidableEq.{succ u1} (α i)], HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => Finset.{u1} (α i)) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i)) (fun (i : ι) (x : Finset.{u1} (α i)) => instDecidableNot (Eq.{succ u1} (Finset.{u1} (α i)) x (OfNat.ofNat.{u1} (Finset.{u1} (α i)) 0 (Zero.toOfNat0.{u1} (Finset.{u1} (α i)) (Finset.zero.{u1} (α i) (_inst_1 i))))) (Finset.decidableEq.{u1} (α i) ((fun (i : ι) (a : α i) (b : α i) => _inst_5 i a b) i) x (OfNat.ofNat.{u1} (Finset.{u1} (α i)) 0 (Zero.toOfNat0.{u1} (Finset.{u1} (α i)) (Finset.zero.{u1} (α i) (_inst_1 i)))))) (Dfinsupp.rangeIcc.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) f g)) (Union.union.{u2} (Finset.{u2} ι) (Finset.instUnionFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_4 a b)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_1 i)))) (_inst_5 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_1 i))))) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_1 i)))) (_inst_5 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_1 i))))) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.support_range_Icc_subset Dfinsupp.support_rangeIcc_subsetₓ'. -/
theorem support_rangeIcc_subset [DecidableEq ι] [∀ i, DecidableEq (α i)] :
    (f.rangeIcc g).support ⊆ f.support ∪ g.support :=
  by
  refine' fun x hx => _
  by_contra
  refine' not_mem_support_iff.2 _ hx
  rw [range_Icc_apply, not_mem_support_iff.1 (not_mem_mono (subset_union_left _ _) h),
    not_mem_support_iff.1 (not_mem_mono (subset_union_right _ _) h)]
  exact Icc_self _
#align dfinsupp.support_range_Icc_subset Dfinsupp.support_rangeIcc_subset

end BundledIcc

section Pi

variable [∀ i, Zero (α i)] [DecidableEq ι] [∀ i, DecidableEq (α i)]

#print Dfinsupp.pi /-
/-- Given a finitely supported function `f : Π₀ i, finset (α i)`, one can define the finset
`f.pi` of all finitely supported functions whose value at `i` is in `f i` for all `i`. -/
def pi (f : Π₀ i, Finset (α i)) : Finset (Π₀ i, α i) :=
  f.support.Dfinsupp f
#align dfinsupp.pi Dfinsupp.pi
-/

/- warning: dfinsupp.mem_pi -> Dfinsupp.mem_pi is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : forall (i : ι), DecidableEq.{succ u2} (α i)] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Finset.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Finset.hasMem.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) g (Dfinsupp.pi.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) f)) (forall (i : ι), Membership.Mem.{u2, u2} (α i) (Finset.{u2} (α i)) (Finset.hasMem.{u2} (α i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) g i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i))) => forall (i : ι), Finset.{u2} (α i)) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i))) f i))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u1} (α i)] [_inst_2 : DecidableEq.{succ u2} ι] [_inst_3 : forall (i : ι), DecidableEq.{succ u1} (α i)] {f : Dfinsupp.{u2, u1} ι (fun (i : ι) => Finset.{u1} (α i)) (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i))} {g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)}, Iff (Membership.mem.{max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Finset.{max u1 u2} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) (Finset.instMembershipFinset.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i))) g (Dfinsupp.pi.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) f)) (forall (i : ι), Membership.mem.{u1, u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) ((fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) i) (Finset.instMembershipFinset.{u1} (α i)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) g i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i)) i)) f i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.mem_pi Dfinsupp.mem_piₓ'. -/
@[simp]
theorem mem_pi {f : Π₀ i, Finset (α i)} {g : Π₀ i, α i} : g ∈ f.pi ↔ ∀ i, g i ∈ f i :=
  mem_dfinsupp_iff_of_support_subset <| Subset.refl _
#align dfinsupp.mem_pi Dfinsupp.mem_pi

/- warning: dfinsupp.card_pi -> Dfinsupp.card_pi is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : forall (i : ι), Zero.{u2} (α i)] [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : forall (i : ι), DecidableEq.{succ u2} (α i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i))), Eq.{1} Nat (Finset.card.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.pi.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) f)) (Dfinsupp.prod.{u1, u2, 0} ι Nat (fun (i : ι) => Finset.{u2} (α i)) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i)) (fun (i : ι) (x : Finset.{u2} (α i)) => Ne.decidable.{succ u2} (Finset.{u2} (α i)) (fun (a : Finset.{u2} (α i)) (b : Finset.{u2} (α i)) => Finset.decidableEq.{u2} (α i) (fun (a : α i) (b : α i) => _inst_3 i a b) a b) x (OfNat.ofNat.{u2} (Finset.{u2} (α i)) 0 (OfNat.mk.{u2} (Finset.{u2} (α i)) 0 (Zero.zero.{u2} (Finset.{u2} (α i)) (Finset.zero.{u2} (α i) (_inst_1 i)))))) Nat.commMonoid f (fun (i : ι) => (fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat ((Finset.{u2} (α i)) -> Nat) (HasLiftT.mk.{1, succ u2} Nat ((Finset.{u2} (α i)) -> Nat) (CoeTCₓ.coe.{1, succ u2} Nat ((Finset.{u2} (α i)) -> Nat) (Nat.castCoe.{u2} ((Finset.{u2} (α i)) -> Nat) (Pi.hasNatCast.{u2, 0} (Finset.{u2} (α i)) (fun (ᾰ : Finset.{u2} (α i)) => Nat) (fun (a : Finset.{u2} (α i)) => AddMonoidWithOne.toNatCast.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)))))))) (Finset.card.{u2} (α i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i))) => forall (i : ι), Finset.{u2} (α i)) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => Finset.{u2} (α i)) (fun (i : ι) => Finset.zero.{u2} (α i) (_inst_1 i))) f i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u1} (α i)] [_inst_2 : DecidableEq.{succ u2} ι] [_inst_3 : forall (i : ι), DecidableEq.{succ u1} (α i)] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => Finset.{u1} (α i)) (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i))), Eq.{1} Nat (Finset.card.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.pi.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_1 i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) f)) (Dfinsupp.prod.{u2, u1, 0} ι Nat (fun (i : ι) => Finset.{u1} (α i)) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i)) (fun (i : ι) (x : Finset.{u1} (α i)) => instDecidableNot (Eq.{succ u1} (Finset.{u1} (α i)) x (OfNat.ofNat.{u1} (Finset.{u1} (α i)) 0 (Zero.toOfNat0.{u1} (Finset.{u1} (α i)) (Finset.zero.{u1} (α i) (_inst_1 i))))) (Finset.decidableEq.{u1} (α i) ((fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) i) x (OfNat.ofNat.{u1} (Finset.{u1} (α i)) 0 (Zero.toOfNat0.{u1} (Finset.{u1} (α i)) (Finset.zero.{u1} (α i) (_inst_1 i)))))) Nat.commMonoid f (fun (i : ι) => Nat.cast.{u1} ((Finset.{u1} (α i)) -> Nat) (Pi.natCast.{u1, 0} (Finset.{u1} (α i)) (fun (a._@.Mathlib.Data.Dfinsupp.Basic._hyg.25258 : Finset.{u1} (α i)) => Nat) (fun (a : Finset.{u1} (α i)) => CanonicallyOrderedCommSemiring.toNatCast.{0} Nat Nat.canonicallyOrderedCommSemiring)) (Finset.card.{u1} (α i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_1 i)) i)) f i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.card_pi Dfinsupp.card_piₓ'. -/
@[simp]
theorem card_pi (f : Π₀ i, Finset (α i)) : f.pi.card = f.Prod fun i => (f i).card :=
  by
  rw [pi, card_dfinsupp]
  exact Finset.prod_congr rfl fun i _ => by simp only [Pi.nat_apply, Nat.cast_id]
#align dfinsupp.card_pi Dfinsupp.card_pi

end Pi

section LocallyFinite

variable [DecidableEq ι] [∀ i, DecidableEq (α i)]

variable [∀ i, PartialOrder (α i)] [∀ i, Zero (α i)] [∀ i, LocallyFiniteOrder (α i)]

instance : LocallyFiniteOrder (Π₀ i, α i) :=
  LocallyFiniteOrder.ofIcc (Π₀ i, α i) (fun f g => (f.support ∪ g.support).Dfinsupp <| f.rangeIcc g)
    fun f g x =>
    by
    refine' (mem_dfinsupp_iff_of_support_subset <| support_range_Icc_subset).trans _
    simp_rw [mem_range_Icc_apply_iff, forall_and]
    rfl

variable (f g : Π₀ i, α i)

/- warning: dfinsupp.Icc_eq -> Dfinsupp.Icc_eq is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u2} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u2} (α i)] [_inst_4 : forall (i : ι), Zero.{u2} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{succ (max u1 u2)} (Finset.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i))) (Finset.Icc.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))) (Dfinsupp.locallyFiniteOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g) (Finset.dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (Union.union.{u1} (Finset.{u1} ι) (Finset.hasUnion.{u1} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) g)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} ((fun (i : ι) => α i) i)) (fun (i : ι) => Finset.zero.{u2} ((fun (i : ι) => α i) i) ((fun (i : ι) => _inst_4 i) i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => Finset.{u2} ((fun (i : ι) => α i) i)) (fun (i : ι) => Finset.zero.{u2} ((fun (i : ι) => α i) i) ((fun (i : ι) => _inst_4 i) i))) => forall (i : ι), Finset.{u2} ((fun (i : ι) => α i) i)) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => Finset.{u2} ((fun (i : ι) => α i) i)) (fun (i : ι) => Finset.zero.{u2} ((fun (i : ι) => α i) i) ((fun (i : ι) => _inst_4 i) i))) (Dfinsupp.rangeIcc.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_5 i) f g)))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u1} (α i)] [_inst_4 : forall (i : ι), Zero.{u1} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{max (succ u2) (succ u1)} (Finset.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i))) (Finset.Icc.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))) (Dfinsupp.instLocallyFiniteOrderDfinsuppInstPreorderDfinsuppToPreorder.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g) (Finset.dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (Union.union.{u2} (Finset.{u2} ι) (Finset.instUnionFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_4 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => Finset.{u1} (α i)) i) (fun (i : ι) => (fun (i : ι) => Finset.zero.{u1} (α i) (_inst_4 i)) i)) (Dfinsupp.rangeIcc.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_5 i) f g)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.Icc_eq Dfinsupp.Icc_eqₓ'. -/
theorem Icc_eq : Icc f g = (f.support ∪ g.support).Dfinsupp (f.rangeIcc g) :=
  rfl
#align dfinsupp.Icc_eq Dfinsupp.Icc_eq

/- warning: dfinsupp.card_Icc -> Dfinsupp.card_Icc is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u2} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u2} (α i)] [_inst_4 : forall (i : ι), Zero.{u2} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{1} Nat (Finset.card.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Finset.Icc.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))) (Dfinsupp.locallyFiniteOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g)) (Finset.prod.{0, u1} Nat ι Nat.commMonoid (Union.union.{u1} (Finset.{u1} ι) (Finset.hasUnion.{u1} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) g)) (fun (i : ι) => Finset.card.{u2} (α i) (Finset.Icc.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i)) (_inst_5 i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) g i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u1} (α i)] [_inst_4 : forall (i : ι), Zero.{u1} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{1} Nat (Finset.card.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Finset.Icc.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))) (Dfinsupp.instLocallyFiniteOrderDfinsuppInstPreorderDfinsuppToPreorder.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g)) (Finset.prod.{0, u2} Nat ι Nat.commMonoid (Union.union.{u2} (Finset.{u2} ι) (Finset.instUnionFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) g)) (fun (i : ι) => Finset.card.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Finset.Icc.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)) (_inst_5 i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) g i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.card_Icc Dfinsupp.card_Iccₓ'. -/
theorem card_Icc : (Icc f g).card = ∏ i in f.support ∪ g.support, (Icc (f i) (g i)).card :=
  card_dfinsupp _ _
#align dfinsupp.card_Icc Dfinsupp.card_Icc

/- warning: dfinsupp.card_Ico -> Dfinsupp.card_Ico is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u2} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u2} (α i)] [_inst_4 : forall (i : ι), Zero.{u2} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{1} Nat (Finset.card.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Finset.Ico.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))) (Dfinsupp.locallyFiniteOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Finset.prod.{0, u1} Nat ι Nat.commMonoid (Union.union.{u1} (Finset.{u1} ι) (Finset.hasUnion.{u1} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) g)) (fun (i : ι) => Finset.card.{u2} (α i) (Finset.Icc.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i)) (_inst_5 i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) g i)))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u1} (α i)] [_inst_4 : forall (i : ι), Zero.{u1} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{1} Nat (Finset.card.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Finset.Ico.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))) (Dfinsupp.instLocallyFiniteOrderDfinsuppInstPreorderDfinsuppToPreorder.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Finset.prod.{0, u2} Nat ι Nat.commMonoid (Union.union.{u2} (Finset.{u2} ι) (Finset.instUnionFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) g)) (fun (i : ι) => Finset.card.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Finset.Icc.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)) (_inst_5 i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) g i)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.card_Ico Dfinsupp.card_Icoₓ'. -/
theorem card_Ico : (Ico f g).card = (∏ i in f.support ∪ g.support, (Icc (f i) (g i)).card) - 1 := by
  rw [card_Ico_eq_card_Icc_sub_one, card_Icc]
#align dfinsupp.card_Ico Dfinsupp.card_Ico

/- warning: dfinsupp.card_Ioc -> Dfinsupp.card_Ioc is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u2} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u2} (α i)] [_inst_4 : forall (i : ι), Zero.{u2} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{1} Nat (Finset.card.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Finset.Ioc.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))) (Dfinsupp.locallyFiniteOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Finset.prod.{0, u1} Nat ι Nat.commMonoid (Union.union.{u1} (Finset.{u1} ι) (Finset.hasUnion.{u1} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) g)) (fun (i : ι) => Finset.card.{u2} (α i) (Finset.Icc.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i)) (_inst_5 i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) g i)))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u1} (α i)] [_inst_4 : forall (i : ι), Zero.{u1} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{1} Nat (Finset.card.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Finset.Ioc.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))) (Dfinsupp.instLocallyFiniteOrderDfinsuppInstPreorderDfinsuppToPreorder.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Finset.prod.{0, u2} Nat ι Nat.commMonoid (Union.union.{u2} (Finset.{u2} ι) (Finset.instUnionFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) g)) (fun (i : ι) => Finset.card.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Finset.Icc.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)) (_inst_5 i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) g i)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.card_Ioc Dfinsupp.card_Iocₓ'. -/
theorem card_Ioc : (Ioc f g).card = (∏ i in f.support ∪ g.support, (Icc (f i) (g i)).card) - 1 := by
  rw [card_Ioc_eq_card_Icc_sub_one, card_Icc]
#align dfinsupp.card_Ioc Dfinsupp.card_Ioc

/- warning: dfinsupp.card_Ioo -> Dfinsupp.card_Ioo is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u2} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u2} (α i)] [_inst_4 : forall (i : ι), Zero.{u2} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{1} Nat (Finset.card.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Finset.Ioo.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (_inst_3 i))) (Dfinsupp.locallyFiniteOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Finset.prod.{0, u1} Nat ι Nat.commMonoid (Union.union.{u1} (Finset.{u1} ι) (Finset.hasUnion.{u1} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (_inst_4 i))))) g)) (fun (i : ι) => Finset.card.{u2} (α i) (Finset.Icc.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (_inst_3 i)) (_inst_5 i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) f i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) g i)))) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι), PartialOrder.{u1} (α i)] [_inst_4 : forall (i : ι), Zero.{u1} (α i)] [_inst_5 : forall (i : ι), LocallyFiniteOrder.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (g : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)), Eq.{1} Nat (Finset.card.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Finset.Ioo.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i)) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (_inst_3 i))) (Dfinsupp.instLocallyFiniteOrderDfinsuppInstPreorderDfinsuppToPreorder.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) (fun (i : ι) => _inst_5 i)) f g)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Finset.prod.{0, u2} Nat ι Nat.commMonoid (Union.union.{u2} (Finset.{u2} ι) (Finset.instUnionFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_1 a b)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) f) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (_inst_4 i))))) g)) (fun (i : ι) => Finset.card.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Finset.Icc.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)) (_inst_5 i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) g i)))) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.card_Ioo Dfinsupp.card_Iooₓ'. -/
theorem card_Ioo : (Ioo f g).card = (∏ i in f.support ∪ g.support, (Icc (f i) (g i)).card) - 2 := by
  rw [card_Ioo_eq_card_Icc_sub_two, card_Icc]
#align dfinsupp.card_Ioo Dfinsupp.card_Ioo

end LocallyFinite

section CanonicallyOrdered

variable [DecidableEq ι] [∀ i, DecidableEq (α i)]

variable [∀ i, CanonicallyOrderedAddMonoid (α i)] [∀ i, LocallyFiniteOrder (α i)]

variable (f : Π₀ i, α i)

/- warning: dfinsupp.card_Iic -> Dfinsupp.card_Iic is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u2} (α i)] [_inst_3 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_4 : forall (i : ι), LocallyFiniteOrder.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))), Eq.{1} Nat (Finset.card.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) (Finset.Iic.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))) (Finset.LocallyFiniteOrder.toLocallyFiniteOrderBot.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))) (Dfinsupp.orderBot.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.locallyFiniteOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))) (fun (i : ι) => _inst_4 i))) f)) (Finset.prod.{0, u1} Nat ι Nat.commMonoid (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))))))) f) (fun (i : ι) => Finset.card.{u2} (α i) (Finset.Iic.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))) (Finset.LocallyFiniteOrder.toLocallyFiniteOrderBot.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))) (CanonicallyOrderedAddMonoid.toOrderBot.{u2} (α i) (_inst_3 i)) (_inst_4 i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) f i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_4 : forall (i : ι), LocallyFiniteOrder.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_3 i))))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))), Eq.{1} Nat (Finset.card.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))) (Finset.Iic.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_3 i))))) (Finset.LocallyFiniteOrder.toLocallyFiniteOrderBot.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_3 i))))) (Dfinsupp.instOrderBotDfinsuppToZeroToAddMonoidToAddCommMonoidToOrderedAddCommMonoidInstLEDfinsuppToLEToPreorderToPartialOrder.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.instLocallyFiniteOrderDfinsuppInstPreorderDfinsuppToPreorder.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_3 i))) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) (fun (i : ι) => _inst_4 i))) f)) (Finset.prod.{0, u2} Nat ι Nat.commMonoid (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))))))) f) (fun (i : ι) => Finset.card.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Finset.Iic.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (OrderedAddCommMonoid.toPartialOrder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)))) (Finset.LocallyFiniteOrder.toLocallyFiniteOrderBot.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (OrderedAddCommMonoid.toPartialOrder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)))) (CanonicallyOrderedAddMonoid.toOrderBot.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)) (_inst_4 i)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) i)) f i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.card_Iic Dfinsupp.card_Iicₓ'. -/
theorem card_Iic : (Iic f).card = ∏ i in f.support, (Iic (f i)).card := by
  simp_rw [Iic_eq_Icc, card_Icc, Dfinsupp.bot_eq_zero, support_zero, empty_union, zero_apply,
    bot_eq_zero]
#align dfinsupp.card_Iic Dfinsupp.card_Iic

/- warning: dfinsupp.card_Iio -> Dfinsupp.card_Iio is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u2} (α i)] [_inst_3 : forall (i : ι), CanonicallyOrderedAddMonoid.{u2} (α i)] [_inst_4 : forall (i : ι), LocallyFiniteOrder.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))), Eq.{1} Nat (Finset.card.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) (Finset.Iio.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))) (Finset.LocallyFiniteOrder.toLocallyFiniteOrderBot.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) (Dfinsupp.preorder.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))) (fun (i : ι) => PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))) (Dfinsupp.orderBot.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.locallyFiniteOrder.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))) (fun (i : ι) => _inst_4 i))) f)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Finset.prod.{0, u1} Nat ι Nat.commMonoid (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))) (fun (i : ι) (x : α i) => Ne.decidable.{succ u2} (α i) (fun (a : α i) (b : α i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (α i) 0 (OfNat.mk.{u2} (α i) 0 (Zero.zero.{u2} (α i) (AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))))))))) f) (fun (i : ι) => Finset.card.{u2} (α i) (Finset.Iic.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))) (Finset.LocallyFiniteOrder.toLocallyFiniteOrderBot.{u2} (α i) (PartialOrder.toPreorder.{u2} (α i) (OrderedAddCommMonoid.toPartialOrder.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i)))) (CanonicallyOrderedAddMonoid.toOrderBot.{u2} (α i) (_inst_3 i)) (_inst_4 i)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) => forall (i : ι), α i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => α i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (α i) (AddMonoid.toAddZeroClass.{u2} (α i) (AddCommMonoid.toAddMonoid.{u2} (α i) (OrderedAddCommMonoid.toAddCommMonoid.{u2} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} (α i) (_inst_3 i))))))) f i)))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι), CanonicallyOrderedAddMonoid.{u1} (α i)] [_inst_4 : forall (i : ι), LocallyFiniteOrder.{u1} (α i) (PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_3 i))))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))), Eq.{1} Nat (Finset.card.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))) (Finset.Iio.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_3 i))))) (Finset.LocallyFiniteOrder.toLocallyFiniteOrderBot.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))) (Dfinsupp.instPreorderDfinsupp.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) (fun (i : ι) => PartialOrder.toPreorder.{u1} (α i) (OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_3 i))))) (Dfinsupp.instOrderBotDfinsuppToZeroToAddMonoidToAddCommMonoidToOrderedAddCommMonoidInstLEDfinsuppToLEToPreorderToPartialOrder.{u2, u1} ι (fun (i : ι) => α i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.instLocallyFiniteOrderDfinsuppInstPreorderDfinsuppToPreorder.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) => OrderedAddCommMonoid.toPartialOrder.{u1} (α i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} (α i) (_inst_3 i))) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) (fun (i : ι) => _inst_4 i))) f)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Finset.prod.{0, u2} Nat ι Nat.commMonoid (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) (fun (i : ι) (x : α i) => instDecidableNot (Eq.{succ u1} (α i) x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i)))))))) (_inst_2 i x (OfNat.ofNat.{u1} (α i) 0 (Zero.toOfNat0.{u1} (α i) (AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))))))) f) (fun (i : ι) => Finset.card.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (Finset.Iic.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (OrderedAddCommMonoid.toPartialOrder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)))) (Finset.LocallyFiniteOrder.toLocallyFiniteOrderBot.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (PartialOrder.toPreorder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (OrderedAddCommMonoid.toPartialOrder.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)))) (CanonicallyOrderedAddMonoid.toOrderBot.{u1} ((fun (i : ι) => (fun (i : ι) => α i) i) i) (_inst_3 i)) (_inst_4 i)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => α i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => α i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u1} ((fun (i : ι) => α i) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (i : ι) => α i) i) (OrderedAddCommMonoid.toAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (i : ι) => α i) i) (_inst_3 i))))) i)) f i)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.card_Iio Dfinsupp.card_Iioₓ'. -/
theorem card_Iio : (Iio f).card = (∏ i in f.support, (Iic (f i)).card) - 1 := by
  rw [card_Iio_eq_card_Iic_sub_one, card_Iic]
#align dfinsupp.card_Iio Dfinsupp.card_Iio

end CanonicallyOrdered

end Dfinsupp

