/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Kenny Lau

! This file was ported from Lean 3 source module data.dfinsupp.basic
! leanprover-community/mathlib commit bcfa726826abd57587355b4b5b7e78ad6527b7e4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Module.LinearMap
import Mathbin.Algebra.BigOperators.Basic
import Mathbin.Data.Set.Finite
import Mathbin.GroupTheory.Submonoid.Membership
import Mathbin.GroupTheory.GroupAction.BigOperators
import Mathbin.Data.Finset.Preimage

/-!
# Dependent functions with finite support

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

For a non-dependent version see `data/finsupp.lean`.

## Notation

This file introduces the notation `Π₀ a, β a` as notation for `dfinsupp β`, mirroring the `α →₀ β`
notation used for `finsupp`. This works for nested binders too, with `Π₀ a b, γ a b` as notation
for `dfinsupp (λ a, dfinsupp (γ a))`.

## Implementation notes

The support is internally represented (in the primed `dfinsupp.support'`) as a `multiset` that
represents a superset of the true support of the function, quotiented by the always-true relation so
that this does not impact equality. This approach has computational benefits over storing a
`finset`; it allows us to add together two finitely-supported functions (`dfinsupp.has_add`) without
having to evaluate the resulting function to recompute its support (which would required
decidability of `b = 0` for `b : β i`).

The true support of the function can still be recovered with `dfinsupp.support`; but these
decidability obligations are now postponed to when the support is actually needed. As a consequence,
there are two ways to sum a `dfinsupp`: with `dfinsupp.sum` which works over an arbitrary function
but requires recomputation of the support and therefore a `decidable` argument; and with
`dfinsupp.sum_add_hom` which requires an additive morphism, using its properties to show that
summing over a superset of the support is sufficient.

`finsupp` takes an altogether different approach here; it uses `classical.decidable` and declares
`finsupp.has_add` as noncomputable. This design difference is independent of the fact that
`dfinsupp` is dependently-typed and `finsupp` is not; in future, we may want to align these two
definitions, or introduce two more definitions for the other combinations of decisions.
-/


universe u u₁ u₂ v v₁ v₂ v₃ w x y l

open BigOperators

variable {ι : Type u} {γ : Type w} {β : ι → Type v} {β₁ : ι → Type v₁} {β₂ : ι → Type v₂}

variable (β)

#print Dfinsupp /-
/-- A dependent function `Π i, β i` with finite support, with notation `Π₀ i, β i`.

Note that `dfinsupp.support` is the preferred API for accessing the support of the function,
`dfinsupp.support'` is a implementation detail that aids computability; see the implementation
notes in this file for more information. -/
structure Dfinsupp [∀ i, Zero (β i)] : Type max u v where mk' ::
  toFun : ∀ i, β i
  support' : Trunc { s : Multiset ι // ∀ i, i ∈ s ∨ to_fun i = 0 }
#align dfinsupp Dfinsupp
-/

variable {β}

-- mathport name: «exprΠ₀ , »
notation3"Π₀ "(...)", "r:(scoped f => Dfinsupp f) => r

-- mathport name: «expr →ₚ »
infixl:25 " →ₚ " => Dfinsupp

namespace Dfinsupp

section Basic

variable [∀ i, Zero (β i)] [∀ i, Zero (β₁ i)] [∀ i, Zero (β₂ i)]

#print Dfinsupp.funLike /-
instance funLike : FunLike (Π₀ i, β i) ι β :=
  ⟨fun f => f.toFun, fun ⟨f₁, s₁⟩ ⟨f₂, s₁⟩ (h : f₁ = f₂) =>
    by
    subst h
    congr ⟩
#align dfinsupp.fun_like Dfinsupp.funLike
-/

/-- Helper instance for when there are too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (Π₀ i, β i) fun _ => ∀ i, β i :=
  FunLike.hasCoeToFun

#print Dfinsupp.toFun_eq_coe /-
@[simp]
theorem toFun_eq_coe (f : Π₀ i, β i) : f.toFun = f :=
  rfl
#align dfinsupp.to_fun_eq_coe Dfinsupp.toFun_eq_coe
-/

#print Dfinsupp.ext /-
@[ext]
theorem ext {f g : Π₀ i, β i} (h : ∀ i, f i = g i) : f = g :=
  FunLike.ext _ _ h
#align dfinsupp.ext Dfinsupp.ext
-/

#print Dfinsupp.ext_iff /-
/-- Deprecated. Use `fun_like.ext_iff` instead. -/
theorem ext_iff {f g : Π₀ i, β i} : f = g ↔ ∀ i, f i = g i :=
  FunLike.ext_iff
#align dfinsupp.ext_iff Dfinsupp.ext_iff
-/

#print Dfinsupp.coeFn_injective /-
/-- Deprecated. Use `fun_like.coe_injective` instead. -/
theorem coeFn_injective : @Function.Injective (Π₀ i, β i) (∀ i, β i) coeFn :=
  FunLike.coe_injective
#align dfinsupp.coe_fn_injective Dfinsupp.coeFn_injective
-/

instance : Zero (Π₀ i, β i) :=
  ⟨⟨0, Trunc.mk <| ⟨∅, fun i => Or.inr rfl⟩⟩⟩

instance : Inhabited (Π₀ i, β i) :=
  ⟨0⟩

#print Dfinsupp.coe_mk' /-
@[simp]
theorem coe_mk' (f : ∀ i, β i) (s) : ⇑(⟨f, s⟩ : Π₀ i, β i) = f :=
  rfl
#align dfinsupp.coe_mk' Dfinsupp.coe_mk'
-/

#print Dfinsupp.coe_zero /-
@[simp]
theorem coe_zero : ⇑(0 : Π₀ i, β i) = 0 :=
  rfl
#align dfinsupp.coe_zero Dfinsupp.coe_zero
-/

#print Dfinsupp.zero_apply /-
theorem zero_apply (i : ι) : (0 : Π₀ i, β i) i = 0 :=
  rfl
#align dfinsupp.zero_apply Dfinsupp.zero_apply
-/

#print Dfinsupp.mapRange /-
/-- The composition of `f : β₁ → β₂` and `g : Π₀ i, β₁ i` is
  `map_range f hf g : Π₀ i, β₂ i`, well defined when `f 0 = 0`.

This preserves the structure on `f`, and exists in various bundled forms for when `f` is itself
bundled:

* `dfinsupp.map_range.add_monoid_hom`
* `dfinsupp.map_range.add_equiv`
* `dfinsupp.map_range.linear_map`
* `dfinsupp.map_range.linear_equiv`
-/
def mapRange (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0) (x : Π₀ i, β₁ i) : Π₀ i, β₂ i :=
  ⟨fun i => f i (x i),
    x.support'.map fun s => ⟨s, fun i => (s.2 i).imp_right fun h : x i = 0 => h.symm ▸ hf i⟩⟩
#align dfinsupp.map_range Dfinsupp.mapRange
-/

#print Dfinsupp.mapRange_apply /-
@[simp]
theorem mapRange_apply (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0) (g : Π₀ i, β₁ i) (i : ι) :
    mapRange f hf g i = f i (g i) :=
  rfl
#align dfinsupp.map_range_apply Dfinsupp.mapRange_apply
-/

#print Dfinsupp.mapRange_id /-
@[simp]
theorem mapRange_id (h : ∀ i, id (0 : β₁ i) = 0 := fun i => rfl) (g : Π₀ i : ι, β₁ i) :
    mapRange (fun i => (id : β₁ i → β₁ i)) h g = g :=
  by
  ext
  rfl
#align dfinsupp.map_range_id Dfinsupp.mapRange_id
-/

#print Dfinsupp.mapRange_comp /-
theorem mapRange_comp (f : ∀ i, β₁ i → β₂ i) (f₂ : ∀ i, β i → β₁ i) (hf : ∀ i, f i 0 = 0)
    (hf₂ : ∀ i, f₂ i 0 = 0) (h : ∀ i, (f i ∘ f₂ i) 0 = 0) (g : Π₀ i : ι, β i) :
    mapRange (fun i => f i ∘ f₂ i) h g = mapRange f hf (mapRange f₂ hf₂ g) :=
  by
  ext
  simp only [map_range_apply]
#align dfinsupp.map_range_comp Dfinsupp.mapRange_comp
-/

#print Dfinsupp.mapRange_zero /-
@[simp]
theorem mapRange_zero (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0) :
    mapRange f hf (0 : Π₀ i, β₁ i) = 0 := by
  ext
  simp only [map_range_apply, coe_zero, Pi.zero_apply, hf]
#align dfinsupp.map_range_zero Dfinsupp.mapRange_zero
-/

#print Dfinsupp.zipWith /-
/-- Let `f i` be a binary operation `β₁ i → β₂ i → β i` such that `f i 0 0 = 0`.
Then `zip_with f hf` is a binary operation `Π₀ i, β₁ i → Π₀ i, β₂ i → Π₀ i, β i`. -/
def zipWith (f : ∀ i, β₁ i → β₂ i → β i) (hf : ∀ i, f i 0 0 = 0) (x : Π₀ i, β₁ i) (y : Π₀ i, β₂ i) :
    Π₀ i, β i :=
  ⟨fun i => f i (x i) (y i), by
    refine' x.support'.bind fun xs => _
    refine' y.support'.map fun ys => _
    refine' ⟨xs + ys, fun i => _⟩
    obtain h1 | (h1 : x i = 0) := xs.prop i
    · left
      rw [Multiset.mem_add]
      left
      exact h1
    obtain h2 | (h2 : y i = 0) := ys.prop i
    · left
      rw [Multiset.mem_add]
      right
      exact h2
    right; rw [h1, h2, hf]⟩
#align dfinsupp.zip_with Dfinsupp.zipWith
-/

#print Dfinsupp.zipWith_apply /-
@[simp]
theorem zipWith_apply (f : ∀ i, β₁ i → β₂ i → β i) (hf : ∀ i, f i 0 0 = 0) (g₁ : Π₀ i, β₁ i)
    (g₂ : Π₀ i, β₂ i) (i : ι) : zipWith f hf g₁ g₂ i = f i (g₁ i) (g₂ i) :=
  rfl
#align dfinsupp.zip_with_apply Dfinsupp.zipWith_apply
-/

section Piecewise

variable (x y : Π₀ i, β i) (s : Set ι) [∀ i, Decidable (i ∈ s)]

#print Dfinsupp.piecewise /-
/-- `x.piecewise y s` is the finitely supported function equal to `x` on the set `s`,
  and to `y` on its complement. -/
def piecewise : Π₀ i, β i :=
  zipWith (fun i x y => if i ∈ s then x else y) (fun _ => if_t_t _ 0) x y
#align dfinsupp.piecewise Dfinsupp.piecewise
-/

#print Dfinsupp.piecewise_apply /-
theorem piecewise_apply (i : ι) : x.piecewise y s i = if i ∈ s then x i else y i :=
  zipWith_apply _ _ x y i
#align dfinsupp.piecewise_apply Dfinsupp.piecewise_apply
-/

#print Dfinsupp.coe_piecewise /-
@[simp, norm_cast]
theorem coe_piecewise : ⇑(x.piecewise y s) = s.piecewise x y :=
  by
  ext
  apply piecewise_apply
#align dfinsupp.coe_piecewise Dfinsupp.coe_piecewise
-/

end Piecewise

end Basic

section Algebra

instance [∀ i, AddZeroClass (β i)] : Add (Π₀ i, β i) :=
  ⟨zipWith (fun _ => (· + ·)) fun _ => add_zero 0⟩

/- warning: dfinsupp.add_apply -> Dfinsupp.add_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂) i) (HAdd.hAdd.{u2, u2, u2} (β i) (β i) (β i) (instHAdd.{u2} (β i) (AddZeroClass.toHasAdd.{u2} (β i) (_inst_1 i))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) g₁ i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) g₂ i))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂) i) (HAdd.hAdd.{u2, u2, u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => (fun (i : ι) => β i) i) i) (instHAdd.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddZeroClass.toAdd.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) g₁ i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) g₂ i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.add_apply Dfinsupp.add_applyₓ'. -/
theorem add_apply [∀ i, AddZeroClass (β i)] (g₁ g₂ : Π₀ i, β i) (i : ι) :
    (g₁ + g₂) i = g₁ i + g₂ i :=
  rfl
#align dfinsupp.add_apply Dfinsupp.add_apply

/- warning: dfinsupp.coe_add -> Dfinsupp.coe_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ (max u1 u2)} (forall (i : ι), β i) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (forall (i : ι), β i) (forall (i : ι), β i) (forall (i : ι), β i) (instHAdd.{max u1 u2} (forall (i : ι), β i) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasAdd.{u2} (β i) (_inst_1 i)))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) g₁) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) g₂))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{max (succ u1) (succ u2)} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (instHAdd.{max u1 u2} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (Pi.instAdd.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => AddZeroClass.toAdd.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) g₁) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) g₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_add Dfinsupp.coe_addₓ'. -/
@[simp]
theorem coe_add [∀ i, AddZeroClass (β i)] (g₁ g₂ : Π₀ i, β i) : ⇑(g₁ + g₂) = g₁ + g₂ :=
  rfl
#align dfinsupp.coe_add Dfinsupp.coe_add

instance [∀ i, AddZeroClass (β i)] : AddZeroClass (Π₀ i, β i) :=
  FunLike.coe_injective.AddZeroClass _ coe_zero coe_add

/- warning: dfinsupp.has_nat_scalar -> Dfinsupp.hasNatScalar is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddMonoid.{u2} (β i)], SMul.{0, max u1 u2} Nat (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_1 i))))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddMonoid.{u2} (β i)], SMul.{0, max u2 u1} Nat (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.has_nat_scalar Dfinsupp.hasNatScalarₓ'. -/
/-- Note the general `dfinsupp.has_smul` instance doesn't apply as `ℕ` is not distributive
unless `β i`'s addition is commutative. -/
instance hasNatScalar [∀ i, AddMonoid (β i)] : SMul ℕ (Π₀ i, β i) :=
  ⟨fun c v => v.mapRange (fun _ => (· • ·) c) fun _ => nsmul_zero _⟩
#align dfinsupp.has_nat_scalar Dfinsupp.hasNatScalar

/- warning: dfinsupp.nsmul_apply -> Dfinsupp.nsmul_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddMonoid.{u2} (β i)] (b : Nat) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (SMul.smul.{0, max u1 u2} Nat (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (Dfinsupp.hasNatScalar.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) b v) i) (SMul.smul.{0, u2} Nat (β i) (AddMonoid.SMul.{u2} (β i) (_inst_1 i)) b (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) v i))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddMonoid.{u2} (β i)] (b : Nat) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Nat (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHSMul.{0, max u1 u2} Nat (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasNatScalar.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) b v) i) (HSMul.hSMul.{0, u2, u2} Nat ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => (fun (i : ι) => β i) i) i) (instHSMul.{0, u2} Nat ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddMonoid.SMul.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i))) b (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) v i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.nsmul_apply Dfinsupp.nsmul_applyₓ'. -/
theorem nsmul_apply [∀ i, AddMonoid (β i)] (b : ℕ) (v : Π₀ i, β i) (i : ι) : (b • v) i = b • v i :=
  rfl
#align dfinsupp.nsmul_apply Dfinsupp.nsmul_apply

/- warning: dfinsupp.coe_nsmul -> Dfinsupp.coe_nsmul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddMonoid.{u2} (β i)] (b : Nat) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))), Eq.{succ (max u1 u2)} (forall (i : ι), β i) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (SMul.smul.{0, max u1 u2} Nat (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (Dfinsupp.hasNatScalar.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) b v)) (SMul.smul.{0, max u1 u2} Nat (forall (i : ι), β i) (Pi.instSMul.{u1, u2, 0} ι Nat (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.SMul.{u2} (β i) (_inst_1 i))) b (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) v))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddMonoid.{u2} (β i)] (b : Nat) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{max (succ u1) (succ u2)} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Nat (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHSMul.{0, max u1 u2} Nat (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasNatScalar.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) b v)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Nat (forall (a : ι), (fun (i : ι) => (fun (i : ι) => β i) i) a) (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (instHSMul.{0, max u1 u2} Nat (forall (a : ι), (fun (i : ι) => (fun (i : ι) => β i) i) a) (AddMonoid.SMul.{max u1 u2} (forall (a : ι), (fun (i : ι) => (fun (i : ι) => β i) i) a) (Pi.addMonoid.{u1, u2} ι (fun (a : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) a) (fun (i : ι) => _inst_1 i)))) b (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) v))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_nsmul Dfinsupp.coe_nsmulₓ'. -/
@[simp]
theorem coe_nsmul [∀ i, AddMonoid (β i)] (b : ℕ) (v : Π₀ i, β i) : ⇑(b • v) = b • v :=
  rfl
#align dfinsupp.coe_nsmul Dfinsupp.coe_nsmul

instance [∀ i, AddMonoid (β i)] : AddMonoid (Π₀ i, β i) :=
  FunLike.coe_injective.AddMonoid _ coe_zero coe_add fun _ _ => coe_nsmul _ _

/- warning: dfinsupp.coe_fn_add_monoid_hom -> Dfinsupp.coeFnAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)], AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (forall (i : ι), β i) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Pi.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)], AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (forall (i : ι), β i) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Pi.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_fn_add_monoid_hom Dfinsupp.coeFnAddMonoidHomₓ'. -/
/-- Coercion from a `dfinsupp` to a pi type is an `add_monoid_hom`. -/
def coeFnAddMonoidHom [∀ i, AddZeroClass (β i)] : (Π₀ i, β i) →+ ∀ i, β i
    where
  toFun := coeFn
  map_zero' := coe_zero
  map_add' := coe_add
#align dfinsupp.coe_fn_add_monoid_hom Dfinsupp.coeFnAddMonoidHom

/- warning: dfinsupp.eval_add_monoid_hom -> Dfinsupp.evalAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι), AddMonoidHom.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (β i) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (_inst_1 i)
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι), AddMonoidHom.{max u2 u1, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (β i) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (_inst_1 i)
Case conversion may be inaccurate. Consider using '#align dfinsupp.eval_add_monoid_hom Dfinsupp.evalAddMonoidHomₓ'. -/
/-- Evaluation at a point is an `add_monoid_hom`. This is the finitely-supported version of
`pi.eval_add_monoid_hom`. -/
def evalAddMonoidHom [∀ i, AddZeroClass (β i)] (i : ι) : (Π₀ i, β i) →+ β i :=
  (Pi.evalAddMonoidHom β i).comp coeFnAddMonoidHom
#align dfinsupp.eval_add_monoid_hom Dfinsupp.evalAddMonoidHom

instance [∀ i, AddCommMonoid (β i)] : AddCommMonoid (Π₀ i, β i) :=
  FunLike.coe_injective.AddCommMonoid _ coe_zero coe_add fun _ _ => coe_nsmul _ _

/- warning: dfinsupp.coe_finset_sum -> Dfinsupp.coe_finset_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {α : Type.{u3}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (s : Finset.{u3} α) (g : α -> (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{max (succ u1) (succ u2)} (forall (i : ι), β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (Finset.sum.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) α (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) s (fun (a : α) => g a))) (Finset.sum.{max u1 u2, u3} (forall (i : ι), β i) α (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) s (fun (a : α) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (g a)))
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} {α : Type.{u1}} [_inst_1 : forall (i : ι), AddCommMonoid.{u3} (β i)] (s : Finset.{u1} α) (g : α -> (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))))), Eq.{max (succ u2) (succ u3)} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) i)) (Finset.sum.{max u2 u3, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)))) α (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) s (fun (a : α) => g a))) (Finset.sum.{max u2 u3, u1} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) α (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => _inst_1 i)) s (fun (a : α) => FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) i)) (g a)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_finset_sum Dfinsupp.coe_finset_sumₓ'. -/
@[simp]
theorem coe_finset_sum {α} [∀ i, AddCommMonoid (β i)] (s : Finset α) (g : α → Π₀ i, β i) :
    ⇑(∑ a in s, g a) = ∑ a in s, g a :=
  (coeFnAddMonoidHom : _ →+ ∀ i, β i).map_sum g s
#align dfinsupp.coe_finset_sum Dfinsupp.coe_finset_sum

/- warning: dfinsupp.finset_sum_apply -> Dfinsupp.finset_sum_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {α : Type.{u3}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (s : Finset.{u3} α) (g : α -> (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (Finset.sum.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) α (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) s (fun (a : α) => g a)) i) (Finset.sum.{u2, u3} (β i) α (_inst_1 i) s (fun (a : α) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (g a) i))
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} {α : Type.{u1}} [_inst_1 : forall (i : ι), AddCommMonoid.{u3} (β i)] (s : Finset.{u1} α) (g : α -> (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))))) (i : ι), Eq.{succ u3} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) i)) (Finset.sum.{max u2 u3, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)))) α (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) s (fun (a : α) => g a)) i) (Finset.sum.{u3, u1} ((fun (i : ι) => (fun (i : ι) => β i) i) i) α (_inst_1 i) s (fun (a : α) => FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) i)) (g a) i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.finset_sum_apply Dfinsupp.finset_sum_applyₓ'. -/
@[simp]
theorem finset_sum_apply {α} [∀ i, AddCommMonoid (β i)] (s : Finset α) (g : α → Π₀ i, β i) (i : ι) :
    (∑ a in s, g a) i = ∑ a in s, g a i :=
  (evalAddMonoidHom i : _ →+ β i).map_sum g s
#align dfinsupp.finset_sum_apply Dfinsupp.finset_sum_apply

instance [∀ i, AddGroup (β i)] : Neg (Π₀ i, β i) :=
  ⟨fun f => f.mapRange (fun _ => Neg.neg) fun _ => neg_zero⟩

/- warning: dfinsupp.neg_apply -> Dfinsupp.neg_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) g) i) (Neg.neg.{u2} (β i) (SubNegMonoid.toHasNeg.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) g i))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) g) i) (Neg.neg.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (NegZeroClass.toNeg.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) g i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.neg_apply Dfinsupp.neg_applyₓ'. -/
theorem neg_apply [∀ i, AddGroup (β i)] (g : Π₀ i, β i) (i : ι) : (-g) i = -g i :=
  rfl
#align dfinsupp.neg_apply Dfinsupp.neg_apply

/- warning: dfinsupp.coe_neg -> Dfinsupp.coe_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{succ (max u1 u2)} (forall (i : ι), β i) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) g)) (Neg.neg.{max u1 u2} (forall (i : ι), β i) (Pi.instNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => SubNegMonoid.toHasNeg.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) g))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{max (succ u1) (succ u2)} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) g)) (Neg.neg.{max u1 u2} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (Pi.instNeg.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => NegZeroClass.toNeg.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_neg Dfinsupp.coe_negₓ'. -/
@[simp]
theorem coe_neg [∀ i, AddGroup (β i)] (g : Π₀ i, β i) : ⇑(-g) = -g :=
  rfl
#align dfinsupp.coe_neg Dfinsupp.coe_neg

instance [∀ i, AddGroup (β i)] : Sub (Π₀ i, β i) :=
  ⟨zipWith (fun _ => Sub.sub) fun _ => sub_zero 0⟩

/- warning: dfinsupp.sub_apply -> Dfinsupp.sub_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂) i) (HSub.hSub.{u2, u2, u2} (β i) (β i) (β i) (instHSub.{u2} (β i) (SubNegMonoid.toHasSub.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) g₁ i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) g₂ i))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂) i) (HSub.hSub.{u2, u2, u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => (fun (i : ι) => β i) i) i) (instHSub.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (SubNegMonoid.toSub.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) g₁ i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) g₂ i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sub_apply Dfinsupp.sub_applyₓ'. -/
theorem sub_apply [∀ i, AddGroup (β i)] (g₁ g₂ : Π₀ i, β i) (i : ι) : (g₁ - g₂) i = g₁ i - g₂ i :=
  rfl
#align dfinsupp.sub_apply Dfinsupp.sub_apply

/- warning: dfinsupp.coe_sub -> Dfinsupp.coe_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{succ (max u1 u2)} (forall (i : ι), β i) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (forall (i : ι), β i) (forall (i : ι), β i) (forall (i : ι), β i) (instHSub.{max u1 u2} (forall (i : ι), β i) (Pi.instSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => SubNegMonoid.toHasSub.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) g₁) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) g₂))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{max (succ u1) (succ u2)} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (instHSub.{max u1 u2} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (Pi.instSub.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => SubNegMonoid.toSub.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) g₁) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) g₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_sub Dfinsupp.coe_subₓ'. -/
@[simp]
theorem coe_sub [∀ i, AddGroup (β i)] (g₁ g₂ : Π₀ i, β i) : ⇑(g₁ - g₂) = g₁ - g₂ :=
  rfl
#align dfinsupp.coe_sub Dfinsupp.coe_sub

/- warning: dfinsupp.has_int_scalar -> Dfinsupp.hasIntScalar is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)], SMul.{0, max u1 u2} Int (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))))))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)], SMul.{0, max u2 u1} Int (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.has_int_scalar Dfinsupp.hasIntScalarₓ'. -/
/-- Note the general `dfinsupp.has_smul` instance doesn't apply as `ℤ` is not distributive
unless `β i`'s addition is commutative. -/
instance hasIntScalar [∀ i, AddGroup (β i)] : SMul ℤ (Π₀ i, β i) :=
  ⟨fun c v => v.mapRange (fun _ => (· • ·) c) fun _ => zsmul_zero _⟩
#align dfinsupp.has_int_scalar Dfinsupp.hasIntScalar

/- warning: dfinsupp.zsmul_apply -> Dfinsupp.zsmul_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (b : Int) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (SMul.smul.{0, max u1 u2} Int (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasIntScalar.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) b v) i) (SMul.smul.{0, u2} Int (β i) (SubNegMonoid.SMulInt.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))) b (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) v i))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (b : Int) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Int (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSMul.{0, max u1 u2} Int (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasIntScalar.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) b v) i) (HSMul.hSMul.{0, u2, u2} Int ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => (fun (i : ι) => β i) i) i) (instHSMul.{0, u2} Int ((fun (i : ι) => (fun (i : ι) => β i) i) i) (SubNegMonoid.SMulInt.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i)))) b (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) v i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.zsmul_apply Dfinsupp.zsmul_applyₓ'. -/
theorem zsmul_apply [∀ i, AddGroup (β i)] (b : ℤ) (v : Π₀ i, β i) (i : ι) : (b • v) i = b • v i :=
  rfl
#align dfinsupp.zsmul_apply Dfinsupp.zsmul_apply

/- warning: dfinsupp.coe_zsmul -> Dfinsupp.coe_zsmul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (b : Int) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{succ (max u1 u2)} (forall (i : ι), β i) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (SMul.smul.{0, max u1 u2} Int (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasIntScalar.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) b v)) (SMul.smul.{0, max u1 u2} Int (forall (i : ι), β i) (Pi.instSMul.{u1, u2, 0} ι Int (fun (i : ι) => β i) (fun (i : ι) => SubNegMonoid.SMulInt.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))) b (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) v))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (b : Int) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{max (succ u1) (succ u2)} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Int (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSMul.{0, max u1 u2} Int (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasIntScalar.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) b v)) (HSMul.hSMul.{0, max u1 u2, max u1 u2} Int (forall (a : ι), (fun (i : ι) => (fun (i : ι) => β i) i) a) (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (instHSMul.{0, max u1 u2} Int (forall (a : ι), (fun (i : ι) => (fun (i : ι) => β i) i) a) (SubNegMonoid.SMulInt.{max u1 u2} (forall (a : ι), (fun (i : ι) => (fun (i : ι) => β i) i) a) (Pi.subNegMonoid.{u1, u2} ι (fun (a : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) a) (fun (i : ι) => AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i))))) b (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) i)) v))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_zsmul Dfinsupp.coe_zsmulₓ'. -/
@[simp]
theorem coe_zsmul [∀ i, AddGroup (β i)] (b : ℤ) (v : Π₀ i, β i) : ⇑(b • v) = b • v :=
  rfl
#align dfinsupp.coe_zsmul Dfinsupp.coe_zsmul

instance [∀ i, AddGroup (β i)] : AddGroup (Π₀ i, β i) :=
  FunLike.coe_injective.AddGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => coe_nsmul _ _)
    fun _ _ => coe_zsmul _ _

instance [∀ i, AddCommGroup (β i)] : AddCommGroup (Π₀ i, β i) :=
  FunLike.coe_injective.AddCommGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => coe_nsmul _ _)
    fun _ _ => coe_zsmul _ _

/-- Dependent functions with finite support inherit a semiring action from an action on each
coordinate. -/
instance [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)] : SMul γ (Π₀ i, β i) :=
  ⟨fun c v => v.mapRange (fun _ => (· • ·) c) fun _ => smul_zero _⟩

/- warning: dfinsupp.smul_apply -> Dfinsupp.smul_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (b : γ) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) b v) i) (SMul.smul.{u3, u2} γ (β i) (SMulZeroClass.toHasSmul.{u3, u2} γ (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i))) (DistribSMul.toSmulZeroClass.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i)) (DistribMulAction.toDistribSMul.{u3, u2} γ (β i) _inst_1 (_inst_2 i) (_inst_3 i)))) b (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) v i))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (b : γ) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i)) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) b v) i) (HSMul.hSMul.{u3, u2, u2} γ ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => (fun (i : ι) => β i) i) i) (instHSMul.{u3, u2} γ ((fun (i : ι) => (fun (i : ι) => β i) i) i) (SMulZeroClass.toSMul.{u3, u2} γ ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_2 i)) (DistribSMul.toSMulZeroClass.{u3, u2} γ ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_2 i)) (DistribMulAction.toDistribSMul.{u3, u2} γ ((fun (i : ι) => (fun (i : ι) => β i) i) i) _inst_1 (_inst_2 i) (_inst_3 i))))) b (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i)) v i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.smul_apply Dfinsupp.smul_applyₓ'. -/
theorem smul_apply [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)] (b : γ)
    (v : Π₀ i, β i) (i : ι) : (b • v) i = b • v i :=
  rfl
#align dfinsupp.smul_apply Dfinsupp.smul_apply

/- warning: dfinsupp.coe_smul -> Dfinsupp.coe_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (b : γ) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))), Eq.{succ (max u1 u2)} (forall (i : ι), β i) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) b v)) (SMul.smul.{u3, max u1 u2} γ (forall (i : ι), β i) (Pi.instSMul.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (i : ι) => SMulZeroClass.toHasSmul.{u3, u2} γ (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i))) (DistribSMul.toSmulZeroClass.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i)) (DistribMulAction.toDistribSMul.{u3, u2} γ (β i) _inst_1 (_inst_2 i) (_inst_3 i))))) b (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) v))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (b : γ) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))), Eq.{max (succ u1) (succ u2)} (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i)) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) b v)) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (forall (a : ι), (fun (i : ι) => (fun (i : ι) => β i) i) a) (forall (i : ι), (fun (i : ι) => (fun (i : ι) => β i) i) i) (instHSMul.{u3, max u1 u2} γ (forall (a : ι), (fun (i : ι) => (fun (i : ι) => β i) i) a) (Pi.instSMul.{u1, u2, u3} ι γ (fun (a : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) a) (fun (i : ι) => SMulZeroClass.toSMul.{u3, u2} γ ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_2 i)) (DistribSMul.toSMulZeroClass.{u3, u2} γ ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_2 i)) (DistribMulAction.toDistribSMul.{u3, u2} γ ((fun (i : ι) => (fun (i : ι) => β i) i) i) _inst_1 (_inst_2 i) (_inst_3 i)))))) b (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i)) v))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_smul Dfinsupp.coe_smulₓ'. -/
@[simp]
theorem coe_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)] (b : γ)
    (v : Π₀ i, β i) : ⇑(b • v) = b • v :=
  rfl
#align dfinsupp.coe_smul Dfinsupp.coe_smul

instance {δ : Type _} [Monoid γ] [Monoid δ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]
    [∀ i, DistribMulAction δ (β i)] [∀ i, SMulCommClass γ δ (β i)] : SMulCommClass γ δ (Π₀ i, β i)
    where smul_comm r s m := ext fun i => by simp only [smul_apply, smul_comm r s (m i)]

instance {δ : Type _} [Monoid γ] [Monoid δ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]
    [∀ i, DistribMulAction δ (β i)] [SMul γ δ] [∀ i, IsScalarTower γ δ (β i)] :
    IsScalarTower γ δ (Π₀ i, β i)
    where smul_assoc r s m := ext fun i => by simp only [smul_apply, smul_assoc r s (m i)]

instance [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]
    [∀ i, DistribMulAction γᵐᵒᵖ (β i)] [∀ i, IsCentralScalar γ (β i)] :
    IsCentralScalar γ (Π₀ i, β i)
    where op_smul_eq_smul r m := ext fun i => by simp only [smul_apply, op_smul_eq_smul r (m i)]

/-- Dependent functions with finite support inherit a `distrib_mul_action` structure from such a
structure on each coordinate. -/
instance [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)] :
    DistribMulAction γ (Π₀ i, β i) :=
  Function.Injective.distribMulAction coeFnAddMonoidHom FunLike.coe_injective coe_smul

/-- Dependent functions with finite support inherit a module structure from such a structure on
each coordinate. -/
instance [Semiring γ] [∀ i, AddCommMonoid (β i)] [∀ i, Module γ (β i)] : Module γ (Π₀ i, β i) :=
  {
    Dfinsupp.distribMulAction with
    zero_smul := fun c => ext fun i => by simp only [smul_apply, zero_smul, zero_apply]
    add_smul := fun c x y => ext fun i => by simp only [add_apply, smul_apply, add_smul] }

end Algebra

section FilterAndSubtypeDomain

#print Dfinsupp.filter /-
/-- `filter p f` is the function which is `f i` if `p i` is true and 0 otherwise. -/
def filter [∀ i, Zero (β i)] (p : ι → Prop) [DecidablePred p] (x : Π₀ i, β i) : Π₀ i, β i :=
  ⟨fun i => if p i then x i else 0,
    x.support'.map fun xs =>
      ⟨xs, fun i => (xs.Prop i).imp_right fun H : x i = 0 => by rw [H, if_t_t]⟩⟩
#align dfinsupp.filter Dfinsupp.filter
-/

#print Dfinsupp.filter_apply /-
@[simp]
theorem filter_apply [∀ i, Zero (β i)] (p : ι → Prop) [DecidablePred p] (i : ι) (f : Π₀ i, β i) :
    f.filter p i = if p i then f i else 0 :=
  rfl
#align dfinsupp.filter_apply Dfinsupp.filter_apply
-/

#print Dfinsupp.filter_apply_pos /-
theorem filter_apply_pos [∀ i, Zero (β i)] {p : ι → Prop} [DecidablePred p] (f : Π₀ i, β i) {i : ι}
    (h : p i) : f.filter p i = f i := by simp only [filter_apply, if_pos h]
#align dfinsupp.filter_apply_pos Dfinsupp.filter_apply_pos
-/

#print Dfinsupp.filter_apply_neg /-
theorem filter_apply_neg [∀ i, Zero (β i)] {p : ι → Prop} [DecidablePred p] (f : Π₀ i, β i) {i : ι}
    (h : ¬p i) : f.filter p i = 0 := by simp only [filter_apply, if_neg h]
#align dfinsupp.filter_apply_neg Dfinsupp.filter_apply_neg
-/

/- warning: dfinsupp.filter_pos_add_filter_neg -> Dfinsupp.filter_pos_add_filter_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p], Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) f) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) => Not (p i)) (fun (a : ι) => Not.decidable (p a) (_inst_2 a)) f)) f
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p], Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) f) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) => Not (p i)) (fun (a : ι) => instDecidableNot (p a) (_inst_2 a)) f)) f
Case conversion may be inaccurate. Consider using '#align dfinsupp.filter_pos_add_filter_neg Dfinsupp.filter_pos_add_filter_negₓ'. -/
theorem filter_pos_add_filter_neg [∀ i, AddZeroClass (β i)] (f : Π₀ i, β i) (p : ι → Prop)
    [DecidablePred p] : (f.filter p + f.filter fun i => ¬p i) = f :=
  ext fun i => by
    simp only [add_apply, filter_apply] <;> split_ifs <;> simp only [add_zero, zero_add]
#align dfinsupp.filter_pos_add_filter_neg Dfinsupp.filter_pos_add_filter_neg

#print Dfinsupp.filter_zero /-
@[simp]
theorem filter_zero [∀ i, Zero (β i)] (p : ι → Prop) [DecidablePred p] :
    (0 : Π₀ i, β i).filter p = 0 := by
  ext
  simp
#align dfinsupp.filter_zero Dfinsupp.filter_zero
-/

/- warning: dfinsupp.filter_add -> Dfinsupp.filter_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) f) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) g))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) f) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.filter_add Dfinsupp.filter_addₓ'. -/
@[simp]
theorem filter_add [∀ i, AddZeroClass (β i)] (p : ι → Prop) [DecidablePred p] (f g : Π₀ i, β i) :
    (f + g).filter p = f.filter p + g.filter p :=
  by
  ext
  simp [ite_add_zero]
#align dfinsupp.filter_add Dfinsupp.filter_add

/- warning: dfinsupp.filter_smul -> Dfinsupp.filter_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (p : ι -> Prop) [_inst_4 : DecidablePred.{succ u1} ι p] (r : γ) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) p (fun (a : ι) => _inst_4 a) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) r f)) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) r (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) p (fun (a : ι) => _inst_4 a) f))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (p : ι -> Prop) [_inst_4 : DecidablePred.{succ u1} ι p] (r : γ) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) p (fun (a : ι) => _inst_4 a) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) r f)) (HSMul.hSMul.{u3, max u2 u1, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) r (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) p (fun (a : ι) => _inst_4 a) f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.filter_smul Dfinsupp.filter_smulₓ'. -/
@[simp]
theorem filter_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)] (p : ι → Prop)
    [DecidablePred p] (r : γ) (f : Π₀ i, β i) : (r • f).filter p = r • f.filter p :=
  by
  ext
  simp [smul_ite]
#align dfinsupp.filter_smul Dfinsupp.filter_smul

variable (γ β)

/- warning: dfinsupp.filter_add_monoid_hom -> Dfinsupp.filterAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p], AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))
but is expected to have type
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p], AddMonoidHom.{max u2 u1, max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.filter_add_monoid_hom Dfinsupp.filterAddMonoidHomₓ'. -/
/-- `dfinsupp.filter` as an `add_monoid_hom`. -/
@[simps]
def filterAddMonoidHom [∀ i, AddZeroClass (β i)] (p : ι → Prop) [DecidablePred p] :
    (Π₀ i, β i) →+ Π₀ i, β i where
  toFun := filter p
  map_zero' := filter_zero p
  map_add' := filter_add p
#align dfinsupp.filter_add_monoid_hom Dfinsupp.filterAddMonoidHom

/- warning: dfinsupp.filter_linear_map -> Dfinsupp.filterLinearMap is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (γ : Type.{u3}) (β : ι -> Type.{u2}) [_inst_1 : Semiring.{u3} γ] [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), Module.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (p : ι -> Prop) [_inst_4 : DecidablePred.{succ u1} ι p], LinearMap.{u3, u3, max u1 u2, max u1 u2} γ γ _inst_1 _inst_1 (RingHom.id.{u3} γ (Semiring.toNonAssocSemiring.{u3} γ _inst_1)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_2 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_2 i))))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.module.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.module.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
but is expected to have type
  forall {ι : Type.{u1}} (γ : Type.{u3}) (β : ι -> Type.{u2}) [_inst_1 : Semiring.{u3} γ] [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), Module.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (p : ι -> Prop) [_inst_4 : DecidablePred.{succ u1} ι p], LinearMap.{u3, u3, max u2 u1, max u2 u1} γ γ _inst_1 _inst_1 (RingHom.id.{u3} γ (Semiring.toNonAssocSemiring.{u3} γ _inst_1)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.instModuleDfinsuppToZeroToAddMonoidInstAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.instModuleDfinsuppToZeroToAddMonoidInstAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.filter_linear_map Dfinsupp.filterLinearMapₓ'. -/
/-- `dfinsupp.filter` as a `linear_map`. -/
@[simps]
def filterLinearMap [Semiring γ] [∀ i, AddCommMonoid (β i)] [∀ i, Module γ (β i)] (p : ι → Prop)
    [DecidablePred p] : (Π₀ i, β i) →ₗ[γ] Π₀ i, β i
    where
  toFun := filter p
  map_add' := filter_add p
  map_smul' := filter_smul p
#align dfinsupp.filter_linear_map Dfinsupp.filterLinearMap

variable {γ β}

/- warning: dfinsupp.filter_neg -> Dfinsupp.filter_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) f))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.filter_neg Dfinsupp.filter_negₓ'. -/
@[simp]
theorem filter_neg [∀ i, AddGroup (β i)] (p : ι → Prop) [DecidablePred p] (f : Π₀ i, β i) :
    (-f).filter p = -f.filter p :=
  (filterAddMonoidHom β p).map_neg f
#align dfinsupp.filter_neg Dfinsupp.filter_neg

/- warning: dfinsupp.filter_sub -> Dfinsupp.filter_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) f) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) g))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) f) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.filter_sub Dfinsupp.filter_subₓ'. -/
@[simp]
theorem filter_sub [∀ i, AddGroup (β i)] (p : ι → Prop) [DecidablePred p] (f g : Π₀ i, β i) :
    (f - g).filter p = f.filter p - g.filter p :=
  (filterAddMonoidHom β p).map_sub f g
#align dfinsupp.filter_sub Dfinsupp.filter_sub

#print Dfinsupp.subtypeDomain /-
/-- `subtype_domain p f` is the restriction of the finitely supported function
  `f` to the subtype `p`. -/
def subtypeDomain [∀ i, Zero (β i)] (p : ι → Prop) [DecidablePred p] (x : Π₀ i, β i) :
    Π₀ i : Subtype p, β i :=
  ⟨fun i => x (i : ι),
    x.support'.map fun xs =>
      ⟨(Multiset.filter p xs).attach.map fun j => ⟨j, (Multiset.mem_filter.1 j.2).2⟩, fun i =>
        (xs.Prop i).imp_left fun H =>
          Multiset.mem_map.2
            ⟨⟨i, Multiset.mem_filter.2 ⟨H, i.2⟩⟩, Multiset.mem_attach _ _, Subtype.eta _ _⟩⟩⟩
#align dfinsupp.subtype_domain Dfinsupp.subtypeDomain
-/

#print Dfinsupp.subtypeDomain_zero /-
@[simp]
theorem subtypeDomain_zero [∀ i, Zero (β i)] {p : ι → Prop} [DecidablePred p] :
    subtypeDomain p (0 : Π₀ i, β i) = 0 :=
  rfl
#align dfinsupp.subtype_domain_zero Dfinsupp.subtypeDomain_zero
-/

#print Dfinsupp.subtypeDomain_apply /-
@[simp]
theorem subtypeDomain_apply [∀ i, Zero (β i)] {p : ι → Prop} [DecidablePred p] {i : Subtype p}
    {v : Π₀ i, β i} : (subtypeDomain p v) i = v i :=
  rfl
#align dfinsupp.subtype_domain_apply Dfinsupp.subtypeDomain_apply
-/

/- warning: dfinsupp.subtype_domain_add -> Dfinsupp.subtypeDomain_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {p : ι -> Prop} [_inst_2 : DecidablePred.{succ u1} ι p] (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (v' : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) v v')) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))) (Dfinsupp.hasAdd.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) v) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) v'))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {p : ι -> Prop} [_inst_2 : DecidablePred.{succ u1} ι p] (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (v' : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) v v')) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i)))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) v) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) p (fun (a : ι) => _inst_2 a) v'))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subtype_domain_add Dfinsupp.subtypeDomain_addₓ'. -/
@[simp]
theorem subtypeDomain_add [∀ i, AddZeroClass (β i)] {p : ι → Prop} [DecidablePred p]
    (v v' : Π₀ i, β i) : (v + v').subtypeDomain p = v.subtypeDomain p + v'.subtypeDomain p :=
  coeFn_injective rfl
#align dfinsupp.subtype_domain_add Dfinsupp.subtypeDomain_add

/- warning: dfinsupp.subtype_domain_smul -> Dfinsupp.subtypeDomain_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] {p : ι -> Prop} [_inst_4 : DecidablePred.{succ u1} ι p] (r : γ) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) p (fun (a : ι) => _inst_4 a) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) r f)) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))))) (Dfinsupp.hasSmul.{u1, u2, u3} (Subtype.{succ u1} ι p) γ (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) _inst_1 (fun (i : Subtype.{succ u1} ι p) => _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))) r (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) p (fun (a : ι) => _inst_4 a) f))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] {p : ι -> Prop} [_inst_4 : DecidablePred.{succ u1} ι p] (r : γ) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_2 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) p (fun (a : ι) => _inst_4 a) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) r f)) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_2 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_2 (Subtype.val.{succ u1} ι p i)))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_2 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} (Subtype.{succ u1} ι p) γ (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) _inst_1 (fun (i : Subtype.{succ u1} ι p) => _inst_2 (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_3 (Subtype.val.{succ u1} ι p i)))) r (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) p (fun (a : ι) => _inst_4 a) f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subtype_domain_smul Dfinsupp.subtypeDomain_smulₓ'. -/
@[simp]
theorem subtypeDomain_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]
    {p : ι → Prop} [DecidablePred p] (r : γ) (f : Π₀ i, β i) :
    (r • f).subtypeDomain p = r • f.subtypeDomain p :=
  coeFn_injective rfl
#align dfinsupp.subtype_domain_smul Dfinsupp.subtypeDomain_smul

variable (γ β)

/- warning: dfinsupp.subtype_domain_add_monoid_hom -> Dfinsupp.subtypeDomainAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p], AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.addZeroClass.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))
but is expected to have type
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (p : ι -> Prop) [_inst_2 : DecidablePred.{succ u1} ι p], AddMonoidHom.{max u2 u1, max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toZero.{u2} ((fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) i) (_inst_1 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 (Subtype.val.{succ u1} ι p i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subtype_domain_add_monoid_hom Dfinsupp.subtypeDomainAddMonoidHomₓ'. -/
/-- `subtype_domain` but as an `add_monoid_hom`. -/
@[simps]
def subtypeDomainAddMonoidHom [∀ i, AddZeroClass (β i)] (p : ι → Prop) [DecidablePred p] :
    (Π₀ i : ι, β i) →+ Π₀ i : Subtype p, β i
    where
  toFun := subtypeDomain p
  map_zero' := subtypeDomain_zero
  map_add' := subtypeDomain_add
#align dfinsupp.subtype_domain_add_monoid_hom Dfinsupp.subtypeDomainAddMonoidHom

/- warning: dfinsupp.subtype_domain_linear_map -> Dfinsupp.subtypeDomainLinearMap is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (γ : Type.{u3}) (β : ι -> Type.{u2}) [_inst_1 : Semiring.{u3} γ] [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), Module.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (p : ι -> Prop) [_inst_4 : DecidablePred.{succ u1} ι p], LinearMap.{u3, u3, max u1 u2, max u1 u2} γ γ _inst_1 _inst_1 (RingHom.id.{u3} γ (Semiring.toNonAssocSemiring.{u3} γ _inst_1)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_2 i))))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddCommMonoid.toAddMonoid.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.addCommMonoid.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))) (Dfinsupp.module.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.module.{u1, u2, u3} (Subtype.{succ u1} ι p) γ (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) _inst_1 (fun (i : Subtype.{succ u1} ι p) => _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))
but is expected to have type
  forall {ι : Type.{u1}} (γ : Type.{u3}) (β : ι -> Type.{u2}) [_inst_1 : Semiring.{u3} γ] [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), Module.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (p : ι -> Prop) [_inst_4 : DecidablePred.{succ u1} ι p], LinearMap.{u3, u3, max u2 u1, max u2 u1} γ γ _inst_1 _inst_1 (RingHom.id.{u3} γ (Semiring.toNonAssocSemiring.{u3} γ _inst_1)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddMonoid.toZero.{u2} ((fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) i) (_inst_2 (Subtype.val.{succ u1} ι p i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_2 (Subtype.val.{succ u1} ι p i))) (Dfinsupp.instModuleDfinsuppToZeroToAddMonoidInstAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.instModuleDfinsuppToZeroToAddMonoidInstAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2, u3} (Subtype.{succ u1} ι p) γ (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) _inst_1 (fun (i : Subtype.{succ u1} ι p) => _inst_2 (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_3 (Subtype.val.{succ u1} ι p i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subtype_domain_linear_map Dfinsupp.subtypeDomainLinearMapₓ'. -/
/-- `dfinsupp.subtype_domain` as a `linear_map`. -/
@[simps]
def subtypeDomainLinearMap [Semiring γ] [∀ i, AddCommMonoid (β i)] [∀ i, Module γ (β i)]
    (p : ι → Prop) [DecidablePred p] : (Π₀ i, β i) →ₗ[γ] Π₀ i : Subtype p, β i
    where
  toFun := subtypeDomain p
  map_add' := subtypeDomain_add
  map_smul' := subtypeDomain_smul
#align dfinsupp.subtype_domain_linear_map Dfinsupp.subtypeDomainLinearMap

variable {γ β}

/- warning: dfinsupp.subtype_domain_neg -> Dfinsupp.subtypeDomain_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] {p : ι -> Prop} [_inst_2 : DecidablePred.{succ u1} ι p] {v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))}, Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))))))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) v)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))))))) (Dfinsupp.hasNeg.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) v))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] {p : ι -> Prop} [_inst_2 : DecidablePred.{succ u1} ι p] {v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))}, Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i))))))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) v)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i))))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 (Subtype.val.{succ u1} ι p i))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) v))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subtype_domain_neg Dfinsupp.subtypeDomain_negₓ'. -/
@[simp]
theorem subtypeDomain_neg [∀ i, AddGroup (β i)] {p : ι → Prop} [DecidablePred p] {v : Π₀ i, β i} :
    (-v).subtypeDomain p = -v.subtypeDomain p :=
  coeFn_injective rfl
#align dfinsupp.subtype_domain_neg Dfinsupp.subtypeDomain_neg

/- warning: dfinsupp.subtype_domain_sub -> Dfinsupp.subtypeDomain_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] {p : ι -> Prop} [_inst_2 : DecidablePred.{succ u1} ι p] {v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {v' : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))}, Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))))))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) v v')) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))))))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))))))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))))))) (Dfinsupp.hasSub.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) v) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) v'))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] {p : ι -> Prop} [_inst_2 : DecidablePred.{succ u1} ι p] {v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {v' : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))}, Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i))))))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) v v')) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i))))))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i))))))) (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i))))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i))))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 (Subtype.val.{succ u1} ι p i)))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) v) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) p (fun (a : ι) => _inst_2 a) v'))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subtype_domain_sub Dfinsupp.subtypeDomain_subₓ'. -/
@[simp]
theorem subtypeDomain_sub [∀ i, AddGroup (β i)] {p : ι → Prop} [DecidablePred p]
    {v v' : Π₀ i, β i} : (v - v').subtypeDomain p = v.subtypeDomain p - v'.subtypeDomain p :=
  coeFn_injective rfl
#align dfinsupp.subtype_domain_sub Dfinsupp.subtypeDomain_sub

end FilterAndSubtypeDomain

variable [dec : DecidableEq ι]

include dec

section Basic

variable [∀ i, Zero (β i)]

omit dec

#print Dfinsupp.finite_support /-
theorem finite_support (f : Π₀ i, β i) : Set.Finite { i | f i ≠ 0 } := by
  classical exact
      Trunc.induction_on f.support' fun xs =>
        (Multiset.toFinset ↑xs).finite_to_set.Subset fun i H =>
          Multiset.mem_toFinset.2 ((xs.Prop i).resolve_right H)
#align dfinsupp.finite_support Dfinsupp.finite_support
-/

include dec

#print Dfinsupp.mk /-
/-- Create an element of `Π₀ i, β i` from a finset `s` and a function `x`
defined on this `finset`. -/
def mk (s : Finset ι) (x : ∀ i : (↑s : Set ι), β (i : ι)) : Π₀ i, β i :=
  ⟨fun i => if H : i ∈ s then x ⟨i, H⟩ else 0,
    Trunc.mk ⟨s.1, fun i => if H : i ∈ s then Or.inl H else Or.inr <| dif_neg H⟩⟩
#align dfinsupp.mk Dfinsupp.mk
-/

variable {s : Finset ι} {x : ∀ i : (↑s : Set ι), β i} {i : ι}

#print Dfinsupp.mk_apply /-
@[simp]
theorem mk_apply : (mk s x : ∀ i, β i) i = if H : i ∈ s then x ⟨i, H⟩ else 0 :=
  rfl
#align dfinsupp.mk_apply Dfinsupp.mk_apply
-/

#print Dfinsupp.mk_of_mem /-
theorem mk_of_mem (hi : i ∈ s) : (mk s x : ∀ i, β i) i = x ⟨i, hi⟩ :=
  dif_pos hi
#align dfinsupp.mk_of_mem Dfinsupp.mk_of_mem
-/

#print Dfinsupp.mk_of_not_mem /-
theorem mk_of_not_mem (hi : i ∉ s) : (mk s x : ∀ i, β i) i = 0 :=
  dif_neg hi
#align dfinsupp.mk_of_not_mem Dfinsupp.mk_of_not_mem
-/

#print Dfinsupp.mk_injective /-
theorem mk_injective (s : Finset ι) : Function.Injective (@mk ι β _ _ s) :=
  by
  intro x y H
  ext i
  have h1 : (mk s x : ∀ i, β i) i = (mk s y : ∀ i, β i) i := by rw [H]
  cases' i with i hi
  change i ∈ s at hi
  dsimp only [mk_apply, Subtype.coe_mk] at h1
  simpa only [dif_pos hi] using h1
#align dfinsupp.mk_injective Dfinsupp.mk_injective
-/

omit dec

#print Dfinsupp.unique /-
instance unique [∀ i, Subsingleton (β i)] : Unique (Π₀ i, β i) :=
  FunLike.coe_injective.unique
#align dfinsupp.unique Dfinsupp.unique
-/

#print Dfinsupp.uniqueOfIsEmpty /-
instance uniqueOfIsEmpty [IsEmpty ι] : Unique (Π₀ i, β i) :=
  FunLike.coe_injective.unique
#align dfinsupp.unique_of_is_empty Dfinsupp.uniqueOfIsEmpty
-/

#print Dfinsupp.equivFunOnFintype /-
/-- Given `fintype ι`, `equiv_fun_on_fintype` is the `equiv` between `Π₀ i, β i` and `Π i, β i`.
  (All dependent functions on a finite type are finitely supported.) -/
@[simps apply]
def equivFunOnFintype [Fintype ι] : (Π₀ i, β i) ≃ ∀ i, β i
    where
  toFun := coeFn
  invFun f := ⟨f, Trunc.mk ⟨Finset.univ.1, fun i => Or.inl <| Finset.mem_univ_val _⟩⟩
  left_inv x := coeFn_injective rfl
  right_inv x := rfl
#align dfinsupp.equiv_fun_on_fintype Dfinsupp.equivFunOnFintype
-/

#print Dfinsupp.equivFunOnFintype_symm_coe /-
@[simp]
theorem equivFunOnFintype_symm_coe [Fintype ι] (f : Π₀ i, β i) : equivFunOnFintype.symm f = f :=
  Equiv.symm_apply_apply _ _
#align dfinsupp.equiv_fun_on_fintype_symm_coe Dfinsupp.equivFunOnFintype_symm_coe
-/

include dec

#print Dfinsupp.single /-
/-- The function `single i b : Π₀ i, β i` sends `i` to `b`
and all other points to `0`. -/
def single (i : ι) (b : β i) : Π₀ i, β i :=
  ⟨Pi.single i b,
    Trunc.mk ⟨{i}, fun j => (Decidable.eq_or_ne j i).imp (by simp) fun h => Pi.single_eq_of_ne h _⟩⟩
#align dfinsupp.single Dfinsupp.single
-/

#print Dfinsupp.single_eq_pi_single /-
theorem single_eq_pi_single {i b} : ⇑(single i b : Π₀ i, β i) = Pi.single i b :=
  rfl
#align dfinsupp.single_eq_pi_single Dfinsupp.single_eq_pi_single
-/

#print Dfinsupp.single_apply /-
@[simp]
theorem single_apply {i i' b} :
    (single i b : Π₀ i, β i) i' = if h : i = i' then Eq.recOn h b else 0 :=
  by
  rw [single_eq_pi_single, Pi.single, Function.update]
  simp [@eq_comm _ i i']
#align dfinsupp.single_apply Dfinsupp.single_apply
-/

#print Dfinsupp.single_zero /-
@[simp]
theorem single_zero (i) : (single i 0 : Π₀ i, β i) = 0 :=
  FunLike.coe_injective <| Pi.single_zero _
#align dfinsupp.single_zero Dfinsupp.single_zero
-/

#print Dfinsupp.single_eq_same /-
@[simp]
theorem single_eq_same {i b} : (single i b : Π₀ i, β i) i = b := by
  simp only [single_apply, dif_pos rfl]
#align dfinsupp.single_eq_same Dfinsupp.single_eq_same
-/

#print Dfinsupp.single_eq_of_ne /-
theorem single_eq_of_ne {i i' b} (h : i ≠ i') : (single i b : Π₀ i, β i) i' = 0 := by
  simp only [single_apply, dif_neg h]
#align dfinsupp.single_eq_of_ne Dfinsupp.single_eq_of_ne
-/

#print Dfinsupp.single_injective /-
theorem single_injective {i} : Function.Injective (single i : β i → Π₀ i, β i) := fun x y H =>
  Pi.single_injective β i <| coeFn_injective.eq_iff.mpr H
#align dfinsupp.single_injective Dfinsupp.single_injective
-/

#print Dfinsupp.single_eq_single_iff /-
/-- Like `finsupp.single_eq_single_iff`, but with a `heq` due to dependent types -/
theorem single_eq_single_iff (i j : ι) (xi : β i) (xj : β j) :
    Dfinsupp.single i xi = Dfinsupp.single j xj ↔ i = j ∧ HEq xi xj ∨ xi = 0 ∧ xj = 0 :=
  by
  constructor
  · intro h
    by_cases hij : i = j
    · subst hij
      exact Or.inl ⟨rfl, hEq_of_eq (Dfinsupp.single_injective h)⟩
    · have h_coe : ⇑(Dfinsupp.single i xi) = Dfinsupp.single j xj := congr_arg coeFn h
      have hci := congr_fun h_coe i
      have hcj := congr_fun h_coe j
      rw [Dfinsupp.single_eq_same] at hci hcj
      rw [Dfinsupp.single_eq_of_ne (Ne.symm hij)] at hci
      rw [Dfinsupp.single_eq_of_ne hij] at hcj
      exact Or.inr ⟨hci, hcj.symm⟩
  · rintro (⟨rfl, hxi⟩ | ⟨hi, hj⟩)
    · rw [eq_of_hEq hxi]
    · rw [hi, hj, Dfinsupp.single_zero, Dfinsupp.single_zero]
#align dfinsupp.single_eq_single_iff Dfinsupp.single_eq_single_iff
-/

#print Dfinsupp.single_left_injective /-
/-- `dfinsupp.single a b` is injective in `a`. For the statement that it is injective in `b`, see
`dfinsupp.single_injective` -/
theorem single_left_injective {b : ∀ i : ι, β i} (h : ∀ i, b i ≠ 0) :
    Function.Injective (fun i => single i (b i) : ι → Π₀ i, β i) := fun a a' H =>
  (((single_eq_single_iff _ _ _ _).mp H).resolve_right fun hb => h _ hb.1).left
#align dfinsupp.single_left_injective Dfinsupp.single_left_injective
-/

#print Dfinsupp.single_eq_zero /-
@[simp]
theorem single_eq_zero {i : ι} {xi : β i} : single i xi = 0 ↔ xi = 0 :=
  by
  rw [← single_zero i, single_eq_single_iff]
  simp
#align dfinsupp.single_eq_zero Dfinsupp.single_eq_zero
-/

#print Dfinsupp.filter_single /-
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 :=
  by
  ext j
  have := apply_ite (fun x : Π₀ i, β i => x j) (p i) (single i x) 0
  dsimp at this
  rw [filter_apply, this]
  obtain rfl | hij := Decidable.eq_or_ne i j
  · rfl
  · rw [single_eq_of_ne hij, if_t_t, if_t_t]
#align dfinsupp.filter_single Dfinsupp.filter_single
-/

#print Dfinsupp.filter_single_pos /-
@[simp]
theorem filter_single_pos {p : ι → Prop} [DecidablePred p] (i : ι) (x : β i) (h : p i) :
    (single i x).filter p = single i x := by rw [filter_single, if_pos h]
#align dfinsupp.filter_single_pos Dfinsupp.filter_single_pos
-/

#print Dfinsupp.filter_single_neg /-
@[simp]
theorem filter_single_neg {p : ι → Prop} [DecidablePred p] (i : ι) (x : β i) (h : ¬p i) :
    (single i x).filter p = 0 := by rw [filter_single, if_neg h]
#align dfinsupp.filter_single_neg Dfinsupp.filter_single_neg
-/

#print Dfinsupp.single_eq_of_sigma_eq /-
/-- Equality of sigma types is sufficient (but not necessary) to show equality of `dfinsupp`s. -/
theorem single_eq_of_sigma_eq {i j} {xi : β i} {xj : β j} (h : (⟨i, xi⟩ : Sigma β) = ⟨j, xj⟩) :
    Dfinsupp.single i xi = Dfinsupp.single j xj :=
  by
  cases h
  rfl
#align dfinsupp.single_eq_of_sigma_eq Dfinsupp.single_eq_of_sigma_eq
-/

#print Dfinsupp.equivFunOnFintype_single /-
@[simp]
theorem equivFunOnFintype_single [Fintype ι] (i : ι) (m : β i) :
    (@Dfinsupp.equivFunOnFintype ι β _ _) (Dfinsupp.single i m) = Pi.single i m :=
  by
  ext
  simp [Dfinsupp.single_eq_pi_single]
#align dfinsupp.equiv_fun_on_fintype_single Dfinsupp.equivFunOnFintype_single
-/

#print Dfinsupp.equivFunOnFintype_symm_single /-
@[simp]
theorem equivFunOnFintype_symm_single [Fintype ι] (i : ι) (m : β i) :
    (@Dfinsupp.equivFunOnFintype ι β _ _).symm (Pi.single i m) = Dfinsupp.single i m :=
  by
  ext i'
  simp only [← single_eq_pi_single, equiv_fun_on_fintype_symm_coe]
#align dfinsupp.equiv_fun_on_fintype_symm_single Dfinsupp.equivFunOnFintype_symm_single
-/

#print Dfinsupp.erase /-
/-- Redefine `f i` to be `0`. -/
def erase (i : ι) (x : Π₀ i, β i) : Π₀ i, β i :=
  ⟨fun j => if j = i then 0 else x.1 j,
    x.support'.map fun xs => ⟨xs, fun j => (xs.Prop j).imp_right fun H => by simp only [H, if_t_t]⟩⟩
#align dfinsupp.erase Dfinsupp.erase
-/

#print Dfinsupp.erase_apply /-
@[simp]
theorem erase_apply {i j : ι} {f : Π₀ i, β i} : (f.erase i) j = if j = i then 0 else f j :=
  rfl
#align dfinsupp.erase_apply Dfinsupp.erase_apply
-/

#print Dfinsupp.erase_same /-
@[simp]
theorem erase_same {i : ι} {f : Π₀ i, β i} : (f.erase i) i = 0 := by simp
#align dfinsupp.erase_same Dfinsupp.erase_same
-/

#print Dfinsupp.erase_ne /-
theorem erase_ne {i i' : ι} {f : Π₀ i, β i} (h : i' ≠ i) : (f.erase i) i' = f i' := by simp [h]
#align dfinsupp.erase_ne Dfinsupp.erase_ne
-/

/- warning: dfinsupp.piecewise_single_erase -> Dfinsupp.piecewise_single_erase is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] (x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (i : ι), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.piecewise.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) i (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) x i)) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) i x) (Singleton.singleton.{u1, u1} ι (Set.{u1} ι) (Set.hasSingleton.{u1} ι) i) (fun (i_1 : ι) => Set.decidableSetOf.{u1} ι i_1 (fun (b : ι) => Eq.{succ u1} ι b i) (dec i_1 i))) x
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] (x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (i : ι) [inst._@.Mathlib.Data.Dfinsupp.Basic._hyg.10896 : forall (i' : ι), Decidable (Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) i' (Singleton.singleton.{u1, u1} ι (Set.{u1} ι) (Set.instSingletonSet.{u1} ι) i))], Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.piecewise.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) i (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (a : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) a) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) x i)) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) i x) (Singleton.singleton.{u1, u1} ι (Set.{u1} ι) (Set.instSingletonSet.{u1} ι) i) (fun (i : ι) => inst._@.Mathlib.Data.Dfinsupp.Basic._hyg.10896 i)) x
Case conversion may be inaccurate. Consider using '#align dfinsupp.piecewise_single_erase Dfinsupp.piecewise_single_eraseₓ'. -/
theorem piecewise_single_erase (x : Π₀ i, β i) (i : ι) :
    (single i (x i)).piecewise (x.erase i) {i} = x :=
  by
  ext j; rw [piecewise_apply]; split_ifs
  · rw [(id h : j = i), single_eq_same]
  · exact erase_ne h
#align dfinsupp.piecewise_single_erase Dfinsupp.piecewise_single_erase

/- warning: dfinsupp.erase_eq_sub_single -> Dfinsupp.erase_eq_sub_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (i : ι), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i f) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) f (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) f i)))
but is expected to have type
  forall {ι : Type.{u2}} [dec : DecidableEq.{succ u2} ι] {β : ι -> Type.{u1}} [_inst_2 : forall (i : ι), AddGroup.{u1} (β i)] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (i : ι), Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.erase.{u2, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))))) i f) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} (β i) (SubNegZeroMonoid.toNegZeroClass.{u1} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (β i) (AddGroup.toSubtractionMonoid.{u1} (β i) (_inst_2 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) f (Dfinsupp.single.{u2, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u1} (β i) (SubNegZeroMonoid.toNegZeroClass.{u1} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (β i) (AddGroup.toSubtractionMonoid.{u1} (β i) (_inst_2 i))))) i (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))))) i)) f i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.erase_eq_sub_single Dfinsupp.erase_eq_sub_singleₓ'. -/
theorem erase_eq_sub_single {β : ι → Type _} [∀ i, AddGroup (β i)] (f : Π₀ i, β i) (i : ι) :
    f.erase i = f - single i (f i) := by
  ext j
  rcases eq_or_ne i j with (rfl | h)
  · simp
  · simp [erase_ne h.symm, single_eq_of_ne h]
#align dfinsupp.erase_eq_sub_single Dfinsupp.erase_eq_sub_single

#print Dfinsupp.erase_zero /-
@[simp]
theorem erase_zero (i : ι) : erase i (0 : Π₀ i, β i) = 0 :=
  ext fun _ => if_t_t _ _
#align dfinsupp.erase_zero Dfinsupp.erase_zero
-/

#print Dfinsupp.filter_ne_eq_erase /-
@[simp]
theorem filter_ne_eq_erase (f : Π₀ i, β i) (i : ι) : f.filter (· ≠ i) = f.erase i :=
  by
  ext1 j
  simp only [Dfinsupp.filter_apply, Dfinsupp.erase_apply, ite_not]
#align dfinsupp.filter_ne_eq_erase Dfinsupp.filter_ne_eq_erase
-/

#print Dfinsupp.filter_ne_eq_erase' /-
@[simp]
theorem filter_ne_eq_erase' (f : Π₀ i, β i) (i : ι) : f.filter ((· ≠ ·) i) = f.erase i :=
  by
  rw [← filter_ne_eq_erase f i]
  congr with j
  exact ne_comm
#align dfinsupp.filter_ne_eq_erase' Dfinsupp.filter_ne_eq_erase'
-/

#print Dfinsupp.erase_single /-
theorem erase_single (j : ι) (i : ι) (x : β i) :
    (single i x).erase j = if i = j then 0 else single i x := by
  rw [← filter_ne_eq_erase, filter_single, ite_not]
#align dfinsupp.erase_single Dfinsupp.erase_single
-/

#print Dfinsupp.erase_single_same /-
@[simp]
theorem erase_single_same (i : ι) (x : β i) : (single i x).erase i = 0 := by
  rw [erase_single, if_pos rfl]
#align dfinsupp.erase_single_same Dfinsupp.erase_single_same
-/

#print Dfinsupp.erase_single_ne /-
@[simp]
theorem erase_single_ne {i j : ι} (x : β i) (h : i ≠ j) : (single i x).erase j = single i x := by
  rw [erase_single, if_neg h]
#align dfinsupp.erase_single_ne Dfinsupp.erase_single_ne
-/

section Update

variable (f : Π₀ i, β i) (i) (b : β i)

#print Dfinsupp.update /-
/-- Replace the value of a `Π₀ i, β i` at a given point `i : ι` by a given value `b : β i`.
If `b = 0`, this amounts to removing `i` from the support.
Otherwise, `i` is added to it.

This is the (dependent) finitely-supported version of `function.update`. -/
def update : Π₀ i, β i :=
  ⟨Function.update f i b,
    f.support'.map fun s =>
      ⟨i ::ₘ s, fun j => by
        rcases eq_or_ne i j with (rfl | hi)
        · simp
        · obtain hj | (hj : f j = 0) := s.prop j
          · exact Or.inl (Multiset.mem_cons_of_mem hj)
          · exact Or.inr ((Function.update_noteq hi.symm b _).trans hj)⟩⟩
#align dfinsupp.update Dfinsupp.update
-/

variable (j : ι)

#print Dfinsupp.coe_update /-
@[simp]
theorem coe_update : (f.update i b : ∀ i : ι, β i) = Function.update f i b :=
  rfl
#align dfinsupp.coe_update Dfinsupp.coe_update
-/

#print Dfinsupp.update_self /-
@[simp]
theorem update_self : f.update i (f i) = f := by
  ext
  simp
#align dfinsupp.update_self Dfinsupp.update_self
-/

#print Dfinsupp.update_eq_erase /-
@[simp]
theorem update_eq_erase : f.update i 0 = f.erase i :=
  by
  ext j
  rcases eq_or_ne i j with (rfl | hi)
  · simp
  · simp [hi.symm]
#align dfinsupp.update_eq_erase Dfinsupp.update_eq_erase
-/

/- warning: dfinsupp.update_eq_single_add_erase -> Dfinsupp.update_eq_single_add_erase is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (i : ι) (b : β i), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.update.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i f b) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i b) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i f))
but is expected to have type
  forall {ι : Type.{u2}} [dec : DecidableEq.{succ u2} ι] {β : ι -> Type.{u1}} [_inst_2 : forall (i : ι), AddZeroClass.{u1} (β i)] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))) (i : ι) (b : β i), Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.update.{u2, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)) i f b) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} (β i) (_inst_2 i))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} (β i) (_inst_2 i))) (instHAdd.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} (β i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.single.{u2, u1} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u1} (β i) (_inst_2 i)) i b) (Dfinsupp.erase.{u2, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)) i f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.update_eq_single_add_erase Dfinsupp.update_eq_single_add_eraseₓ'. -/
theorem update_eq_single_add_erase {β : ι → Type _} [∀ i, AddZeroClass (β i)] (f : Π₀ i, β i)
    (i : ι) (b : β i) : f.update i b = single i b + f.erase i :=
  by
  ext j
  rcases eq_or_ne i j with (rfl | h)
  · simp
  · simp [Function.update_noteq h.symm, h, erase_ne, h.symm]
#align dfinsupp.update_eq_single_add_erase Dfinsupp.update_eq_single_add_erase

/- warning: dfinsupp.update_eq_erase_add_single -> Dfinsupp.update_eq_erase_add_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (i : ι) (b : β i), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.update.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i f b) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i f) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)) i b))
but is expected to have type
  forall {ι : Type.{u2}} [dec : DecidableEq.{succ u2} ι] {β : ι -> Type.{u1}} [_inst_2 : forall (i : ι), AddZeroClass.{u1} (β i)] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))) (i : ι) (b : β i), Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.update.{u2, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)) i f b) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} (β i) (_inst_2 i))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHAdd.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.erase.{u2, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)) i f) (Dfinsupp.single.{u2, u1} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u1} (β i) (_inst_2 i)) i b))
Case conversion may be inaccurate. Consider using '#align dfinsupp.update_eq_erase_add_single Dfinsupp.update_eq_erase_add_singleₓ'. -/
theorem update_eq_erase_add_single {β : ι → Type _} [∀ i, AddZeroClass (β i)] (f : Π₀ i, β i)
    (i : ι) (b : β i) : f.update i b = f.erase i + single i b :=
  by
  ext j
  rcases eq_or_ne i j with (rfl | h)
  · simp
  · simp [Function.update_noteq h.symm, h, erase_ne, h.symm]
#align dfinsupp.update_eq_erase_add_single Dfinsupp.update_eq_erase_add_single

/- warning: dfinsupp.update_eq_sub_add_single -> Dfinsupp.update_eq_sub_add_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (i : ι) (b : β i), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.update.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i f b) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) f (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) f i))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i b))
but is expected to have type
  forall {ι : Type.{u2}} [dec : DecidableEq.{succ u2} ι] {β : ι -> Type.{u1}} [_inst_2 : forall (i : ι), AddGroup.{u1} (β i)] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (i : ι) (b : β i), Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.update.{u2, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))))) i f b) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} (β i) (SubNegZeroMonoid.toNegZeroClass.{u1} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (β i) (AddGroup.toSubtractionMonoid.{u1} (β i) (_inst_2 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHAdd.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.instAddDfinsuppToZero.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u1} (β i) (SubNegMonoid.toAddMonoid.{u1} (β i) (AddGroup.toSubNegMonoid.{u1} (β i) (_inst_2 i)))))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} (β i) (SubNegZeroMonoid.toNegZeroClass.{u1} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (β i) (AddGroup.toSubtractionMonoid.{u1} (β i) (_inst_2 i)))))) (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) f (Dfinsupp.single.{u2, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u1} (β i) (SubNegZeroMonoid.toNegZeroClass.{u1} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (β i) (AddGroup.toSubtractionMonoid.{u1} (β i) (_inst_2 i))))) i (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => NegZeroClass.toZero.{u1} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (i : ι) => β i) i) (_inst_2 i))))) i)) f i))) (Dfinsupp.single.{u2, u1} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u1} (β i) (SubNegZeroMonoid.toNegZeroClass.{u1} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (β i) (AddGroup.toSubtractionMonoid.{u1} (β i) (_inst_2 i))))) i b))
Case conversion may be inaccurate. Consider using '#align dfinsupp.update_eq_sub_add_single Dfinsupp.update_eq_sub_add_singleₓ'. -/
theorem update_eq_sub_add_single {β : ι → Type _} [∀ i, AddGroup (β i)] (f : Π₀ i, β i) (i : ι)
    (b : β i) : f.update i b = f - single i (f i) + single i b := by
  rw [update_eq_erase_add_single f i b, erase_eq_sub_single f i]
#align dfinsupp.update_eq_sub_add_single Dfinsupp.update_eq_sub_add_single

end Update

end Basic

section AddMonoid

variable [∀ i, AddZeroClass (β i)]

/- warning: dfinsupp.single_add -> Dfinsupp.single_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι) (b₁ : β i) (b₂ : β i), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)) i (HAdd.hAdd.{u2, u2, u2} (β i) (β i) (β i) (instHAdd.{u2} (β i) (AddZeroClass.toHasAdd.{u2} (β i) (_inst_1 i))) b₁ b₂)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)) i b₁) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)) i b₂))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι) (b₁ : β i) (b₂ : β i), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i)) i (HAdd.hAdd.{u2, u2, u2} (β i) (β i) (β i) (instHAdd.{u2} (β i) (AddZeroClass.toAdd.{u2} (β i) (_inst_1 i))) b₁ b₂)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i)) i b₁) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i)) i b₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.single_add Dfinsupp.single_addₓ'. -/
@[simp]
theorem single_add (i : ι) (b₁ b₂ : β i) : single i (b₁ + b₂) = single i b₁ + single i b₂ :=
  ext fun i' => by
    by_cases h : i = i'
    · subst h
      simp only [add_apply, single_eq_same]
    · simp only [add_apply, single_eq_of_ne h, zero_add]
#align dfinsupp.single_add Dfinsupp.single_add

/- warning: dfinsupp.erase_add -> Dfinsupp.erase_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι) (f₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (f₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f₁ f₂)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i f₁) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i f₂))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι) (f₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (f₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f₁ f₂)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i f₁) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i f₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.erase_add Dfinsupp.erase_addₓ'. -/
@[simp]
theorem erase_add (i : ι) (f₁ f₂ : Π₀ i, β i) : erase i (f₁ + f₂) = erase i f₁ + erase i f₂ :=
  ext fun _ => by simp [ite_zero_add]
#align dfinsupp.erase_add Dfinsupp.erase_add

variable (β)

/- warning: dfinsupp.single_add_hom -> Dfinsupp.singleAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (_inst_1 i) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))
but is expected to have type
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι), AddMonoidHom.{u2, max u2 u1} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (_inst_1 i) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.single_add_hom Dfinsupp.singleAddHomₓ'. -/
/-- `dfinsupp.single` as an `add_monoid_hom`. -/
@[simps]
def singleAddHom (i : ι) : β i →+ Π₀ i, β i
    where
  toFun := single i
  map_zero' := single_zero i
  map_add' := single_add i
#align dfinsupp.single_add_hom Dfinsupp.singleAddHom

/- warning: dfinsupp.erase_add_hom -> Dfinsupp.eraseAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)], ι -> (AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))
but is expected to have type
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)], ι -> (AddMonoidHom.{max u2 u1, max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.erase_add_hom Dfinsupp.eraseAddHomₓ'. -/
/-- `dfinsupp.erase` as an `add_monoid_hom`. -/
@[simps]
def eraseAddHom (i : ι) : (Π₀ i, β i) →+ Π₀ i, β i
    where
  toFun := erase i
  map_zero' := erase_zero i
  map_add' := erase_add i
#align dfinsupp.erase_add_hom Dfinsupp.eraseAddHom

variable {β}

/- warning: dfinsupp.single_neg -> Dfinsupp.single_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (i : ι) (x : β i), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i))))) i (Neg.neg.{u2} (β i) (SubNegMonoid.toHasNeg.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i))) x)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i))))) i x))
but is expected to have type
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (i : ι) (x : β i), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i))))) i (Neg.neg.{u2} (β i) (NegZeroClass.toNeg.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i))))) x)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i))))) i x))
Case conversion may be inaccurate. Consider using '#align dfinsupp.single_neg Dfinsupp.single_negₓ'. -/
@[simp]
theorem single_neg {β : ι → Type v} [∀ i, AddGroup (β i)] (i : ι) (x : β i) :
    single i (-x) = -single i x :=
  (singleAddHom β i).map_neg x
#align dfinsupp.single_neg Dfinsupp.single_neg

/- warning: dfinsupp.single_sub -> Dfinsupp.single_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (i : ι) (x : β i) (y : β i), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i))))) i (HSub.hSub.{u2, u2, u2} (β i) (β i) (β i) (instHSub.{u2} (β i) (SubNegMonoid.toHasSub.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i)))) x y)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i))))) i x) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i))))) i y))
but is expected to have type
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (i : ι) (x : β i) (y : β i), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i))))) i (HSub.hSub.{u2, u2, u2} (β i) (β i) (β i) (instHSub.{u2} (β i) (SubNegMonoid.toSub.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_2 i)))) x y)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i))))) i x) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_2 i))))) i y))
Case conversion may be inaccurate. Consider using '#align dfinsupp.single_sub Dfinsupp.single_subₓ'. -/
@[simp]
theorem single_sub {β : ι → Type v} [∀ i, AddGroup (β i)] (i : ι) (x y : β i) :
    single i (x - y) = single i x - single i y :=
  (singleAddHom β i).map_sub x y
#align dfinsupp.single_sub Dfinsupp.single_sub

/- warning: dfinsupp.erase_neg -> Dfinsupp.erase_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (i : ι) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) f)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i f))
but is expected to have type
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (i : ι) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) f)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.erase_neg Dfinsupp.erase_negₓ'. -/
@[simp]
theorem erase_neg {β : ι → Type v} [∀ i, AddGroup (β i)] (i : ι) (f : Π₀ i, β i) :
    (-f).erase i = -f.erase i :=
  (eraseAddHom β i).map_neg f
#align dfinsupp.erase_neg Dfinsupp.erase_neg

/- warning: dfinsupp.erase_sub -> Dfinsupp.erase_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (i : ι) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i f) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i g))
but is expected to have type
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddGroup.{u2} (β i)] (i : ι) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i f) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) i g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.erase_sub Dfinsupp.erase_subₓ'. -/
@[simp]
theorem erase_sub {β : ι → Type v} [∀ i, AddGroup (β i)] (i : ι) (f g : Π₀ i, β i) :
    (f - g).erase i = f.erase i - g.erase i :=
  (eraseAddHom β i).map_sub f g
#align dfinsupp.erase_sub Dfinsupp.erase_sub

/- warning: dfinsupp.single_add_erase -> Dfinsupp.single_add_erase is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) f i)) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i f)) f
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i)) i (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) f i)) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i f)) f
Case conversion may be inaccurate. Consider using '#align dfinsupp.single_add_erase Dfinsupp.single_add_eraseₓ'. -/
theorem single_add_erase (i : ι) (f : Π₀ i, β i) : single i (f i) + f.erase i = f :=
  ext fun i' =>
    if h : i = i' then by
      subst h <;> simp only [add_apply, single_apply, erase_apply, dif_pos rfl, if_pos, add_zero]
    else by
      simp only [add_apply, single_apply, erase_apply, dif_neg h, if_neg (Ne.symm h), zero_add]
#align dfinsupp.single_add_erase Dfinsupp.single_add_erase

/- warning: dfinsupp.erase_add_single -> Dfinsupp.erase_add_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i f) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) f i))) f
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (i : ι) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.erase.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i f) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i)) i (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) f i))) f
Case conversion may be inaccurate. Consider using '#align dfinsupp.erase_add_single Dfinsupp.erase_add_singleₓ'. -/
theorem erase_add_single (i : ι) (f : Π₀ i, β i) : f.erase i + single i (f i) = f :=
  ext fun i' =>
    if h : i = i' then by
      subst h <;> simp only [add_apply, single_apply, erase_apply, dif_pos rfl, if_pos, zero_add]
    else by
      simp only [add_apply, single_apply, erase_apply, dif_neg h, if_neg (Ne.symm h), add_zero]
#align dfinsupp.erase_add_single Dfinsupp.erase_add_single

/- warning: dfinsupp.induction -> Dfinsupp.induction is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {p : (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) -> Prop} (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), (p (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))))) -> (forall (i : ι) (b : β i) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), (Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) f i) (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)))))) -> (Ne.{succ u2} (β i) b (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)))))) -> (p f) -> (p (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i b) f))) -> (p f)
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {p : (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) -> Prop} (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), (p (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) 0 (Zero.toOfNat0.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instZeroDfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) -> (forall (i : ι) (b : β i) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), (Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) f i) (OfNat.ofNat.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) 0 (Zero.toOfNat0.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddZeroClass.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i))))) -> (Ne.{succ u2} (β i) b (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddZeroClass.toZero.{u2} (β i) (_inst_1 i))))) -> (p f) -> (p (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i b) f))) -> (p f)
Case conversion may be inaccurate. Consider using '#align dfinsupp.induction Dfinsupp.inductionₓ'. -/
protected theorem induction {p : (Π₀ i, β i) → Prop} (f : Π₀ i, β i) (h0 : p 0)
    (ha : ∀ (i b) (f : Π₀ i, β i), f i = 0 → b ≠ 0 → p f → p (single i b + f)) : p f :=
  by
  cases' f with f s
  induction s using Trunc.induction_on
  cases' s with s H
  induction' s using Multiset.induction_on with i s ih generalizing f
  · have : f = 0 := funext fun i => (H i).resolve_left id
    subst this
    exact h0
  have H2 : p (erase i ⟨f, Trunc.mk ⟨i ::ₘ s, H⟩⟩) :=
    by
    dsimp only [erase, Trunc.map, Trunc.bind, Trunc.liftOn, Trunc.lift_mk, Function.comp,
      Subtype.coe_mk]
    have H2 : ∀ j, j ∈ s ∨ ite (j = i) 0 (f j) = 0 :=
      by
      intro j
      cases' H j with H2 H2
      · cases' Multiset.mem_cons.1 H2 with H3 H3
        · right
          exact if_pos H3
        · left
          exact H3
      right
      split_ifs <;> [rfl, exact H2]
    have H3 :
      (⟨fun j : ι => ite (j = i) 0 (f j), Trunc.mk ⟨i ::ₘ s, _⟩⟩ : Π₀ i, β i) =
        ⟨fun j : ι => ite (j = i) 0 (f j), Trunc.mk ⟨s, H2⟩⟩ :=
      ext fun _ => rfl
    rw [H3]
    apply ih
  have H3 : single i _ + _ = (⟨f, Trunc.mk ⟨i ::ₘ s, H⟩⟩ : Π₀ i, β i) := single_add_erase _ _
  rw [← H3]
  change p (single i (f i) + _)
  cases' Classical.em (f i = 0) with h h
  · rw [h, single_zero, zero_add]
    exact H2
  refine' ha _ _ _ _ h H2
  rw [erase_same]
#align dfinsupp.induction Dfinsupp.induction

/- warning: dfinsupp.induction₂ -> Dfinsupp.induction₂ is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {p : (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) -> Prop} (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), (p (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))))) -> (forall (i : ι) (b : β i) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), (Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) f i) (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)))))) -> (Ne.{succ u2} (β i) b (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)))))) -> (p f) -> (p (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i b)))) -> (p f)
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {p : (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) -> Prop} (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), (p (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) 0 (Zero.toOfNat0.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instZeroDfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) -> (forall (i : ι) (b : β i) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), (Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) f i) (OfNat.ofNat.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) 0 (Zero.toOfNat0.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddZeroClass.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (_inst_1 i))))) -> (Ne.{succ u2} (β i) b (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddZeroClass.toZero.{u2} (β i) (_inst_1 i))))) -> (p f) -> (p (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i b)))) -> (p f)
Case conversion may be inaccurate. Consider using '#align dfinsupp.induction₂ Dfinsupp.induction₂ₓ'. -/
theorem induction₂ {p : (Π₀ i, β i) → Prop} (f : Π₀ i, β i) (h0 : p 0)
    (ha : ∀ (i b) (f : Π₀ i, β i), f i = 0 → b ≠ 0 → p f → p (f + single i b)) : p f :=
  Dfinsupp.induction f h0 fun i b f h1 h2 h3 =>
    have h4 : f + single i b = single i b + f :=
      by
      ext j; by_cases H : i = j
      · subst H
        simp [h1]
      · simp [H]
    Eq.recOn h4 <| ha i b f h1 h2 h3
#align dfinsupp.induction₂ Dfinsupp.induction₂

/- warning: dfinsupp.add_closure_Union_range_single -> Dfinsupp.add_closure_unionᵢ_range_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)], Eq.{succ (max u1 u2)} (AddSubmonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddSubmonoid.closure.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Set.unionᵢ.{max u1 u2, succ u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) ι (fun (i : ι) => Set.range.{max u1 u2, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (β i) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)))) (Top.top.{max u1 u2} (AddSubmonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddSubmonoid.hasTop.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)], Eq.{max (succ u1) (succ u2)} (AddSubmonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddSubmonoid.closure.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Set.unionᵢ.{max u1 u2, succ u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) ι (fun (i : ι) => Set.range.{max u1 u2, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (β i) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i)))) (Top.top.{max u1 u2} (AddSubmonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddSubmonoid.instTopAddSubmonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.add_closure_Union_range_single Dfinsupp.add_closure_unionᵢ_range_singleₓ'. -/
@[simp]
theorem add_closure_unionᵢ_range_single :
    AddSubmonoid.closure (⋃ i : ι, Set.range (single i : β i → Π₀ i, β i)) = ⊤ :=
  top_unique fun x hx => by
    apply Dfinsupp.induction x
    exact AddSubmonoid.zero_mem _
    exact fun a b f ha hb hf =>
      AddSubmonoid.add_mem _
        (AddSubmonoid.subset_closure <| Set.mem_unionᵢ.2 ⟨a, Set.mem_range_self _⟩) hf
#align dfinsupp.add_closure_Union_range_single Dfinsupp.add_closure_unionᵢ_range_single

/- warning: dfinsupp.add_hom_ext -> Dfinsupp.add_hom_ext is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {γ : Type.{u3}} [_inst_2 : AddZeroClass.{u3} γ] {{f : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2}} {{g : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2}}, (forall (i : ι) (y : β i), Eq.{succ u3} γ (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) f (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)) i y)) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) g (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)) i y))) -> (Eq.{max (succ u3) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) f g)
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {γ : Type.{u3}} [_inst_2 : AddZeroClass.{u3} γ] {{f : AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2}} {{g : AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2}}, (forall (i : ι) (y : β i), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i y)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u1) (succ u2), succ u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) _x) (AddHomClass.toFunLike.{max (max u1 u2) u3, max u1 u2, u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (AddZeroClass.toAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddZeroClass.toAdd.{u3} γ _inst_2) (AddMonoidHomClass.toAddHomClass.{max (max u1 u2) u3, max u1 u2, u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2 (AddMonoidHom.addMonoidHomClass.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2))) f (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i y)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u1) (succ u2), succ u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) _x) (AddHomClass.toFunLike.{max (max u1 u2) u3, max u1 u2, u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (AddZeroClass.toAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddZeroClass.toAdd.{u3} γ _inst_2) (AddMonoidHomClass.toAddHomClass.{max (max u1 u2) u3, max u1 u2, u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2 (AddMonoidHom.addMonoidHomClass.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2))) g (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i y))) -> (Eq.{max (max (succ u1) (succ u2)) (succ u3)} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.add_hom_ext Dfinsupp.add_hom_extₓ'. -/
/-- If two additive homomorphisms from `Π₀ i, β i` are equal on each `single a b`, then
they are equal. -/
theorem add_hom_ext {γ : Type w} [AddZeroClass γ] ⦃f g : (Π₀ i, β i) →+ γ⦄
    (H : ∀ (i : ι) (y : β i), f (single i y) = g (single i y)) : f = g :=
  by
  refine' AddMonoidHom.eq_of_eqOn_denseM add_closure_Union_range_single fun f hf => _
  simp only [Set.mem_unionᵢ, Set.mem_range] at hf
  rcases hf with ⟨x, y, rfl⟩
  apply H
#align dfinsupp.add_hom_ext Dfinsupp.add_hom_ext

/- warning: dfinsupp.add_hom_ext' -> Dfinsupp.add_hom_ext' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {γ : Type.{u3}} [_inst_2 : AddZeroClass.{u3} γ] {{f : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2}} {{g : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2}}, (forall (x : ι), Eq.{max (succ u3) (succ u2)} (AddMonoidHom.{u2, u3} (β x) γ (_inst_1 x) _inst_2) (AddMonoidHom.comp.{u2, max u1 u2, u3} (β x) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (_inst_1 x) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2 f (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) x)) (AddMonoidHom.comp.{u2, max u1 u2, u3} (β x) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (_inst_1 x) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2 g (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) x))) -> (Eq.{max (succ u3) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) f g)
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {γ : Type.{u3}} [_inst_2 : AddZeroClass.{u3} γ] {{f : AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2}} {{g : AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2}}, (forall (x : ι), Eq.{max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} (β x) γ (_inst_1 x) _inst_2) (AddMonoidHom.comp.{u2, max u1 u2, u3} (β x) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (_inst_1 x) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2 f (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) x)) (AddMonoidHom.comp.{u2, max u1 u2, u3} (β x) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (_inst_1 x) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2 g (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) x))) -> (Eq.{max (max (succ u1) (succ u2)) (succ u3)} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.add_hom_ext' Dfinsupp.add_hom_ext'ₓ'. -/
/-- If two additive homomorphisms from `Π₀ i, β i` are equal on each `single a b`, then
they are equal.

See note [partially-applied ext lemmas]. -/
@[ext]
theorem add_hom_ext' {γ : Type w} [AddZeroClass γ] ⦃f g : (Π₀ i, β i) →+ γ⦄
    (H : ∀ x, f.comp (singleAddHom β x) = g.comp (singleAddHom β x)) : f = g :=
  add_hom_ext fun x => AddMonoidHom.congr_fun (H x)
#align dfinsupp.add_hom_ext' Dfinsupp.add_hom_ext'

end AddMonoid

/- warning: dfinsupp.mk_add -> Dfinsupp.mk_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {s : Finset.{u1} ι} {x : forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)} {y : forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)}, Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)) s (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (instHAdd.{max u1 u2} (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (Pi.instAdd.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => AddZeroClass.toHasAdd.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i))))) x y)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.mk.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)) s x) (Dfinsupp.mk.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)) s y))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] {s : Finset.{u1} ι} {x : forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)} {y : forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)}, Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i)) s (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (instHAdd.{max u1 u2} (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (Pi.instAdd.{u1, u2} (Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => AddZeroClass.toAdd.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (_inst_1 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i))))) x y)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i)) s x) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} (β i) (_inst_1 i)) s y))
Case conversion may be inaccurate. Consider using '#align dfinsupp.mk_add Dfinsupp.mk_addₓ'. -/
@[simp]
theorem mk_add [∀ i, AddZeroClass (β i)] {s : Finset ι} {x y : ∀ i : (↑s : Set ι), β i} :
    mk s (x + y) = mk s x + mk s y :=
  ext fun i => by simp only [add_apply, mk_apply] <;> split_ifs <;> [rfl, rw [zero_add]]
#align dfinsupp.mk_add Dfinsupp.mk_add

#print Dfinsupp.mk_zero /-
@[simp]
theorem mk_zero [∀ i, Zero (β i)] {s : Finset ι} : mk s (0 : ∀ i : (↑s : Set ι), β i.1) = 0 :=
  ext fun i => by simp only [mk_apply] <;> split_ifs <;> rfl
#align dfinsupp.mk_zero Dfinsupp.mk_zero
-/

/- warning: dfinsupp.mk_neg -> Dfinsupp.mk_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] {s : Finset.{u1} ι} {x : forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) i)}, Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))))) s (Neg.neg.{max u1 u2} (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (Pi.instNeg.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => SubNegMonoid.toHasNeg.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (AddGroup.toSubNegMonoid.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i))))) x)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.mk.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))))) s x))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] {s : Finset.{u1} ι} {x : forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)}, Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i))))) s (Neg.neg.{max u1 u2} (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (Pi.instNeg.{u1, u2} (Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => NegZeroClass.toNeg.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (SubNegZeroMonoid.toNegZeroClass.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (AddGroup.toSubtractionMonoid.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (_inst_1 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i))))))) x)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i))))) s x))
Case conversion may be inaccurate. Consider using '#align dfinsupp.mk_neg Dfinsupp.mk_negₓ'. -/
@[simp]
theorem mk_neg [∀ i, AddGroup (β i)] {s : Finset ι} {x : ∀ i : (↑s : Set ι), β i.1} :
    mk s (-x) = -mk s x :=
  ext fun i => by simp only [neg_apply, mk_apply] <;> split_ifs <;> [rfl, rw [neg_zero]]
#align dfinsupp.mk_neg Dfinsupp.mk_neg

/- warning: dfinsupp.mk_sub -> Dfinsupp.mk_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] {s : Finset.{u1} ι} {x : forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) i)} {y : forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) i)}, Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))))) s (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (instHSub.{max u1 u2} (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (Pi.instSub.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => SubNegMonoid.toHasSub.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (AddGroup.toSubNegMonoid.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)))))) x y)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.mk.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))))) s x) (Dfinsupp.mk.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))))) s y))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] {s : Finset.{u1} ι} {x : forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)} {y : forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)}, Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i))))) s (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (instHSub.{max u1 u2} (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (Pi.instSub.{u1, u2} (Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => SubNegMonoid.toSub.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (AddGroup.toSubNegMonoid.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (_inst_1 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)))))) x y)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i))))) s x) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i))))) s y))
Case conversion may be inaccurate. Consider using '#align dfinsupp.mk_sub Dfinsupp.mk_subₓ'. -/
@[simp]
theorem mk_sub [∀ i, AddGroup (β i)] {s : Finset ι} {x y : ∀ i : (↑s : Set ι), β i.1} :
    mk s (x - y) = mk s x - mk s y :=
  ext fun i => by simp only [sub_apply, mk_apply] <;> split_ifs <;> [rfl, rw [sub_zero]]
#align dfinsupp.mk_sub Dfinsupp.mk_sub

/- warning: dfinsupp.mk_add_group_hom -> Dfinsupp.mkAddGroupHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (s : Finset.{u1} ι), AddMonoidHom.{max u1 u2, max u1 u2} (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))) (Pi.addZeroClass.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => AddMonoid.toAddZeroClass.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (SubNegMonoid.toAddMonoid.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (AddGroup.toSubNegMonoid.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)))))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] (s : Finset.{u1} ι), AddMonoidHom.{max u1 u2, max u2 u1} (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Pi.addZeroClass.{u1, u2} (Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => AddMonoid.toAddZeroClass.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (SubNegMonoid.toAddMonoid.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (AddGroup.toSubNegMonoid.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (_inst_1 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.mk_add_group_hom Dfinsupp.mkAddGroupHomₓ'. -/
/-- If `s` is a subset of `ι` then `mk_add_group_hom s` is the canonical additive
group homomorphism from $\prod_{i\in s}\beta_i$ to $\prod_{\mathtt{i : \iota}}\beta_i.$-/
def mkAddGroupHom [∀ i, AddGroup (β i)] (s : Finset ι) : (∀ i : (s : Set ι), β ↑i) →+ Π₀ i : ι, β i
    where
  toFun := mk s
  map_zero' := mk_zero
  map_add' _ _ := mk_add
#align dfinsupp.mk_add_group_hom Dfinsupp.mkAddGroupHom

section

variable [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]

/- warning: dfinsupp.mk_smul -> Dfinsupp.mk_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] {s : Finset.{u1} ι} (c : γ) (x : forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i)))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i))) s (SMul.smul.{u3, max u1 u2} γ (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (Pi.instSMul.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) γ (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => SMulZeroClass.toHasSmul.{u3, u2} γ (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (AddZeroClass.toHasZero.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (AddMonoid.toAddZeroClass.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (_inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)))) (DistribSMul.toSmulZeroClass.{u3, u2} γ (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (AddMonoid.toAddZeroClass.{u2} (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (_inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i))) (DistribMulAction.toDistribSMul.{u3, u2} γ (β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) _inst_1 (_inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)) (_inst_3 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))))) i)))))) c x)) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) c (Dfinsupp.mk.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i))) s x))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] {s : Finset.{u1} ι} (c : γ) (x : forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i))) (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i)) s (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (instHSMul.{u3, max u1 u2} γ (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (Pi.instSMul.{u1, u2, u3} (Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) γ (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => SMulZeroClass.toSMul.{u3, u2} γ (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (AddMonoid.toZero.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (_inst_2 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i))) (DistribSMul.toSMulZeroClass.{u3, u2} γ (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (AddMonoid.toAddZeroClass.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (_inst_2 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i))) (DistribMulAction.toDistribSMul.{u3, u2} γ (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) _inst_1 (_inst_2 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (_inst_3 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i))))))) c x)) (HSMul.hSMul.{u3, max u2 u1, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) c (Dfinsupp.mk.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i)) s x))
Case conversion may be inaccurate. Consider using '#align dfinsupp.mk_smul Dfinsupp.mk_smulₓ'. -/
@[simp]
theorem mk_smul {s : Finset ι} (c : γ) (x : ∀ i : (↑s : Set ι), β (i : ι)) :
    mk s (c • x) = c • mk s x :=
  ext fun i => by simp only [smul_apply, mk_apply] <;> split_ifs <;> [rfl, rw [smul_zero]]
#align dfinsupp.mk_smul Dfinsupp.mk_smul

/- warning: dfinsupp.single_smul -> Dfinsupp.single_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] {i : ι} (c : γ) (x : β i), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i)))) (Dfinsupp.single.{u1, u2} ι (fun {i : ι} => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i))) i (SMul.smul.{u3, u2} γ (β i) (SMulZeroClass.toHasSmul.{u3, u2} γ (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i))) (DistribSMul.toSmulZeroClass.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i)) (DistribMulAction.toDistribSMul.{u3, u2} γ (β i) _inst_1 (_inst_2 i) (_inst_3 i)))) c x)) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) c (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i))) i x))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] {i : ι} (c : γ) (x : β i), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i))) (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i)) i (HSMul.hSMul.{u3, u2, u2} γ (β i) (β i) (instHSMul.{u3, u2} γ (β i) (SMulZeroClass.toSMul.{u3, u2} γ (β i) (AddMonoid.toZero.{u2} (β i) (_inst_2 i)) (DistribSMul.toSMulZeroClass.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (_inst_2 i)) (DistribMulAction.toDistribSMul.{u3, u2} γ (β i) _inst_1 (_inst_2 i) (_inst_3 i))))) c x)) (HSMul.hSMul.{u3, max u2 u1, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) c (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (_inst_2 i)) i x))
Case conversion may be inaccurate. Consider using '#align dfinsupp.single_smul Dfinsupp.single_smulₓ'. -/
@[simp]
theorem single_smul {i : ι} (c : γ) (x : β i) : single i (c • x) = c • single i x :=
  ext fun i => by
    simp only [smul_apply, single_apply] <;> split_ifs <;> [cases h, rw [smul_zero]] <;> rfl
#align dfinsupp.single_smul Dfinsupp.single_smul

end

section SupportBasic

variable [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]

#print Dfinsupp.support /-
/-- Set `{i | f x ≠ 0}` as a `finset`. -/
def support (f : Π₀ i, β i) : Finset ι :=
  (f.support'.lift fun xs => (Multiset.toFinset ↑xs).filter fun i => f i ≠ 0) <|
    by
    rintro ⟨sx, hx⟩ ⟨sy, hy⟩
    dsimp only [Subtype.coe_mk, to_fun_eq_coe] at *
    ext i; constructor
    · intro H
      rcases Finset.mem_filter.1 H with ⟨h1, h2⟩
      exact Finset.mem_filter.2 ⟨Multiset.mem_toFinset.2 <| (hy i).resolve_right h2, h2⟩
    · intro H
      rcases Finset.mem_filter.1 H with ⟨h1, h2⟩
      exact Finset.mem_filter.2 ⟨Multiset.mem_toFinset.2 <| (hx i).resolve_right h2, h2⟩
#align dfinsupp.support Dfinsupp.support
-/

#print Dfinsupp.support_mk_subset /-
@[simp]
theorem support_mk_subset {s : Finset ι} {x : ∀ i : (↑s : Set ι), β i.1} : (mk s x).support ⊆ s :=
  fun i H => Multiset.mem_toFinset.1 (Finset.mem_filter.1 H).1
#align dfinsupp.support_mk_subset Dfinsupp.support_mk_subset
-/

#print Dfinsupp.support_mk'_subset /-
@[simp]
theorem support_mk'_subset {f : ∀ i, β i} {s : Multiset ι} {h} :
    (mk' f <| Trunc.mk ⟨s, h⟩).support ⊆ s.toFinset := fun i H =>
  Multiset.mem_toFinset.1 <| by simpa using (Finset.mem_filter.1 H).1
#align dfinsupp.support_mk'_subset Dfinsupp.support_mk'_subset
-/

#print Dfinsupp.mem_support_toFun /-
@[simp]
theorem mem_support_toFun (f : Π₀ i, β i) (i) : i ∈ f.support ↔ f i ≠ 0 :=
  by
  cases' f with f s
  induction s using Trunc.induction_on
  dsimp only [support, Trunc.lift_mk]
  rw [Finset.mem_filter, Multiset.mem_toFinset, coe_mk']
  exact and_iff_right_of_imp (s.prop i).resolve_right
#align dfinsupp.mem_support_to_fun Dfinsupp.mem_support_toFun
-/

#print Dfinsupp.eq_mk_support /-
theorem eq_mk_support (f : Π₀ i, β i) : f = mk f.support fun i => f i :=
  by
  change f = mk f.support fun i => f i.1
  ext i
  by_cases h : f i ≠ 0 <;> [skip, rw [Classical.not_not] at h] <;> simp [h]
#align dfinsupp.eq_mk_support Dfinsupp.eq_mk_support
-/

#print Dfinsupp.support_zero /-
@[simp]
theorem support_zero : (0 : Π₀ i, β i).support = ∅ :=
  rfl
#align dfinsupp.support_zero Dfinsupp.support_zero
-/

#print Dfinsupp.mem_support_iff /-
theorem mem_support_iff {f : Π₀ i, β i} {i : ι} : i ∈ f.support ↔ f i ≠ 0 :=
  f.mem_support_to_fun _
#align dfinsupp.mem_support_iff Dfinsupp.mem_support_iff
-/

#print Dfinsupp.not_mem_support_iff /-
theorem not_mem_support_iff {f : Π₀ i, β i} {i : ι} : i ∉ f.support ↔ f i = 0 :=
  not_iff_comm.1 mem_support_iff.symm
#align dfinsupp.not_mem_support_iff Dfinsupp.not_mem_support_iff
-/

#print Dfinsupp.support_eq_empty /-
@[simp]
theorem support_eq_empty {f : Π₀ i, β i} : f.support = ∅ ↔ f = 0 :=
  ⟨fun H => ext <| by simpa [Finset.ext_iff] using H, by simp (config := { contextual := true })⟩
#align dfinsupp.support_eq_empty Dfinsupp.support_eq_empty
-/

#print Dfinsupp.decidableZero /-
instance decidableZero : DecidablePred (Eq (0 : Π₀ i, β i)) := fun f =>
  decidable_of_iff _ <| support_eq_empty.trans eq_comm
#align dfinsupp.decidable_zero Dfinsupp.decidableZero
-/

/- ./././Mathport/Syntax/Translate/Basic.lean:628:2: warning: expanding binder collection (i «expr ∉ » s) -/
#print Dfinsupp.support_subset_iff /-
theorem support_subset_iff {s : Set ι} {f : Π₀ i, β i} :
    ↑f.support ⊆ s ↔ ∀ (i) (_ : i ∉ s), f i = 0 := by
  simp [Set.subset_def] <;> exact forall_congr' fun i => not_imp_comm
#align dfinsupp.support_subset_iff Dfinsupp.support_subset_iff
-/

#print Dfinsupp.support_single_ne_zero /-
theorem support_single_ne_zero {i : ι} {b : β i} (hb : b ≠ 0) : (single i b).support = {i} :=
  by
  ext j; by_cases h : i = j
  · subst h
    simp [hb]
  simp [Ne.symm h, h]
#align dfinsupp.support_single_ne_zero Dfinsupp.support_single_ne_zero
-/

#print Dfinsupp.support_single_subset /-
theorem support_single_subset {i : ι} {b : β i} : (single i b).support ⊆ {i} :=
  support_mk'_subset
#align dfinsupp.support_single_subset Dfinsupp.support_single_subset
-/

section MapRangeAndZipWith

variable [∀ i, Zero (β₁ i)] [∀ i, Zero (β₂ i)]

#print Dfinsupp.mapRange_def /-
theorem mapRange_def [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] {f : ∀ i, β₁ i → β₂ i}
    {hf : ∀ i, f i 0 = 0} {g : Π₀ i, β₁ i} :
    mapRange f hf g = mk g.support fun i => f i.1 (g i.1) :=
  by
  ext i
  by_cases h : g i ≠ 0 <;> simp at h <;> simp [h, hf]
#align dfinsupp.map_range_def Dfinsupp.mapRange_def
-/

#print Dfinsupp.mapRange_single /-
@[simp]
theorem mapRange_single {f : ∀ i, β₁ i → β₂ i} {hf : ∀ i, f i 0 = 0} {i : ι} {b : β₁ i} :
    mapRange f hf (single i b) = single i (f i b) :=
  Dfinsupp.ext fun i' => by
    by_cases i = i' <;>
      [·
        subst i'
        simp, simp [h, hf]]
#align dfinsupp.map_range_single Dfinsupp.mapRange_single
-/

variable [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ (i) (x : β₂ i), Decidable (x ≠ 0)]

#print Dfinsupp.support_mapRange /-
theorem support_mapRange {f : ∀ i, β₁ i → β₂ i} {hf : ∀ i, f i 0 = 0} {g : Π₀ i, β₁ i} :
    (mapRange f hf g).support ⊆ g.support := by simp [map_range_def]
#align dfinsupp.support_map_range Dfinsupp.support_mapRange
-/

#print Dfinsupp.zipWith_def /-
theorem zipWith_def {ι : Type u} {β : ι → Type v} {β₁ : ι → Type v₁} {β₂ : ι → Type v₂}
    [dec : DecidableEq ι] [∀ i : ι, Zero (β i)] [∀ i : ι, Zero (β₁ i)] [∀ i : ι, Zero (β₂ i)]
    [∀ (i : ι) (x : β₁ i), Decidable (x ≠ 0)] [∀ (i : ι) (x : β₂ i), Decidable (x ≠ 0)]
    {f : ∀ i, β₁ i → β₂ i → β i} {hf : ∀ i, f i 0 0 = 0} {g₁ : Π₀ i, β₁ i} {g₂ : Π₀ i, β₂ i} :
    zipWith f hf g₁ g₂ = mk (g₁.support ∪ g₂.support) fun i => f i.1 (g₁ i.1) (g₂ i.1) :=
  by
  ext i
  by_cases h1 : g₁ i ≠ 0 <;> by_cases h2 : g₂ i ≠ 0 <;>
      simp only [Classical.not_not, Ne.def] at h1 h2 <;>
    simp [h1, h2, hf]
#align dfinsupp.zip_with_def Dfinsupp.zipWith_def
-/

#print Dfinsupp.support_zipWith /-
theorem support_zipWith {f : ∀ i, β₁ i → β₂ i → β i} {hf : ∀ i, f i 0 0 = 0} {g₁ : Π₀ i, β₁ i}
    {g₂ : Π₀ i, β₂ i} : (zipWith f hf g₁ g₂).support ⊆ g₁.support ∪ g₂.support := by
  simp [zip_with_def]
#align dfinsupp.support_zip_with Dfinsupp.support_zipWith
-/

end MapRangeAndZipWith

#print Dfinsupp.erase_def /-
theorem erase_def (i : ι) (f : Π₀ i, β i) : f.erase i = mk (f.support.erase i) fun j => f j.1 :=
  by
  ext j
  by_cases h1 : j = i <;> by_cases h2 : f j ≠ 0 <;> simp at h2 <;> simp [h1, h2]
#align dfinsupp.erase_def Dfinsupp.erase_def
-/

#print Dfinsupp.support_erase /-
@[simp]
theorem support_erase (i : ι) (f : Π₀ i, β i) : (f.erase i).support = f.support.erase i :=
  by
  ext j
  by_cases h1 : j = i
  simp [h1]
  by_cases h2 : f j ≠ 0 <;> simp at h2 <;> simp [h1, h2]
#align dfinsupp.support_erase Dfinsupp.support_erase
-/

#print Dfinsupp.support_update_ne_zero /-
theorem support_update_ne_zero (f : Π₀ i, β i) (i : ι) {b : β i} (h : b ≠ 0) :
    support (f.update i b) = insert i f.support :=
  by
  ext j
  rcases eq_or_ne i j with (rfl | hi)
  · simp [h]
  · simp [hi.symm]
#align dfinsupp.support_update_ne_zero Dfinsupp.support_update_ne_zero
-/

#print Dfinsupp.support_update /-
theorem support_update (f : Π₀ i, β i) (i : ι) (b : β i) [Decidable (b = 0)] :
    support (f.update i b) = if b = 0 then support (f.erase i) else insert i f.support :=
  by
  ext j
  split_ifs with hb
  · subst hb
    simp [update_eq_erase, support_erase]
  · rw [support_update_ne_zero f _ hb]
#align dfinsupp.support_update Dfinsupp.support_update
-/

section FilterAndSubtypeDomain

variable {p : ι → Prop} [DecidablePred p]

#print Dfinsupp.filter_def /-
theorem filter_def (f : Π₀ i, β i) : f.filter p = mk (f.support.filter p) fun i => f i.1 := by
  ext i <;> by_cases h1 : p i <;> by_cases h2 : f i ≠ 0 <;> simp at h2 <;> simp [h1, h2]
#align dfinsupp.filter_def Dfinsupp.filter_def
-/

#print Dfinsupp.support_filter /-
@[simp]
theorem support_filter (f : Π₀ i, β i) : (f.filter p).support = f.support.filter p := by
  ext i <;> by_cases h : p i <;> simp [h]
#align dfinsupp.support_filter Dfinsupp.support_filter
-/

/- warning: dfinsupp.subtype_domain_def -> Dfinsupp.subtypeDomain_def is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_1 i)))))] {p : ι -> Prop} [_inst_3 : DecidablePred.{succ u1} ι p] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) p (fun (a : ι) => _inst_3 a) f) (Dfinsupp.mk.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (a : Subtype.{succ u1} ι p) (b : Subtype.{succ u1} ι p) => Subtype.decidableEq.{u1} ι (fun (x : ι) => p x) (fun (a : ι) (b : ι) => dec a b) a b) (fun (i : Subtype.{succ u1} ι p) => _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Subtype.{succ u1} ι p)) Type.{u1} (Set.hasCoeToSort.{u1} (Subtype.{succ u1} ι p)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (Finset.Set.hasCoeT.{u1} (Subtype.{succ u1} ι p)))) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)))) => coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Subtype.{succ u1} ι p)) Type.{u1} (Set.hasCoeToSort.{u1} (Subtype.{succ u1} ι p)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (Finset.Set.hasCoeT.{u1} (Subtype.{succ u1} ι p)))) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)))) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Subtype.{succ u1} ι p)) Type.{u1} (Set.hasCoeToSort.{u1} (Subtype.{succ u1} ι p)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (Finset.Set.hasCoeT.{u1} (Subtype.{succ u1} ι p)))) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)))) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Subtype.{succ u1} ι p)) Type.{u1} (Set.hasCoeToSort.{u1} (Subtype.{succ u1} ι p)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (Finset.Set.hasCoeT.{u1} (Subtype.{succ u1} ι p)))) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)))) ι (coeTrans.{succ u1, succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Subtype.{succ u1} ι p)) Type.{u1} (Set.hasCoeToSort.{u1} (Subtype.{succ u1} ι p)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (Finset.Set.hasCoeT.{u1} (Subtype.{succ u1} ι p)))) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)))) (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))) (coeSubtype.{succ u1} (Subtype.{succ u1} ι p) (fun (x : Subtype.{succ u1} ι p) => Membership.Mem.{u1, u1} (Subtype.{succ u1} ι p) (Set.{u1} (Subtype.{succ u1} ι p)) (Set.hasMem.{u1} (Subtype.{succ u1} ι p)) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Set.{u1} (Subtype.{succ u1} ι p)) (Finset.Set.hasCoeT.{u1} (Subtype.{succ u1} ι p)))) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)))))))) i)))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (_inst_1 i))))] {p : ι -> Prop} [_inst_3 : DecidablePred.{succ u1} ι p] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 (Subtype.val.{succ u1} ι p i))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) p (fun (a : ι) => _inst_3 a) f) (Dfinsupp.mk.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (a : Subtype.{succ u1} ι p) (b : Subtype.{succ u1} ι p) => Subtype.instDecidableEqSubtype.{u1} ι (fun (x : ι) => p x) (fun (a : ι) (b : ι) => dec a b) a b) (fun (i : Subtype.{succ u1} ι p) => _inst_1 (Subtype.val.{succ u1} ι p i)) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)) (fun (i : Set.Elem.{u1} (Subtype.{succ u1} ι p) (Finset.toSet.{u1} (Subtype.{succ u1} ι p) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)))) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f (Subtype.val.{succ u1} ι p (Subtype.val.{succ u1} (Subtype.{succ u1} ι p) (fun (x : Subtype.{succ u1} ι p) => Membership.mem.{u1, u1} (Subtype.{succ u1} ι p) (Set.{u1} (Subtype.{succ u1} ι p)) (Set.instMembershipSet.{u1} (Subtype.{succ u1} ι p)) x (Finset.toSet.{u1} (Subtype.{succ u1} ι p) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f)))) i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subtype_domain_def Dfinsupp.subtypeDomain_defₓ'. -/
theorem subtypeDomain_def (f : Π₀ i, β i) :
    f.subtypeDomain p = mk (f.support.Subtype p) fun i => f i := by
  ext i <;> by_cases h2 : f i ≠ 0 <;> try simp at h2 <;> dsimp <;> simp [h2]
#align dfinsupp.subtype_domain_def Dfinsupp.subtypeDomain_def

/- warning: dfinsupp.support_subtype_domain -> Dfinsupp.support_subtypeDomain is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_1 i)))))] {p : ι -> Prop} [_inst_3 : DecidablePred.{succ u1} ι p] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)}, Eq.{succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Dfinsupp.support.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (a : Subtype.{succ u1} ι p) (b : Subtype.{succ u1} ι p) => Subtype.decidableEq.{u1} ι (fun (x : ι) => p x) (fun (a : ι) (b : ι) => dec a b) a b) (fun (i : Subtype.{succ u1} ι p) => _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) (x : β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) => _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i) x) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) p (fun (a : ι) => _inst_3 a) f)) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (_inst_1 i))))] {p : ι -> Prop} [_inst_3 : DecidablePred.{succ u1} ι p] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)}, Eq.{succ u1} (Finset.{u1} (Subtype.{succ u1} ι p)) (Dfinsupp.support.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (a : Subtype.{succ u1} ι p) (b : Subtype.{succ u1} ι p) => Subtype.instDecidableEqSubtype.{u1} ι (fun (x : ι) => p x) (fun (a : ι) (b : ι) => dec a b) a b) (fun (i : Subtype.{succ u1} ι p) => _inst_1 (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) (x : β (Subtype.val.{succ u1} ι p i)) => _inst_2 (Subtype.val.{succ u1} ι p i) x) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) p (fun (a : ι) => _inst_3 a) f)) (Finset.subtype.{u1} ι p (fun (a : ι) => _inst_3 a) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.support_subtype_domain Dfinsupp.support_subtypeDomainₓ'. -/
@[simp]
theorem support_subtypeDomain {f : Π₀ i, β i} : (subtypeDomain p f).support = f.support.Subtype p :=
  by
  ext i
  simp
#align dfinsupp.support_subtype_domain Dfinsupp.support_subtypeDomain

end FilterAndSubtypeDomain

end SupportBasic

/- warning: dfinsupp.support_add -> Dfinsupp.support_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))))))] {g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))} {g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))}, HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) (x : β i) => _inst_2 i x) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂)) (Union.union.{u1} (Finset.{u1} ι) (Finset.hasUnion.{u1} ι (fun (a : ι) (b : ι) => dec a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) (x : β i) => _inst_2 i x) g₁) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) (x : β i) => _inst_2 i x) g₂))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddZeroClass.toZero.{u2} (β i) (_inst_1 i)))))] {g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))} {g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))}, HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.instHasSubsetFinset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) (x : β i) => _inst_2 i x) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) g₁ g₂)) (Union.union.{u1} (Finset.{u1} ι) (Finset.instUnionFinset.{u1} ι (fun (a : ι) (b : ι) => dec a b)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) (x : β i) => _inst_2 i x) g₁) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) (x : β i) => _inst_2 i x) g₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.support_add Dfinsupp.support_addₓ'. -/
theorem support_add [∀ i, AddZeroClass (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]
    {g₁ g₂ : Π₀ i, β i} : (g₁ + g₂).support ⊆ g₁.support ∪ g₂.support :=
  support_zip_with
#align dfinsupp.support_add Dfinsupp.support_add

/- warning: dfinsupp.support_neg -> Dfinsupp.support_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))))))] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))}, Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) f)
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i))))))))] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))}, Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) f)
Case conversion may be inaccurate. Consider using '#align dfinsupp.support_neg Dfinsupp.support_negₓ'. -/
@[simp]
theorem support_neg [∀ i, AddGroup (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] {f : Π₀ i, β i} :
    support (-f) = support f := by ext i <;> simp
#align dfinsupp.support_neg Dfinsupp.support_neg

/- warning: dfinsupp.support_smul -> Dfinsupp.support_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {γ : Type.{u3}} [_inst_1 : Semiring.{u3} γ] [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), Module.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] [_inst_4 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_2 i))))))))] (b : γ) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))), HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (fun (i : ι) (x : β i) => _inst_4 i x) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (SMulZeroClass.toHasSmul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (AddZeroClass.toHasZero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))))) (SMulWithZero.toSmulZeroClass.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (MulZeroClass.toHasZero.{u3} γ (MulZeroOneClass.toMulZeroClass.{u3} γ (MonoidWithZero.toMulZeroOneClass.{u3} γ (Semiring.toMonoidWithZero.{u3} γ _inst_1)))) (AddZeroClass.toHasZero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))))) (MulActionWithZero.toSMulWithZero.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (Semiring.toMonoidWithZero.{u3} γ _inst_1) (AddZeroClass.toHasZero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i))))) (Module.toMulActionWithZero.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))))) _inst_1 (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.module.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) b v)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (fun (i : ι) (x : β i) => _inst_4 i x) v)
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {γ : Type.{u3}} [_inst_1 : Semiring.{u3} γ] [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), Module.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] [_inst_4 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_2 i))))))] (b : γ) (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))), HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.instHasSubsetFinset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (fun (i : ι) (x : β i) => _inst_4 i x) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι γ (fun (i : ι) => β i) (MonoidWithZero.toMonoid.{u3} γ (Semiring.toMonoidWithZero.{u3} γ _inst_1)) (fun (i : ι) => AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_2 i)) (fun (i : ι) => Module.toDistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i) (_inst_3 i)))) b v)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) (fun (i : ι) (x : β i) => _inst_4 i x) v)
Case conversion may be inaccurate. Consider using '#align dfinsupp.support_smul Dfinsupp.support_smulₓ'. -/
theorem support_smul {γ : Type w} [Semiring γ] [∀ i, AddCommMonoid (β i)] [∀ i, Module γ (β i)]
    [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] (b : γ) (v : Π₀ i, β i) :
    (b • v).support ⊆ v.support :=
  support_map_range
#align dfinsupp.support_smul Dfinsupp.support_smul

instance [∀ i, Zero (β i)] [∀ i, DecidableEq (β i)] : DecidableEq (Π₀ i, β i) := fun f g =>
  decidable_of_iff (f.support = g.support ∧ ∀ i ∈ f.support, f i = g i)
    ⟨fun ⟨h₁, h₂⟩ =>
      ext fun i =>
        if h : i ∈ f.support then h₂ i h
        else by
          have hf : f i = 0 := by rwa [mem_support_iff, Classical.not_not] at h
          have hg : g i = 0 := by rwa [h₁, mem_support_iff, Classical.not_not] at h
          rw [hf, hg],
      by
      rintro rfl
      simp⟩

section Equiv

open Finset

variable {κ : Type _}

#print Dfinsupp.comapDomain /-
/-- Reindexing (and possibly removing) terms of a dfinsupp.-/
noncomputable def comapDomain [∀ i, Zero (β i)] (h : κ → ι) (hh : Function.Injective h)
    (f : Π₀ i, β i) : Π₀ k, β (h k) where
  toFun x := f (h x)
  support' :=
    f.support'.map fun s =>
      ⟨((Multiset.toFinset ↑s).Preimage h (hh.InjOn _)).val, fun x =>
        (s.Prop (h x)).imp_left fun hx => mem_preimage.mpr <| Multiset.mem_toFinset.mpr hx⟩
#align dfinsupp.comap_domain Dfinsupp.comapDomain
-/

/- warning: dfinsupp.comap_domain_apply -> Dfinsupp.comapDomain_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {κ : Type.{u3}} [_inst_1 : forall (i : ι), Zero.{u2} (β i)] (h : κ -> ι) (hh : Function.Injective.{succ u3, succ u1} κ ι h) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (k : κ), Eq.{succ u2} ((fun (i : ι) => β i) (h k)) (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (Dfinsupp.{u3, u2} κ (fun (k : κ) => (fun (i : ι) => β i) (h k)) (fun (i : κ) => (fun (i : ι) => _inst_1 i) (h i))) (fun (_x : Dfinsupp.{u3, u2} κ (fun (i : κ) => (fun (i : ι) => β i) (h i)) (fun (i : κ) => (fun (i : ι) => _inst_1 i) (h i))) => forall (i : κ), (fun (i : ι) => β i) (h i)) (Dfinsupp.hasCoeToFun.{u3, u2} κ (fun (k : κ) => (fun (i : ι) => β i) (h k)) (fun (i : κ) => (fun (i : ι) => _inst_1 i) (h i))) (Dfinsupp.comapDomain.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => _inst_1 i) h hh f) k) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f (h k))
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] {κ : Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u3} (β i)] (h : κ -> ι) (hh : Function.Injective.{succ u1, succ u2} κ ι h) (f : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (k : κ), Eq.{succ u3} ((fun (i : κ) => (fun (k : κ) => β (h k)) i) k) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Dfinsupp.{u1, u3} κ (fun (i : κ) => (fun (k : κ) => β (h k)) i) (fun (i : κ) => (fun (i : κ) => _inst_1 (h i)) i)) κ (fun (_x : κ) => (fun (i : κ) => (fun (k : κ) => β (h k)) i) _x) (Dfinsupp.funLike.{u1, u3} κ (fun (k : κ) => (fun (i : κ) => β (h i)) k) (fun (i : κ) => (fun (i : κ) => _inst_1 (h i)) i)) (Dfinsupp.comapDomain.{u2, u3, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => _inst_1 i) h hh f) k) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f (h k))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain_apply Dfinsupp.comapDomain_applyₓ'. -/
@[simp]
theorem comapDomain_apply [∀ i, Zero (β i)] (h : κ → ι) (hh : Function.Injective h) (f : Π₀ i, β i)
    (k : κ) : comapDomain h hh f k = f (h k) :=
  rfl
#align dfinsupp.comap_domain_apply Dfinsupp.comapDomain_apply

/- warning: dfinsupp.comap_domain_zero -> Dfinsupp.comapDomain_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {κ : Type.{u3}} [_inst_1 : forall (i : ι), Zero.{u2} (β i)] (h : κ -> ι) (hh : Function.Injective.{succ u3, succ u1} κ ι h), Eq.{succ (max u3 u2)} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) (Dfinsupp.comapDomain.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => _inst_1 i) h hh (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.hasZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) (OfNat.ofNat.{max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) 0 (OfNat.mk.{max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) 0 (Zero.zero.{max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) (Dfinsupp.hasZero.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))))))
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] {κ : Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u3} (β i)] (h : κ -> ι) (hh : Function.Injective.{succ u1, succ u2} κ ι h), Eq.{max (succ u3) (succ u1)} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) (Dfinsupp.comapDomain.{u2, u3, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => _inst_1 i) h hh (OfNat.ofNat.{max u2 u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.toOfNat0.{max u2 u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instZeroDfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (OfNat.ofNat.{max u3 u1} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) 0 (Zero.toOfNat0.{max u3 u1} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) (Dfinsupp.instZeroDfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i)))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain_zero Dfinsupp.comapDomain_zeroₓ'. -/
@[simp]
theorem comapDomain_zero [∀ i, Zero (β i)] (h : κ → ι) (hh : Function.Injective h) :
    comapDomain h hh (0 : Π₀ i, β i) = 0 := by
  ext
  rw [zero_apply, comap_domain_apply, zero_apply]
#align dfinsupp.comap_domain_zero Dfinsupp.comapDomain_zero

/- warning: dfinsupp.comap_domain_add -> Dfinsupp.comapDomain_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {κ : Type.{u3}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (h : κ -> ι) (hh : Function.Injective.{succ u3, succ u1} κ ι h) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ (max u3 u2)} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.comapDomain.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) h hh (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g)) (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (instHAdd.{max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.hasAdd.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i)))) (Dfinsupp.comapDomain.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) h hh f) (Dfinsupp.comapDomain.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) h hh g))
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] {κ : Type.{u1}} [_inst_1 : forall (i : ι), AddZeroClass.{u3} (β i)] (h : κ -> ι) (hh : Function.Injective.{succ u1, succ u2} κ ι h) (f : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (g : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{max (succ u3) (succ u1)} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.comapDomain.{u2, u3, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) h hh (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u2 u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g)) (HAdd.hAdd.{max u3 u1, max u3 u1, max u3 u1} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (instHAdd.{max u3 u1} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.instAddDfinsuppToZero.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i)))) (Dfinsupp.comapDomain.{u2, u3, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) h hh f) (Dfinsupp.comapDomain.{u2, u3, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) h hh g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain_add Dfinsupp.comapDomain_addₓ'. -/
@[simp]
theorem comapDomain_add [∀ i, AddZeroClass (β i)] (h : κ → ι) (hh : Function.Injective h)
    (f g : Π₀ i, β i) : comapDomain h hh (f + g) = comapDomain h hh f + comapDomain h hh g :=
  by
  ext
  rw [add_apply, comap_domain_apply, comap_domain_apply, comap_domain_apply, add_apply]
#align dfinsupp.comap_domain_add Dfinsupp.comapDomain_add

/- warning: dfinsupp.comap_domain_smul -> Dfinsupp.comapDomain_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {κ : Type.{u4}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (h : κ -> ι) (hh : Function.Injective.{succ u4, succ u1} κ ι h) (r : γ) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))), Eq.{succ (max u4 u2)} (Dfinsupp.{u4, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i))))) (Dfinsupp.comapDomain.{u1, u2, u4} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) h hh (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) r f)) (SMul.smul.{u3, max u4 u2} γ (Dfinsupp.{u4, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i))))) (Dfinsupp.hasSmul.{u4, u2, u3} κ γ (fun (k : κ) => β (h k)) _inst_1 (fun (i : κ) => _inst_2 (h i)) (fun (i : κ) => _inst_3 (h i))) r (Dfinsupp.comapDomain.{u1, u2, u4} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) h hh f))
but is expected to have type
  forall {ι : Type.{u2}} {γ : Type.{u4}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] {κ : Type.{u1}} [_inst_1 : Monoid.{u4} γ] [_inst_2 : forall (i : ι), AddMonoid.{u3} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u4, u3} γ (β i) _inst_1 (_inst_2 i)] (h : κ -> ι) (hh : Function.Injective.{succ u1, succ u2} κ ι h) (r : γ) (f : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i))), Eq.{max (succ u3) (succ u1)} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i)))) (Dfinsupp.comapDomain.{u2, u3, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i)) h hh (HSMul.hSMul.{u4, max u2 u3, max u2 u3} γ (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHSMul.{u4, max u2 u3} γ (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u2, u3, u4} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) r f)) (HSMul.hSMul.{u4, max u1 u3, max u3 u1} γ (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i)))) (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i)))) (instHSMul.{u4, max u3 u1} γ (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i)))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u3, u4} κ γ (fun (k : κ) => β (h k)) _inst_1 (fun (i : κ) => _inst_2 (h i)) (fun (i : κ) => _inst_3 (h i)))) r (Dfinsupp.comapDomain.{u2, u3, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i)) h hh f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain_smul Dfinsupp.comapDomain_smulₓ'. -/
@[simp]
theorem comapDomain_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]
    (h : κ → ι) (hh : Function.Injective h) (r : γ) (f : Π₀ i, β i) :
    comapDomain h hh (r • f) = r • comapDomain h hh f :=
  by
  ext
  rw [smul_apply, comap_domain_apply, smul_apply, comap_domain_apply]
#align dfinsupp.comap_domain_smul Dfinsupp.comapDomain_smul

/- warning: dfinsupp.comap_domain_single -> Dfinsupp.comapDomain_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {κ : Type.{u3}} [_inst_1 : DecidableEq.{succ u3} κ] [_inst_2 : forall (i : ι), Zero.{u2} (β i)] (h : κ -> ι) (hh : Function.Injective.{succ u3, succ u1} κ ι h) (k : κ) (x : β (h k)), Eq.{succ (max u3 u2)} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_2 (h i))) (Dfinsupp.comapDomain.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => _inst_2 i) h hh (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) _inst_2 (h k) x)) (Dfinsupp.single.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (a : κ) (b : κ) => _inst_1 a b) (fun (i : κ) => _inst_2 (h i)) k x)
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] {κ : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} κ] [_inst_2 : forall (i : ι), Zero.{u3} (β i)] (h : κ -> ι) (hh : Function.Injective.{succ u1, succ u2} κ ι h) (k : κ) (x : β (h k)), Eq.{max (succ u3) (succ u1)} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_2 (h i))) (Dfinsupp.comapDomain.{u2, u3, u1} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) κ (fun (i : ι) => _inst_2 i) h hh (Dfinsupp.single.{u2, u3} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_2 i) (h k) x)) (Dfinsupp.single.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (a : κ) (b : κ) => _inst_1 a b) (fun (i : κ) => _inst_2 (h i)) k x)
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain_single Dfinsupp.comapDomain_singleₓ'. -/
@[simp]
theorem comapDomain_single [DecidableEq κ] [∀ i, Zero (β i)] (h : κ → ι) (hh : Function.Injective h)
    (k : κ) (x : β (h k)) : comapDomain h hh (single (h k) x) = single k x :=
  by
  ext
  rw [comap_domain_apply]
  obtain rfl | hik := Decidable.eq_or_ne i k
  · rw [single_eq_same, single_eq_same]
  · rw [single_eq_of_ne hik.symm, single_eq_of_ne (hh.ne hik.symm)]
#align dfinsupp.comap_domain_single Dfinsupp.comapDomain_single

omit dec

#print Dfinsupp.comapDomain' /-
/-- A computable version of comap_domain when an explicit left inverse is provided.-/
def comapDomain' [∀ i, Zero (β i)] (h : κ → ι) {h' : ι → κ} (hh' : Function.LeftInverse h' h)
    (f : Π₀ i, β i) : Π₀ k, β (h k) where
  toFun x := f (h x)
  support' :=
    f.support'.map fun s =>
      ⟨Multiset.map h' s, fun x =>
        (s.Prop (h x)).imp_left fun hx => Multiset.mem_map.mpr ⟨_, hx, hh' _⟩⟩
#align dfinsupp.comap_domain' Dfinsupp.comapDomain'
-/

/- warning: dfinsupp.comap_domain'_apply -> Dfinsupp.comapDomain'_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {κ : Type.{u3}} [_inst_1 : forall (i : ι), Zero.{u2} (β i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u3, succ u1} κ ι h' h) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (k : κ), Eq.{succ u2} ((fun (i : ι) => β i) (h k)) (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (Dfinsupp.{u3, u2} κ (fun (k : κ) => (fun (i : ι) => β i) (h k)) (fun (i : κ) => (fun (i : ι) => _inst_1 i) (h i))) (fun (_x : Dfinsupp.{u3, u2} κ (fun (i : κ) => (fun (i : ι) => β i) (h i)) (fun (i : κ) => (fun (i : ι) => _inst_1 i) (h i))) => forall (i : κ), (fun (i : ι) => β i) (h i)) (Dfinsupp.hasCoeToFun.{u3, u2} κ (fun (k : κ) => (fun (i : ι) => β i) (h k)) (fun (i : κ) => (fun (i : ι) => _inst_1 i) (h i))) (Dfinsupp.comapDomain'.{u1, u2, u3} ι (fun (i : ι) => β i) κ (fun (i : ι) => _inst_1 i) h h' hh' f) k) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f (h k))
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} {κ : Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u3} (β i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u1, succ u2} κ ι h' h) (f : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (k : κ), Eq.{succ u3} ((fun (i : κ) => (fun (k : κ) => β (h k)) i) k) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Dfinsupp.{u1, u3} κ (fun (i : κ) => (fun (k : κ) => β (h k)) i) (fun (i : κ) => (fun (i : κ) => _inst_1 (h i)) i)) κ (fun (_x : κ) => (fun (i : κ) => (fun (k : κ) => β (h k)) i) _x) (Dfinsupp.funLike.{u1, u3} κ (fun (k : κ) => (fun (i : κ) => β (h i)) k) (fun (i : κ) => (fun (i : κ) => _inst_1 (h i)) i)) (Dfinsupp.comapDomain'.{u2, u3, u1} ι (fun (i : ι) => β i) κ (fun (i : ι) => _inst_1 i) h h' hh' f) k) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f (h k))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain'_apply Dfinsupp.comapDomain'_applyₓ'. -/
@[simp]
theorem comapDomain'_apply [∀ i, Zero (β i)] (h : κ → ι) {h' : ι → κ}
    (hh' : Function.LeftInverse h' h) (f : Π₀ i, β i) (k : κ) : comapDomain' h hh' f k = f (h k) :=
  rfl
#align dfinsupp.comap_domain'_apply Dfinsupp.comapDomain'_apply

/- warning: dfinsupp.comap_domain'_zero -> Dfinsupp.comapDomain'_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {κ : Type.{u3}} [_inst_1 : forall (i : ι), Zero.{u2} (β i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u3, succ u1} κ ι h' h), Eq.{succ (max u3 u2)} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) (Dfinsupp.comapDomain'.{u1, u2, u3} ι (fun (i : ι) => β i) κ (fun (i : ι) => _inst_1 i) h h' hh' (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.hasZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) (OfNat.ofNat.{max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) 0 (OfNat.mk.{max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) 0 (Zero.zero.{max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) (Dfinsupp.hasZero.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))))))
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} {κ : Type.{u1}} [_inst_1 : forall (i : ι), Zero.{u3} (β i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u1, succ u2} κ ι h' h), Eq.{max (succ u3) (succ u1)} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) (Dfinsupp.comapDomain'.{u2, u3, u1} ι (fun (i : ι) => β i) κ (fun (i : ι) => _inst_1 i) h h' hh' (OfNat.ofNat.{max u2 u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.toOfNat0.{max u2 u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instZeroDfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (OfNat.ofNat.{max u3 u1} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) 0 (Zero.toOfNat0.{max u3 u1} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i))) (Dfinsupp.instZeroDfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i)))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain'_zero Dfinsupp.comapDomain'_zeroₓ'. -/
@[simp]
theorem comapDomain'_zero [∀ i, Zero (β i)] (h : κ → ι) {h' : ι → κ}
    (hh' : Function.LeftInverse h' h) : comapDomain' h hh' (0 : Π₀ i, β i) = 0 :=
  by
  ext
  rw [zero_apply, comap_domain'_apply, zero_apply]
#align dfinsupp.comap_domain'_zero Dfinsupp.comapDomain'_zero

/- warning: dfinsupp.comap_domain'_add -> Dfinsupp.comapDomain'_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {κ : Type.{u3}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u3, succ u1} κ ι h' h) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ (max u3 u2)} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.comapDomain'.{u1, u2, u3} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) h h' hh' (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g)) (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (instHAdd.{max u3 u2} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.hasAdd.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i)))) (Dfinsupp.comapDomain'.{u1, u2, u3} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) h h' hh' f) (Dfinsupp.comapDomain'.{u1, u2, u3} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) h h' hh' g))
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} {κ : Type.{u1}} [_inst_1 : forall (i : ι), AddZeroClass.{u3} (β i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u1, succ u2} κ ι h' h) (f : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (g : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{max (succ u3) (succ u1)} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.comapDomain'.{u2, u3, u1} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) h h' hh' (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHAdd.{max u2 u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g)) (HAdd.hAdd.{max u3 u1, max u3 u1, max u3 u1} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (instHAdd.{max u3 u1} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_1 (h i)))) (Dfinsupp.instAddDfinsuppToZero.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_1 (h i)))) (Dfinsupp.comapDomain'.{u2, u3, u1} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) h h' hh' f) (Dfinsupp.comapDomain'.{u2, u3, u1} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) h h' hh' g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain'_add Dfinsupp.comapDomain'_addₓ'. -/
@[simp]
theorem comapDomain'_add [∀ i, AddZeroClass (β i)] (h : κ → ι) {h' : ι → κ}
    (hh' : Function.LeftInverse h' h) (f g : Π₀ i, β i) :
    comapDomain' h hh' (f + g) = comapDomain' h hh' f + comapDomain' h hh' g :=
  by
  ext
  rw [add_apply, comap_domain'_apply, comap_domain'_apply, comap_domain'_apply, add_apply]
#align dfinsupp.comap_domain'_add Dfinsupp.comapDomain'_add

/- warning: dfinsupp.comap_domain'_smul -> Dfinsupp.comapDomain'_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} {κ : Type.{u4}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι), AddMonoid.{u2} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u3, u2} γ (β i) _inst_1 (_inst_2 i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u4, succ u1} κ ι h' h) (r : γ) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))), Eq.{succ (max u4 u2)} (Dfinsupp.{u4, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i))))) (Dfinsupp.comapDomain'.{u1, u2, u4} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) h h' hh' (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) r f)) (SMul.smul.{u3, max u4 u2} γ (Dfinsupp.{u4, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) (h i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i))))) (Dfinsupp.hasSmul.{u4, u2, u3} κ γ (fun (k : κ) => β (h k)) _inst_1 (fun (i : κ) => _inst_2 (h i)) (fun (i : κ) => _inst_3 (h i))) r (Dfinsupp.comapDomain'.{u1, u2, u4} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (_inst_2 i))) h h' hh' f))
but is expected to have type
  forall {ι : Type.{u2}} {γ : Type.{u4}} {β : ι -> Type.{u3}} {κ : Type.{u1}} [_inst_1 : Monoid.{u4} γ] [_inst_2 : forall (i : ι), AddMonoid.{u3} (β i)] [_inst_3 : forall (i : ι), DistribMulAction.{u4, u3} γ (β i) _inst_1 (_inst_2 i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u1, succ u2} κ ι h' h) (r : γ) (f : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i))), Eq.{max (succ u3) (succ u1)} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i)))) (Dfinsupp.comapDomain'.{u2, u3, u1} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i)) h h' hh' (HSMul.hSMul.{u4, max u2 u3, max u2 u3} γ (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i))) (instHSMul.{u4, max u2 u3} γ (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u2, u3, u4} ι γ (fun (i : ι) => β i) _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) r f)) (HSMul.hSMul.{u4, max u1 u3, max u3 u1} γ (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i)))) (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i)))) (instHSMul.{u4, max u3 u1} γ (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) (h i)) (_inst_2 (h i)))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u3, u4} κ γ (fun (k : κ) => β (h k)) _inst_1 (fun (i : κ) => _inst_2 (h i)) (fun (i : κ) => _inst_3 (h i)))) r (Dfinsupp.comapDomain'.{u2, u3, u1} ι (fun (i : ι) => β i) κ (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_2 i)) h h' hh' f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain'_smul Dfinsupp.comapDomain'_smulₓ'. -/
@[simp]
theorem comapDomain'_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]
    (h : κ → ι) {h' : ι → κ} (hh' : Function.LeftInverse h' h) (r : γ) (f : Π₀ i, β i) :
    comapDomain' h hh' (r • f) = r • comapDomain' h hh' f :=
  by
  ext
  rw [smul_apply, comap_domain'_apply, smul_apply, comap_domain'_apply]
#align dfinsupp.comap_domain'_smul Dfinsupp.comapDomain'_smul

/- warning: dfinsupp.comap_domain'_single -> Dfinsupp.comapDomain'_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {κ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : DecidableEq.{succ u3} κ] [_inst_3 : forall (i : ι), Zero.{u2} (β i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u3, succ u1} κ ι h' h) (k : κ) (x : β (h k)), Eq.{succ (max u3 u2)} (Dfinsupp.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_3 (h i))) (Dfinsupp.comapDomain'.{u1, u2, u3} ι (fun (i : ι) => β i) κ (fun (i : ι) => _inst_3 i) h h' hh' (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (h k) x)) (Dfinsupp.single.{u3, u2} κ (fun (k : κ) => β (h k)) (fun (a : κ) (b : κ) => _inst_2 a b) (fun (i : κ) => _inst_3 (h i)) k x)
but is expected to have type
  forall {ι : Type.{u2}} {β : ι -> Type.{u3}} {κ : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : DecidableEq.{succ u1} κ] [_inst_3 : forall (i : ι), Zero.{u3} (β i)] (h : κ -> ι) {h' : ι -> κ} (hh' : Function.LeftInverse.{succ u1, succ u2} κ ι h' h) (k : κ) (x : β (h k)), Eq.{max (succ u3) (succ u1)} (Dfinsupp.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (i : κ) => _inst_3 (h i))) (Dfinsupp.comapDomain'.{u2, u3, u1} ι (fun (i : ι) => β i) κ (fun (i : ι) => _inst_3 i) h h' hh' (Dfinsupp.single.{u2, u3} ι β (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_3 i) (h k) x)) (Dfinsupp.single.{u1, u3} κ (fun (k : κ) => β (h k)) (fun (a : κ) (b : κ) => _inst_2 a b) (fun (i : κ) => _inst_3 (h i)) k x)
Case conversion may be inaccurate. Consider using '#align dfinsupp.comap_domain'_single Dfinsupp.comapDomain'_singleₓ'. -/
@[simp]
theorem comapDomain'_single [DecidableEq ι] [DecidableEq κ] [∀ i, Zero (β i)] (h : κ → ι)
    {h' : ι → κ} (hh' : Function.LeftInverse h' h) (k : κ) (x : β (h k)) :
    comapDomain' h hh' (single (h k) x) = single k x :=
  by
  ext
  rw [comap_domain'_apply]
  obtain rfl | hik := Decidable.eq_or_ne i k
  · rw [single_eq_same, single_eq_same]
  · rw [single_eq_of_ne hik.symm, single_eq_of_ne (hh'.injective.ne hik.symm)]
#align dfinsupp.comap_domain'_single Dfinsupp.comapDomain'_single

#print Dfinsupp.equivCongrLeft /-
/-- Reindexing terms of a dfinsupp.

This is the dfinsupp version of `equiv.Pi_congr_left'`. -/
@[simps apply]
def equivCongrLeft [∀ i, Zero (β i)] (h : ι ≃ κ) : (Π₀ i, β i) ≃ Π₀ k, β (h.symm k)
    where
  toFun := comapDomain' h.symm h.right_inv
  invFun f :=
    mapRange (fun i => Equiv.cast <| congr_arg β <| h.symm_apply_apply i)
      (fun i =>
        (Equiv.cast_eq_iff_heq _).mpr <| by
          convert HEq.rfl
          repeat' exact (h.symm_apply_apply i).symm)
      (@comapDomain' _ _ _ _ h _ h.left_inv f)
  left_inv f := by
    ext i
    rw [map_range_apply, comap_domain'_apply, comap_domain'_apply, Equiv.cast_eq_iff_heq,
      h.symm_apply_apply]
  right_inv f := by
    ext k
    rw [comap_domain'_apply, map_range_apply, comap_domain'_apply, Equiv.cast_eq_iff_heq,
      h.apply_symm_apply]
#align dfinsupp.equiv_congr_left Dfinsupp.equivCongrLeft
-/

section Curry

variable {α : ι → Type _} {δ : ∀ i, α i → Type v}

/- warning: dfinsupp.has_add₂ -> Dfinsupp.hasAdd₂ is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), AddZeroClass.{u2} (δ i j)], Add.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), AddZeroClass.{u2} (δ i j)], Add.{max (max u2 u3) u1} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u2} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u2} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.has_add₂ Dfinsupp.hasAdd₂ₓ'. -/
-- lean can't find these instances
instance hasAdd₂ [∀ i j, AddZeroClass (δ i j)] : Add (Π₀ (i : ι) (j : α i), δ i j) :=
  @Dfinsupp.hasAdd ι (fun i => Π₀ j, δ i j) _
#align dfinsupp.has_add₂ Dfinsupp.hasAdd₂

/- warning: dfinsupp.add_zero_class₂ -> Dfinsupp.addZeroClass₂ is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), AddZeroClass.{u2} (δ i j)], AddZeroClass.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), AddZeroClass.{u2} (δ i j)], AddZeroClass.{max (max u2 u3) u1} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u2} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u2} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.add_zero_class₂ Dfinsupp.addZeroClass₂ₓ'. -/
instance addZeroClass₂ [∀ i j, AddZeroClass (δ i j)] : AddZeroClass (Π₀ (i : ι) (j : α i), δ i j) :=
  @Dfinsupp.addZeroClass ι (fun i => Π₀ j, δ i j) _
#align dfinsupp.add_zero_class₂ Dfinsupp.addZeroClass₂

/- warning: dfinsupp.add_monoid₂ -> Dfinsupp.addMonoid₂ is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), AddMonoid.{u2} (δ i j)], AddMonoid.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_1 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_1 i i_1)))))
but is expected to have type
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), AddMonoid.{u2} (δ i j)], AddMonoid.{max (max u2 u3) u1} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u2} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u2} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.add_monoid₂ Dfinsupp.addMonoid₂ₓ'. -/
instance addMonoid₂ [∀ i j, AddMonoid (δ i j)] : AddMonoid (Π₀ (i : ι) (j : α i), δ i j) :=
  @Dfinsupp.addMonoid ι (fun i => Π₀ j, δ i j) _
#align dfinsupp.add_monoid₂ Dfinsupp.addMonoid₂

/- warning: dfinsupp.distrib_mul_action₂ -> Dfinsupp.distribMulAction₂ is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι) (j : α i), AddMonoid.{u2} (δ i j)] [_inst_3 : forall (i : ι) (j : α i), DistribMulAction.{u3, u2} γ (δ i j) _inst_1 (_inst_2 i j)], DistribMulAction.{u3, max u1 u4 u2} γ (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))))) _inst_1 (Dfinsupp.addMonoid₂.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_2 i i_1))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι) (j : α i), AddMonoid.{u2} (δ i j)] [_inst_3 : forall (i : ι) (j : α i), DistribMulAction.{u3, u2} γ (δ i j) _inst_1 (_inst_2 i j)], DistribMulAction.{u3, max (max u2 u4) u1} γ (Dfinsupp.{u1, max u2 u4} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u2} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u2} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1)))) _inst_1 (Dfinsupp.addMonoid₂.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_2 i i_1))
Case conversion may be inaccurate. Consider using '#align dfinsupp.distrib_mul_action₂ Dfinsupp.distribMulAction₂ₓ'. -/
instance distribMulAction₂ [Monoid γ] [∀ i j, AddMonoid (δ i j)]
    [∀ i j, DistribMulAction γ (δ i j)] : DistribMulAction γ (Π₀ (i : ι) (j : α i), δ i j) :=
  @Dfinsupp.distribMulAction ι _ (fun i => Π₀ j, δ i j) _ _ _
#align dfinsupp.distrib_mul_action₂ Dfinsupp.distribMulAction₂

/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
#print Dfinsupp.sigmaCurry /-
/-- The natural map between `Π₀ (i : Σ i, α i), δ i.1 i.2` and `Π₀ i (j : α i), δ i j`.  -/
noncomputable def sigmaCurry [∀ i j, Zero (δ i j)] (f : Π₀ i : Σi, _, δ i.1 i.2) :
    Π₀ (i) (j), δ i j := by
  classical exact
      mk (f.support.image fun i => i.1) fun i =>
        mk (f.support.preimage (Sigma.mk i) <| sigma_mk_injective.inj_on _) fun j => f ⟨i, j⟩
#align dfinsupp.sigma_curry Dfinsupp.sigmaCurry
-/

/- warning: dfinsupp.sigma_curry_apply -> Dfinsupp.sigmaCurry_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), Zero.{u2} (δ i j)] (f : Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (i : ι) (j : α i), Eq.{succ u2} (δ i j) (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (Dfinsupp.{u3, u2} ((fun (i : ι) => α i) i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (_x : Dfinsupp.{u3, u2} ((fun (i : ι) => α i) i) (fun (i_1 : α i) => δ i i_1) (fun (i_1 : α i) => _inst_1 i i_1)) => forall (i_1 : α i), δ i i_1) (Dfinsupp.hasCoeToFun.{u3, u2} ((fun (i : ι) => α i) i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (coeFn.{succ (max u1 u3 u2), max (succ u1) (succ (max u3 u2))} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} ((fun (i : ι) => α i) i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} ((fun (i : ι) => α i) i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (fun (_x : Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} ((fun (i : ι) => α i) i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} ((fun (i : ι) => α i) i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) => forall (i : ι), Dfinsupp.{u3, u2} ((fun (i : ι) => α i) i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (Dfinsupp.hasCoeToFun.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} ((fun (i : ι) => α i) i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} ((fun (i : ι) => α i) i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (Dfinsupp.sigmaCurry.{u1, u2, u3} ι (fun (i : ι) => α i) δ _inst_1 f) i) j) (coeFn.{succ (max (max u1 u3) u2), max (succ (max u1 u3)) (succ u2)} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (fun (_x : Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) => forall (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)), δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (Dfinsupp.hasCoeToFun.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) f (Sigma.mk.{u1, u3} ι (fun (i : ι) => α i) i j))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_1 : forall (i : ι) (j : α i), Zero.{u3} (δ i j)] (f : Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (i : ι) (j : α i), Eq.{succ u3} ((fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) j) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Dfinsupp.{u1, u3} (α i) (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) (fun (i_1 : α i) => (fun (i_1 : α i) => _inst_1 i i_1) i_1)) (α i) (fun (_x : α i) => (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) _x) (Dfinsupp.funLike.{u1, u3} (α i) (fun (j : α i) => (fun (j : α i) => δ i j) j) (fun (i_1 : α i) => (fun (i_1 : α i) => _inst_1 i i_1) i_1)) (FunLike.coe.{max (succ u2) (succ (max u3 u1)), succ u2, succ (max u3 u1)} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i) (fun (i : ι) => (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i) _x) (Dfinsupp.funLike.{u2, max u3 u1} ι (fun (i : ι) => (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i) (fun (i : ι) => (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i)) (Dfinsupp.sigmaCurry.{u2, u3, u1} ι (fun (i : ι) => α i) δ _inst_1 f) i) j) (FunLike.coe.{max (succ (max u2 u1)) (succ u3), succ (max u2 u1), succ u3} (Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i)) (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (_x : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) _x) (Dfinsupp.funLike.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i)) f (Sigma.mk.{u2, u1} ι (fun (i : ι) => α i) i j))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_curry_apply Dfinsupp.sigmaCurry_applyₓ'. -/
@[simp]
theorem sigmaCurry_apply [∀ i j, Zero (δ i j)] (f : Π₀ i : Σi, _, δ i.1 i.2) (i : ι) (j : α i) :
    sigmaCurry f i j = f ⟨i, j⟩ := by
  dsimp only [sigma_curry]; by_cases h : f ⟨i, j⟩ = 0
  · rw [h, mk_apply]
    split_ifs
    · rw [mk_apply]
      split_ifs
      · exact h
      · rfl
    · rfl
  · rw [mk_of_mem, mk_of_mem]
    · rfl
    · rw [mem_preimage, mem_support_to_fun]
      exact h
    · rw [mem_image]
      refine' ⟨⟨i, j⟩, _, rfl⟩
      rw [mem_support_to_fun]
      exact h
#align dfinsupp.sigma_curry_apply Dfinsupp.sigmaCurry_apply

/- warning: dfinsupp.sigma_curry_zero -> Dfinsupp.sigmaCurry_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), Zero.{u2} (δ i j)], Eq.{succ (max u1 u3 u2)} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (Dfinsupp.sigmaCurry.{u1, u2, u3} ι (fun (i : ι) => α i) δ _inst_1 (OfNat.ofNat.{max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) 0 (OfNat.mk.{max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) 0 (Zero.zero.{max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (Dfinsupp.hasZero.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))))))) (OfNat.ofNat.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) 0 (OfNat.mk.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) 0 (Zero.zero.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (Dfinsupp.hasZero.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_1 : forall (i : ι) (j : α i), Zero.{u3} (δ i j)], Eq.{max (max (succ u2) (succ u3)) (succ u1)} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (Dfinsupp.sigmaCurry.{u2, u3, u1} ι (fun (i : ι) => α i) δ _inst_1 (OfNat.ofNat.{max (max u2 u3) u1} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) 0 (Zero.toOfNat0.{max (max u2 u3) u1} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (Dfinsupp.instZeroDfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))))) (OfNat.ofNat.{max (max u2 u3) u1} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) 0 (Zero.toOfNat0.{max (max u2 u3) u1} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (Dfinsupp.instZeroDfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_curry_zero Dfinsupp.sigmaCurry_zeroₓ'. -/
@[simp]
theorem sigmaCurry_zero [∀ i j, Zero (δ i j)] : sigmaCurry (0 : Π₀ i : Σi, _, δ i.1 i.2) = 0 :=
  by
  ext (i j)
  rw [sigma_curry_apply]
  rfl
#align dfinsupp.sigma_curry_zero Dfinsupp.sigmaCurry_zero

/- warning: dfinsupp.sigma_curry_add -> Dfinsupp.sigmaCurry_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), AddZeroClass.{u2} (δ i j)] (f : Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} ((fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) i) (_inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)))) (g : Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} ((fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) i) (_inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)))), Eq.{succ (max u1 u3 u2)} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1))) (Dfinsupp.sigmaCurry.{u1, u2, u3} ι (fun (i : ι) => α i) δ (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) (HAdd.hAdd.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (instHAdd.{max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (Dfinsupp.hasAdd.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)))) f g)) (HAdd.hAdd.{max u1 u3 u2, max u1 u3 u2, max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1))) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1))) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1))) (instHAdd.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) i i_1))) (Dfinsupp.hasAdd₂.{u1, u2, u3} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_1 i i_1))) (Dfinsupp.sigmaCurry.{u1, u2, u3} ι (fun (i : ι) => α i) δ (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) f) (Dfinsupp.sigmaCurry.{u1, u2, u3} ι α δ (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j)) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_1 : forall (i : ι) (j : α i), AddZeroClass.{u3} (δ i j)] (f : Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (g : Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))), Eq.{max (max (succ u2) (succ u3)) (succ u1)} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1)))) (Dfinsupp.sigmaCurry.{u2, u3, u1} ι (fun (i : ι) => α i) δ (fun (i : ι) (j : α i) => AddZeroClass.toZero.{u3} (δ i j) (_inst_1 i j)) (HAdd.hAdd.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (instHAdd.{max (max u2 u3) u1} (Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.instAddDfinsuppToZero.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) f g)) (HAdd.hAdd.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1)))) (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1)))) (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1)))) (instHAdd.{max (max u2 u3) u1} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} (δ i i_1) (_inst_1 i i_1)))) (Dfinsupp.hasAdd₂.{u2, u3, u1} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_1 i i_1))) (Dfinsupp.sigmaCurry.{u2, u3, u1} ι (fun (i : ι) => α i) δ (fun (i : ι) (j : α i) => AddZeroClass.toZero.{u3} (δ i j) (_inst_1 i j)) f) (Dfinsupp.sigmaCurry.{u2, u3, u1} ι α δ (fun (i : ι) (j : α i) => AddZeroClass.toZero.{u3} (δ i j) (_inst_1 i j)) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_curry_add Dfinsupp.sigmaCurry_addₓ'. -/
@[simp]
theorem sigmaCurry_add [∀ i j, AddZeroClass (δ i j)] (f g : Π₀ i : Σi, α i, δ i.1 i.2) :
    @sigmaCurry _ _ δ _ (f + g) = @sigmaCurry _ _ δ _ f + @sigmaCurry ι α δ _ g :=
  by
  ext (i j)
  rw [@add_apply _ (fun i => Π₀ j, δ i j) _ (sigma_curry _), add_apply, sigma_curry_apply,
    sigma_curry_apply, sigma_curry_apply, add_apply]
#align dfinsupp.sigma_curry_add Dfinsupp.sigmaCurry_add

/- warning: dfinsupp.sigma_curry_smul -> Dfinsupp.sigmaCurry_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι) (j : α i), AddMonoid.{u2} (δ i j)] [_inst_3 : forall (i : ι) (j : α i), DistribMulAction.{u3, u2} γ (δ i j) _inst_1 (_inst_2 i j)] (r : γ) (f : Dfinsupp.{max u1 u4, u2} (Sigma.{u1, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} ((fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) i) (_inst_2 (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i))))), Eq.{succ (max u1 u4 u2)} (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1))) (Dfinsupp.sigmaCurry.{u1, u2, u4} ι (fun (i : ι) => α i) δ (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) (SMul.smul.{u3, max (max u1 u4) u2} γ (Dfinsupp.{max u1 u4, u2} (Sigma.{u1, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i))) (Dfinsupp.hasSmul.{max u1 u4, u2, u3} (Sigma.{u1, u4} ι (fun (i : ι) => α i)) γ (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) _inst_1 (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => _inst_2 (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i))) r f)) (SMul.smul.{u3, max u1 u4 u2} γ (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1))) (SMulZeroClass.toHasSmul.{u3, max u1 u4 u2} γ (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1))) (AddZeroClass.toHasZero.{max u1 u4 u2} (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1))) (AddMonoid.toAddZeroClass.{max u1 u4 u2} (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1))) (Dfinsupp.addMonoid₂.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_2 i i_1)))) (DistribSMul.toSmulZeroClass.{u3, max u1 u4 u2} γ (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1))) (AddMonoid.toAddZeroClass.{max u1 u4 u2} (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1))) (Dfinsupp.addMonoid₂.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_2 i i_1))) (DistribMulAction.toDistribSMul.{u3, max u1 u4 u2} γ (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) i i_1))) _inst_1 (Dfinsupp.addMonoid₂.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_2 i i_1)) (Dfinsupp.distribMulAction₂.{u1, u2, u3, u4} ι γ (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) _inst_1 (fun (i : ι) (i_1 : α i) => _inst_2 i i_1) (fun (i : ι) (j : α i) => _inst_3 i j))))) r (Dfinsupp.sigmaCurry.{u1, u2, u4} ι (fun (i : ι) => α i) δ (fun (i : ι) (j : α i) => AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j))) f))
but is expected to have type
  forall {ι : Type.{u2}} {γ : Type.{u4}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_1 : Monoid.{u4} γ] [_inst_2 : forall (i : ι) (j : α i), AddMonoid.{u3} (δ i j)] [_inst_3 : forall (i : ι) (j : α i), DistribMulAction.{u4, u3} γ (δ i j) _inst_1 (_inst_2 i j)] (r : γ) (f : Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddMonoid.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))), Eq.{max (max (succ u2) (succ u3)) (succ u1)} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} (δ i i_1) (_inst_2 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} (δ i i_1) (_inst_2 i i_1)))) (Dfinsupp.sigmaCurry.{u2, u3, u1} ι (fun (i : ι) => α i) δ (fun (i : ι) (j : α i) => AddMonoid.toZero.{u3} (δ i j) (_inst_2 i j)) (HSMul.hSMul.{u4, max (max u2 u3) u1, max (max u2 u3) u1} γ (Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddMonoid.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddMonoid.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (instHSMul.{u4, max (max u2 u3) u1} γ (Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddMonoid.toZero.{u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (_inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.instSMulDfinsuppToZero.{max u2 u1, u3, u4} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) γ (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) _inst_1 (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) r f)) (HSMul.hSMul.{u4, max (max u2 u3) u1, max (max u2 u3) u1} γ (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} (δ i i_1) (_inst_2 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} (δ i i_1) (_inst_2 i i_1)))) (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} (δ i i_1) (_inst_2 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} (δ i i_1) (_inst_2 i i_1)))) (instHSMul.{u4, max (max u2 u3) u1} γ (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} (δ i i_1) (_inst_2 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} (δ i i_1) (_inst_2 i i_1)))) (Dfinsupp.instSMulDfinsuppToZero.{u2, max u3 u1, u4} ι γ (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} (δ i i_1) (_inst_2 i i_1))) _inst_1 (fun (i : ι) => Dfinsupp.instAddMonoidDfinsuppToZero.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_2 i i_1)) (fun (i : ι) => Dfinsupp.distribMulAction.{u1, u3, u4} (α i) γ (fun (j : α i) => δ i j) _inst_1 (fun (i_1 : α i) => _inst_2 i i_1) (fun (i_1 : α i) => _inst_3 i i_1)))) r (Dfinsupp.sigmaCurry.{u2, u3, u1} ι (fun (i : ι) => α i) δ (fun (i : ι) (j : α i) => AddMonoid.toZero.{u3} (δ i j) (_inst_2 i j)) f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_curry_smul Dfinsupp.sigmaCurry_smulₓ'. -/
@[simp]
theorem sigmaCurry_smul [Monoid γ] [∀ i j, AddMonoid (δ i j)] [∀ i j, DistribMulAction γ (δ i j)]
    (r : γ) (f : Π₀ i : Σi, α i, δ i.1 i.2) :
    @sigmaCurry _ _ δ _ (r • f) = r • @sigmaCurry _ _ δ _ f :=
  by
  ext (i j)
  rw [@smul_apply _ _ (fun i => Π₀ j, δ i j) _ _ _ _ (sigma_curry _), smul_apply, sigma_curry_apply,
    sigma_curry_apply, smul_apply]
#align dfinsupp.sigma_curry_smul Dfinsupp.sigmaCurry_smul

/- warning: dfinsupp.sigma_curry_single -> Dfinsupp.sigmaCurry_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : ι), DecidableEq.{succ u3} (α i)] [_inst_3 : forall (i : ι) (j : α i), Zero.{u2} (δ i j)] (ij : Sigma.{u1, u3} ι (fun (i : ι) => α i)) (x : δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) ij)), Eq.{succ (max u1 u3 u2)} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (Dfinsupp.sigmaCurry.{u1, u2, u3} ι (fun (i : ι) => α i) δ _inst_3 (Dfinsupp.single.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (ij : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) ij)) (fun (a : Sigma.{u1, u3} ι (fun (i : ι) => α i)) (b : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => Sigma.decidableEq.{u1, u3} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (a : ι) (a_1 : α a) (b : α a) => _inst_2 a a_1 b) a b) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) ij x)) (Dfinsupp.single.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij) (Dfinsupp.single.{u3, u2} (α (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij)) (fun (j : α (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij) j) (fun (a : α (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij)) (b : α (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij)) => _inst_2 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij) a b) (fun (i : α (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij)) => _inst_3 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) ij) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) ij) x))
but is expected to have type
  forall {ι : Type.{u2}} [α : DecidableEq.{succ u2} ι] {δ : ι -> Type.{u1}} {_inst_1 : forall (i : ι), (δ i) -> Type.{u3}} [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (δ i)] [_inst_3 : forall (i : ι) (j : δ i), Zero.{u3} (_inst_1 i j)] (ij : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) (x : _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij) (Sigma.snd.{u2, u1} ι (fun (i : ι) => δ i) ij)), Eq.{max (max (succ u2) (succ u3)) (succ u1)} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (δ i) (fun (j : δ i) => _inst_1 i j) (fun (i_1 : δ i) => _inst_3 i i_1)) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (δ i) (fun (j : δ i) => _inst_1 i j) (fun (i_1 : δ i) => _inst_3 i i_1))) (Dfinsupp.sigmaCurry.{u2, u3, u1} ι (fun (i : ι) => δ i) _inst_1 _inst_3 (Dfinsupp.single.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => δ i)) (fun (ij : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij) (Sigma.snd.{u2, u1} ι (fun (i : ι) => δ i) ij)) (fun (a : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) (b : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) => Sigma.instDecidableEqSigma.{u2, u1} ι (fun (i : ι) => δ i) (fun (a : ι) (b : ι) => α a b) (fun (a : ι) => (fun (a : ι) (a_1 : δ a) (b : δ a) => _inst_2 a a_1 b) a) a b) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => δ i) i)) ij x)) (Dfinsupp.single.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (δ i) (fun (j : δ i) => _inst_1 i j) (fun (i_1 : δ i) => _inst_3 i i_1)) (fun (a : ι) (b : ι) => α a b) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (δ i) (fun (j : δ i) => _inst_1 i j) (fun (i_1 : δ i) => _inst_3 i i_1)) (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij) (Dfinsupp.single.{u1, u3} (δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij)) (fun (j : δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij) j) (fun (a : δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij)) (b : δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij)) => _inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij) a b) (fun (i : δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) ij) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => δ i) ij) x))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_curry_single Dfinsupp.sigmaCurry_singleₓ'. -/
@[simp]
theorem sigmaCurry_single [DecidableEq ι] [∀ i, DecidableEq (α i)] [∀ i j, Zero (δ i j)]
    (ij : Σi, α i) (x : δ ij.1 ij.2) :
    @sigmaCurry _ _ _ _ (single ij x) = single ij.1 (single ij.2 x : Π₀ j, δ ij.1 j) :=
  by
  obtain ⟨i, j⟩ := ij
  ext (i' j')
  dsimp only
  rw [sigma_curry_apply]
  obtain rfl | hi := eq_or_ne i i'
  · rw [single_eq_same]
    obtain rfl | hj := eq_or_ne j j'
    · rw [single_eq_same, single_eq_same]
    · rw [single_eq_of_ne, single_eq_of_ne hj]
      simpa using hj
  · rw [single_eq_of_ne, single_eq_of_ne hi, zero_apply]
    simpa using hi
#align dfinsupp.sigma_curry_single Dfinsupp.sigmaCurry_single

/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
#print Dfinsupp.sigmaUncurry /-
/-- The natural map between `Π₀ i (j : α i), δ i j` and `Π₀ (i : Σ i, α i), δ i.1 i.2`, inverse of
`curry`.-/
def sigmaUncurry [∀ i j, Zero (δ i j)] [∀ i, DecidableEq (α i)]
    [∀ (i j) (x : δ i j), Decidable (x ≠ 0)] (f : Π₀ (i) (j), δ i j) : Π₀ i : Σi, _, δ i.1 i.2
    where
  toFun i := f i.1 i.2
  support' :=
    f.support'.map fun s =>
      ⟨Multiset.bind ↑s fun i => ((f i).support.map ⟨Sigma.mk i, sigma_mk_injective⟩).val, fun i =>
        by
        simp_rw [Multiset.mem_bind, map_val, Multiset.mem_map, Function.Embedding.coeFn_mk, ←
          Finset.mem_def, mem_support_to_fun]
        obtain hi | (hi : f i.1 = 0) := s.prop i.1
        · by_cases hi' : f i.1 i.2 = 0
          · exact Or.inr hi'
          · exact Or.inl ⟨_, hi, i.2, hi', Sigma.eta _⟩
        · right
          rw [hi, zero_apply]⟩
#align dfinsupp.sigma_uncurry Dfinsupp.sigmaUncurry
-/

/- warning: dfinsupp.sigma_uncurry_apply -> Dfinsupp.sigmaUncurry_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), Zero.{u2} (δ i j)] [_inst_2 : forall (i : ι), DecidableEq.{succ u3} (α i)] [_inst_3 : forall (i : ι) (j : α i) (x : δ i j), Decidable (Ne.{succ u2} (δ i j) x (OfNat.ofNat.{u2} (δ i j) 0 (OfNat.mk.{u2} (δ i j) 0 (Zero.zero.{u2} (δ i j) (_inst_1 i j)))))] (f : Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (i : ι) (j : α i), Eq.{succ u2} ((fun (i : ι) (j : α i) => δ i j) (Sigma.fst.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) (Sigma.mk.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i j)) (Sigma.snd.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) (Sigma.mk.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i j))) (coeFn.{succ (max (max u1 u3) u2), max (succ (max u1 u3)) (succ u2)} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)) => (fun (i : ι) (j : α i) => δ i j) (Sigma.fst.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)) => (fun (i : ι) (i_1 : α i) => _inst_1 i i_1) (Sigma.fst.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i))) (fun (_x : Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)) => (fun (i : ι) (j : α i) => δ i j) (Sigma.fst.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)) => (fun (i : ι) (i_1 : α i) => _inst_1 i i_1) (Sigma.fst.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i))) => forall (i : Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)), (fun (i : ι) (j : α i) => δ i j) (Sigma.fst.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i)) (Dfinsupp.hasCoeToFun.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)) => (fun (i : ι) (j : α i) => δ i j) (Sigma.fst.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i)) => (fun (i : ι) (i_1 : α i) => _inst_1 i i_1) (Sigma.fst.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i))) (Dfinsupp.sigmaUncurry.{u1, u2, u3} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_1 i i_1) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) f) (Sigma.mk.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => α i) i) i j)) (coeFn.{succ (max u3 u2), max (succ u3) (succ u2)} (Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (_x : Dfinsupp.{u3, u2} (α i) (fun (i_1 : α i) => δ i i_1) (fun (i_1 : α i) => _inst_1 i i_1)) => forall (i_1 : α i), δ i i_1) (Dfinsupp.hasCoeToFun.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (coeFn.{succ (max u1 u3 u2), max (succ u1) (succ (max u3 u2))} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (fun (_x : Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) => forall (i : ι), Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (Dfinsupp.hasCoeToFun.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) f i) j)
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_1 : forall (i : ι) (j : α i), Zero.{u3} (δ i j)] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι) (j : α i) (x : δ i j), Decidable (Ne.{succ u3} (δ i j) x (OfNat.ofNat.{u3} (δ i j) 0 (Zero.toOfNat0.{u3} (δ i j) (_inst_1 i j))))] (f : Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (i : ι) (j : α i), Eq.{succ u3} ((fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (Sigma.mk.{u2, u1} ι (fun (i : ι) => α i) i j)) (FunLike.coe.{max (succ (max u2 u1)) (succ u3), succ (max u2 u1), succ u3} (Dfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i)) (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (_x : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) _x) (Dfinsupp.funLike.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) i)) (Dfinsupp.sigmaUncurry.{u2, u3, u1} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_1 i i_1) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) f) (Sigma.mk.{u2, u1} ι (fun (i : ι) => α i) i j)) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Dfinsupp.{u1, u3} (α i) (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) (fun (i_1 : α i) => (fun (i_1 : α i) => _inst_1 i i_1) i_1)) (α i) (fun (_x : α i) => (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) _x) (Dfinsupp.funLike.{u1, u3} (α i) (fun (j : α i) => (fun (j : α i) => δ i j) j) (fun (i_1 : α i) => (fun (i_1 : α i) => _inst_1 i i_1) i_1)) (FunLike.coe.{max (succ u2) (succ (max u3 u1)), succ u2, succ (max u3 u1)} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i) (fun (i : ι) => (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i) _x) (Dfinsupp.funLike.{u2, max u3 u1} ι (fun (i : ι) => (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i) (fun (i : ι) => (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i)) f i) j)
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_uncurry_apply Dfinsupp.sigmaUncurry_applyₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem sigmaUncurry_apply [∀ i j, Zero (δ i j)] [∀ i, DecidableEq (α i)]
    [∀ (i j) (x : δ i j), Decidable (x ≠ 0)] (f : Π₀ (i) (j), δ i j) (i : ι) (j : α i) :
    sigmaUncurry f ⟨i, j⟩ = f i j :=
  rfl
#align dfinsupp.sigma_uncurry_apply Dfinsupp.sigmaUncurry_apply

/- warning: dfinsupp.sigma_uncurry_zero -> Dfinsupp.sigmaUncurry_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), Zero.{u2} (δ i j)] [_inst_2 : forall (i : ι), DecidableEq.{succ u3} (α i)] [_inst_3 : forall (i : ι) (j : α i) (x : δ i j), Decidable (Ne.{succ u2} (δ i j) x (OfNat.ofNat.{u2} (δ i j) 0 (OfNat.mk.{u2} (δ i j) 0 (Zero.zero.{u2} (δ i j) (_inst_1 i j)))))], Eq.{succ (max (max u1 u3) u2)} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (Dfinsupp.sigmaUncurry.{u1, u2, u3} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_1 i i_1) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) (OfNat.ofNat.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) 0 (OfNat.mk.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) 0 (Zero.zero.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (Dfinsupp.hasZero.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))))))) (OfNat.ofNat.{max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) 0 (OfNat.mk.{max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) 0 (Zero.zero.{max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (Dfinsupp.hasZero.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_1 : forall (i : ι) (j : α i), Zero.{u3} (δ i j)] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι) (j : α i) (x : δ i j), Decidable (Ne.{succ u3} (δ i j) x (OfNat.ofNat.{u3} (δ i j) 0 (Zero.toOfNat0.{u3} (δ i j) (_inst_1 i j))))], Eq.{max (max (succ u2) (succ u3)) (succ u1)} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (Dfinsupp.sigmaUncurry.{u2, u3, u1} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_1 i i_1) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) (OfNat.ofNat.{max (max u2 u3) u1} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) 0 (Zero.toOfNat0.{max (max u2 u3) u1} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1))) (Dfinsupp.instZeroDfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)))))) (OfNat.ofNat.{max (max u2 u3) u1} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) 0 (Zero.toOfNat0.{max (max u2 u3) u1} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (Dfinsupp.instZeroDfinsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_uncurry_zero Dfinsupp.sigmaUncurry_zeroₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem sigmaUncurry_zero [∀ i j, Zero (δ i j)] [∀ i, DecidableEq (α i)]
    [∀ (i j) (x : δ i j), Decidable (x ≠ 0)] : sigmaUncurry (0 : Π₀ (i) (j), δ i j) = 0 :=
  rfl
#align dfinsupp.sigma_uncurry_zero Dfinsupp.sigmaUncurry_zero

/- warning: dfinsupp.sigma_uncurry_add -> Dfinsupp.sigmaUncurry_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), AddZeroClass.{u2} (δ i j)] [_inst_2 : forall (i : ι), DecidableEq.{succ u3} (α i)] [_inst_3 : forall (i : ι) (j : α i) (x : δ i j), Decidable (Ne.{succ u2} (δ i j) x (OfNat.ofNat.{u2} (δ i j) 0 (OfNat.mk.{u2} (δ i j) 0 (Zero.zero.{u2} (δ i j) (AddZeroClass.toHasZero.{u2} (δ i j) (_inst_1 i j))))))] (f : Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1)))) (g : Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1)))), Eq.{succ (max (max u1 u3) u2)} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} (δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)))) (Dfinsupp.sigmaUncurry.{u1, u2, u3} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1)) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) (HAdd.hAdd.{max u1 u3 u2, max u1 u3 u2, max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1)))) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1)))) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1)))) (instHAdd.{max u1 u3 u2} (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1)))) (Dfinsupp.hasAdd₂.{u1, u2, u3} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_1 i i_1))) f g)) (HAdd.hAdd.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} (δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)))) (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} (δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)))) (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} (δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)))) (instHAdd.{max (max u1 u3) u2} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} (δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)))) (Dfinsupp.hasAdd.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)))) (Dfinsupp.sigmaUncurry.{u1, u2, u3} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1)) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) f) (Dfinsupp.sigmaUncurry.{u1, u2, u3} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (_inst_1 i i_1)) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_1 : forall (i : ι) (j : α i), AddZeroClass.{u3} (δ i j)] [_inst_2 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_3 : forall (i : ι) (j : α i) (x : δ i j), Decidable (Ne.{succ u3} (δ i j) x (OfNat.ofNat.{u3} (δ i j) 0 (Zero.toOfNat0.{u3} (δ i j) (AddZeroClass.toZero.{u3} (δ i j) (_inst_1 i j)))))] (f : Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1)))) (g : Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1)))), Eq.{max (max (succ u2) (succ u3)) (succ u1)} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (j : α (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) j) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.sigmaUncurry.{u2, u3, u1} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1)) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) (HAdd.hAdd.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1)))) (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1)))) (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1)))) (instHAdd.{max (max u2 u3) u1} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1)))) (Dfinsupp.hasAdd₂.{u2, u3, u1} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_1 i i_1))) f g)) (HAdd.hAdd.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (j : α (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) j) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (j : α (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) j) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (j : α (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) j) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (instHAdd.{max (max u2 u3) u1} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddZeroClass.toZero.{u3} ((fun (j : α (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) j) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (_inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.instAddDfinsuppToZero.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.sigmaUncurry.{u2, u3, u1} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1)) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) f) (Dfinsupp.sigmaUncurry.{u2, u3, u1} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddZeroClass.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_1 i i_1)) (fun (i : ι) (a : α i) (b : α i) => _inst_2 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_3 i j x) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_uncurry_add Dfinsupp.sigmaUncurry_addₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem sigmaUncurry_add [∀ i j, AddZeroClass (δ i j)] [∀ i, DecidableEq (α i)]
    [∀ (i j) (x : δ i j), Decidable (x ≠ 0)] (f g : Π₀ (i) (j), δ i j) :
    sigmaUncurry (f + g) = sigmaUncurry f + sigmaUncurry g :=
  coeFn_injective rfl
#align dfinsupp.sigma_uncurry_add Dfinsupp.sigmaUncurry_add

/- warning: dfinsupp.sigma_uncurry_smul -> Dfinsupp.sigmaUncurry_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : ι) (j : α i), AddMonoid.{u2} (δ i j)] [_inst_3 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_4 : forall (i : ι) (j : α i) (x : δ i j), Decidable (Ne.{succ u2} (δ i j) x (OfNat.ofNat.{u2} (δ i j) 0 (OfNat.mk.{u2} (δ i j) 0 (Zero.zero.{u2} (δ i j) (AddZeroClass.toHasZero.{u2} (δ i j) (AddMonoid.toAddZeroClass.{u2} (δ i j) (_inst_2 i j)))))))] [_inst_5 : forall (i : ι) (j : α i), DistribMulAction.{u3, u2} γ (δ i j) _inst_1 (_inst_2 i j)] (r : γ) (f : Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))))), Eq.{succ (max (max u1 u4) u2)} (Dfinsupp.{max u1 u4, u2} (Sigma.{u1, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} (δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (AddMonoid.toAddZeroClass.{u2} (δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (_inst_2 (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i))))) (Dfinsupp.sigmaUncurry.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))) (fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_4 i j x) (SMul.smul.{u3, max u1 u4 u2} γ (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))))) (SMulZeroClass.toHasSmul.{u3, max u1 u4 u2} γ (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))))) (AddZeroClass.toHasZero.{max u1 u4 u2} (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))))) (AddMonoid.toAddZeroClass.{max u1 u4 u2} (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))))) (Dfinsupp.addMonoid₂.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_2 i i_1)))) (DistribSMul.toSmulZeroClass.{u3, max u1 u4 u2} γ (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))))) (AddMonoid.toAddZeroClass.{max u1 u4 u2} (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))))) (Dfinsupp.addMonoid₂.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_2 i i_1))) (DistribMulAction.toDistribSMul.{u3, max u1 u4 u2} γ (Dfinsupp.{u1, max u4 u2} ι (fun (i : ι) => Dfinsupp.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1)))) (fun (i : ι) => Dfinsupp.hasZero.{u4, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))))) _inst_1 (Dfinsupp.addMonoid₂.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_2 i i_1)) (Dfinsupp.distribMulAction₂.{u1, u2, u3, u4} ι γ (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) _inst_1 (fun (i : ι) (i_1 : α i) => _inst_2 i i_1) (fun (i : ι) (j : α i) => _inst_5 i j))))) r f)) (SMul.smul.{u3, max (max u1 u4) u2} γ (Dfinsupp.{max u1 u4, u2} (Sigma.{u1, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => AddZeroClass.toHasZero.{u2} (δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (AddMonoid.toAddZeroClass.{u2} (δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (_inst_2 (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i))))) (Dfinsupp.hasSmul.{max u1 u4, u2, u3} (Sigma.{u1, u4} ι (fun (i : ι) => α i)) γ (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) _inst_1 (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => _inst_2 (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u4} ι (fun (i : ι) => α i)) => _inst_5 (Sigma.fst.{u1, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u4} ι (fun (i : ι) => α i) i))) r (Dfinsupp.sigmaUncurry.{u1, u2, u4} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddZeroClass.toHasZero.{u2} (δ i i_1) (AddMonoid.toAddZeroClass.{u2} (δ i i_1) (_inst_2 i i_1))) (fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_4 i j x) f))
but is expected to have type
  forall {ι : Type.{u2}} {γ : Type.{u4}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_1 : Monoid.{u4} γ] [_inst_2 : forall (i : ι) (j : α i), AddMonoid.{u3} (δ i j)] [_inst_3 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_4 : forall (i : ι) (j : α i) (x : δ i j), Decidable (Ne.{succ u3} (δ i j) x (OfNat.ofNat.{u3} (δ i j) 0 (Zero.toOfNat0.{u3} (δ i j) (AddMonoid.toZero.{u3} (δ i j) (_inst_2 i j)))))] [_inst_5 : forall (i : ι) (j : α i), DistribMulAction.{u4, u3} γ (δ i j) _inst_1 (_inst_2 i j)] (r : γ) (f : Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1)))), Eq.{max (max (succ u2) (succ u3)) (succ u1)} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddMonoid.toZero.{u3} ((fun (j : α (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) j) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (_inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.sigmaUncurry.{u2, u3, u1} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1)) (fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_4 i j x) (HSMul.hSMul.{u4, max (max u2 u3) u1, max (max u2 u3) u1} γ (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1)))) (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1)))) (instHSMul.{u4, max (max u2 u3) u1} γ (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1))) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1)))) (Dfinsupp.instSMulDfinsuppToZero.{u2, max u3 u1, u4} ι γ (fun (i : ι) => Dfinsupp.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1))) _inst_1 (fun (i : ι) => Dfinsupp.instAddMonoidDfinsuppToZero.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_2 i i_1)) (fun (i : ι) => Dfinsupp.distribMulAction.{u1, u3, u4} (α i) γ (fun (j : α i) => δ i j) _inst_1 (fun (i_1 : α i) => _inst_2 i i_1) (fun (i_1 : α i) => _inst_5 i i_1)))) r f)) (HSMul.hSMul.{u4, max (max u1 u3) u2, max (max u2 u3) u1} γ (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddMonoid.toZero.{u3} ((fun (j : α (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) j) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (_inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddMonoid.toZero.{u3} ((fun (j : α (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) j) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (_inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (instHSMul.{u4, max (max u2 u3) u1} γ (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => AddMonoid.toZero.{u3} ((fun (j : α (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) j) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (_inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) (Dfinsupp.instSMulDfinsuppToZero.{max u2 u1, u3, u4} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) γ (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) _inst_1 (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_5 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))) r (Dfinsupp.sigmaUncurry.{u2, u3, u1} ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => AddMonoid.toZero.{u3} ((fun (j : α i) => δ i j) i_1) (_inst_2 i i_1)) (fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_4 i j x) f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_uncurry_smul Dfinsupp.sigmaUncurry_smulₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem sigmaUncurry_smul [Monoid γ] [∀ i j, AddMonoid (δ i j)] [∀ i, DecidableEq (α i)]
    [∀ (i j) (x : δ i j), Decidable (x ≠ 0)] [∀ i j, DistribMulAction γ (δ i j)] (r : γ)
    (f : Π₀ (i) (j), δ i j) : sigmaUncurry (r • f) = r • sigmaUncurry f :=
  coeFn_injective rfl
#align dfinsupp.sigma_uncurry_smul Dfinsupp.sigmaUncurry_smul

/- warning: dfinsupp.sigma_uncurry_single -> Dfinsupp.sigmaUncurry_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : ι -> Type.{u3}} {δ : forall (i : ι), (α i) -> Type.{u2}} [_inst_1 : forall (i : ι) (j : α i), Zero.{u2} (δ i j)] [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : forall (i : ι), DecidableEq.{succ u3} (α i)] [_inst_4 : forall (i : ι) (j : α i) (x : δ i j), Decidable (Ne.{succ u2} (δ i j) x (OfNat.ofNat.{u2} (δ i j) 0 (OfNat.mk.{u2} (δ i j) 0 (Zero.zero.{u2} (δ i j) (_inst_1 i j)))))] (i : ι) (j : α i) (x : δ i j), Eq.{succ (max (max u1 u3) u2)} (Dfinsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i))) (Dfinsupp.sigmaUncurry.{u1, u2, u3} ι (fun (i : ι) => α i) (fun (i : ι) (i_1 : α i) => δ i i_1) (fun (i : ι) (i_1 : α i) => _inst_1 i i_1) (fun (i : ι) (a : α i) (b : α i) => _inst_3 i a b) (fun (i : ι) (j : α i) (x : δ i j) => _inst_4 i j x) (Dfinsupp.single.{u1, max u3 u2} ι (fun (i : ι) => Dfinsupp.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => Dfinsupp.hasZero.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_1 i i_1)) i (Dfinsupp.single.{u3, u2} (α i) (fun (j : α i) => δ i j) (fun (a : α i) (b : α i) => _inst_3 i a b) (fun (i_1 : α i) => _inst_1 i i_1) j x))) (Dfinsupp.single.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (fun (a : Sigma.{u1, u3} ι (fun (i : ι) => α i)) (b : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => Sigma.decidableEq.{u1, u3} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (a : ι) (a_1 : α a) (b : α a) => _inst_3 a a_1 b) a b) (fun (i : Sigma.{u1, u3} ι (fun (i : ι) => α i)) => _inst_1 (Sigma.fst.{u1, u3} ι (fun (i : ι) => α i) i) (Sigma.snd.{u1, u3} ι (fun (i : ι) => α i) i)) (Sigma.mk.{u1, u3} ι (fun (i : ι) => α i) i j) x)
but is expected to have type
  forall {ι : Type.{u2}} [α : DecidableEq.{succ u2} ι] {δ : ι -> Type.{u1}} {_inst_1 : forall (i : ι), (δ i) -> Type.{u3}} [_inst_2 : forall (i : ι) (j : δ i), Zero.{u3} (_inst_1 i j)] [_inst_3 : forall (i : ι), DecidableEq.{succ u1} (δ i)] [_inst_4 : forall (i : ι) (j : δ i) (x : _inst_1 i j), Decidable (Ne.{succ u3} (_inst_1 i j) x (OfNat.ofNat.{u3} (_inst_1 i j) 0 (Zero.toOfNat0.{u3} (_inst_1 i j) (_inst_2 i j))))] (i : ι) (j : δ i) (x : _inst_1 i j), Eq.{max (max (succ u2) (succ u3)) (succ u1)} (Dfinsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => δ i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => δ i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) => _inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => δ i) i))) (Dfinsupp.sigmaUncurry.{u2, u3, u1} ι δ _inst_1 _inst_2 (fun (i : ι) (a : δ i) (b : δ i) => _inst_3 i a b) (fun (i : ι) (j : δ i) (x : _inst_1 i j) => _inst_4 i j x) (Dfinsupp.single.{u2, max u1 u3} ι (fun (i : ι) => Dfinsupp.{u1, u3} (δ i) (fun (j : δ i) => _inst_1 i j) (fun (i_1 : δ i) => _inst_2 i i_1)) (fun (a : ι) (b : ι) => α a b) (fun (i : ι) => Dfinsupp.instZeroDfinsupp.{u1, u3} (δ i) (fun (j : δ i) => _inst_1 i j) (fun (i_1 : δ i) => _inst_2 i i_1)) i (Dfinsupp.single.{u1, u3} (δ i) (fun (j : δ i) => _inst_1 i j) (fun (a : δ i) (b : δ i) => _inst_3 i a b) (fun (i_1 : δ i) => _inst_2 i i_1) j x))) (Dfinsupp.single.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => δ i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) => _inst_1 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => δ i) i)) (fun (a : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) (b : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) => Sigma.instDecidableEqSigma.{u2, u1} ι (fun (i : ι) => δ i) (fun (a : ι) (b : ι) => α a b) (fun (a : ι) => (fun (a : ι) (a_1 : δ a) (b : δ a) => _inst_3 a a_1 b) a) a b) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => δ i)) => _inst_2 (Sigma.fst.{u2, u1} ι (fun (i : ι) => δ i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => δ i) i)) (Sigma.mk.{u2, u1} ι (fun (i : ι) => δ i) i j) x)
Case conversion may be inaccurate. Consider using '#align dfinsupp.sigma_uncurry_single Dfinsupp.sigmaUncurry_singleₓ'. -/
@[simp]
theorem sigmaUncurry_single [∀ i j, Zero (δ i j)] [DecidableEq ι] [∀ i, DecidableEq (α i)]
    [∀ (i j) (x : δ i j), Decidable (x ≠ 0)] (i) (j : α i) (x : δ i j) :
    sigmaUncurry (single i (single j x : Π₀ j : α i, δ i j)) = single ⟨i, j⟩ x :=
  by
  ext ⟨i', j'⟩
  dsimp only
  rw [sigma_uncurry_apply]
  obtain rfl | hi := eq_or_ne i i'
  · rw [single_eq_same]
    obtain rfl | hj := eq_or_ne j j'
    · rw [single_eq_same, single_eq_same]
    · rw [single_eq_of_ne hj, single_eq_of_ne]
      simpa using hj
  · rw [single_eq_of_ne hi, single_eq_of_ne, zero_apply]
    simpa using hi
#align dfinsupp.sigma_uncurry_single Dfinsupp.sigmaUncurry_single

/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
#print Dfinsupp.sigmaCurryEquiv /-
/-- The natural bijection between `Π₀ (i : Σ i, α i), δ i.1 i.2` and `Π₀ i (j : α i), δ i j`.

This is the dfinsupp version of `equiv.Pi_curry`. -/
noncomputable def sigmaCurryEquiv [∀ i j, Zero (δ i j)] [∀ i, DecidableEq (α i)]
    [∀ (i j) (x : δ i j), Decidable (x ≠ 0)] : (Π₀ i : Σi, _, δ i.1 i.2) ≃ Π₀ (i) (j), δ i j
    where
  toFun := sigmaCurry
  invFun := sigmaUncurry
  left_inv f := by
    ext ⟨i, j⟩
    rw [sigma_uncurry_apply, sigma_curry_apply]
  right_inv f := by
    ext (i j)
    rw [sigma_curry_apply, sigma_uncurry_apply]
#align dfinsupp.sigma_curry_equiv Dfinsupp.sigmaCurryEquiv
-/

end Curry

variable {α : Option ι → Type v}

#print Dfinsupp.extendWith /-
/-- Adds a term to a dfinsupp, making a dfinsupp indexed by an `option`.

This is the dfinsupp version of `option.rec`. -/
def extendWith [∀ i, Zero (α i)] (a : α none) (f : Π₀ i, α (some i)) : Π₀ i, α i
    where
  toFun := Option.rec a f
  support' :=
    f.support'.map fun s =>
      ⟨none ::ₘ Multiset.map some s, fun i =>
        Option.rec (Or.inl <| Multiset.mem_cons_self _ _)
          (fun i =>
            (s.Prop i).imp_left fun h => Multiset.mem_cons_of_mem <| Multiset.mem_map_of_mem _ h)
          i⟩
#align dfinsupp.extend_with Dfinsupp.extendWith
-/

#print Dfinsupp.extendWith_none /-
@[simp]
theorem extendWith_none [∀ i, Zero (α i)] (f : Π₀ i, α (some i)) (a : α none) :
    f.extendWith a none = a :=
  rfl
#align dfinsupp.extend_with_none Dfinsupp.extendWith_none
-/

#print Dfinsupp.extendWith_some /-
@[simp]
theorem extendWith_some [∀ i, Zero (α i)] (f : Π₀ i, α (some i)) (a : α none) (i : ι) :
    f.extendWith a (some i) = f i :=
  rfl
#align dfinsupp.extend_with_some Dfinsupp.extendWith_some
-/

/- warning: dfinsupp.extend_with_single_zero -> Dfinsupp.extendWith_single_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : (Option.{u1} ι) -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : Option.{u1} ι), Zero.{u2} (α i)] (i : ι) (x : α (Option.some.{u1} ι i)), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_2 i)) (Dfinsupp.extendWith.{u1, u2} ι α (fun (i : Option.{u1} ι) => _inst_2 i) (OfNat.ofNat.{u2} (α (Option.none.{u1} ι)) 0 (OfNat.mk.{u2} (α (Option.none.{u1} ι)) 0 (Zero.zero.{u2} (α (Option.none.{u1} ι)) (_inst_2 (Option.none.{u1} ι))))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 (Option.some.{u1} ι i)) i x)) (Dfinsupp.single.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (a : Option.{u1} ι) (b : Option.{u1} ι) => Option.decidableEq.{u1} ι (fun (a : ι) (b : ι) => _inst_1 a b) a b) (fun (i : Option.{u1} ι) => _inst_2 i) (Option.some.{u1} ι i) x)
but is expected to have type
  forall {ι : Type.{u1}} {α : (Option.{u1} ι) -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : forall (i : Option.{u1} ι), Zero.{u2} (α i)] (i : ι) (x : α (Option.some.{u1} ι i)), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_2 i)) (Dfinsupp.extendWith.{u1, u2} ι α _inst_2 (OfNat.ofNat.{u2} (α (Option.none.{u1} ι)) 0 (Zero.toOfNat0.{u2} (α (Option.none.{u1} ι)) (_inst_2 (Option.none.{u1} ι)))) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 (Option.some.{u1} ι i)) i x)) (Dfinsupp.single.{u1, u2} (Option.{u1} ι) α (fun (a : Option.{u1} ι) (b : Option.{u1} ι) => instDecidableEqOption.{u1} ι (fun (a : ι) (b : ι) => _inst_1 a b) a b) (fun (i : Option.{u1} ι) => _inst_2 i) (Option.some.{u1} ι i) x)
Case conversion may be inaccurate. Consider using '#align dfinsupp.extend_with_single_zero Dfinsupp.extendWith_single_zeroₓ'. -/
@[simp]
theorem extendWith_single_zero [DecidableEq ι] [∀ i, Zero (α i)] (i : ι) (x : α (some i)) :
    (single i x).extendWith 0 = single (some i) x :=
  by
  ext (_ | j)
  · rw [extend_with_none, single_eq_of_ne (Option.some_ne_none _)]
  · rw [extend_with_some]
    obtain rfl | hij := Decidable.eq_or_ne i j
    · rw [single_eq_same, single_eq_same]
    · rw [single_eq_of_ne hij, single_eq_of_ne ((Option.some_injective _).Ne hij)]
#align dfinsupp.extend_with_single_zero Dfinsupp.extendWith_single_zero

#print Dfinsupp.extendWith_zero /-
@[simp]
theorem extendWith_zero [DecidableEq ι] [∀ i, Zero (α i)] (x : α none) :
    (0 : Π₀ i, α (some i)).extendWith x = single none x :=
  by
  ext (_ | j)
  · rw [extend_with_none, single_eq_same]
  · rw [extend_with_some, single_eq_of_ne (Option.some_ne_none _).symm, zero_apply]
#align dfinsupp.extend_with_zero Dfinsupp.extendWith_zero
-/

include dec

#print Dfinsupp.equivProdDfinsupp /-
/-- Bijection obtained by separating the term of index `none` of a dfinsupp over `option ι`.

This is the dfinsupp version of `equiv.pi_option_equiv_prod`. -/
@[simps]
noncomputable def equivProdDfinsupp [∀ i, Zero (α i)] : (Π₀ i, α i) ≃ α none × Π₀ i, α (some i)
    where
  toFun f := (f none, comapDomain some (Option.some_injective _) f)
  invFun f := f.2.extendWith f.1
  left_inv f := by
    ext i; cases' i with i
    · rw [extend_with_none]
    · rw [extend_with_some, comap_domain_apply]
  right_inv x := by
    dsimp only
    ext
    · exact extend_with_none x.snd _
    · rw [comap_domain_apply, extend_with_some]
#align dfinsupp.equiv_prod_dfinsupp Dfinsupp.equivProdDfinsupp
-/

/- warning: dfinsupp.equiv_prod_dfinsupp_add -> Dfinsupp.equivProdDfinsupp_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {α : (Option.{u1} ι) -> Type.{u2}} [_inst_1 : forall (i : Option.{u1} ι), AddZeroClass.{u2} (α i)] (f : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (g : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))), Eq.{max (succ u2) (succ (max u1 u2))} (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (coeFn.{max 1 (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (fun (_x : Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) => (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) -> (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Dfinsupp.hasAdd.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_1 i))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (instHAdd.{max u1 u2} (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (Prod.hasAdd.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))) (AddZeroClass.toHasAdd.{u2} (α (Option.none.{u1} ι)) (_inst_1 (Option.none.{u1} ι))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_1 (Option.some.{u1} ι i))))) (coeFn.{max 1 (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (fun (_x : Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) => (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) -> (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) f) (coeFn.{max 1 (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (fun (_x : Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) => (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) -> (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) g))
but is expected to have type
  forall {ι : Type.{u1}} [dec : DecidableEq.{succ u1} ι] {α : (Option.{u1} ι) -> Type.{u2}} [_inst_1 : forall (i : Option.{u1} ι), AddZeroClass.{u2} (α i)] (f : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (g : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_1 i))) f g)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_1 i))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) f) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) g) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) f) (instHAdd.{max u1 u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) f) (Prod.instAddSum.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))) (AddZeroClass.toAdd.{u2} (α (Option.none.{u1} ι)) (_inst_1 (Option.none.{u1} ι))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_1 (Option.some.{u1} ι i))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) f) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i))))) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_1 (Option.some.{u1} ι i)))))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_1 i))) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.equiv_prod_dfinsupp_add Dfinsupp.equivProdDfinsupp_addₓ'. -/
theorem equivProdDfinsupp_add [∀ i, AddZeroClass (α i)] (f g : Π₀ i, α i) :
    equivProdDfinsupp (f + g) = equivProdDfinsupp f + equivProdDfinsupp g :=
  Prod.ext (add_apply _ _ _) (comapDomain_add _ _ _ _)
#align dfinsupp.equiv_prod_dfinsupp_add Dfinsupp.equivProdDfinsupp_add

/- warning: dfinsupp.equiv_prod_dfinsupp_smul -> Dfinsupp.equivProdDfinsupp_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} [dec : DecidableEq.{succ u1} ι] {α : (Option.{u1} ι) -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : Option.{u1} ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : Option.{u1} ι), DistribMulAction.{u3, u2} γ (α i) _inst_1 (_inst_2 i)] (r : γ) (f : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))), Eq.{max (succ u2) (succ (max u1 u2))} (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))) (coeFn.{max 1 (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))))) (fun (_x : Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))))) => (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) -> (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))))) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) (SMul.smul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) (Dfinsupp.hasSmul.{u1, u2, u3} (Option.{u1} ι) γ (fun (i : Option.{u1} ι) => α i) _inst_1 (fun (i : Option.{u1} ι) => _inst_2 i) (fun (i : Option.{u1} ι) => _inst_3 i)) r f)) (SMul.smul.{u3, max u1 u2} γ (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))) (Prod.smul.{u3, u2, max u1 u2} γ (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) (SMulZeroClass.toHasSmul.{u3, u2} γ (α (Option.none.{u1} ι)) (AddZeroClass.toHasZero.{u2} (α (Option.none.{u1} ι)) (AddMonoid.toAddZeroClass.{u2} (α (Option.none.{u1} ι)) (_inst_2 (Option.none.{u1} ι)))) (DistribSMul.toSmulZeroClass.{u3, u2} γ (α (Option.none.{u1} ι)) (AddMonoid.toAddZeroClass.{u2} (α (Option.none.{u1} ι)) (_inst_2 (Option.none.{u1} ι))) (DistribMulAction.toDistribSMul.{u3, u2} γ (α (Option.none.{u1} ι)) _inst_1 (_inst_2 (Option.none.{u1} ι)) (_inst_3 (Option.none.{u1} ι))))) (Dfinsupp.hasSmul.{u1, u2, u3} ι γ (fun (i : ι) => α (Option.some.{u1} ι i)) _inst_1 (fun (i : ι) => _inst_2 (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i)))) r (coeFn.{max 1 (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))))) (fun (_x : Equiv.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))))) => (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) -> (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))))) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u2) (succ (max u1 u2))} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddZeroClass.toHasZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i)))) f))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} [dec : DecidableEq.{succ u1} ι] {α : (Option.{u1} ι) -> Type.{u2}} [_inst_1 : Monoid.{u3} γ] [_inst_2 : forall (i : Option.{u1} ι), AddMonoid.{u2} (α i)] [_inst_3 : forall (i : Option.{u1} ι), DistribMulAction.{u3, u2} γ (α i) _inst_1 (_inst_2 i)] (r : γ) (f : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} (Option.{u1} ι) γ (fun (i : Option.{u1} ι) => α i) _inst_1 (fun (i : Option.{u1} ι) => _inst_2 i) (fun (i : Option.{u1} ι) => _inst_3 i))) r f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (fun (_x : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (instHSMul.{u3, max u1 u2} γ (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} (Option.{u1} ι) γ (fun (i : Option.{u1} ι) => α i) _inst_1 (fun (i : Option.{u1} ι) => _inst_2 i) (fun (i : Option.{u1} ι) => _inst_3 i))) r f)) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} γ ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) f) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) f) (instHSMul.{u3, max u1 u2} γ ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) f) (Prod.smul.{u3, u2, max u1 u2} γ (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))) (SMulZeroClass.toSMul.{u3, u2} γ (α (Option.none.{u1} ι)) (AddMonoid.toZero.{u2} (α (Option.none.{u1} ι)) (_inst_2 (Option.none.{u1} ι))) (DistribSMul.toSMulZeroClass.{u3, u2} γ (α (Option.none.{u1} ι)) (AddMonoid.toAddZeroClass.{u2} (α (Option.none.{u1} ι)) (_inst_2 (Option.none.{u1} ι))) (DistribMulAction.toDistribSMul.{u3, u2} γ (α (Option.none.{u1} ι)) _inst_1 (_inst_2 (Option.none.{u1} ι)) (_inst_3 (Option.none.{u1} ι))))) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι γ (fun (i : ι) => α (Option.some.{u1} ι i)) _inst_1 (fun (i : ι) => _inst_2 (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i))))) r (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (fun (_x : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) => Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ (max u2 u1)) (succ u2)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))) (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i))))) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Dfinsupp.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) (Option.some.{u1} ι i)) (_inst_2 (Option.some.{u1} ι i)))))))) (Dfinsupp.equivProdDfinsupp.{u1, u2} ι (fun (a : ι) (b : ι) => dec a b) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => AddMonoid.toZero.{u2} ((fun (i : Option.{u1} ι) => α i) i) (_inst_2 i))) f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.equiv_prod_dfinsupp_smul Dfinsupp.equivProdDfinsupp_smulₓ'. -/
theorem equivProdDfinsupp_smul [Monoid γ] [∀ i, AddMonoid (α i)] [∀ i, DistribMulAction γ (α i)]
    (r : γ) (f : Π₀ i, α i) : equivProdDfinsupp (r • f) = r • equivProdDfinsupp f :=
  Prod.ext (smul_apply _ _ _) (comapDomain_smul _ _ _ _)
#align dfinsupp.equiv_prod_dfinsupp_smul Dfinsupp.equivProdDfinsupp_smul

end Equiv

section ProdAndSum

#print Dfinsupp.prod /-
/-- `prod f g` is the product of `g i (f i)` over the support of `f`. -/
@[to_additive "`sum f g` is the sum of `g i (f i)` over the support of `f`."]
def prod [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ] (f : Π₀ i, β i)
    (g : ∀ i, β i → γ) : γ :=
  ∏ i in f.support, g i (f i)
#align dfinsupp.prod Dfinsupp.prod
#align dfinsupp.sum Dfinsupp.sum
-/

/- warning: dfinsupp.prod_map_range_index -> Dfinsupp.prod_mapRange_index is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u4}} [dec : DecidableEq.{succ u1} ι] {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_1 : forall (i : ι), Zero.{u2} (β₁ i)] [_inst_2 : forall (i : ι), Zero.{u3} (β₂ i)] [_inst_3 : forall (i : ι) (x : β₁ i), Decidable (Ne.{succ u2} (β₁ i) x (OfNat.ofNat.{u2} (β₁ i) 0 (OfNat.mk.{u2} (β₁ i) 0 (Zero.zero.{u2} (β₁ i) (_inst_1 i)))))] [_inst_4 : forall (i : ι) (x : β₂ i), Decidable (Ne.{succ u3} (β₂ i) x (OfNat.ofNat.{u3} (β₂ i) 0 (OfNat.mk.{u3} (β₂ i) 0 (Zero.zero.{u3} (β₂ i) (_inst_2 i)))))] [_inst_5 : CommMonoid.{u4} γ] {f : forall (i : ι), (β₁ i) -> (β₂ i)} {hf : forall (i : ι), Eq.{succ u3} (β₂ i) (f i (OfNat.ofNat.{u2} (β₁ i) 0 (OfNat.mk.{u2} (β₁ i) 0 (Zero.zero.{u2} (β₁ i) (_inst_1 i))))) (OfNat.ofNat.{u3} (β₂ i) 0 (OfNat.mk.{u3} (β₂ i) 0 (Zero.zero.{u3} (β₂ i) (_inst_2 i))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_1 i)} {h : forall (i : ι), (β₂ i) -> γ}, (forall (i : ι), Eq.{succ u4} γ (h i (OfNat.ofNat.{u3} (β₂ i) 0 (OfNat.mk.{u3} (β₂ i) 0 (Zero.zero.{u3} (β₂ i) (_inst_2 i))))) (OfNat.ofNat.{u4} γ 1 (OfNat.mk.{u4} γ 1 (One.one.{u4} γ (MulOneClass.toHasOne.{u4} γ (Monoid.toMulOneClass.{u4} γ (CommMonoid.toMonoid.{u4} γ _inst_5))))))) -> (Eq.{succ u4} γ (Dfinsupp.prod.{u1, u3, u4} ι γ (fun (i : ι) => β₂ i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β₂ i) => _inst_4 i x) _inst_5 (Dfinsupp.mapRange.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) f hf g) h) (Dfinsupp.prod.{u1, u2, u4} ι γ (fun (i : ι) => β₁ i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β₁ i) => _inst_3 i x) _inst_5 g (fun (i : ι) (b : β₁ i) => h i (f i b))))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u4}} [dec : DecidableEq.{succ u1} ι] {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_1 : forall (i : ι), Zero.{u2} (β₁ i)] [_inst_2 : forall (i : ι), Zero.{u3} (β₂ i)] [_inst_3 : forall (i : ι) (x : β₁ i), Decidable (Ne.{succ u2} (β₁ i) x (OfNat.ofNat.{u2} (β₁ i) 0 (Zero.toOfNat0.{u2} (β₁ i) (_inst_1 i))))] [_inst_4 : forall (i : ι) (x : β₂ i), Decidable (Ne.{succ u3} (β₂ i) x (OfNat.ofNat.{u3} (β₂ i) 0 (Zero.toOfNat0.{u3} (β₂ i) (_inst_2 i))))] [_inst_5 : CommMonoid.{u4} γ] {f : forall (i : ι), (β₁ i) -> (β₂ i)} {hf : forall (i : ι), Eq.{succ u3} (β₂ i) (f i (OfNat.ofNat.{u2} (β₁ i) 0 (Zero.toOfNat0.{u2} (β₁ i) (_inst_1 i)))) (OfNat.ofNat.{u3} (β₂ i) 0 (Zero.toOfNat0.{u3} (β₂ i) (_inst_2 i)))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_1 i)} {h : forall (i : ι), (β₂ i) -> γ}, (forall (i : ι), Eq.{succ u4} γ (h i (OfNat.ofNat.{u3} (β₂ i) 0 (Zero.toOfNat0.{u3} (β₂ i) (_inst_2 i)))) (OfNat.ofNat.{u4} γ 1 (One.toOfNat1.{u4} γ (Monoid.toOne.{u4} γ (CommMonoid.toMonoid.{u4} γ _inst_5))))) -> (Eq.{succ u4} γ (Dfinsupp.prod.{u1, u3, u4} ι γ (fun (i : ι) => β₂ i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β₂ i) => _inst_4 i x) _inst_5 (Dfinsupp.mapRange.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) f hf g) h) (Dfinsupp.prod.{u1, u2, u4} ι γ (fun (i : ι) => β₁ i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β₁ i) => _inst_3 i x) _inst_5 g (fun (i : ι) (b : β₁ i) => h i (f i b))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_map_range_index Dfinsupp.prod_mapRange_indexₓ'. -/
@[to_additive]
theorem prod_mapRange_index {β₁ : ι → Type v₁} {β₂ : ι → Type v₂} [∀ i, Zero (β₁ i)]
    [∀ i, Zero (β₂ i)] [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ (i) (x : β₂ i), Decidable (x ≠ 0)]
    [CommMonoid γ] {f : ∀ i, β₁ i → β₂ i} {hf : ∀ i, f i 0 = 0} {g : Π₀ i, β₁ i} {h : ∀ i, β₂ i → γ}
    (h0 : ∀ i, h i 0 = 1) : (mapRange f hf g).Prod h = g.Prod fun i b => h i (f i b) :=
  by
  rw [map_range_def]
  refine' (Finset.prod_subset support_mk_subset _).trans _
  · intro i h1 h2
    dsimp
    simp [h1] at h2
    dsimp at h2
    simp [h1, h2, h0]
  · refine' Finset.prod_congr rfl _
    intro i h1
    simp [h1]
#align dfinsupp.prod_map_range_index Dfinsupp.prod_mapRange_index
#align dfinsupp.sum_map_range_index Dfinsupp.sum_mapRange_index

/- warning: dfinsupp.prod_zero_index -> Dfinsupp.prod_zero_index is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] [_inst_3 : CommMonoid.{u3} γ] {h : forall (i : ι), (β i) -> γ}, Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (Dfinsupp.hasZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))))) h) (OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] [_inst_3 : CommMonoid.{u3} γ] {h : forall (i : ι), (β i) -> γ}, Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) 0 (Zero.toOfNat0.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (Dfinsupp.instZeroDfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) h) (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_zero_index Dfinsupp.prod_zero_indexₓ'. -/
@[to_additive]
theorem prod_zero_index [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]
    [CommMonoid γ] {h : ∀ i, β i → γ} : (0 : Π₀ i, β i).Prod h = 1 :=
  rfl
#align dfinsupp.prod_zero_index Dfinsupp.prod_zero_index
#align dfinsupp.sum_zero_index Dfinsupp.sum_zero_index

/- warning: dfinsupp.prod_single_index -> Dfinsupp.prod_single_index is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_1 i)))))] [_inst_3 : CommMonoid.{u3} γ] {i : ι} {b : β i} {h : forall (i : ι), (β i) -> γ}, (Eq.{succ u3} γ (h i (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_1 i))))) (OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (Dfinsupp.single.{u1, u2} ι (fun {i : ι} => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) i b) h) (h i b))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (_inst_1 i))))] [_inst_3 : CommMonoid.{u3} γ] {i : ι} {b : β i} {h : forall (i : ι), (β i) -> γ}, (Eq.{succ u3} γ (h i (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (_inst_1 i)))) (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (Dfinsupp.single.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) i b) h) (h i b))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_single_index Dfinsupp.prod_single_indexₓ'. -/
@[to_additive]
theorem prod_single_index [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]
    {i : ι} {b : β i} {h : ∀ i, β i → γ} (h_zero : h i 0 = 1) : (single i b).Prod h = h i b :=
  by
  by_cases h : b ≠ 0
  · simp [Dfinsupp.prod, support_single_ne_zero h]
  · rw [Classical.not_not] at h
    simp [h, prod_zero_index, h_zero]
    rfl
#align dfinsupp.prod_single_index Dfinsupp.prod_single_index
#align dfinsupp.sum_single_index Dfinsupp.sum_single_index

/- warning: dfinsupp.prod_neg_index -> Dfinsupp.prod_neg_index is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))))))] [_inst_3 : CommMonoid.{u3} γ] {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u3} γ (h i (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))))))))) (OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) g) h) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 g (fun (i : ι) (b : β i) => h i (Neg.neg.{u2} (β i) (SubNegMonoid.toHasNeg.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i))) b))))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i))))))))] [_inst_3 : CommMonoid.{u3} γ] {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u3} γ (h i (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i)))))))) (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) g) h) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 g (fun (i : ι) (b : β i) => h i (Neg.neg.{u2} (β i) (NegZeroClass.toNeg.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i))))) b))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_neg_index Dfinsupp.prod_neg_indexₓ'. -/
@[to_additive]
theorem prod_neg_index [∀ i, AddGroup (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]
    {g : Π₀ i, β i} {h : ∀ i, β i → γ} (h0 : ∀ i, h i 0 = 1) :
    (-g).Prod h = g.Prod fun i b => h i (-b) :=
  prod_mapRange_index h0
#align dfinsupp.prod_neg_index Dfinsupp.prod_neg_index
#align dfinsupp.sum_neg_index Dfinsupp.sum_neg_index

omit dec

/- warning: dfinsupp.prod_comm -> Dfinsupp.prod_comm is a dubious translation:
lean 3 declaration is
  forall {γ : Type.{u1}} {ι₁ : Type.{u2}} {ι₂ : Type.{u3}} {β₁ : ι₁ -> Type.{u4}} {β₂ : ι₂ -> Type.{u5}} [_inst_1 : DecidableEq.{succ u2} ι₁] [_inst_2 : DecidableEq.{succ u3} ι₂] [_inst_3 : forall (i : ι₁), Zero.{u4} (β₁ i)] [_inst_4 : forall (i : ι₂), Zero.{u5} (β₂ i)] [_inst_5 : forall (i : ι₁) (x : β₁ i), Decidable (Ne.{succ u4} (β₁ i) x (OfNat.ofNat.{u4} (β₁ i) 0 (OfNat.mk.{u4} (β₁ i) 0 (Zero.zero.{u4} (β₁ i) (_inst_3 i)))))] [_inst_6 : forall (i : ι₂) (x : β₂ i), Decidable (Ne.{succ u5} (β₂ i) x (OfNat.ofNat.{u5} (β₂ i) 0 (OfNat.mk.{u5} (β₂ i) 0 (Zero.zero.{u5} (β₂ i) (_inst_4 i)))))] [_inst_7 : CommMonoid.{u1} γ] (f₁ : Dfinsupp.{u2, u4} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (f₂ : Dfinsupp.{u3, u5} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (h : forall (i : ι₁), (β₁ i) -> (forall (i : ι₂), (β₂ i) -> γ)), Eq.{succ u1} γ (Dfinsupp.prod.{u2, u4, u1} ι₁ γ (fun (i : ι₁) => β₁ i) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_3 i) (fun (i : ι₁) (x : β₁ i) => _inst_5 i x) _inst_7 f₁ (fun (i₁ : ι₁) (x₁ : β₁ i₁) => Dfinsupp.prod.{u3, u5, u1} ι₂ γ (fun (i : ι₂) => β₂ i) (fun (a : ι₂) (b : ι₂) => _inst_2 a b) (fun (i : ι₂) => _inst_4 i) (fun (i : ι₂) (x : β₂ i) => _inst_6 i x) _inst_7 f₂ (fun (i₂ : ι₂) (x₂ : β₂ i₂) => h i₁ x₁ i₂ x₂))) (Dfinsupp.prod.{u3, u5, u1} ι₂ γ (fun (i : ι₂) => β₂ i) (fun (a : ι₂) (b : ι₂) => _inst_2 a b) (fun (i : ι₂) => _inst_4 i) (fun (i : ι₂) (x : β₂ i) => _inst_6 i x) _inst_7 f₂ (fun (i₂ : ι₂) (x₂ : β₂ i₂) => Dfinsupp.prod.{u2, u4, u1} ι₁ γ (fun (i : ι₁) => β₁ i) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_3 i) (fun (i : ι₁) (x : β₁ i) => _inst_5 i x) _inst_7 f₁ (fun (i₁ : ι₁) (x₁ : β₁ i₁) => h i₁ x₁ i₂ x₂)))
but is expected to have type
  forall {γ : Type.{u5}} {ι₁ : Type.{u4}} {ι₂ : Type.{u3}} {β₁ : ι₁ -> Type.{u2}} {β₂ : ι₂ -> Type.{u1}} [_inst_1 : DecidableEq.{succ u4} ι₁] [_inst_2 : DecidableEq.{succ u3} ι₂] [_inst_3 : forall (i : ι₁), Zero.{u2} (β₁ i)] [_inst_4 : forall (i : ι₂), Zero.{u1} (β₂ i)] [_inst_5 : forall (i : ι₁) (x : β₁ i), Decidable (Ne.{succ u2} (β₁ i) x (OfNat.ofNat.{u2} (β₁ i) 0 (Zero.toOfNat0.{u2} (β₁ i) (_inst_3 i))))] [_inst_6 : forall (i : ι₂) (x : β₂ i), Decidable (Ne.{succ u1} (β₂ i) x (OfNat.ofNat.{u1} (β₂ i) 0 (Zero.toOfNat0.{u1} (β₂ i) (_inst_4 i))))] [_inst_7 : CommMonoid.{u5} γ] (f₁ : Dfinsupp.{u4, u2} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (f₂ : Dfinsupp.{u3, u1} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (h : forall (i : ι₁), (β₁ i) -> (forall (i : ι₂), (β₂ i) -> γ)), Eq.{succ u5} γ (Dfinsupp.prod.{u4, u2, u5} ι₁ γ (fun (i : ι₁) => β₁ i) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_3 i) (fun (i : ι₁) (x : β₁ i) => _inst_5 i x) _inst_7 f₁ (fun (i₁ : ι₁) (x₁ : β₁ i₁) => Dfinsupp.prod.{u3, u1, u5} ι₂ γ (fun (i : ι₂) => β₂ i) (fun (a : ι₂) (b : ι₂) => _inst_2 a b) (fun (i : ι₂) => _inst_4 i) (fun (i : ι₂) (x : β₂ i) => _inst_6 i x) _inst_7 f₂ (fun (i₂ : ι₂) (x₂ : β₂ i₂) => h i₁ x₁ i₂ x₂))) (Dfinsupp.prod.{u3, u1, u5} ι₂ γ (fun (i : ι₂) => β₂ i) (fun (a : ι₂) (b : ι₂) => _inst_2 a b) (fun (i : ι₂) => _inst_4 i) (fun (i : ι₂) (x : β₂ i) => _inst_6 i x) _inst_7 f₂ (fun (i₂ : ι₂) (x₂ : β₂ i₂) => Dfinsupp.prod.{u4, u2, u5} ι₁ γ (fun (i : ι₁) => β₁ i) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_3 i) (fun (i : ι₁) (x : β₁ i) => _inst_5 i x) _inst_7 f₁ (fun (i₁ : ι₁) (x₁ : β₁ i₁) => h i₁ x₁ i₂ x₂)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_comm Dfinsupp.prod_commₓ'. -/
@[to_additive]
theorem prod_comm {ι₁ ι₂ : Sort _} {β₁ : ι₁ → Type _} {β₂ : ι₂ → Type _} [DecidableEq ι₁]
    [DecidableEq ι₂] [∀ i, Zero (β₁ i)] [∀ i, Zero (β₂ i)] [∀ (i) (x : β₁ i), Decidable (x ≠ 0)]
    [∀ (i) (x : β₂ i), Decidable (x ≠ 0)] [CommMonoid γ] (f₁ : Π₀ i, β₁ i) (f₂ : Π₀ i, β₂ i)
    (h : ∀ i, β₁ i → ∀ i, β₂ i → γ) :
    (f₁.Prod fun i₁ x₁ => f₂.Prod fun i₂ x₂ => h i₁ x₁ i₂ x₂) =
      f₂.Prod fun i₂ x₂ => f₁.Prod fun i₁ x₁ => h i₁ x₁ i₂ x₂ :=
  Finset.prod_comm
#align dfinsupp.prod_comm Dfinsupp.prod_comm
#align dfinsupp.sum_comm Dfinsupp.sum_comm

/- warning: dfinsupp.sum_apply -> Dfinsupp.sum_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u3}} {ι₁ : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} ι₁] {β₁ : ι₁ -> Type.{u4}} [_inst_2 : forall (i₁ : ι₁), Zero.{u4} (β₁ i₁)] [_inst_3 : forall (i : ι₁) (x : β₁ i), Decidable (Ne.{succ u4} (β₁ i) x (OfNat.ofNat.{u4} (β₁ i) 0 (OfNat.mk.{u4} (β₁ i) 0 (Zero.zero.{u4} (β₁ i) (_inst_2 i)))))] [_inst_4 : forall (i : ι), AddCommMonoid.{u3} (β i)] {f : Dfinsupp.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (i : ι₁) => _inst_2 i)} {g : forall (i₁ : ι₁), (β₁ i₁) -> (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))))} {i₂ : ι}, Eq.{succ u3} (β i₂) (coeFn.{succ (max u1 u3), max (succ u1) (succ u3)} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))) (fun (_x : Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))) (Dfinsupp.sum.{u2, u4, max u1 u3} ι₁ (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) (Dfinsupp.addCommMonoid.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) f g) i₂) (Dfinsupp.sum.{u2, u4, u3} ι₁ (β i₂) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) (_inst_4 i₂) f (fun (i₁ : ι₁) (b : β₁ i₁) => coeFn.{succ (max u1 u3), max (succ u1) (succ u3)} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))) (fun (_x : Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))) (g i₁ b) i₂))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u3}} {ι₁ : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} ι₁] {β₁ : ι₁ -> Type.{u4}} [_inst_2 : forall (i₁ : ι₁), Zero.{u4} (β₁ i₁)] [_inst_3 : forall (i : ι₁) (x : β₁ i), Decidable (Ne.{succ u4} (β₁ i) x (OfNat.ofNat.{u4} (β₁ i) 0 (Zero.toOfNat0.{u4} (β₁ i) (_inst_2 i))))] [_inst_4 : forall (i : ι), AddCommMonoid.{u3} (β i)] {f : Dfinsupp.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (i : ι₁) => _inst_2 i)} {g : forall (i₁ : ι₁), (β₁ i₁) -> (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))} {i₂ : ι}, Eq.{succ u3} ((fun (i : ι) => (fun (i : ι) => β i) i) i₂) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Dfinsupp.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))) i)) (Dfinsupp.sum.{u2, u4, max u1 u3} ι₁ (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) f g) i₂) (Dfinsupp.sum.{u2, u4, u3} ι₁ ((fun (i : ι) => (fun (i : ι) => β i) i) i₂) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) (_inst_4 i₂) f (fun (i₁ : ι₁) (b : β₁ i₁) => FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Dfinsupp.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))) i)) (g i₁ b) i₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_apply Dfinsupp.sum_applyₓ'. -/
@[simp]
theorem sum_apply {ι₁ : Type u₁} [DecidableEq ι₁] {β₁ : ι₁ → Type v₁} [∀ i₁, Zero (β₁ i₁)]
    [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ i, AddCommMonoid (β i)] {f : Π₀ i₁, β₁ i₁}
    {g : ∀ i₁, β₁ i₁ → Π₀ i, β i} {i₂ : ι} : (f.Sum g) i₂ = f.Sum fun i₁ b => g i₁ b i₂ :=
  (evalAddMonoidHom i₂ : (Π₀ i, β i) →+ β i₂).map_sum _ f.support
#align dfinsupp.sum_apply Dfinsupp.sum_apply

include dec

/- warning: dfinsupp.support_sum -> Dfinsupp.support_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u1} ι] {ι₁ : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} ι₁] {β₁ : ι₁ -> Type.{u4}} [_inst_2 : forall (i₁ : ι₁), Zero.{u4} (β₁ i₁)] [_inst_3 : forall (i : ι₁) (x : β₁ i), Decidable (Ne.{succ u4} (β₁ i) x (OfNat.ofNat.{u4} (β₁ i) 0 (OfNat.mk.{u4} (β₁ i) 0 (Zero.zero.{u4} (β₁ i) (_inst_2 i)))))] [_inst_4 : forall (i : ι), AddCommMonoid.{u3} (β i)] [_inst_5 : forall (i : ι) (x : β i), Decidable (Ne.{succ u3} (β i) x (OfNat.ofNat.{u3} (β i) 0 (OfNat.mk.{u3} (β i) 0 (Zero.zero.{u3} (β i) (AddZeroClass.toHasZero.{u3} (β i) (AddMonoid.toAddZeroClass.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_4 i))))))))] {f : Dfinsupp.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (i : ι₁) => _inst_2 i)} {g : forall (i₁ : ι₁), (β₁ i₁) -> (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))))}, HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Dfinsupp.support.{u1, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))) (fun (i : ι) (x : β i) => _inst_5 i x) (Dfinsupp.sum.{u2, u4, max u1 u3} ι₁ (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) (Dfinsupp.addCommMonoid.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) f g)) (Finset.bunionᵢ.{u2, u1} ι₁ ι (fun (a : ι) (b : ι) => dec a b) (Dfinsupp.support.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) f) (fun (i : ι₁) => Dfinsupp.support.{u1, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))) (fun (i : ι) (x : β i) => _inst_5 i x) (g i (coeFn.{succ (max u2 u4), max (succ u2) (succ u4)} (Dfinsupp.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (i : ι₁) => _inst_2 i)) (fun (_x : Dfinsupp.{u2, u4} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_2 i)) => forall (i : ι₁), β₁ i) (Dfinsupp.hasCoeToFun.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (i : ι₁) => _inst_2 i)) f i))))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u1} ι] {ι₁ : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} ι₁] {β₁ : ι₁ -> Type.{u4}} [_inst_2 : forall (i₁ : ι₁), Zero.{u4} (β₁ i₁)] [_inst_3 : forall (i : ι₁) (x : β₁ i), Decidable (Ne.{succ u4} (β₁ i) x (OfNat.ofNat.{u4} (β₁ i) 0 (Zero.toOfNat0.{u4} (β₁ i) (_inst_2 i))))] [_inst_4 : forall (i : ι), AddCommMonoid.{u3} (β i)] [_inst_5 : forall (i : ι) (x : β i), Decidable (Ne.{succ u3} (β i) x (OfNat.ofNat.{u3} (β i) 0 (Zero.toOfNat0.{u3} (β i) (AddMonoid.toZero.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_4 i))))))] {f : Dfinsupp.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (i : ι₁) => _inst_2 i)} {g : forall (i₁ : ι₁), (β₁ i₁) -> (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))}, HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.instHasSubsetFinset.{u1} ι) (Dfinsupp.support.{u1, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (i : ι) (x : β i) => _inst_5 i x) (Dfinsupp.sum.{u2, u4, max u1 u3} ι₁ (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) f g)) (Finset.bunionᵢ.{u2, u1} ι₁ ι (fun (a : ι) (b : ι) => dec a b) (Dfinsupp.support.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) f) (fun (i : ι₁) => Dfinsupp.support.{u1, u3} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (i : ι) (x : β i) => _inst_5 i x) (g i (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (Dfinsupp.{u2, u4} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => (fun (i : ι₁) => _inst_2 i) i)) ι₁ (fun (_x : ι₁) => (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) _x) (Dfinsupp.funLike.{u2, u4} ι₁ (fun (i₁ : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i₁) (fun (i : ι₁) => (fun (i : ι₁) => _inst_2 i) i)) f i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.support_sum Dfinsupp.support_sumₓ'. -/
theorem support_sum {ι₁ : Type u₁} [DecidableEq ι₁] {β₁ : ι₁ → Type v₁} [∀ i₁, Zero (β₁ i₁)]
    [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ i, AddCommMonoid (β i)]
    [∀ (i) (x : β i), Decidable (x ≠ 0)] {f : Π₀ i₁, β₁ i₁} {g : ∀ i₁, β₁ i₁ → Π₀ i, β i} :
    (f.Sum g).support ⊆ f.support.bUnion fun i => (g i (f i)).support :=
  by
  have :
    ∀ i₁ : ι,
      (f.Sum fun (i : ι₁) (b : β₁ i) => (g i b) i₁) ≠ 0 → ∃ i : ι₁, f i ≠ 0 ∧ ¬(g i (f i)) i₁ = 0 :=
    fun i₁ h =>
    let ⟨i, hi, Ne⟩ := Finset.exists_ne_zero_of_sum_ne_zero h
    ⟨i, mem_support_iff.1 hi, Ne⟩
  simpa [Finset.subset_iff, mem_support_iff, Finset.mem_bunionᵢ, sum_apply] using this
#align dfinsupp.support_sum Dfinsupp.support_sum

/- warning: dfinsupp.prod_one -> Dfinsupp.prod_one is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] [_inst_3 : CommMonoid.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))}, Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f (fun (i : ι) (b : β i) => OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))))) (OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] [_inst_3 : CommMonoid.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))}, Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f (fun (i : ι) (b : β i) => OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))) (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_one Dfinsupp.prod_oneₓ'. -/
@[simp, to_additive]
theorem prod_one [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]
    {f : Π₀ i, β i} : (f.Prod fun i b => (1 : γ)) = 1 :=
  Finset.prod_const_one
#align dfinsupp.prod_one Dfinsupp.prod_one
#align dfinsupp.sum_zero Dfinsupp.sum_zero

/- warning: dfinsupp.prod_mul -> Dfinsupp.prod_mul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] [_inst_3 : CommMonoid.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))} {h₁ : forall (i : ι), (β i) -> γ} {h₂ : forall (i : ι), (β i) -> γ}, Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f (fun (i : ι) (b : β i) => HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toHasMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (h₁ i b) (h₂ i b))) (HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toHasMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f h₁) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f h₂))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] [_inst_3 : CommMonoid.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))} {h₁ : forall (i : ι), (β i) -> γ} {h₂ : forall (i : ι), (β i) -> γ}, Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f (fun (i : ι) (b : β i) => HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (h₁ i b) (h₂ i b))) (HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f h₁) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f h₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_mul Dfinsupp.prod_mulₓ'. -/
@[simp, to_additive]
theorem prod_mul [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]
    {f : Π₀ i, β i} {h₁ h₂ : ∀ i, β i → γ} :
    (f.Prod fun i b => h₁ i b * h₂ i b) = f.Prod h₁ * f.Prod h₂ :=
  Finset.prod_mul_distrib
#align dfinsupp.prod_mul Dfinsupp.prod_mul
#align dfinsupp.sum_add Dfinsupp.sum_add

/- warning: dfinsupp.prod_inv -> Dfinsupp.prod_inv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] [_inst_3 : CommGroup.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))} {h : forall (i : ι), (β i) -> γ}, Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) (CommGroup.toCommMonoid.{u3} γ _inst_3) f (fun (i : ι) (b : β i) => Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (Group.toDivInvMonoid.{u3} γ (CommGroup.toGroup.{u3} γ _inst_3))) (h i b))) (Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (Group.toDivInvMonoid.{u3} γ (CommGroup.toGroup.{u3} γ _inst_3))) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) (CommGroup.toCommMonoid.{u3} γ _inst_3) f h))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] [_inst_3 : CommGroup.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))} {h : forall (i : ι), (β i) -> γ}, Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) (CommGroup.toCommMonoid.{u3} γ _inst_3) f (fun (i : ι) (b : β i) => Inv.inv.{u3} γ (InvOneClass.toInv.{u3} γ (DivInvOneMonoid.toInvOneClass.{u3} γ (DivisionMonoid.toDivInvOneMonoid.{u3} γ (DivisionCommMonoid.toDivisionMonoid.{u3} γ (CommGroup.toDivisionCommMonoid.{u3} γ _inst_3))))) (h i b))) (Inv.inv.{u3} γ (InvOneClass.toInv.{u3} γ (DivInvOneMonoid.toInvOneClass.{u3} γ (DivisionMonoid.toDivInvOneMonoid.{u3} γ (DivisionCommMonoid.toDivisionMonoid.{u3} γ (CommGroup.toDivisionCommMonoid.{u3} γ _inst_3))))) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) (CommGroup.toCommMonoid.{u3} γ _inst_3) f h))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_inv Dfinsupp.prod_invₓ'. -/
@[simp, to_additive]
theorem prod_inv [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommGroup γ]
    {f : Π₀ i, β i} {h : ∀ i, β i → γ} : (f.Prod fun i b => (h i b)⁻¹) = (f.Prod h)⁻¹ :=
  ((invMonoidHom : γ →* γ).map_prod _ f.support).symm
#align dfinsupp.prod_inv Dfinsupp.prod_inv
#align dfinsupp.sum_neg Dfinsupp.sum_neg

/- warning: dfinsupp.prod_eq_one -> Dfinsupp.prod_eq_one is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_1 i)))))] [_inst_3 : CommMonoid.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u3} γ (h i (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f i)) (OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f h) (OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))))))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (_inst_1 i))))] [_inst_3 : CommMonoid.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u3} γ (h i (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f i)) (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f h) (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_eq_one Dfinsupp.prod_eq_oneₓ'. -/
@[to_additive]
theorem prod_eq_one [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]
    {f : Π₀ i, β i} {h : ∀ i, β i → γ} (hyp : ∀ i, h i (f i) = 1) : f.Prod h = 1 :=
  Finset.prod_eq_one fun i hi => hyp i
#align dfinsupp.prod_eq_one Dfinsupp.prod_eq_one
#align dfinsupp.sum_eq_zero Dfinsupp.sum_eq_zero

/- warning: dfinsupp.smul_sum -> Dfinsupp.smul_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {α : Type.{u4}} [_inst_1 : Monoid.{u4} α] [_inst_2 : forall (i : ι), Zero.{u2} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_2 i)))))] [_inst_4 : AddCommMonoid.{u3} γ] [_inst_5 : DistribMulAction.{u4, u3} α γ _inst_1 (AddCommMonoid.toAddMonoid.{u3} γ _inst_4)] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)} {h : forall (i : ι), (β i) -> γ} {c : α}, Eq.{succ u3} γ (SMul.smul.{u4, u3} α γ (SMulZeroClass.toHasSmul.{u4, u3} α γ (AddZeroClass.toHasZero.{u3} γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_4))) (DistribSMul.toSmulZeroClass.{u4, u3} α γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_4)) (DistribMulAction.toDistribSMul.{u4, u3} α γ _inst_1 (AddCommMonoid.toAddMonoid.{u3} γ _inst_4) _inst_5))) c (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f h)) (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f (fun (a : ι) (b : β a) => SMul.smul.{u4, u3} α γ (SMulZeroClass.toHasSmul.{u4, u3} α γ (AddZeroClass.toHasZero.{u3} γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_4))) (DistribSMul.toSmulZeroClass.{u4, u3} α γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_4)) (DistribMulAction.toDistribSMul.{u4, u3} α γ _inst_1 (AddCommMonoid.toAddMonoid.{u3} γ _inst_4) _inst_5))) c (h a b)))
but is expected to have type
  forall {ι : Type.{u2}} {γ : Type.{u4}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] {α : Type.{u1}} [_inst_1 : Monoid.{u1} α] [_inst_2 : forall (i : ι), Zero.{u3} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u3} (β i) x (OfNat.ofNat.{u3} (β i) 0 (Zero.toOfNat0.{u3} (β i) (_inst_2 i))))] [_inst_4 : AddCommMonoid.{u4} γ] [_inst_5 : DistribMulAction.{u1, u4} α γ _inst_1 (AddCommMonoid.toAddMonoid.{u4} γ _inst_4)] {f : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)} {h : forall (i : ι), (β i) -> γ} {c : α}, Eq.{succ u4} γ (HSMul.hSMul.{u1, u4, u4} α γ γ (instHSMul.{u1, u4} α γ (SMulZeroClass.toSMul.{u1, u4} α γ (AddMonoid.toZero.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_4)) (DistribSMul.toSMulZeroClass.{u1, u4} α γ (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_4)) (DistribMulAction.toDistribSMul.{u1, u4} α γ _inst_1 (AddCommMonoid.toAddMonoid.{u4} γ _inst_4) _inst_5)))) c (Dfinsupp.sum.{u2, u3, u4} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f h)) (Dfinsupp.sum.{u2, u3, u4} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f (fun (a : ι) (b : β a) => HSMul.hSMul.{u1, u4, u4} α γ γ (instHSMul.{u1, u4} α γ (SMulZeroClass.toSMul.{u1, u4} α γ (AddMonoid.toZero.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_4)) (DistribSMul.toSMulZeroClass.{u1, u4} α γ (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_4)) (DistribMulAction.toDistribSMul.{u1, u4} α γ _inst_1 (AddCommMonoid.toAddMonoid.{u4} γ _inst_4) _inst_5)))) c (h a b)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.smul_sum Dfinsupp.smul_sumₓ'. -/
theorem smul_sum {α : Type _} [Monoid α] [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]
    [AddCommMonoid γ] [DistribMulAction α γ] {f : Π₀ i, β i} {h : ∀ i, β i → γ} {c : α} :
    c • f.Sum h = f.Sum fun a b => c • h a b :=
  Finset.smul_sum
#align dfinsupp.smul_sum Dfinsupp.smul_sum

/- warning: dfinsupp.prod_add_index -> Dfinsupp.prod_add_index is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] [_inst_3 : CommMonoid.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u3} γ (h i (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))))) (OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))))) -> (forall (i : ι) (b₁ : β i) (b₂ : β i), Eq.{succ u3} γ (h i (HAdd.hAdd.{u2, u2, u2} (β i) (β i) (β i) (instHAdd.{u2} (β i) (AddZeroClass.toHasAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) b₁ b₂)) (HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toHasMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (h i b₁) (h i b₂))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) f g) h) (HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toHasMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f h) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 g h)))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] [_inst_3 : CommMonoid.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u3} γ (h i (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))) (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))) -> (forall (i : ι) (b₁ : β i) (b₂ : β i), Eq.{succ u3} γ (h i (HAdd.hAdd.{u2, u2, u2} (β i) (β i) (β i) (instHAdd.{u2} (β i) (AddZeroClass.toAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) b₁ b₂)) (HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (h i b₁) (h i b₂))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) f g) h) (HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f h) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 g h)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_add_index Dfinsupp.prod_add_indexₓ'. -/
@[to_additive]
theorem prod_add_index [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]
    [CommMonoid γ] {f g : Π₀ i, β i} {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)
    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) : (f + g).Prod h = f.Prod h * g.Prod h :=
  have f_eq : (∏ i in f.support ∪ g.support, h i (f i)) = f.Prod h :=
    (Finset.prod_subset (Finset.subset_union_left _ _) <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (∏ i in f.support ∪ g.support, h i (g i)) = g.Prod h :=
    (Finset.prod_subset (Finset.subset_union_right _ _) <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (∏ i in (f + g).support, h i ((f + g) i)) = ∏ i in f.support ∪ g.support, h i ((f + g) i) :=
      Finset.prod_subset support_add <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]
    _ = (∏ i in f.support ∪ g.support, h i (f i)) * ∏ i in f.support ∪ g.support, h i (g i) := by
      simp [h_add, Finset.prod_mul_distrib]
    _ = _ := by rw [f_eq, g_eq]
    
#align dfinsupp.prod_add_index Dfinsupp.prod_add_index
#align dfinsupp.sum_add_index Dfinsupp.sum_add_index

/- warning: dfinsupp_prod_mem -> dfinsupp_prod_mem is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_1 i)))))] [_inst_3 : CommMonoid.{u3} γ] {S : Type.{u4}} [_inst_4 : SetLike.{u4, u3} S γ] [_inst_5 : SubmonoidClass.{u4, u3} S γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)) _inst_4] (s : S) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (g : forall (i : ι), (β i) -> γ), (forall (c : ι), (Ne.{succ u2} (β c) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f c) (OfNat.ofNat.{u2} (β c) 0 (OfNat.mk.{u2} (β c) 0 (Zero.zero.{u2} (β c) (_inst_1 c))))) -> (Membership.Mem.{u3, u4} γ S (SetLike.hasMem.{u4, u3} S γ _inst_4) (g c (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f c)) s)) -> (Membership.Mem.{u3, u4} γ S (SetLike.hasMem.{u4, u3} S γ _inst_4) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f g) s)
but is expected to have type
  forall {ι : Type.{u2}} {γ : Type.{u4}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] [_inst_1 : forall (i : ι), Zero.{u3} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u3} (β i) x (OfNat.ofNat.{u3} (β i) 0 (Zero.toOfNat0.{u3} (β i) (_inst_1 i))))] [_inst_3 : CommMonoid.{u4} γ] {S : Type.{u1}} [_inst_4 : SetLike.{u1, u4} S γ] [_inst_5 : SubmonoidClass.{u1, u4} S γ (Monoid.toMulOneClass.{u4} γ (CommMonoid.toMonoid.{u4} γ _inst_3)) _inst_4] (s : S) (f : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (g : forall (i : ι), (β i) -> γ), (forall (c : ι), (Ne.{succ u3} ((fun (i : ι) => (fun (i : ι) => β i) i) c) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f c) (OfNat.ofNat.{u3} ((fun (i : ι) => (fun (i : ι) => β i) i) c) 0 (Zero.toOfNat0.{u3} ((fun (i : ι) => (fun (i : ι) => β i) i) c) (_inst_1 c)))) -> (Membership.mem.{u4, u1} γ S (SetLike.instMembership.{u1, u4} S γ _inst_4) (g c (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) f c)) s)) -> (Membership.mem.{u4, u1} γ S (SetLike.instMembership.{u1, u4} S γ _inst_4) (Dfinsupp.prod.{u2, u3, u4} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f g) s)
Case conversion may be inaccurate. Consider using '#align dfinsupp_prod_mem dfinsupp_prod_memₓ'. -/
@[to_additive]
theorem dfinsupp_prod_mem [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]
    {S : Type _} [SetLike S γ] [SubmonoidClass S γ] (s : S) (f : Π₀ i, β i) (g : ∀ i, β i → γ)
    (h : ∀ c, f c ≠ 0 → g c (f c) ∈ s) : f.Prod g ∈ s :=
  prod_mem fun i hi => h _ <| mem_support_iff.1 hi
#align dfinsupp_prod_mem dfinsupp_prod_mem
#align dfinsupp_sum_mem dfinsupp_sum_mem

/- warning: dfinsupp.prod_eq_prod_fintype -> Dfinsupp.prod_eq_prod_fintype is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : Fintype.{u1} ι] [_inst_2 : forall (i : ι), Zero.{u2} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_2 i)))))] [_inst_4 : CommMonoid.{u3} γ] (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) [f : forall (i : ι), (β i) -> γ], (forall (i : ι), Eq.{succ u3} γ (f i (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_2 i))))) (OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_4))))))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 v f) (Finset.prod.{u3, u1} γ ι _inst_4 (Finset.univ.{u1} ι _inst_1) (fun (i : ι) => f i (coeFn.{max 1 (max (succ (max u1 u2)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u1) (succ u2)} (Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), β i)) (fun (_x : Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), β i)) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) -> (forall (i : ι), β i)) (Equiv.hasCoeToFun.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), β i)) (Dfinsupp.equivFunOnFintype.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i) _inst_1) v i))))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : Fintype.{u1} ι] [_inst_2 : forall (i : ι), Zero.{u2} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (_inst_2 i))))] [_inst_4 : CommMonoid.{u3} γ] (v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) {f : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u3} γ (f i (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (_inst_2 i)))) (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_4))))) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 v f) (Finset.prod.{u3, u1} γ ι _inst_4 (Finset.univ.{u1} ι _inst_1) (fun (i : ι) => f i (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), β i)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), β i) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), β i)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), β i) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), β i)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), β i) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), β i)))) (Dfinsupp.equivFunOnFintype.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i) _inst_1) v i))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_eq_prod_fintype Dfinsupp.prod_eq_prod_fintypeₓ'. -/
@[simp, to_additive]
theorem prod_eq_prod_fintype [Fintype ι] [∀ i, Zero (β i)] [∀ (i : ι) (x : β i), Decidable (x ≠ 0)]
    [CommMonoid γ] (v : Π₀ i, β i) [f : ∀ i, β i → γ] (hf : ∀ i, f i 0 = 1) :
    v.Prod f = ∏ i, f i (Dfinsupp.equivFunOnFintype v i) :=
  by
  suffices (∏ i in v.support, f i (v i)) = ∏ i, f i (v i) by simp [Dfinsupp.prod, this]
  apply Finset.prod_subset v.support.subset_univ
  intro i hi' hi
  rw [mem_support_iff, Classical.not_not] at hi
  rw [hi, hf]
#align dfinsupp.prod_eq_prod_fintype Dfinsupp.prod_eq_prod_fintype
#align dfinsupp.sum_eq_sum_fintype Dfinsupp.sum_eq_sum_fintype

/- warning: dfinsupp.sum_add_hom -> Dfinsupp.sumAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ], (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) -> (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ], (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) -> (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_add_hom Dfinsupp.sumAddHomₓ'. -/
/--
When summing over an `add_monoid_hom`, the decidability assumption is not needed, and the result is
also an `add_monoid_hom`.
-/
def sumAddHom [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (φ : ∀ i, β i →+ γ) : (Π₀ i, β i) →+ γ
    where
  toFun f :=
    (f.support'.lift fun s => ∑ i in Multiset.toFinset ↑s, φ i (f i)) <|
      by
      rintro ⟨sx, hx⟩ ⟨sy, hy⟩
      dsimp only [Subtype.coe_mk, to_fun_eq_coe] at *
      have H1 : sx.to_finset ∩ sy.to_finset ⊆ sx.to_finset := Finset.inter_subset_left _ _
      have H2 : sx.to_finset ∩ sy.to_finset ⊆ sy.to_finset := Finset.inter_subset_right _ _
      refine'
        (Finset.sum_subset H1 _).symm.trans
          ((Finset.sum_congr rfl _).trans (Finset.sum_subset H2 _))
      · intro i H1 H2
        rw [Finset.mem_inter] at H2
        simp only [Multiset.mem_toFinset] at H1 H2
        rw [(hy i).resolve_left (mt (And.intro H1) H2), AddMonoidHom.map_zero]
      · intro i H1
        rfl
      · intro i H1 H2
        rw [Finset.mem_inter] at H2
        simp only [Multiset.mem_toFinset] at H1 H2
        rw [(hx i).resolve_left (mt (fun H3 => And.intro H3 H1) H2), AddMonoidHom.map_zero]
  map_add' := by
    rintro ⟨f, sf, hf⟩ ⟨g, sg, hg⟩
    change (∑ i in _, _) = (∑ i in _, _) + ∑ i in _, _
    simp only [coe_add, coe_mk', Subtype.coe_mk, Pi.add_apply, map_add, Finset.sum_add_distrib]
    congr 1
    · refine' (Finset.sum_subset _ _).symm
      · intro i
        simp only [Multiset.mem_toFinset, Multiset.mem_add]
        exact Or.inl
      · intro i H1 H2
        simp only [Multiset.mem_toFinset, Multiset.mem_add] at H2
        rw [(hf i).resolve_left H2, AddMonoidHom.map_zero]
    · refine' (Finset.sum_subset _ _).symm
      · intro i
        simp only [Multiset.mem_toFinset, Multiset.mem_add]
        exact Or.inr
      · intro i H1 H2
        simp only [Multiset.mem_toFinset, Multiset.mem_add] at H2
        rw [(hg i).resolve_left H2, AddMonoidHom.map_zero]
  map_zero' := rfl
#align dfinsupp.sum_add_hom Dfinsupp.sumAddHom

/- warning: dfinsupp.sum_add_hom_single -> Dfinsupp.sumAddHom_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] (φ : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (i : ι) (x : β i), Eq.{succ u3} γ (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 φ) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i)) i x)) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (_x : AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => (β i) -> γ) (AddMonoidHom.hasCoeToFun.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (φ i) x)
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] (φ : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (i : ι) (x : β i), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i x)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u1) (succ u2), succ u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) _x) (AddHomClass.toFunLike.{max (max u1 u2) u3, max u1 u2, u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (AddZeroClass.toAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddZeroClass.toAdd.{u3} γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u2) u3, max u1 u2, u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoidHom.addMonoidHomClass.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 φ) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i x)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (β i) (fun (_x : β i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β i) => γ) _x) (AddHomClass.toFunLike.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (β i) γ (AddZeroClass.toAdd.{u2} (β i) (_inst_1 i)) (AddZeroClass.toAdd.{u3} γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoidHom.addMonoidHomClass.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))))) (φ i) x)
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_add_hom_single Dfinsupp.sumAddHom_singleₓ'. -/
@[simp]
theorem sumAddHom_single [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (φ : ∀ i, β i →+ γ) (i)
    (x : β i) : sumAddHom φ (single i x) = φ i x :=
  by
  dsimp [sum_add_hom, single, Trunc.lift_mk]
  rw [Multiset.toFinset_singleton, Finset.sum_singleton, Pi.single_eq_same]
#align dfinsupp.sum_add_hom_single Dfinsupp.sumAddHom_single

#print Dfinsupp.sumAddHom_comp_single /-
@[simp]
theorem sumAddHom_comp_single [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (f : ∀ i, β i →+ γ)
    (i : ι) : (sumAddHom f).comp (singleAddHom β i) = f i :=
  AddMonoidHom.ext fun x => sumAddHom_single f i x
#align dfinsupp.sum_add_hom_comp_single Dfinsupp.sumAddHom_comp_single
-/

/- warning: dfinsupp.sum_add_hom_apply -> Dfinsupp.sumAddHom_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))))))] [_inst_3 : AddCommMonoid.{u3} γ] (φ : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ u3} γ (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_3 φ) f) (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f (fun (x : ι) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} (β x) γ (_inst_1 x) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (fun (_x : AddMonoidHom.{u2, u3} (β x) γ (_inst_1 x) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) => (β x) -> γ) (AddMonoidHom.hasCoeToFun.{u2, u3} (β x) γ (_inst_1 x) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (φ x)))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddZeroClass.toZero.{u2} (β i) (_inst_1 i)))))] [_inst_3 : AddCommMonoid.{u3} γ] (φ : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) f) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u1) (succ u2), succ u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) _x) (AddHomClass.toFunLike.{max (max u1 u2) u3, max u1 u2, u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (AddZeroClass.toAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddZeroClass.toAdd.{u3} γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u2) u3, max u1 u2, u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3)) (AddMonoidHom.addMonoidHomClass.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_3 φ) f) (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 f (fun (x : ι) => FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddMonoidHom.{u2, u3} (β x) γ (_inst_1 x) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (β x) (fun (_x : β x) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β x) => γ) _x) (AddHomClass.toFunLike.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} (β x) γ (_inst_1 x) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (β x) γ (AddZeroClass.toAdd.{u2} (β x) (_inst_1 x)) (AddZeroClass.toAdd.{u3} γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} (β x) γ (_inst_1 x) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))) (β x) γ (_inst_1 x) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3)) (AddMonoidHom.addMonoidHomClass.{u2, u3} (β x) γ (_inst_1 x) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_3))))) (φ x)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_add_hom_apply Dfinsupp.sumAddHom_applyₓ'. -/
/-- While we didn't need decidable instances to define it, we do to reduce it to a sum -/
theorem sumAddHom_apply [∀ i, AddZeroClass (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]
    [AddCommMonoid γ] (φ : ∀ i, β i →+ γ) (f : Π₀ i, β i) : sumAddHom φ f = f.Sum fun x => φ x :=
  by
  rcases f with ⟨f, s, hf⟩
  change (∑ i in _, _) = ∑ i in Finset.filter _ _, _
  rw [Finset.sum_filter, Finset.sum_congr rfl]
  intro i _
  dsimp only [coe_mk', Subtype.coe_mk] at *
  split_ifs
  rfl
  rw [not_not.mp h, AddMonoidHom.map_zero]
#align dfinsupp.sum_add_hom_apply Dfinsupp.sumAddHom_apply

/- warning: dfinsupp_sum_add_hom_mem -> dfinsupp_sumAddHom_mem is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] {S : Type.{u4}} [_inst_3 : SetLike.{u4, u3} S γ] [_inst_4 : AddSubmonoidClass.{u4, u3} S γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) _inst_3] (s : S) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))), (forall (c : ι), (Ne.{succ u2} (β c) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) f c) (OfNat.ofNat.{u2} (β c) 0 (OfNat.mk.{u2} (β c) 0 (Zero.zero.{u2} (β c) (AddZeroClass.toHasZero.{u2} (β c) (_inst_1 c)))))) -> (Membership.Mem.{u3, u4} γ S (SetLike.hasMem.{u4, u3} S γ _inst_3) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} (β c) γ (_inst_1 c) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (_x : AddMonoidHom.{u2, u3} (β c) γ (_inst_1 c) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => (β c) -> γ) (AddMonoidHom.hasCoeToFun.{u2, u3} (β c) γ (_inst_1 c) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (g c) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) f c)) s)) -> (Membership.Mem.{u3, u4} γ S (SetLike.hasMem.{u4, u3} S γ _inst_3) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 g) f) s)
but is expected to have type
  forall {ι : Type.{u2}} {γ : Type.{u4}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u3} (β i)] [_inst_2 : AddCommMonoid.{u4} γ] {S : Type.{u1}} [_inst_3 : SetLike.{u1, u4} S γ] [_inst_4 : AddSubmonoidClass.{u1, u4} S γ (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2)) _inst_3] (s : S) (f : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (g : forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))), (forall (c : ι), (Ne.{succ u3} ((fun (i : ι) => (fun (i : ι) => β i) i) c) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) f c) (OfNat.ofNat.{u3} ((fun (i : ι) => (fun (i : ι) => β i) i) c) 0 (Zero.toOfNat0.{u3} ((fun (i : ι) => (fun (i : ι) => β i) i) c) (AddZeroClass.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => β i) i) c) (_inst_1 c))))) -> (Membership.mem.{u4, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β c) => γ) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (a : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) a) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) f c)) S (SetLike.instMembership.{u1, u4} S γ _inst_3) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (AddMonoidHom.{u3, u4} (β c) γ (_inst_1 c) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (β c) (fun (_x : β c) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β c) => γ) _x) (AddHomClass.toFunLike.{max u3 u4, u3, u4} (AddMonoidHom.{u3, u4} (β c) γ (_inst_1 c) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (β c) γ (AddZeroClass.toAdd.{u3} (β c) (_inst_1 c)) (AddZeroClass.toAdd.{u4} γ (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u3 u4, u3, u4} (AddMonoidHom.{u3, u4} (β c) γ (_inst_1 c) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (β c) γ (_inst_1 c) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u4} (β c) γ (_inst_1 c) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))))) (g c) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i)) i)) f c)) s)) -> (Membership.mem.{u4, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) f) S (SetLike.instMembership.{u1, u4} S γ _inst_3) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) _x) (AddHomClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (AddZeroClass.toAdd.{max u2 u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddZeroClass.toAdd.{u4} γ (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHomClass.toAddHomClass.{max (max u2 u3) u4, max u2 u3, u4} (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2)) (AddMonoidHom.addMonoidHomClass.{max u2 u3, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))))) (Dfinsupp.sumAddHom.{u2, u3, u4} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 g) f) s)
Case conversion may be inaccurate. Consider using '#align dfinsupp_sum_add_hom_mem dfinsupp_sumAddHom_memₓ'. -/
theorem dfinsupp_sumAddHom_mem [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] {S : Type _}
    [SetLike S γ] [AddSubmonoidClass S γ] (s : S) (f : Π₀ i, β i) (g : ∀ i, β i →+ γ)
    (h : ∀ c, f c ≠ 0 → g c (f c) ∈ s) : Dfinsupp.sumAddHom g f ∈ s := by
  classical
    rw [Dfinsupp.sumAddHom_apply]
    convert dfinsupp_sum_mem _ _ _ _
    · infer_instance
    exact h
#align dfinsupp_sum_add_hom_mem dfinsupp_sumAddHom_mem

/- warning: add_submonoid.supr_eq_mrange_dfinsupp_sum_add_hom -> AddSubmonoid.supᵢ_eq_mrange_dfinsupp_sumAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))), Eq.{succ u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (CompleteSemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (CompleteLattice.toCompleteSemilatticeSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (AddSubmonoid.completeLattice.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))))) ι S) (AddMonoidHom.mrange.{max u1 u2, u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (AddMonoidHom.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (AddMonoidHom.addMonoidHomClass.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (Dfinsupp.sumAddHom.{u1, u2, u2} ι γ (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) _inst_1 (fun (i : ι) => AddSubmonoid.subtype.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))), Eq.{succ u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (CompleteLattice.toSupSet.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) ι S) (AddMonoidHom.mrange.{max u1 u2, u2, max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (AddMonoidHom.{max u2 u1, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (AddMonoidHom.addMonoidHomClass.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (Dfinsupp.sumAddHom.{u1, u2, u2} ι γ (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) _inst_1 (fun (i : ι) => AddSubmonoid.subtype.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))))
Case conversion may be inaccurate. Consider using '#align add_submonoid.supr_eq_mrange_dfinsupp_sum_add_hom AddSubmonoid.supᵢ_eq_mrange_dfinsupp_sumAddHomₓ'. -/
/-- The supremum of a family of commutative additive submonoids is equal to the range of
`dfinsupp.sum_add_hom`; that is, every element in the `supr` can be produced from taking a finite
number of non-zero elements of `S i`, coercing them to `γ`, and summing them. -/
theorem AddSubmonoid.supᵢ_eq_mrange_dfinsupp_sumAddHom [AddCommMonoid γ] (S : ι → AddSubmonoid γ) :
    supᵢ S = (Dfinsupp.sumAddHom fun i => (S i).Subtype).mrange :=
  by
  apply le_antisymm
  · apply supᵢ_le _
    intro i y hy
    exact ⟨Dfinsupp.single i ⟨y, hy⟩, Dfinsupp.sumAddHom_single _ _ _⟩
  · rintro x ⟨v, rfl⟩
    exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_supᵢ S i : S i ≤ _) (v i).Prop
#align add_submonoid.supr_eq_mrange_dfinsupp_sum_add_hom AddSubmonoid.supᵢ_eq_mrange_dfinsupp_sumAddHom

/- warning: add_submonoid.bsupr_eq_mrange_dfinsupp_sum_add_hom -> AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] (p : ι -> Prop) [_inst_1 : DecidablePred.{succ u1} ι p] [_inst_2 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))), Eq.{succ u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteSemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteLattice.toCompleteSemilatticeSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddSubmonoid.completeLattice.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))))) ι (fun (i : ι) => supᵢ.{u2, 0} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteSemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteLattice.toCompleteSemilatticeSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddSubmonoid.completeLattice.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))))) (p i) (fun (h : p i) => S i))) (AddMonoidHom.mrange.{max u1 u2, u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (AddMonoidHom.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddMonoidHom.addMonoidHomClass.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddMonoidHom.comp.{max u1 u2, max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (Dfinsupp.sumAddHom.{u1, u2, u2} ι γ (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) _inst_2 (fun (i : ι) => AddSubmonoid.subtype.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (Dfinsupp.filterAddMonoidHom.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) p (fun (a : ι) => _inst_1 a))))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] (p : ι -> Prop) [_inst_1 : DecidablePred.{succ u1} ι p] [_inst_2 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))), Eq.{succ u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteLattice.toSupSet.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) ι (fun (i : ι) => supᵢ.{u2, 0} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteLattice.toSupSet.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (p i) (fun (h : p i) => S i))) (AddMonoidHom.mrange.{max u1 u2, u2, max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (AddMonoidHom.{max u2 u1, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddMonoidHom.addMonoidHomClass.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddMonoidHom.comp.{max u2 u1, max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (Dfinsupp.sumAddHom.{u1, u2, u2} ι γ (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) _inst_2 (fun (i : ι) => AddSubmonoid.subtype.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (Dfinsupp.filterAddMonoidHom.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) p (fun (a : ι) => _inst_1 a))))
Case conversion may be inaccurate. Consider using '#align add_submonoid.bsupr_eq_mrange_dfinsupp_sum_add_hom AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHomₓ'. -/
/-- The bounded supremum of a family of commutative additive submonoids is equal to the range of
`dfinsupp.sum_add_hom` composed with `dfinsupp.filter_add_monoid_hom`; that is, every element in the
bounded `supr` can be produced from taking a finite number of non-zero elements from the `S i` that
satisfy `p i`, coercing them to `γ`, and summing them. -/
theorem AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom (p : ι → Prop) [DecidablePred p]
    [AddCommMonoid γ] (S : ι → AddSubmonoid γ) :
    (⨆ (i) (h : p i), S i) =
      ((sumAddHom fun i => (S i).Subtype).comp (filterAddMonoidHom _ p)).mrange :=
  by
  apply le_antisymm
  · refine' supᵢ₂_le fun i hi y hy => ⟨Dfinsupp.single i ⟨y, hy⟩, _⟩
    rw [AddMonoidHom.comp_apply, filter_add_monoid_hom_apply, filter_single_pos _ _ hi]
    exact sum_add_hom_single _ _ _
  · rintro x ⟨v, rfl⟩
    refine' dfinsupp_sumAddHom_mem _ _ _ fun i hi => _
    refine' AddSubmonoid.mem_supᵢ_of_mem i _
    by_cases hp : p i
    · simp [hp]
    · simp [hp]
#align add_submonoid.bsupr_eq_mrange_dfinsupp_sum_add_hom AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom

/- warning: add_submonoid.mem_supr_iff_exists_dfinsupp -> AddSubmonoid.mem_supᵢ_iff_exists_dfinsupp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (x : γ), Iff (Membership.Mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (CompleteSemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (CompleteLattice.toCompleteSemilatticeSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (AddSubmonoid.completeLattice.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))))) ι S)) (Exists.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (fun (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) => Eq.{succ u2} γ (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (AddMonoidHom.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) ((fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) i)) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (fun (_x : AddMonoidHom.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) ((fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) i)) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) ((fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) ((fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) i)) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (Dfinsupp.sumAddHom.{u1, u2, u2} ι γ (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) _inst_1 (fun (i : ι) => AddSubmonoid.subtype.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) f) x))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (x : γ), Iff (Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (CompleteLattice.toSupSet.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) ι S)) (Exists.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (fun (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) => Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) => γ) f) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), succ u2} (AddMonoidHom.{max u2 u1, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) => γ) _x) (AddHomClass.toFunLike.{max u1 u2, max u1 u2, u2} (AddMonoidHom.{max u2 u1, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (AddZeroClass.toAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) (AddZeroClass.toAdd.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, max u1 u2, u2} (AddMonoidHom.{max u2 u1, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (AddMonoidHom.addMonoidHomClass.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))))) (Dfinsupp.sumAddHom.{u1, u2, u2} ι γ (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) _inst_1 (fun (i : ι) => AddSubmonoid.subtype.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) f) x))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mem_supr_iff_exists_dfinsupp AddSubmonoid.mem_supᵢ_iff_exists_dfinsuppₓ'. -/
theorem AddSubmonoid.mem_supᵢ_iff_exists_dfinsupp [AddCommMonoid γ] (S : ι → AddSubmonoid γ)
    (x : γ) : x ∈ supᵢ S ↔ ∃ f : Π₀ i, S i, Dfinsupp.sumAddHom (fun i => (S i).Subtype) f = x :=
  SetLike.ext_iff.mp (AddSubmonoid.supᵢ_eq_mrange_dfinsupp_sumAddHom S) x
#align add_submonoid.mem_supr_iff_exists_dfinsupp AddSubmonoid.mem_supᵢ_iff_exists_dfinsupp

/- warning: add_submonoid.mem_supr_iff_exists_dfinsupp' -> AddSubmonoid.mem_supᵢ_iff_exists_dfinsupp' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) [_inst_2 : forall (i : ι) (x : coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)), Decidable (Ne.{succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) x (OfNat.ofNat.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) 0 (OfNat.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) 0 (Zero.zero.{u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))))))] (x : γ), Iff (Membership.Mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (CompleteSemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (CompleteLattice.toCompleteSemilatticeSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (AddSubmonoid.completeLattice.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))))) ι S)) (Exists.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (fun (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) => Eq.{succ u2} γ (Dfinsupp.sum.{u1, u2, u2} ι γ (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) (fun (i : ι) (x : coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) => _inst_2 i x) _inst_1 f (fun (i : ι) (xi : coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) γ (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) γ (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) γ (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) (S i)) γ (coeSubtype.{succ u2} γ (fun (x : γ) => Membership.Mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i)))))) xi)) x))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) [_inst_2 : forall (i : ι) (x : Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))), Decidable (Ne.{succ u2} (Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) x (OfNat.ofNat.{u2} (Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) 0 (Zero.toOfNat0.{u2} (Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)))))] (x : γ), Iff (Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (CompleteLattice.toSupSet.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) ι S)) (Exists.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) (fun (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i))) => Eq.{succ u2} γ (Dfinsupp.sum.{u1, u2, u2} ι γ (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)) (S i)) (fun (i : ι) (x : Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) => _inst_2 i x) _inst_1 f (fun (i : ι) (xi : Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1)))) x (S i))) => Subtype.val.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (Set.{u2} γ) (Set.instMembershipSet.{u2} γ) x (SetLike.coe.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_1))) (S i))) xi)) x))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mem_supr_iff_exists_dfinsupp' AddSubmonoid.mem_supᵢ_iff_exists_dfinsupp'ₓ'. -/
/-- A variant of `add_submonoid.mem_supr_iff_exists_dfinsupp` with the RHS fully unfolded. -/
theorem AddSubmonoid.mem_supᵢ_iff_exists_dfinsupp' [AddCommMonoid γ] (S : ι → AddSubmonoid γ)
    [∀ (i) (x : S i), Decidable (x ≠ 0)] (x : γ) :
    x ∈ supᵢ S ↔ ∃ f : Π₀ i, S i, (f.Sum fun i xi => ↑xi) = x :=
  by
  rw [AddSubmonoid.mem_supᵢ_iff_exists_dfinsupp]
  simp_rw [sum_add_hom_apply]
  congr
#align add_submonoid.mem_supr_iff_exists_dfinsupp' AddSubmonoid.mem_supᵢ_iff_exists_dfinsupp'

/- warning: add_submonoid.mem_bsupr_iff_exists_dfinsupp -> AddSubmonoid.mem_bsupr_iff_exists_dfinsupp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] (p : ι -> Prop) [_inst_1 : DecidablePred.{succ u1} ι p] [_inst_2 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (x : γ), Iff (Membership.Mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.hasMem.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteSemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteLattice.toCompleteSemilatticeSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddSubmonoid.completeLattice.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))))) ι (fun (i : ι) => supᵢ.{u2, 0} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteSemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteLattice.toCompleteSemilatticeSup.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddSubmonoid.completeLattice.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))))) (p i) (fun (h : p i) => S i)))) (Exists.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (fun (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) => Eq.{succ u2} γ (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (AddMonoidHom.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) ((fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) i)) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (fun (_x : AddMonoidHom.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) ((fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) i)) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) ((fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) ((fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) i)) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (Dfinsupp.sumAddHom.{u1, u2, u2} ι γ (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) _inst_2 (fun (i : ι) => AddSubmonoid.subtype.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => coeSort.{succ u2, succ (succ u2)} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.setLike.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (S i)) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) p (fun (a : ι) => _inst_1 a) f)) x))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u2}} [dec : DecidableEq.{succ u1} ι] (p : ι -> Prop) [_inst_1 : DecidablePred.{succ u1} ι p] [_inst_2 : AddCommMonoid.{u2} γ] (S : ι -> (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (x : γ), Iff (Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (supᵢ.{u2, succ u1} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteLattice.toSupSet.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) ι (fun (i : ι) => supᵢ.{u2, 0} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (CompleteLattice.toSupSet.{u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) (p i) (fun (h : p i) => S i)))) (Exists.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (fun (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.zero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) => Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) => γ) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) p (fun (a : ι) => _inst_1 a) f)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), succ u2} (AddMonoidHom.{max u2 u1, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) => γ) _x) (AddHomClass.toFunLike.{max u1 u2, max u1 u2, u2} (AddMonoidHom.{max u2 u1, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (AddZeroClass.toAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) (AddZeroClass.toAdd.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, max u1 u2, u2} (AddMonoidHom.{max u2 u1, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (AddMonoidHom.addMonoidHomClass.{max u1 u2, u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))))) (Dfinsupp.sumAddHom.{u1, u2, u2} ι γ (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i)) _inst_2 (fun (i : ι) => AddSubmonoid.subtype.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) (Dfinsupp.filter.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => Subtype.{succ u2} γ (fun (x : γ) => Membership.mem.{u2, u2} γ (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2))) γ (AddSubmonoid.instSetLikeAddSubmonoid.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)))) x (S i))) i) (AddSubmonoid.toAddZeroClass.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ _inst_2)) (S i))) p (fun (a : ι) => _inst_1 a) f)) x))
Case conversion may be inaccurate. Consider using '#align add_submonoid.mem_bsupr_iff_exists_dfinsupp AddSubmonoid.mem_bsupr_iff_exists_dfinsuppₓ'. -/
theorem AddSubmonoid.mem_bsupr_iff_exists_dfinsupp (p : ι → Prop) [DecidablePred p]
    [AddCommMonoid γ] (S : ι → AddSubmonoid γ) (x : γ) :
    (x ∈ ⨆ (i) (h : p i), S i) ↔
      ∃ f : Π₀ i, S i, Dfinsupp.sumAddHom (fun i => (S i).Subtype) (f.filter p) = x :=
  SetLike.ext_iff.mp (AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom p S) x
#align add_submonoid.mem_bsupr_iff_exists_dfinsupp AddSubmonoid.mem_bsupr_iff_exists_dfinsupp

omit dec

/- warning: dfinsupp.sum_add_hom_comm -> Dfinsupp.sumAddHom_comm is a dubious translation:
lean 3 declaration is
  forall {ι₁ : Type.{u1}} {ι₂ : Type.{u2}} {β₁ : ι₁ -> Type.{u3}} {β₂ : ι₂ -> Type.{u4}} {γ : Type.{u5}} [_inst_1 : DecidableEq.{succ u1} ι₁] [_inst_2 : DecidableEq.{succ u2} ι₂] [_inst_3 : forall (i : ι₁), AddZeroClass.{u3} (β₁ i)] [_inst_4 : forall (i : ι₂), AddZeroClass.{u4} (β₂ i)] [_inst_5 : AddCommMonoid.{u5} γ] (f₁ : Dfinsupp.{u1, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toHasZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (f₂ : Dfinsupp.{u2, u4} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toHasZero.{u4} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (h : forall (i : ι₁) (j : ι₂), AddMonoidHom.{u3, max u5 u4} (β₁ i) (AddMonoidHom.{u4, u5} (β₂ j) γ (_inst_4 j) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (_inst_3 i) (AddMonoid.toAddZeroClass.{max u5 u4} (AddMonoidHom.{u4, u5} (β₂ j) γ (_inst_4 j) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u5 u4} (AddMonoidHom.{u4, u5} (β₂ j) γ (_inst_4 j) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u4, u5} (β₂ j) γ (_inst_4 j) _inst_5)))), Eq.{succ u5} γ (coeFn.{max (succ u5) (succ (max u2 u4)), max (succ (max u2 u4)) (succ u5)} (AddMonoidHom.{max u2 u4, u5} (Dfinsupp.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => AddZeroClass.toHasZero.{u4} ((fun (i₂ : ι₂) => β₂ i₂) i) ((fun (i₂ : ι₂) => _inst_4 i₂) i))) γ (Dfinsupp.addZeroClass.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => (fun (i₂ : ι₂) => _inst_4 i₂) i)) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (fun (_x : AddMonoidHom.{max u2 u4, u5} (Dfinsupp.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => AddZeroClass.toHasZero.{u4} ((fun (i₂ : ι₂) => β₂ i₂) i) ((fun (i₂ : ι₂) => _inst_4 i₂) i))) γ (Dfinsupp.addZeroClass.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => (fun (i₂ : ι₂) => _inst_4 i₂) i)) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) => (Dfinsupp.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => AddZeroClass.toHasZero.{u4} ((fun (i₂ : ι₂) => β₂ i₂) i) ((fun (i₂ : ι₂) => _inst_4 i₂) i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u2 u4, u5} (Dfinsupp.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => AddZeroClass.toHasZero.{u4} ((fun (i₂ : ι₂) => β₂ i₂) i) ((fun (i₂ : ι₂) => _inst_4 i₂) i))) γ (Dfinsupp.addZeroClass.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => (fun (i₂ : ι₂) => _inst_4 i₂) i)) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (Dfinsupp.sumAddHom.{u2, u4, u5} ι₂ γ (fun (i₂ : ι₂) => β₂ i₂) (fun (a : ι₂) (b : ι₂) => _inst_2 a b) (fun (i₂ : ι₂) => _inst_4 i₂) _inst_5 (fun (i₂ : ι₂) => coeFn.{max (succ (max u5 u4)) (succ (max u1 u3)), max (succ (max u1 u3)) (succ (max u5 u4))} (AddMonoidHom.{max u1 u3, max u5 u4} (Dfinsupp.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => AddZeroClass.toHasZero.{u3} ((fun (i₁ : ι₁) => β₁ i₁) i) ((fun (i₁ : ι₁) => _inst_3 i₁) i))) (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (Dfinsupp.addZeroClass.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => (fun (i₁ : ι₁) => _inst_3 i₁) i)) (AddMonoid.toAddZeroClass.{max u5 u4} (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u5 u4} (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) _inst_5)))) (fun (_x : AddMonoidHom.{max u1 u3, max u5 u4} (Dfinsupp.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => AddZeroClass.toHasZero.{u3} ((fun (i₁ : ι₁) => β₁ i₁) i) ((fun (i₁ : ι₁) => _inst_3 i₁) i))) (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (Dfinsupp.addZeroClass.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => (fun (i₁ : ι₁) => _inst_3 i₁) i)) (AddMonoid.toAddZeroClass.{max u5 u4} (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u5 u4} (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) _inst_5)))) => (Dfinsupp.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => AddZeroClass.toHasZero.{u3} ((fun (i₁ : ι₁) => β₁ i₁) i) ((fun (i₁ : ι₁) => _inst_3 i₁) i))) -> (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5)))) (AddMonoidHom.hasCoeToFun.{max u1 u3, max u5 u4} (Dfinsupp.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => AddZeroClass.toHasZero.{u3} ((fun (i₁ : ι₁) => β₁ i₁) i) ((fun (i₁ : ι₁) => _inst_3 i₁) i))) (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (Dfinsupp.addZeroClass.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => (fun (i₁ : ι₁) => _inst_3 i₁) i)) (AddMonoid.toAddZeroClass.{max u5 u4} (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u5 u4} (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) _inst_5)))) (Dfinsupp.sumAddHom.{u1, u3, max u5 u4} ι₁ (AddMonoidHom.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i₁ : ι₁) => _inst_3 i₁) (AddMonoidHom.addCommMonoid.{u4, u5} (β₂ i₂) γ (_inst_4 i₂) _inst_5) (fun (i₁ : ι₁) => h i₁ i₂)) f₁)) f₂) (coeFn.{max (succ u5) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u5)} (AddMonoidHom.{max u1 u3, u5} (Dfinsupp.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => AddZeroClass.toHasZero.{u3} ((fun (i₁ : ι₁) => β₁ i₁) i) ((fun (i₁ : ι₁) => _inst_3 i₁) i))) γ (Dfinsupp.addZeroClass.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => (fun (i₁ : ι₁) => _inst_3 i₁) i)) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (fun (_x : AddMonoidHom.{max u1 u3, u5} (Dfinsupp.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => AddZeroClass.toHasZero.{u3} ((fun (i₁ : ι₁) => β₁ i₁) i) ((fun (i₁ : ι₁) => _inst_3 i₁) i))) γ (Dfinsupp.addZeroClass.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => (fun (i₁ : ι₁) => _inst_3 i₁) i)) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) => (Dfinsupp.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => AddZeroClass.toHasZero.{u3} ((fun (i₁ : ι₁) => β₁ i₁) i) ((fun (i₁ : ι₁) => _inst_3 i₁) i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u1 u3, u5} (Dfinsupp.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => AddZeroClass.toHasZero.{u3} ((fun (i₁ : ι₁) => β₁ i₁) i) ((fun (i₁ : ι₁) => _inst_3 i₁) i))) γ (Dfinsupp.addZeroClass.{u1, u3} ι₁ (fun (i : ι₁) => (fun (i₁ : ι₁) => β₁ i₁) i) (fun (i : ι₁) => (fun (i₁ : ι₁) => _inst_3 i₁) i)) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (Dfinsupp.sumAddHom.{u1, u3, u5} ι₁ γ (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i₁ : ι₁) => _inst_3 i₁) _inst_5 (fun (i₁ : ι₁) => coeFn.{max (succ (max u5 u3)) (succ (max u2 u4)), max (succ (max u2 u4)) (succ (max u5 u3))} (AddMonoidHom.{max u2 u4, max u5 u3} (Dfinsupp.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => AddZeroClass.toHasZero.{u4} ((fun (i₂ : ι₂) => β₂ i₂) i) ((fun (i₂ : ι₂) => _inst_4 i₂) i))) (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (Dfinsupp.addZeroClass.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => (fun (i₂ : ι₂) => _inst_4 i₂) i)) (AddMonoid.toAddZeroClass.{max u5 u3} (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u5 u3} (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) _inst_5)))) (fun (_x : AddMonoidHom.{max u2 u4, max u5 u3} (Dfinsupp.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => AddZeroClass.toHasZero.{u4} ((fun (i₂ : ι₂) => β₂ i₂) i) ((fun (i₂ : ι₂) => _inst_4 i₂) i))) (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (Dfinsupp.addZeroClass.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => (fun (i₂ : ι₂) => _inst_4 i₂) i)) (AddMonoid.toAddZeroClass.{max u5 u3} (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u5 u3} (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) _inst_5)))) => (Dfinsupp.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => AddZeroClass.toHasZero.{u4} ((fun (i₂ : ι₂) => β₂ i₂) i) ((fun (i₂ : ι₂) => _inst_4 i₂) i))) -> (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5)))) (AddMonoidHom.hasCoeToFun.{max u2 u4, max u5 u3} (Dfinsupp.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => AddZeroClass.toHasZero.{u4} ((fun (i₂ : ι₂) => β₂ i₂) i) ((fun (i₂ : ι₂) => _inst_4 i₂) i))) (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (Dfinsupp.addZeroClass.{u2, u4} ι₂ (fun (i : ι₂) => (fun (i₂ : ι₂) => β₂ i₂) i) (fun (i : ι₂) => (fun (i₂ : ι₂) => _inst_4 i₂) i)) (AddMonoid.toAddZeroClass.{max u5 u3} (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u5 u3} (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) _inst_5)))) (Dfinsupp.sumAddHom.{u2, u4, max u5 u3} ι₂ (AddMonoidHom.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u5} γ (AddCommMonoid.toAddMonoid.{u5} γ _inst_5))) (fun (i₂ : ι₂) => β₂ i₂) (fun (a : ι₂) (b : ι₂) => _inst_2 a b) (fun (i₂ : ι₂) => _inst_4 i₂) (AddMonoidHom.addCommMonoid.{u3, u5} (β₁ i₁) γ (_inst_3 i₁) _inst_5) (fun (i₂ : ι₂) => AddMonoidHom.flip.{u3, u4, u5} (β₁ i₁) (β₂ i₂) γ (_inst_3 i₁) (_inst_4 i₂) _inst_5 (h i₁ i₂))) f₂)) f₁)
but is expected to have type
  forall {ι₁ : Type.{u5}} {ι₂ : Type.{u4}} {β₁ : ι₁ -> Type.{u3}} {β₂ : ι₂ -> Type.{u2}} {γ : Type.{u1}} [_inst_1 : DecidableEq.{succ u5} ι₁] [_inst_2 : DecidableEq.{succ u4} ι₂] [_inst_3 : forall (i : ι₁), AddZeroClass.{u3} (β₁ i)] [_inst_4 : forall (i : ι₂), AddZeroClass.{u2} (β₂ i)] [_inst_5 : AddCommMonoid.{u1} γ] (f₁ : Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (f₂ : Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (h : forall (i : ι₁) (j : ι₂), AddMonoidHom.{u3, max u1 u2} (β₁ i) (AddMonoidHom.{u2, u1} (β₂ j) γ (_inst_4 j) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (_inst_3 i) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ j) γ (_inst_4 j) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ j) γ (_inst_4 j) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u2, u1} (β₂ j) γ (_inst_4 j) _inst_5)))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) => γ) f₂) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u4), max (succ u2) (succ u4), succ u1} (AddMonoidHom.{max u2 u4, u1} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) => γ) _x) (AddHomClass.toFunLike.{max (max u2 u1) u4, max u2 u4, u1} (AddMonoidHom.{max u2 u4, u1} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) γ (AddZeroClass.toAdd.{max u2 u4} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHomClass.toAddHomClass.{max (max u2 u1) u4, max u2 u4, u1} (AddMonoidHom.{max u2 u4, u1} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5)) (AddMonoidHom.addMonoidHomClass.{max u2 u4, u1} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))))) (Dfinsupp.sumAddHom.{u4, u2, u1} ι₂ γ (fun (i₂ : ι₂) => β₂ i₂) (fun (a : ι₂) (b : ι₂) => _inst_2 a b) (fun (i₂ : ι₂) => _inst_4 i₂) _inst_5 (fun (i₂ : ι₂) => FunLike.coe.{max (max (max (succ u3) (succ u2)) (succ u1)) (succ u5), max (succ u3) (succ u5), max (succ u2) (succ u1)} (AddMonoidHom.{max u3 u5, max u2 u1} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) _inst_5)))) (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (fun (_x : Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) => AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) _x) (AddHomClass.toFunLike.{max (max (max u3 u2) u1) u5, max u3 u5, max u2 u1} (AddMonoidHom.{max u3 u5, max u2 u1} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) _inst_5)))) (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddZeroClass.toAdd.{max u3 u5} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i))) (AddZeroClass.toAdd.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max (max (max u3 u2) u1) u5, max u3 u5, max u2 u1} (AddMonoidHom.{max u3 u5, max u2 u1} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) _inst_5)))) (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) _inst_5))) (AddMonoidHom.addMonoidHomClass.{max u3 u5, max u2 u1} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) _inst_5)))))) (Dfinsupp.sumAddHom.{u5, u3, max u2 u1} ι₁ (AddMonoidHom.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i₁ : ι₁) => _inst_3 i₁) (AddMonoidHom.addCommMonoid.{u2, u1} (β₂ i₂) γ (_inst_4 i₂) _inst_5) (fun (i₁ : ι₁) => h i₁ i₂)) f₁)) f₂) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u5), max (succ u3) (succ u5), succ u1} (AddMonoidHom.{max u3 u5, u1} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (fun (_x : Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) => γ) _x) (AddHomClass.toFunLike.{max (max u3 u1) u5, max u3 u5, u1} (AddMonoidHom.{max u3 u5, u1} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) γ (AddZeroClass.toAdd.{max u3 u5} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u1) u5, max u3 u5, u1} (AddMonoidHom.{max u3 u5, u1} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5)) (AddMonoidHom.addMonoidHomClass.{max u3 u5, u1} (Dfinsupp.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => AddZeroClass.toZero.{u3} ((fun (i : ι₁) => β₁ i) i) (_inst_3 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u5, u3} ι₁ (fun (i : ι₁) => β₁ i) (fun (i : ι₁) => _inst_3 i)) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))))) (Dfinsupp.sumAddHom.{u5, u3, u1} ι₁ γ (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i₁ : ι₁) => _inst_3 i₁) _inst_5 (fun (i₁ : ι₁) => FunLike.coe.{max (max (max (succ u3) (succ u2)) (succ u1)) (succ u4), max (succ u2) (succ u4), max (succ u3) (succ u1)} (AddMonoidHom.{max u2 u4, max u3 u1} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) _inst_5)))) (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) => AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) _x) (AddHomClass.toFunLike.{max (max (max u3 u2) u1) u4, max u2 u4, max u3 u1} (AddMonoidHom.{max u2 u4, max u3 u1} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) _inst_5)))) (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddZeroClass.toAdd.{max u2 u4} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i))) (AddZeroClass.toAdd.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoid.toAddZeroClass.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max (max (max u3 u2) u1) u4, max u2 u4, max u3 u1} (AddMonoidHom.{max u2 u4, max u3 u1} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) _inst_5)))) (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) _inst_5))) (AddMonoidHom.addMonoidHomClass.{max u2 u4, max u3 u1} (Dfinsupp.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => AddZeroClass.toZero.{u2} ((fun (i : ι₂) => β₂ i) i) (_inst_4 i))) (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u4, u2} ι₂ (fun (i : ι₂) => β₂ i) (fun (i : ι₂) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u1} (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) _inst_5)))))) (Dfinsupp.sumAddHom.{u4, u2, max u3 u1} ι₂ (AddMonoidHom.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) (AddMonoid.toAddZeroClass.{u1} γ (AddCommMonoid.toAddMonoid.{u1} γ _inst_5))) (fun (i₂ : ι₂) => β₂ i₂) (fun (a : ι₂) (b : ι₂) => _inst_2 a b) (fun (i₂ : ι₂) => _inst_4 i₂) (AddMonoidHom.addCommMonoid.{u3, u1} (β₁ i₁) γ (_inst_3 i₁) _inst_5) (fun (i₂ : ι₂) => AddMonoidHom.flip.{u3, u2, u1} (β₁ i₁) (β₂ i₂) γ (_inst_3 i₁) (_inst_4 i₂) _inst_5 (h i₁ i₂))) f₂)) f₁)
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_add_hom_comm Dfinsupp.sumAddHom_commₓ'. -/
theorem sumAddHom_comm {ι₁ ι₂ : Sort _} {β₁ : ι₁ → Type _} {β₂ : ι₂ → Type _} {γ : Type _}
    [DecidableEq ι₁] [DecidableEq ι₂] [∀ i, AddZeroClass (β₁ i)] [∀ i, AddZeroClass (β₂ i)]
    [AddCommMonoid γ] (f₁ : Π₀ i, β₁ i) (f₂ : Π₀ i, β₂ i) (h : ∀ i j, β₁ i →+ β₂ j →+ γ) :
    sumAddHom (fun i₂ => sumAddHom (fun i₁ => h i₁ i₂) f₁) f₂ =
      sumAddHom (fun i₁ => sumAddHom (fun i₂ => (h i₁ i₂).flip) f₂) f₁ :=
  by
  obtain ⟨⟨f₁, s₁, h₁⟩, ⟨f₂, s₂, h₂⟩⟩ := f₁, f₂
  simp only [sum_add_hom, AddMonoidHom.finset_sum_apply, Quotient.liftOn_mk, AddMonoidHom.coe_mk,
    AddMonoidHom.flip_apply, Trunc.lift]
  exact Finset.sum_comm
#align dfinsupp.sum_add_hom_comm Dfinsupp.sumAddHom_comm

include dec

/- warning: dfinsupp.lift_add_hom -> Dfinsupp.liftAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ], AddEquiv.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ], AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)
Case conversion may be inaccurate. Consider using '#align dfinsupp.lift_add_hom Dfinsupp.liftAddHomₓ'. -/
/-- The `dfinsupp` version of `finsupp.lift_add_hom`,-/
@[simps apply symm_apply]
def liftAddHom [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] : (∀ i, β i →+ γ) ≃+ ((Π₀ i, β i) →+ γ)
    where
  toFun := sumAddHom
  invFun F i := F.comp (singleAddHom β i)
  left_inv x := by
    ext
    simp
  right_inv ψ := by
    ext
    simp
  map_add' F G := by
    ext
    simp
#align dfinsupp.lift_add_hom Dfinsupp.liftAddHom

/- warning: dfinsupp.lift_add_hom_single_add_hom -> Dfinsupp.liftAddHom_singleAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)], Eq.{succ (max u1 u2)} (AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (AddEquiv.{max u1 u2, max u1 u2} (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Pi.instAdd.{u1, max u1 u2} ι (fun (i : ι) => AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.hasAdd.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (fun (_x : AddEquiv.{max u1 u2, max u1 u2} (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Pi.instAdd.{u1, max u1 u2} ι (fun (i : ι) => AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.hasAdd.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) => (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) -> (AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) (AddEquiv.hasCoeToFun.{max u1 u2, max u1 u2} (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Pi.instAdd.{u1, max u1 u2} ι (fun (i : ι) => AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.hasAdd.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (Dfinsupp.liftAddHom.{u1, u2, max u1 u2} ι (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoidHom.id.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)], Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) => AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ (max u1 u2)), max (max (succ u1) (succ u2)) (succ (max u1 u2)), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (AddEquiv.{max u1 u2, max (max u1 u2) u2 u1} (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Pi.instAdd.{u1, max u1 u2} ι (fun (i : ι) => AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (i : ι) => AddMonoidHom.add.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.add.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (_x : forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) => AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) _x) (EmbeddingLike.toFunLike.{max (max (succ u1) (succ u2)) (succ (max u1 u2)), max (max (succ u1) (succ u2)) (succ (max u1 u2)), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (AddEquiv.{max u1 u2, max (max u1 u2) u2 u1} (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Pi.instAdd.{u1, max u1 u2} ι (fun (i : ι) => AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (i : ι) => AddMonoidHom.add.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.add.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (EquivLike.toEmbeddingLike.{max (max (succ u1) (succ u2)) (succ (max u1 u2)), max (max (succ u1) (succ u2)) (succ (max u1 u2)), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (AddEquiv.{max u1 u2, max (max u1 u2) u2 u1} (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Pi.instAdd.{u1, max u1 u2} ι (fun (i : ι) => AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (i : ι) => AddMonoidHom.add.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.add.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddEquivClass.toEquivLike.{max u1 u2, max u1 u2, max u1 u2} (AddEquiv.{max u1 u2, max (max u1 u2) u2 u1} (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Pi.instAdd.{u1, max u1 u2} ι (fun (i : ι) => AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (i : ι) => AddMonoidHom.add.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.add.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Pi.instAdd.{u1, max u1 u2} ι (fun (i : ι) => AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (i : ι) => AddMonoidHom.add.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.add.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddEquiv.instAddEquivClassAddEquiv.{max u1 u2, max u1 u2} (forall (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Pi.instAdd.{u1, max u1 u2} ι (fun (i : ι) => AddMonoidHom.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (i : ι) => AddMonoidHom.add.{u2, max u1 u2} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.add.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) (Dfinsupp.liftAddHom.{u1, u2, max u1 u2} ι (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoidHom.id.{max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.lift_add_hom_single_add_hom Dfinsupp.liftAddHom_singleAddHomₓ'. -/
/-- The `dfinsupp` version of `finsupp.lift_add_hom_single_add_hom`,-/
@[simp]
theorem liftAddHom_singleAddHom [∀ i, AddCommMonoid (β i)] :
    liftAddHom (singleAddHom β) = AddMonoidHom.id (Π₀ i, β i) :=
  liftAddHom.toEquiv.apply_eq_iff_eq_symm_apply.2 rfl
#align dfinsupp.lift_add_hom_single_add_hom Dfinsupp.liftAddHom_singleAddHom

/- warning: dfinsupp.lift_add_hom_apply_single -> Dfinsupp.liftAddHom_apply_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] (f : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (i : ι) (x : β i), Eq.{succ u3} γ (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) -> γ) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (coeFn.{max (succ (max u1 u3 u2)) (succ (max u3 u1 u2)), max (succ (max u1 u3 u2)) (succ (max u3 u1 u2))} (AddEquiv.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (fun (_x : AddEquiv.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) => (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) -> (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)))) (AddEquiv.hasCoeToFun.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (Dfinsupp.liftAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2) f) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i)) i x)) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (_x : AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => (β i) -> γ) (AddMonoidHom.hasCoeToFun.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (f i) x)
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] (f : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (i : ι) (x : β i), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i x)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u1) (succ u2), succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) f) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => γ) _x) (AddHomClass.toFunLike.{max (max u1 u2) u3, max u1 u2, u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) f) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (AddZeroClass.toAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddZeroClass.toAdd.{u3} γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u2) u3, max u1 u2, u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) f) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoidHom.addMonoidHomClass.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))))) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (_x : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) _x) (EmbeddingLike.toFunLike.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (EquivLike.toEmbeddingLike.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddEquivClass.toEquivLike.{max (max u1 u2) u3, max (max u1 u2) u3, max (max u1 u2) u3} (AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u2) u3, max (max u1 u2) u3} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2))))) (Dfinsupp.liftAddHom.{u1, u2, u3} ι γ β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2) f) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i x)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (β i) (fun (_x : β i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β i) => γ) _x) (AddHomClass.toFunLike.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (β i) γ (AddZeroClass.toAdd.{u2} (β i) (_inst_1 i)) (AddZeroClass.toAdd.{u3} γ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoidHom.addMonoidHomClass.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))))) (f i) x)
Case conversion may be inaccurate. Consider using '#align dfinsupp.lift_add_hom_apply_single Dfinsupp.liftAddHom_apply_singleₓ'. -/
/-- The `dfinsupp` version of `finsupp.lift_add_hom_apply_single`,-/
theorem liftAddHom_apply_single [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (f : ∀ i, β i →+ γ)
    (i : ι) (x : β i) : liftAddHom f (single i x) = f i x := by simp
#align dfinsupp.lift_add_hom_apply_single Dfinsupp.liftAddHom_apply_single

/- warning: dfinsupp.lift_add_hom_comp_single -> Dfinsupp.liftAddHom_comp_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] (f : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (i : ι), Eq.{max (succ u3) (succ u2)} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.comp.{u2, max u1 u2, u3} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (_inst_1 i) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (coeFn.{max (succ (max u1 u3 u2)) (succ (max u3 u1 u2)), max (succ (max u1 u3 u2)) (succ (max u3 u1 u2))} (AddEquiv.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (fun (_x : AddEquiv.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) => (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) -> (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)))) (AddEquiv.hasCoeToFun.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (Dfinsupp.liftAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2) f) (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) i)) (f i)
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] (f : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (i : ι), Eq.{max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.comp.{u2, max u1 u2, u3} (β i) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (_inst_1 i) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (_x : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) => AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) _x) (EmbeddingLike.toFunLike.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (EquivLike.toEmbeddingLike.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddEquivClass.toEquivLike.{max (max u1 u2) u3, max (max u1 u2) u3, max (max u1 u2) u3} (AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u2) u3, max (max u1 u2) u3} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2))))) (Dfinsupp.liftAddHom.{u1, u2, u3} ι γ β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2) f) (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) i)) (f i)
Case conversion may be inaccurate. Consider using '#align dfinsupp.lift_add_hom_comp_single Dfinsupp.liftAddHom_comp_singleₓ'. -/
/-- The `dfinsupp` version of `finsupp.lift_add_hom_comp_single`,-/
theorem liftAddHom_comp_single [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (f : ∀ i, β i →+ γ)
    (i : ι) : (liftAddHom f).comp (singleAddHom β i) = f i := by simp
#align dfinsupp.lift_add_hom_comp_single Dfinsupp.liftAddHom_comp_single

/- warning: dfinsupp.comp_lift_add_hom -> Dfinsupp.comp_liftAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {δ : Type.{u4}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] [_inst_3 : AddCommMonoid.{u4} δ] (g : AddMonoidHom.{u3, u4} γ δ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (f : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))), Eq.{max (succ u4) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (AddMonoidHom.comp.{max u1 u2, u3, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3)) g (coeFn.{max (succ (max u1 u3 u2)) (succ (max u3 u1 u2)), max (succ (max u1 u3 u2)) (succ (max u3 u1 u2))} (AddEquiv.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (fun (_x : AddEquiv.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) => (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) -> (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)))) (AddEquiv.hasCoeToFun.{max u1 u3 u2, max u3 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Pi.instAdd.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (Dfinsupp.liftAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2) f)) (coeFn.{max (succ (max u1 u4 u2)) (succ (max u4 u1 u2)), max (succ (max u1 u4 u2)) (succ (max u4 u1 u2))} (AddEquiv.{max u1 u4 u2, max u4 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u4} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (Pi.instAdd.{u1, max u4 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u4} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u4} (β i) δ (_inst_1 i) _inst_3)) (AddMonoidHom.hasAdd.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_3)) (fun (_x : AddEquiv.{max u1 u4 u2, max u4 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u4} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (Pi.instAdd.{u1, max u4 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u4} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u4} (β i) δ (_inst_1 i) _inst_3)) (AddMonoidHom.hasAdd.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_3)) => (forall (i : ι), AddMonoidHom.{u2, u4} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) -> (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3)))) (AddEquiv.hasCoeToFun.{max u1 u4 u2, max u4 u1 u2} (forall (i : ι), AddMonoidHom.{u2, u4} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (Pi.instAdd.{u1, max u4 u2} ι (fun (i : ι) => AddMonoidHom.{u2, u4} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (fun (i : ι) => AddMonoidHom.hasAdd.{u2, u4} (β i) δ (_inst_1 i) _inst_3)) (AddMonoidHom.hasAdd.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_3)) (Dfinsupp.liftAddHom.{u1, u2, u4} ι δ (fun (a : ι) => β a) (fun (a : ι) (b : ι) => dec a b) (fun (a : ι) => _inst_1 a) _inst_3) (fun (a : ι) => AddMonoidHom.comp.{u2, u3, u4} (β a) γ δ (_inst_1 a) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3)) g (f a)))
but is expected to have type
  forall {ι : Type.{u2}} {γ : Type.{u4}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] {δ : Type.{u1}} [_inst_1 : forall (i : ι), AddZeroClass.{u3} (β i)] [_inst_2 : AddCommMonoid.{u4} γ] [_inst_3 : AddCommMonoid.{u1} δ] (g : AddMonoidHom.{u4, u1} γ δ (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (f : forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))), Eq.{max (max (succ u2) (succ u3)) (succ u1)} (AddMonoidHom.{max u2 u3, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.comp.{max u2 u3, u4, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3)) g (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (max (succ u2) (succ u3)) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (AddEquiv.{max (max u2 u3) u4, max u4 u3 u2} (forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (Pi.instAdd.{u2, max u3 u4} ι (fun (i : ι) => AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u3, u4} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u2 u3, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (fun (_x : forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) => AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) _x) (EmbeddingLike.toFunLike.{max (max (succ u2) (succ u3)) (succ u4), max (max (succ u2) (succ u3)) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (AddEquiv.{max (max u2 u3) u4, max u4 u3 u2} (forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (Pi.instAdd.{u2, max u3 u4} ι (fun (i : ι) => AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u3, u4} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u2 u3, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (EquivLike.toEmbeddingLike.{max (max (succ u2) (succ u3)) (succ u4), max (max (succ u2) (succ u3)) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (AddEquiv.{max (max u2 u3) u4, max u4 u3 u2} (forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (Pi.instAdd.{u2, max u3 u4} ι (fun (i : ι) => AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u3, u4} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u2 u3, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddEquivClass.toEquivLike.{max (max u2 u3) u4, max (max u2 u3) u4, max (max u2 u3) u4} (AddEquiv.{max (max u2 u3) u4, max u4 u3 u2} (forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (Pi.instAdd.{u2, max u3 u4} ι (fun (i : ι) => AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u3, u4} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u2 u3, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (Pi.instAdd.{u2, max u3 u4} ι (fun (i : ι) => AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u3, u4} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u2 u3, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2) (AddEquiv.instAddEquivClassAddEquiv.{max (max u2 u3) u4, max (max u2 u3) u4} (forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (AddMonoidHom.{max u3 u2, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (Pi.instAdd.{u2, max u3 u4} ι (fun (i : ι) => AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))) (fun (i : ι) => AddMonoidHom.add.{u3, u4} (β i) γ (_inst_1 i) _inst_2)) (AddMonoidHom.add.{max u2 u3, u4} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2))))) (Dfinsupp.liftAddHom.{u2, u3, u4} ι γ β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2) f)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1)} (AddEquiv.{max (max u2 u3) u1, max u1 u3 u2} (forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (Pi.instAdd.{u2, max u3 u1} ι (fun (i : ι) => AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (fun (i : ι) => AddMonoidHom.add.{u3, u1} (β i) δ (_inst_1 i) _inst_3)) (AddMonoidHom.add.{max u2 u3, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_3)) (forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (fun (_x : forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) => AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) _x) (EmbeddingLike.toFunLike.{max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1)} (AddEquiv.{max (max u2 u3) u1, max u1 u3 u2} (forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (Pi.instAdd.{u2, max u3 u1} ι (fun (i : ι) => AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (fun (i : ι) => AddMonoidHom.add.{u3, u1} (β i) δ (_inst_1 i) _inst_3)) (AddMonoidHom.add.{max u2 u3, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_3)) (forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (EquivLike.toEmbeddingLike.{max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1)} (AddEquiv.{max (max u2 u3) u1, max u1 u3 u2} (forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (Pi.instAdd.{u2, max u3 u1} ι (fun (i : ι) => AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (fun (i : ι) => AddMonoidHom.add.{u3, u1} (β i) δ (_inst_1 i) _inst_3)) (AddMonoidHom.add.{max u2 u3, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_3)) (forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddEquivClass.toEquivLike.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max (max u2 u3) u1, max u1 u3 u2} (forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (Pi.instAdd.{u2, max u3 u1} ι (fun (i : ι) => AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (fun (i : ι) => AddMonoidHom.add.{u3, u1} (β i) δ (_inst_1 i) _inst_3)) (AddMonoidHom.add.{max u2 u3, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_3)) (forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (Pi.instAdd.{u2, max u3 u1} ι (fun (i : ι) => AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (fun (i : ι) => AddMonoidHom.add.{u3, u1} (β i) δ (_inst_1 i) _inst_3)) (AddMonoidHom.add.{max u2 u3, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_3) (AddEquiv.instAddEquivClassAddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (forall (i : ι), AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (Pi.instAdd.{u2, max u3 u1} ι (fun (i : ι) => AddMonoidHom.{u3, u1} (β i) δ (_inst_1 i) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (fun (i : ι) => AddMonoidHom.add.{u3, u1} (β i) δ (_inst_1 i) _inst_3)) (AddMonoidHom.add.{max u2 u3, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_3))))) (Dfinsupp.liftAddHom.{u2, u3, u1} ι δ β (fun (a : ι) (b : ι) => dec a b) (fun (a : ι) => _inst_1 a) _inst_3) (fun (a : ι) => AddMonoidHom.comp.{u3, u4, u1} (β a) γ δ (_inst_1 a) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3)) g (f a)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comp_lift_add_hom Dfinsupp.comp_liftAddHomₓ'. -/
/-- The `dfinsupp` version of `finsupp.comp_lift_add_hom`,-/
theorem comp_liftAddHom {δ : Type _} [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] [AddCommMonoid δ]
    (g : γ →+ δ) (f : ∀ i, β i →+ γ) : g.comp (liftAddHom f) = liftAddHom fun a => g.comp (f a) :=
  liftAddHom.symm_apply_eq.1 <|
    funext fun a => by
      rw [lift_add_hom_symm_apply, AddMonoidHom.comp_assoc, lift_add_hom_comp_single]
#align dfinsupp.comp_lift_add_hom Dfinsupp.comp_liftAddHom

/- warning: dfinsupp.sum_add_hom_zero -> Dfinsupp.sumAddHom_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ], Eq.{max (succ u3) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 (fun (i : ι) => OfNat.ofNat.{max u3 u2} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) 0 (OfNat.mk.{max u3 u2} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) 0 (Zero.zero.{max u3 u2} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.hasZero.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))))))) (OfNat.ofNat.{max u3 u1 u2} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) 0 (OfNat.mk.{max u3 u1 u2} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) 0 (Zero.zero.{max u3 u1 u2} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.hasZero.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))))))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ], Eq.{max (max (succ u1) (succ u2)) (succ u3)} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 (fun (i : ι) => OfNat.ofNat.{max u2 u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) 0 (Zero.toOfNat0.{max u2 u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (instZeroAddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)))))) (OfNat.ofNat.{max (max u1 u2) u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) 0 (Zero.toOfNat0.{max (max u1 u2) u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (instZeroAddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_add_hom_zero Dfinsupp.sumAddHom_zeroₓ'. -/
@[simp]
theorem sumAddHom_zero [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] :
    (sumAddHom fun i => (0 : β i →+ γ)) = 0 :=
  (liftAddHom : (∀ i, β i →+ γ) ≃+ _).map_zero
#align dfinsupp.sum_add_hom_zero Dfinsupp.sumAddHom_zero

/- warning: dfinsupp.sum_add_hom_add -> Dfinsupp.sumAddHom_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] (g : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (h : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))), Eq.{max (succ u3) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 (fun (i : ι) => HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (instHAdd.{max u3 u2} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.hasAdd.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (g i) (h i))) (HAdd.hAdd.{max u3 u1 u2, max u3 u1 u2, max u3 u1 u2} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (instHAdd.{max u3 u1 u2} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 g) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 h))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] (g : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (h : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))), Eq.{max (max (succ u1) (succ u2)) (succ u3)} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 (fun (i : ι) => HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (instHAdd.{max u2 u3} (AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.add.{u2, u3} (β i) γ (_inst_1 i) _inst_2)) (g i) (h i))) (HAdd.hAdd.{max (max u1 u2) u3, max (max u1 u2) u3, max (max u1 u2) u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (instHAdd.{max (max u1 u2) u3} (AddMonoidHom.{max u2 u1, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) (AddMonoidHom.add.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) γ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _inst_2)) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 g) (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 h))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_add_hom_add Dfinsupp.sumAddHom_addₓ'. -/
@[simp]
theorem sumAddHom_add [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (g : ∀ i, β i →+ γ)
    (h : ∀ i, β i →+ γ) : (sumAddHom fun i => g i + h i) = sumAddHom g + sumAddHom h :=
  liftAddHom.map_add _ _
#align dfinsupp.sum_add_hom_add Dfinsupp.sumAddHom_add

/- warning: dfinsupp.sum_add_hom_single_add_hom -> Dfinsupp.sumAddHom_singleAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)], Eq.{succ (max u1 u2)} (AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Dfinsupp.sumAddHom.{u1, u2, max u1 u2} ι (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoidHom.id.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) i)))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)], Eq.{max (succ u1) (succ u2)} (AddMonoidHom.{max u2 u1, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (Dfinsupp.sumAddHom.{u1, u2, max u1 u2} ι (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.singleAddHom.{u1, u2} ι β (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (AddMonoidHom.id.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_add_hom_single_add_hom Dfinsupp.sumAddHom_singleAddHomₓ'. -/
@[simp]
theorem sumAddHom_singleAddHom [∀ i, AddCommMonoid (β i)] :
    sumAddHom (singleAddHom β) = AddMonoidHom.id _ :=
  lift_add_hom_single_add_hom
#align dfinsupp.sum_add_hom_single_add_hom Dfinsupp.sumAddHom_singleAddHom

/- warning: dfinsupp.comp_sum_add_hom -> Dfinsupp.comp_sumAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {δ : Type.{u4}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : AddCommMonoid.{u3} γ] [_inst_3 : AddCommMonoid.{u4} δ] (g : AddMonoidHom.{u3, u4} γ δ (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (f : forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))), Eq.{max (succ u4) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3))) (AddMonoidHom.comp.{max u1 u2, u3, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) γ δ (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3)) g (Dfinsupp.sumAddHom.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 f)) (Dfinsupp.sumAddHom.{u1, u2, u4} ι δ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_3 (fun (a : ι) => AddMonoidHom.comp.{u2, u3, u4} (β a) γ δ (_inst_1 a) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u4} δ (AddCommMonoid.toAddMonoid.{u4} δ _inst_3)) g (f a)))
but is expected to have type
  forall {ι : Type.{u2}} {γ : Type.{u4}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u2} ι] {δ : Type.{u1}} [_inst_1 : forall (i : ι), AddZeroClass.{u3} (β i)] [_inst_2 : AddCommMonoid.{u4} γ] [_inst_3 : AddCommMonoid.{u1} δ] (g : AddMonoidHom.{u4, u1} γ δ (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (f : forall (i : ι), AddMonoidHom.{u3, u4} (β i) γ (_inst_1 i) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2))), Eq.{max (max (succ u2) (succ u3)) (succ u1)} (AddMonoidHom.{max u3 u2, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3))) (AddMonoidHom.comp.{max u3 u2, u4, u1} (Dfinsupp.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β i) i) (_inst_1 i))) γ δ (Dfinsupp.instAddZeroClassDfinsuppToZero.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3)) g (Dfinsupp.sumAddHom.{u2, u3, u4} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_2 f)) (Dfinsupp.sumAddHom.{u2, u3, u1} ι δ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) _inst_3 (fun (a : ι) => AddMonoidHom.comp.{u3, u4, u1} (β a) γ δ (_inst_1 a) (AddMonoid.toAddZeroClass.{u4} γ (AddCommMonoid.toAddMonoid.{u4} γ _inst_2)) (AddMonoid.toAddZeroClass.{u1} δ (AddCommMonoid.toAddMonoid.{u1} δ _inst_3)) g (f a)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.comp_sum_add_hom Dfinsupp.comp_sumAddHomₓ'. -/
theorem comp_sumAddHom {δ : Type _} [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] [AddCommMonoid δ]
    (g : γ →+ δ) (f : ∀ i, β i →+ γ) : g.comp (sumAddHom f) = sumAddHom fun a => g.comp (f a) :=
  comp_liftAddHom _ _
#align dfinsupp.comp_sum_add_hom Dfinsupp.comp_sumAddHom

/- warning: dfinsupp.sum_sub_index -> Dfinsupp.sum_sub_index is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (SubNegMonoid.toAddMonoid.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))))))))] [_inst_3 : AddCommGroup.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι) (b₁ : β i) (b₂ : β i), Eq.{succ u3} γ (h i (HSub.hSub.{u2, u2, u2} (β i) (β i) (β i) (instHSub.{u2} (β i) (SubNegMonoid.toHasSub.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))) b₁ b₂)) (HSub.hSub.{u3, u3, u3} γ γ γ (instHSub.{u3} γ (SubNegMonoid.toHasSub.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3)))) (h i b₁) (h i b₂))) -> (Eq.{succ u3} γ (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) (AddCommGroup.toAddCommMonoid.{u3} γ _inst_3) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g) h) (HSub.hSub.{u3, u3, u3} γ γ γ (instHSub.{u3} γ (SubNegMonoid.toHasSub.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3)))) (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) (AddCommGroup.toAddCommMonoid.{u3} γ _inst_3) f h) (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) (AddCommGroup.toAddCommMonoid.{u3} γ _inst_3) g h)))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddGroup.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (NegZeroClass.toZero.{u2} (β i) (SubNegZeroMonoid.toNegZeroClass.{u2} (β i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} (β i) (AddGroup.toSubtractionMonoid.{u2} (β i) (_inst_1 i))))))))] [_inst_3 : AddCommGroup.{u3} γ] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {g : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι) (b₁ : β i) (b₂ : β i), Eq.{succ u3} γ (h i (HSub.hSub.{u2, u2, u2} (β i) (β i) (β i) (instHSub.{u2} (β i) (SubNegMonoid.toSub.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (_inst_1 i)))) b₁ b₂)) (HSub.hSub.{u3, u3, u3} γ γ γ (instHSub.{u3} γ (SubNegMonoid.toSub.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3)))) (h i b₁) (h i b₂))) -> (Eq.{succ u3} γ (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) (AddCommGroup.toAddCommMonoid.{u3} γ _inst_3) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) f g) h) (HSub.hSub.{u3, u3, u3} γ γ γ (instHSub.{u3} γ (SubNegMonoid.toSub.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3)))) (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) (AddCommGroup.toAddCommMonoid.{u3} γ _inst_3) f h) (Dfinsupp.sum.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => β i) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => β i) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) (fun (i : ι) (x : β i) => _inst_2 i x) (AddCommGroup.toAddCommMonoid.{u3} γ _inst_3) g h)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_sub_index Dfinsupp.sum_sub_indexₓ'. -/
theorem sum_sub_index [∀ i, AddGroup (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [AddCommGroup γ]
    {f g : Π₀ i, β i} {h : ∀ i, β i → γ} (h_sub : ∀ i b₁ b₂, h i (b₁ - b₂) = h i b₁ - h i b₂) :
    (f - g).Sum h = f.Sum h - g.Sum h :=
  by
  have := (lift_add_hom fun a => AddMonoidHom.ofMapSub (h a) (h_sub a)).map_sub f g
  rw [lift_add_hom_apply, sum_add_hom_apply, sum_add_hom_apply, sum_add_hom_apply] at this
  exact this
#align dfinsupp.sum_sub_index Dfinsupp.sum_sub_index

/- warning: dfinsupp.prod_finset_sum_index -> Dfinsupp.prod_finset_sum_index is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {γ : Type.{u3}} {α : Type.{u4}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] [_inst_3 : CommMonoid.{u3} γ] {s : Finset.{u4} α} {g : α -> (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u3} γ (h i (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))))) (OfNat.ofNat.{u3} γ 1 (OfNat.mk.{u3} γ 1 (One.one.{u3} γ (MulOneClass.toHasOne.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))))) -> (forall (i : ι) (b₁ : β i) (b₂ : β i), Eq.{succ u3} γ (h i (HAdd.hAdd.{u2, u2, u2} (β i) (β i) (β i) (instHAdd.{u2} (β i) (AddZeroClass.toHasAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) b₁ b₂)) (HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toHasMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (h i b₁) (h i b₂))) -> (Eq.{succ u3} γ (Finset.prod.{u3, u4} γ α _inst_3 s (fun (i : α) => Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (g i) h)) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (Finset.sum.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) α (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) s (fun (i : α) => g i)) h))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] {γ : Type.{u3}} {α : Type.{u4}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] [_inst_3 : CommMonoid.{u3} γ] {s : Finset.{u4} α} {g : α -> (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u3} γ (h i (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))) (OfNat.ofNat.{u3} γ 1 (One.toOfNat1.{u3} γ (Monoid.toOne.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3))))) -> (forall (i : ι) (b₁ : β i) (b₂ : β i), Eq.{succ u3} γ (h i (HAdd.hAdd.{u2, u2, u2} (β i) (β i) (β i) (instHAdd.{u2} (β i) (AddZeroClass.toAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) b₁ b₂)) (HMul.hMul.{u3, u3, u3} γ γ γ (instHMul.{u3} γ (MulOneClass.toMul.{u3} γ (Monoid.toMulOneClass.{u3} γ (CommMonoid.toMonoid.{u3} γ _inst_3)))) (h i b₁) (h i b₂))) -> (Eq.{succ u3} γ (Finset.prod.{u3, u4} γ α _inst_3 s (fun (i : α) => Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (g i) h)) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 (Finset.sum.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) α (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) s (fun (i : α) => g i)) h))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_finset_sum_index Dfinsupp.prod_finset_sum_indexₓ'. -/
@[to_additive]
theorem prod_finset_sum_index {γ : Type w} {α : Type x} [∀ i, AddCommMonoid (β i)]
    [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ] {s : Finset α} {g : α → Π₀ i, β i}
    {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)
    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) :
    (∏ i in s, (g i).Prod h) = (∑ i in s, g i).Prod h := by
  classical exact
      Finset.induction_on s (by simp [prod_zero_index])
        (by simp (config := { contextual := true }) [prod_add_index, h_zero, h_add])
#align dfinsupp.prod_finset_sum_index Dfinsupp.prod_finset_sum_index
#align dfinsupp.sum_finset_sum_index Dfinsupp.sum_finset_sum_index

/- warning: dfinsupp.prod_sum_index -> Dfinsupp.prod_sum_index is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u5}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u1} ι] {ι₁ : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} ι₁] {β₁ : ι₁ -> Type.{u4}} [_inst_2 : forall (i₁ : ι₁), Zero.{u4} (β₁ i₁)] [_inst_3 : forall (i : ι₁) (x : β₁ i), Decidable (Ne.{succ u4} (β₁ i) x (OfNat.ofNat.{u4} (β₁ i) 0 (OfNat.mk.{u4} (β₁ i) 0 (Zero.zero.{u4} (β₁ i) (_inst_2 i)))))] [_inst_4 : forall (i : ι), AddCommMonoid.{u3} (β i)] [_inst_5 : forall (i : ι) (x : β i), Decidable (Ne.{succ u3} (β i) x (OfNat.ofNat.{u3} (β i) 0 (OfNat.mk.{u3} (β i) 0 (Zero.zero.{u3} (β i) (AddZeroClass.toHasZero.{u3} (β i) (AddMonoid.toAddZeroClass.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_4 i))))))))] [_inst_6 : CommMonoid.{u5} γ] {f : Dfinsupp.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (i : ι₁) => _inst_2 i)} {g : forall (i₁ : ι₁), (β₁ i₁) -> (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u5} γ (h i (OfNat.ofNat.{u3} (β i) 0 (OfNat.mk.{u3} (β i) 0 (Zero.zero.{u3} (β i) (AddZeroClass.toHasZero.{u3} (β i) (AddMonoid.toAddZeroClass.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_4 i)))))))) (OfNat.ofNat.{u5} γ 1 (OfNat.mk.{u5} γ 1 (One.one.{u5} γ (MulOneClass.toHasOne.{u5} γ (Monoid.toMulOneClass.{u5} γ (CommMonoid.toMonoid.{u5} γ _inst_6))))))) -> (forall (i : ι) (b₁ : β i) (b₂ : β i), Eq.{succ u5} γ (h i (HAdd.hAdd.{u3, u3, u3} (β i) (β i) (β i) (instHAdd.{u3} (β i) (AddZeroClass.toHasAdd.{u3} (β i) (AddMonoid.toAddZeroClass.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_4 i))))) b₁ b₂)) (HMul.hMul.{u5, u5, u5} γ γ γ (instHMul.{u5} γ (MulOneClass.toHasMul.{u5} γ (Monoid.toMulOneClass.{u5} γ (CommMonoid.toMonoid.{u5} γ _inst_6)))) (h i b₁) (h i b₂))) -> (Eq.{succ u5} γ (Dfinsupp.prod.{u1, u3, u5} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))) (fun (i : ι) (x : β i) => _inst_5 i x) _inst_6 (Dfinsupp.sum.{u2, u4, max u1 u3} ι₁ (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) (Dfinsupp.addCommMonoid.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) f g) h) (Dfinsupp.prod.{u2, u4, u5} ι₁ γ (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) _inst_6 f (fun (i : ι₁) (b : β₁ i) => Dfinsupp.prod.{u1, u3, u5} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))) (fun (i : ι) (x : β i) => _inst_5 i x) _inst_6 (g i b) h)))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u5}} {β : ι -> Type.{u3}} [dec : DecidableEq.{succ u1} ι] {ι₁ : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} ι₁] {β₁ : ι₁ -> Type.{u4}} [_inst_2 : forall (i₁ : ι₁), Zero.{u4} (β₁ i₁)] [_inst_3 : forall (i : ι₁) (x : β₁ i), Decidable (Ne.{succ u4} (β₁ i) x (OfNat.ofNat.{u4} (β₁ i) 0 (Zero.toOfNat0.{u4} (β₁ i) (_inst_2 i))))] [_inst_4 : forall (i : ι), AddCommMonoid.{u3} (β i)] [_inst_5 : forall (i : ι) (x : β i), Decidable (Ne.{succ u3} (β i) x (OfNat.ofNat.{u3} (β i) 0 (Zero.toOfNat0.{u3} (β i) (AddMonoid.toZero.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_4 i))))))] [_inst_6 : CommMonoid.{u5} γ] {f : Dfinsupp.{u2, u4} ι₁ (fun (i₁ : ι₁) => β₁ i₁) (fun (i : ι₁) => _inst_2 i)} {g : forall (i₁ : ι₁), (β₁ i₁) -> (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))))} {h : forall (i : ι), (β i) -> γ}, (forall (i : ι), Eq.{succ u5} γ (h i (OfNat.ofNat.{u3} (β i) 0 (Zero.toOfNat0.{u3} (β i) (AddMonoid.toZero.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_4 i)))))) (OfNat.ofNat.{u5} γ 1 (One.toOfNat1.{u5} γ (Monoid.toOne.{u5} γ (CommMonoid.toMonoid.{u5} γ _inst_6))))) -> (forall (i : ι) (b₁ : β i) (b₂ : β i), Eq.{succ u5} γ (h i (HAdd.hAdd.{u3, u3, u3} (β i) (β i) (β i) (instHAdd.{u3} (β i) (AddZeroClass.toAdd.{u3} (β i) (AddMonoid.toAddZeroClass.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_4 i))))) b₁ b₂)) (HMul.hMul.{u5, u5, u5} γ γ γ (instHMul.{u5} γ (MulOneClass.toMul.{u5} γ (Monoid.toMulOneClass.{u5} γ (CommMonoid.toMonoid.{u5} γ _inst_6)))) (h i b₁) (h i b₂))) -> (Eq.{succ u5} γ (Dfinsupp.prod.{u1, u3, u5} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (i : ι) (x : β i) => _inst_5 i x) _inst_6 (Dfinsupp.sum.{u2, u4, max u1 u3} ι₁ (Dfinsupp.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i)))) (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) f g) h) (Dfinsupp.prod.{u2, u4, u5} ι₁ γ (fun (i₁ : ι₁) => β₁ i₁) (fun (a : ι₁) (b : ι₁) => _inst_1 a b) (fun (i : ι₁) => _inst_2 i) (fun (i : ι₁) (x : β₁ i) => _inst_3 i x) _inst_6 f (fun (i : ι₁) (b : β₁ i) => Dfinsupp.prod.{u1, u3, u5} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (i : ι) (x : β i) => _inst_5 i x) _inst_6 (g i b) h)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_sum_index Dfinsupp.prod_sum_indexₓ'. -/
@[to_additive]
theorem prod_sum_index {ι₁ : Type u₁} [DecidableEq ι₁] {β₁ : ι₁ → Type v₁} [∀ i₁, Zero (β₁ i₁)]
    [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ i, AddCommMonoid (β i)]
    [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ] {f : Π₀ i₁, β₁ i₁}
    {g : ∀ i₁, β₁ i₁ → Π₀ i, β i} {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)
    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) :
    (f.Sum g).Prod h = f.Prod fun i b => (g i b).Prod h :=
  (prod_finset_sum_index h_zero h_add).symm
#align dfinsupp.prod_sum_index Dfinsupp.prod_sum_index
#align dfinsupp.sum_sum_index Dfinsupp.sum_sum_index

/- warning: dfinsupp.sum_single -> Dfinsupp.sum_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))}, Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (Dfinsupp.sum.{u1, u2, max u1 u2} ι (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) (fun (i : ι) (x : β i) => _inst_2 i x) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))) f
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] {f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))}, Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (Dfinsupp.sum.{u1, u2, max u1 u2} ι (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (i : ι) (x : β i) => _inst_2 i x) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) f (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) f
Case conversion may be inaccurate. Consider using '#align dfinsupp.sum_single Dfinsupp.sum_singleₓ'. -/
@[simp]
theorem sum_single [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] {f : Π₀ i, β i} :
    f.Sum single = f :=
  by
  have := AddMonoidHom.congr_fun lift_add_hom_single_add_hom f
  rw [lift_add_hom_apply, sum_add_hom_apply] at this
  exact this
#align dfinsupp.sum_single Dfinsupp.sum_single

/- warning: dfinsupp.prod_subtype_domain_index -> Dfinsupp.prod_subtypeDomain_index is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_1 i)))))] [_inst_3 : CommMonoid.{u3} γ] {v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)} {p : ι -> Prop} [_inst_4 : DecidablePred.{succ u1} ι p] {h : forall (i : ι), (β i) -> γ}, (forall (x : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) x (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) v)) -> (p x)) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} (Subtype.{succ u1} ι p) γ (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (a : Subtype.{succ u1} ι p) (b : Subtype.{succ u1} ι p) => Subtype.decidableEq.{u1} ι (fun (x : ι) => p x) (fun (a : ι) (b : ι) => dec a b) a b) (fun (i : Subtype.{succ u1} ι p) => _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) (x : β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) => _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i) x) _inst_3 (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) p (fun (a : ι) => _inst_4 a) v) (fun (i : Subtype.{succ u1} ι p) (b : β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) => h ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i) b)) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 v h))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [dec : DecidableEq.{succ u1} ι] [_inst_1 : forall (i : ι), Zero.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (_inst_1 i))))] [_inst_3 : CommMonoid.{u3} γ] {v : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)} {p : ι -> Prop} [_inst_4 : DecidablePred.{succ u1} ι p] {h : forall (i : ι), (β i) -> γ}, (forall (x : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) x (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) v)) -> (p x)) -> (Eq.{succ u3} γ (Dfinsupp.prod.{u1, u2, u3} (Subtype.{succ u1} ι p) γ (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (a : Subtype.{succ u1} ι p) (b : Subtype.{succ u1} ι p) => Subtype.instDecidableEqSubtype.{u1} ι (fun (x : ι) => p x) (fun (a : ι) (b : ι) => dec a b) a b) (fun (i : Subtype.{succ u1} ι p) => _inst_1 (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) (x : β (Subtype.val.{succ u1} ι p i)) => _inst_2 (Subtype.val.{succ u1} ι p i) x) _inst_3 (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) p (fun (a : ι) => _inst_4 a) v) (fun (i : Subtype.{succ u1} ι p) (b : β (Subtype.val.{succ u1} ι p i)) => h (Subtype.val.{succ u1} ι p i) b)) (Dfinsupp.prod.{u1, u2, u3} ι γ (fun (i : ι) => β i) (fun (a : ι) (b : ι) => dec a b) (fun (i : ι) => _inst_1 i) (fun (i : ι) (x : β i) => _inst_2 i x) _inst_3 v h))
Case conversion may be inaccurate. Consider using '#align dfinsupp.prod_subtype_domain_index Dfinsupp.prod_subtypeDomain_indexₓ'. -/
@[to_additive]
theorem prod_subtypeDomain_index [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]
    [CommMonoid γ] {v : Π₀ i, β i} {p : ι → Prop} [DecidablePred p] {h : ∀ i, β i → γ}
    (hp : ∀ x ∈ v.support, p x) : ((v.subtypeDomain p).Prod fun i b => h i b) = v.Prod h :=
  Finset.prod_bij (fun p _ => p) (by simp) (by simp) (fun ⟨a₀, ha₀⟩ ⟨a₁, ha₁⟩ => by simp)
    fun i hi => ⟨⟨i, hp i hi⟩, by simpa using hi, rfl⟩
#align dfinsupp.prod_subtype_domain_index Dfinsupp.prod_subtypeDomain_index
#align dfinsupp.sum_subtype_domain_index Dfinsupp.sum_subtypeDomain_index

omit dec

/- warning: dfinsupp.subtype_domain_sum -> Dfinsupp.subtypeDomain_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] {s : Finset.{u3} γ} {h : γ -> (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))))} {p : ι -> Prop} [_inst_2 : DecidablePred.{succ u1} ι p], Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) p (fun (a : ι) => _inst_2 a) (Finset.sum.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))) γ (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) s (fun (c : γ) => h c))) (Finset.sum.{max u1 u2, u3} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))))) γ (Dfinsupp.addCommMonoid.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))) s (fun (c : γ) => Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) p (fun (a : ι) => _inst_2 a) (h c)))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] {s : Finset.{u3} γ} {h : γ -> (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))))} {p : ι -> Prop} [_inst_2 : DecidablePred.{succ u1} ι p], Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i))))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) p (fun (a : ι) => _inst_2 a) (Finset.sum.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)))) γ (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) s (fun (c : γ) => h c))) (Finset.sum.{max u1 u2, u3} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_1 (Subtype.val.{succ u1} ι p i))))) γ (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_1 (Subtype.val.{succ u1} ι p i))) s (fun (c : γ) => Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) p (fun (a : ι) => _inst_2 a) (h c)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subtype_domain_sum Dfinsupp.subtypeDomain_sumₓ'. -/
theorem subtypeDomain_sum [∀ i, AddCommMonoid (β i)] {s : Finset γ} {h : γ → Π₀ i, β i}
    {p : ι → Prop} [DecidablePred p] :
    (∑ c in s, h c).subtypeDomain p = ∑ c in s, (h c).subtypeDomain p :=
  (subtypeDomainAddMonoidHom β p).map_sum _ s
#align dfinsupp.subtype_domain_sum Dfinsupp.subtypeDomain_sum

/- warning: dfinsupp.subtype_domain_finsupp_sum -> Dfinsupp.subtypeDomain_finsupp_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} {δ : γ -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} γ] [_inst_2 : forall (c : γ), Zero.{u4} (δ c)] [_inst_3 : forall (c : γ) (x : δ c), Decidable (Ne.{succ u4} (δ c) x (OfNat.ofNat.{u4} (δ c) 0 (OfNat.mk.{u4} (δ c) 0 (Zero.zero.{u4} (δ c) (_inst_2 c)))))] [_inst_4 : forall (i : ι), AddCommMonoid.{u2} (β i)] {p : ι -> Prop} [_inst_5 : DecidablePred.{succ u1} ι p] {s : Dfinsupp.{u3, u4} γ (fun (c : γ) => δ c) (fun (i : γ) => _inst_2 i)} {h : forall (c : γ), (δ c) -> (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_4 i)))))}, Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_4 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_4 i)))) p (fun (a : ι) => _inst_5 a) (Dfinsupp.sum.{u3, u4, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_4 i))))) (fun (c : γ) => δ c) (fun (a : γ) (b : γ) => _inst_1 a b) (fun (i : γ) => _inst_2 i) (fun (i : γ) (x : δ i) => _inst_3 i x) (Dfinsupp.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) s h)) (Dfinsupp.sum.{u3, u4, max u1 u2} γ (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (_inst_4 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)))))) (fun (c : γ) => δ c) (fun (a : γ) (b : γ) => _inst_1 a b) (fun (i : γ) => _inst_2 i) (fun (i : γ) (x : δ i) => _inst_3 i x) (Dfinsupp.addCommMonoid.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i)) (fun (i : Subtype.{succ u1} ι p) => _inst_4 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} ι p) ι (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeBase.{succ u1, succ u1} (Subtype.{succ u1} ι p) ι (coeSubtype.{succ u1} ι (fun (x : ι) => p x))))) i))) s (fun (c : γ) (d : δ c) => Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_4 i)))) p (fun (a : ι) => _inst_5 a) (h c d)))
but is expected to have type
  forall {ι : Type.{u1}} {γ : Type.{u3}} {β : ι -> Type.{u2}} {δ : γ -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} γ] [_inst_2 : forall (c : γ), Zero.{u4} (δ c)] [_inst_3 : forall (c : γ) (x : δ c), Decidable (Ne.{succ u4} (δ c) x (OfNat.ofNat.{u4} (δ c) 0 (Zero.toOfNat0.{u4} (δ c) (_inst_2 c))))] [_inst_4 : forall (i : ι), AddCommMonoid.{u2} (β i)] {p : ι -> Prop} [_inst_5 : DecidablePred.{succ u1} ι p] {s : Dfinsupp.{u3, u4} γ (fun (c : γ) => δ c) (fun (i : γ) => _inst_2 i)} {h : forall (c : γ), (δ c) -> (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_4 i))))}, Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_4 (Subtype.val.{succ u1} ι p i))))) (Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_4 i))) p (fun (a : ι) => _inst_5 a) (Dfinsupp.sum.{u3, u4, max u1 u2} γ (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_4 i)))) (fun (c : γ) => δ c) (fun (a : γ) (b : γ) => _inst_1 a b) (fun (i : γ) => _inst_2 i) (fun (i : γ) (x : δ i) => _inst_3 i x) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) s h)) (Dfinsupp.sum.{u3, u4, max u1 u2} γ (Dfinsupp.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) (Subtype.val.{succ u1} ι p i)) (_inst_4 (Subtype.val.{succ u1} ι p i))))) (fun (c : γ) => δ c) (fun (a : γ) (b : γ) => _inst_1 a b) (fun (i : γ) => _inst_2 i) (fun (i : γ) (x : δ i) => _inst_3 i x) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u2} (Subtype.{succ u1} ι p) (fun (i : Subtype.{succ u1} ι p) => β (Subtype.val.{succ u1} ι p i)) (fun (i : Subtype.{succ u1} ι p) => _inst_4 (Subtype.val.{succ u1} ι p i))) s (fun (c : γ) (d : δ c) => Dfinsupp.subtypeDomain.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_4 i))) p (fun (a : ι) => _inst_5 a) (h c d)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.subtype_domain_finsupp_sum Dfinsupp.subtypeDomain_finsupp_sumₓ'. -/
theorem subtypeDomain_finsupp_sum {δ : γ → Type x} [DecidableEq γ] [∀ c, Zero (δ c)]
    [∀ (c) (x : δ c), Decidable (x ≠ 0)] [∀ i, AddCommMonoid (β i)] {p : ι → Prop} [DecidablePred p]
    {s : Π₀ c, δ c} {h : ∀ c, δ c → Π₀ i, β i} :
    (s.Sum h).subtypeDomain p = s.Sum fun c d => (h c d).subtypeDomain p :=
  subtype_domain_sum
#align dfinsupp.subtype_domain_finsupp_sum Dfinsupp.subtypeDomain_finsupp_sum

end ProdAndSum

/-! ### Bundled versions of `dfinsupp.map_range`

The names should match the equivalent bundled `finsupp.map_range` definitions.
-/


section MapRange

omit dec

variable [∀ i, AddZeroClass (β i)] [∀ i, AddZeroClass (β₁ i)] [∀ i, AddZeroClass (β₂ i)]

/- warning: dfinsupp.map_range_add -> Dfinsupp.mapRange_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u3} (β₂ i)] (f : forall (i : ι), (β₁ i) -> (β₂ i)) (hf : forall (i : ι), Eq.{succ u3} (β₂ i) (f i (OfNat.ofNat.{u2} (β₁ i) 0 (OfNat.mk.{u2} (β₁ i) 0 (Zero.zero.{u2} (β₁ i) (AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i)))))) (OfNat.ofNat.{u3} (β₂ i) 0 (OfNat.mk.{u3} (β₂ i) 0 (Zero.zero.{u3} (β₂ i) (AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i)))))), (forall (i : ι) (x : β₁ i) (y : β₁ i), Eq.{succ u3} (β₂ i) (f i (HAdd.hAdd.{u2, u2, u2} (β₁ i) (β₁ i) (β₁ i) (instHAdd.{u2} (β₁ i) (AddZeroClass.toHasAdd.{u2} (β₁ i) (_inst_2 i))) x y)) (HAdd.hAdd.{u3, u3, u3} (β₂ i) (β₂ i) (β₂ i) (instHAdd.{u3} (β₂ i) (AddZeroClass.toHasAdd.{u3} (β₂ i) (_inst_3 i))) (f i x) (f i y))) -> (forall (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))), Eq.{succ (max u1 u3)} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.mapRange.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i)) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i)) f hf (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i))) g₁ g₂)) (HAdd.hAdd.{max u1 u3, max u1 u3, max u1 u3} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i))) (instHAdd.{max u1 u3} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.hasAdd.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.mapRange.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i)) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i)) f hf g₁) (Dfinsupp.mapRange.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i)) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i)) f hf g₂)))
but is expected to have type
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u3} (β₂ i)] (f : forall (i : ι), (β₁ i) -> (β₂ i)) (hf : forall (i : ι), Eq.{succ u3} (β₂ i) (f i (OfNat.ofNat.{u2} (β₁ i) 0 (Zero.toOfNat0.{u2} (β₁ i) (AddZeroClass.toZero.{u2} (β₁ i) (_inst_2 i))))) (OfNat.ofNat.{u3} (β₂ i) 0 (Zero.toOfNat0.{u3} (β₂ i) (AddZeroClass.toZero.{u3} (β₂ i) (_inst_3 i))))), (forall (i : ι) (x : β₁ i) (y : β₁ i), Eq.{succ u3} (β₂ i) (f i (HAdd.hAdd.{u2, u2, u2} (β₁ i) (β₁ i) (β₁ i) (instHAdd.{u2} (β₁ i) (AddZeroClass.toAdd.{u2} (β₁ i) (_inst_2 i))) x y)) (HAdd.hAdd.{u3, u3, u3} (β₂ i) (β₂ i) (β₂ i) (instHAdd.{u3} (β₂ i) (AddZeroClass.toAdd.{u3} (β₂ i) (_inst_3 i))) (f i x) (f i y))) -> (forall (g₁ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (g₂ : Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))), Eq.{max (succ u1) (succ u3)} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.mapRange.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β₁ i) (_inst_2 i)) (fun (i : ι) => AddZeroClass.toZero.{u3} (β₂ i) (_inst_3 i)) f hf (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i))) g₁ g₂)) (HAdd.hAdd.{max u1 u3, max u1 u3, max u1 u3} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u3} (β₂ i) (_inst_3 i))) (instHAdd.{max u1 u3} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.mapRange.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β₁ i) (_inst_2 i)) (fun (i : ι) => AddZeroClass.toZero.{u3} (β₂ i) (_inst_3 i)) f hf g₁) (Dfinsupp.mapRange.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u2} (β₁ i) (_inst_2 i)) (fun (i : ι) => AddZeroClass.toZero.{u3} (β₂ i) (_inst_3 i)) f hf g₂)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.map_range_add Dfinsupp.mapRange_addₓ'. -/
theorem mapRange_add (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0)
    (hf' : ∀ i x y, f i (x + y) = f i x + f i y) (g₁ g₂ : Π₀ i, β₁ i) :
    mapRange f hf (g₁ + g₂) = mapRange f hf g₁ + mapRange f hf g₂ :=
  by
  ext
  simp only [map_range_apply f, coe_add, Pi.add_apply, hf']
#align dfinsupp.map_range_add Dfinsupp.mapRange_add

/- warning: dfinsupp.map_range.add_monoid_hom -> Dfinsupp.mapRange.addMonoidHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u3} (β₂ i)], (forall (i : ι), AddMonoidHom.{u2, u3} (β₁ i) (β₂ i) (_inst_2 i) (_inst_3 i)) -> (AddMonoidHom.{max u1 u2, max u1 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.addZeroClass.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)))
but is expected to have type
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u3} (β₂ i)], (forall (i : ι), AddMonoidHom.{u2, u3} (β₁ i) (β₂ i) (_inst_2 i) (_inst_3 i)) -> (AddMonoidHom.{max u2 u1, max u3 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.map_range.add_monoid_hom Dfinsupp.mapRange.addMonoidHomₓ'. -/
/-- `dfinsupp.map_range` as an `add_monoid_hom`. -/
@[simps apply]
def mapRange.addMonoidHom (f : ∀ i, β₁ i →+ β₂ i) : (Π₀ i, β₁ i) →+ Π₀ i, β₂ i
    where
  toFun := mapRange (fun i x => f i x) fun i => (f i).map_zero
  map_zero' := mapRange_zero _ _
  map_add' := mapRange_add _ _ fun i => (f i).map_add
#align dfinsupp.map_range.add_monoid_hom Dfinsupp.mapRange.addMonoidHom

/- warning: dfinsupp.map_range.add_monoid_hom_id -> Dfinsupp.mapRange.addMonoidHom_id is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β₂ : ι -> Type.{u2}} [_inst_3 : forall (i : ι), AddZeroClass.{u2} (β₂ i)], Eq.{succ (max u1 u2)} (AddMonoidHom.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₂ i) (_inst_3 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₂ i) (_inst_3 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.mapRange.addMonoidHom.{u1, u2, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => AddMonoidHom.id.{u2} (β₂ i) (_inst_3 i))) (AddMonoidHom.id.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₂ i) (_inst_3 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)))
but is expected to have type
  forall {ι : Type.{u1}} {β₂ : ι -> Type.{u2}} [_inst_3 : forall (i : ι), AddZeroClass.{u2} (β₂ i)], Eq.{max (succ u1) (succ u2)} (AddMonoidHom.{max u2 u1, max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.mapRange.addMonoidHom.{u1, u2, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => AddMonoidHom.id.{u2} (β₂ i) (_inst_3 i))) (AddMonoidHom.id.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.map_range.add_monoid_hom_id Dfinsupp.mapRange.addMonoidHom_idₓ'. -/
@[simp]
theorem mapRange.addMonoidHom_id :
    (mapRange.addMonoidHom fun i => AddMonoidHom.id (β₂ i)) = AddMonoidHom.id _ :=
  AddMonoidHom.ext mapRange_id
#align dfinsupp.map_range.add_monoid_hom_id Dfinsupp.mapRange.addMonoidHom_id

/- warning: dfinsupp.map_range.add_monoid_hom_comp -> Dfinsupp.mapRange.addMonoidHom_comp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {β₁ : ι -> Type.{u3}} {β₂ : ι -> Type.{u4}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : forall (i : ι), AddZeroClass.{u3} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u4} (β₂ i)] (f : forall (i : ι), AddMonoidHom.{u3, u4} (β₁ i) (β₂ i) (_inst_2 i) (_inst_3 i)) (f₂ : forall (i : ι), AddMonoidHom.{u2, u3} (β i) (β₁ i) (_inst_1 i) (_inst_2 i)), Eq.{max (succ (max u1 u4)) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, max u1 u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u4} (β₂ i) (_inst_3 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.addZeroClass.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.mapRange.addMonoidHom.{u1, u2, u4} ι (fun (i : ι) => β i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => AddMonoidHom.comp.{u2, u3, u4} (β i) (β₁ i) (β₂ i) (_inst_1 i) (_inst_2 i) (_inst_3 i) (f i) (f₂ i))) (AddMonoidHom.comp.{max u1 u2, max u1 u3, max u1 u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₁ i) (_inst_2 i))) (Dfinsupp.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u4} (β₂ i) (_inst_3 i))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.addZeroClass.{u1, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.addZeroClass.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.mapRange.addMonoidHom.{u1, u3, u4} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) f) (Dfinsupp.mapRange.addMonoidHom.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) f₂))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {β₁ : ι -> Type.{u3}} {β₂ : ι -> Type.{u4}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : forall (i : ι), AddZeroClass.{u3} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u4} (β₂ i)] (f : forall (i : ι), AddMonoidHom.{u3, u4} (β₁ i) (β₂ i) (_inst_2 i) (_inst_3 i)) (f₂ : forall (i : ι), AddMonoidHom.{u2, u3} (β i) (β₁ i) (_inst_1 i) (_inst_2 i)), Eq.{max (max (succ u1) (succ u2)) (succ u4)} (AddMonoidHom.{max u2 u1, max u4 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.mapRange.addMonoidHom.{u1, u2, u4} ι (fun (i : ι) => β i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => AddMonoidHom.comp.{u2, u3, u4} (β i) (β₁ i) (β₂ i) (_inst_1 i) (_inst_2 i) (_inst_3 i) (f i) (f₂ i))) (AddMonoidHom.comp.{max u2 u1, max u1 u3, max u1 u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.mapRange.addMonoidHom.{u1, u3, u4} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) f) (Dfinsupp.mapRange.addMonoidHom.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) f₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.map_range.add_monoid_hom_comp Dfinsupp.mapRange.addMonoidHom_compₓ'. -/
theorem mapRange.addMonoidHom_comp (f : ∀ i, β₁ i →+ β₂ i) (f₂ : ∀ i, β i →+ β₁ i) :
    (mapRange.addMonoidHom fun i => (f i).comp (f₂ i)) =
      (mapRange.addMonoidHom f).comp (mapRange.addMonoidHom f₂) :=
  AddMonoidHom.ext <| mapRange_comp (fun i x => f i x) (fun i x => f₂ i x) _ _ _
#align dfinsupp.map_range.add_monoid_hom_comp Dfinsupp.mapRange.addMonoidHom_comp

/- warning: dfinsupp.map_range.add_equiv -> Dfinsupp.mapRange.addEquiv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u3} (β₂ i)], (forall (i : ι), AddEquiv.{u2, u3} (β₁ i) (β₂ i) (AddZeroClass.toHasAdd.{u2} (β₁ i) (_inst_2 i)) (AddZeroClass.toHasAdd.{u3} (β₂ i) (_inst_3 i))) -> (AddEquiv.{max u1 u2, max u1 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.hasAdd.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)))
but is expected to have type
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u3} (β₂ i)], (forall (i : ι), AddEquiv.{u2, u3} (β₁ i) (β₂ i) (AddZeroClass.toAdd.{u2} (β₁ i) (_inst_2 i)) (AddZeroClass.toAdd.{u3} (β₂ i) (_inst_3 i))) -> (AddEquiv.{max u2 u1, max u3 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.instAddDfinsuppToZero.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.map_range.add_equiv Dfinsupp.mapRange.addEquivₓ'. -/
/-- `dfinsupp.map_range.add_monoid_hom` as an `add_equiv`. -/
@[simps apply]
def mapRange.addEquiv (e : ∀ i, β₁ i ≃+ β₂ i) : (Π₀ i, β₁ i) ≃+ Π₀ i, β₂ i :=
  {
    mapRange.addMonoidHom fun i =>
      (e i).toAddMonoidHom with
    toFun := mapRange (fun i x => e i x) fun i => (e i).map_zero
    invFun := mapRange (fun i x => (e i).symm x) fun i => (e i).symm.map_zero
    left_inv := fun x => by
      rw [← map_range_comp] <;>
        · simp_rw [AddEquiv.symm_comp_self]
          simp
    right_inv := fun x => by
      rw [← map_range_comp] <;>
        · simp_rw [AddEquiv.self_comp_symm]
          simp }
#align dfinsupp.map_range.add_equiv Dfinsupp.mapRange.addEquiv

/- warning: dfinsupp.map_range.add_equiv_refl -> Dfinsupp.mapRange.addEquiv_refl is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)], Eq.{succ (max u1 u2)} (AddEquiv.{max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.mapRange.addEquiv.{u1, u2, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => AddEquiv.refl.{u2} (β₁ i) (AddZeroClass.toHasAdd.{u2} (β₁ i) (_inst_2 i)))) (AddEquiv.refl.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)))
but is expected to have type
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)], Eq.{max (succ u1) (succ u2)} (AddEquiv.{max u2 u1, max u2 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i))) (Dfinsupp.mapRange.addEquiv.{u1, u2, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => AddEquiv.refl.{u2} (β₁ i) (AddZeroClass.toAdd.{u2} (β₁ i) (_inst_2 i)))) (AddEquiv.refl.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.map_range.add_equiv_refl Dfinsupp.mapRange.addEquiv_reflₓ'. -/
@[simp]
theorem mapRange.addEquiv_refl :
    (map_range.add_equiv fun i => AddEquiv.refl (β₁ i)) = AddEquiv.refl _ :=
  AddEquiv.ext mapRange_id
#align dfinsupp.map_range.add_equiv_refl Dfinsupp.mapRange.addEquiv_refl

/- warning: dfinsupp.map_range.add_equiv_trans -> Dfinsupp.mapRange.addEquiv_trans is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {β₁ : ι -> Type.{u3}} {β₂ : ι -> Type.{u4}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : forall (i : ι), AddZeroClass.{u3} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u4} (β₂ i)] (f : forall (i : ι), AddEquiv.{u2, u3} (β i) (β₁ i) (AddZeroClass.toHasAdd.{u2} (β i) (_inst_1 i)) (AddZeroClass.toHasAdd.{u3} (β₁ i) (_inst_2 i))) (f₂ : forall (i : ι), AddEquiv.{u3, u4} (β₁ i) (β₂ i) (AddZeroClass.toHasAdd.{u3} (β₁ i) (_inst_2 i)) (AddZeroClass.toHasAdd.{u4} (β₂ i) (_inst_3 i))), Eq.{max (succ (max u1 u2)) (succ (max u1 u4))} (AddEquiv.{max u1 u2, max u1 u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u4} (β₂ i) (_inst_3 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.hasAdd.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.mapRange.addEquiv.{u1, u2, u4} ι (fun (i : ι) => β i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => AddEquiv.trans.{u2, u3, u4} (β i) (β₁ i) (β₂ i) (AddZeroClass.toHasAdd.{u2} (β i) (_inst_1 i)) (AddZeroClass.toHasAdd.{u3} (β₁ i) (_inst_2 i)) (AddZeroClass.toHasAdd.{u4} (β₂ i) (_inst_3 i)) (f i) (f₂ i))) (AddEquiv.trans.{max u1 u2, max u1 u3, max u1 u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β i) (_inst_1 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₁ i) (_inst_2 i))) (Dfinsupp.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u4} (β₂ i) (_inst_3 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.hasAdd.{u1, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.hasAdd.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.mapRange.addEquiv.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) f) (Dfinsupp.mapRange.addEquiv.{u1, u3, u4} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) f₂))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} {β₁ : ι -> Type.{u3}} {β₂ : ι -> Type.{u4}} [_inst_1 : forall (i : ι), AddZeroClass.{u2} (β i)] [_inst_2 : forall (i : ι), AddZeroClass.{u3} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u4} (β₂ i)] (f : forall (i : ι), AddEquiv.{u2, u3} (β i) (β₁ i) (AddZeroClass.toAdd.{u2} (β i) (_inst_1 i)) (AddZeroClass.toAdd.{u3} (β₁ i) (_inst_2 i))) (f₂ : forall (i : ι), AddEquiv.{u3, u4} (β₁ i) (β₂ i) (AddZeroClass.toAdd.{u3} (β₁ i) (_inst_2 i)) (AddZeroClass.toAdd.{u4} (β₂ i) (_inst_3 i))), Eq.{max (max (succ u1) (succ u2)) (succ u4)} (AddEquiv.{max u2 u1, max u4 u1} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instAddDfinsuppToZero.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i))) (Dfinsupp.mapRange.addEquiv.{u1, u2, u4} ι (fun (i : ι) => β i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => AddEquiv.trans.{u2, u3, u4} (β i) (β₁ i) (β₂ i) (AddZeroClass.toAdd.{u2} (β i) (_inst_1 i)) (AddZeroClass.toAdd.{u3} (β₁ i) (_inst_2 i)) (AddZeroClass.toAdd.{u4} (β₂ i) (_inst_3 i)) (f i) (f₂ i))) (AddEquiv.trans.{max u1 u2, max u1 u3, max u1 u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.instAddDfinsuppToZero.{u1, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.instAddDfinsuppToZero.{u1, u4} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.mapRange.addEquiv.{u1, u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_1 i) (fun (i : ι) => _inst_2 i) f) (Dfinsupp.mapRange.addEquiv.{u1, u3, u4} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) f₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.map_range.add_equiv_trans Dfinsupp.mapRange.addEquiv_transₓ'. -/
theorem mapRange.addEquiv_trans (f : ∀ i, β i ≃+ β₁ i) (f₂ : ∀ i, β₁ i ≃+ β₂ i) :
    (mapRange.addEquiv fun i => (f i).trans (f₂ i)) =
      (mapRange.addEquiv f).trans (mapRange.addEquiv f₂) :=
  AddEquiv.ext <| mapRange_comp (fun i x => f₂ i x) (fun i x => f i x) _ _ _
#align dfinsupp.map_range.add_equiv_trans Dfinsupp.mapRange.addEquiv_trans

/- warning: dfinsupp.map_range.add_equiv_symm -> Dfinsupp.mapRange.addEquiv_symm is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u3} (β₂ i)] (e : forall (i : ι), AddEquiv.{u2, u3} (β₁ i) (β₂ i) (AddZeroClass.toHasAdd.{u2} (β₁ i) (_inst_2 i)) (AddZeroClass.toHasAdd.{u3} (β₂ i) (_inst_3 i))), Eq.{max (succ (max u1 u3)) (succ (max u1 u2))} (AddEquiv.{max u1 u3, max u1 u2} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.hasAdd.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i))) (AddEquiv.symm.{max u1 u2, max u1 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} (β₁ i) (_inst_2 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (β₂ i) (_inst_3 i))) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.hasAdd.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.mapRange.addEquiv.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) e)) (Dfinsupp.mapRange.addEquiv.{u1, u3, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => AddEquiv.symm.{u2, u3} (β₁ i) (β₂ i) (AddZeroClass.toHasAdd.{u2} (β₁ i) (_inst_2 i)) (AddZeroClass.toHasAdd.{u3} (β₂ i) (_inst_3 i)) (e i)))
but is expected to have type
  forall {ι : Type.{u1}} {β₁ : ι -> Type.{u2}} {β₂ : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddZeroClass.{u2} (β₁ i)] [_inst_3 : forall (i : ι), AddZeroClass.{u3} (β₂ i)] (e : forall (i : ι), AddEquiv.{u2, u3} (β₁ i) (β₂ i) (AddZeroClass.toAdd.{u2} (β₁ i) (_inst_2 i)) (AddZeroClass.toAdd.{u3} (β₂ i) (_inst_3 i))), Eq.{max (max (succ u1) (succ u2)) (succ u3)} (AddEquiv.{max u1 u3, max u1 u2} (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i))) (AddEquiv.symm.{max u1 u2, max u1 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => β₁ i) i) (_inst_2 i))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => β₂ i) i) (_inst_3 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_2 i)) (Dfinsupp.instAddDfinsuppToZero.{u1, u3} ι (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_3 i)) (Dfinsupp.mapRange.addEquiv.{u1, u2, u3} ι (fun (i : ι) => β₁ i) (fun (i : ι) => β₂ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) e)) (Dfinsupp.mapRange.addEquiv.{u1, u3, u2} ι (fun (i : ι) => β₂ i) (fun (i : ι) => β₁ i) (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => AddEquiv.symm.{u2, u3} (β₁ i) (β₂ i) (AddZeroClass.toAdd.{u2} (β₁ i) (_inst_2 i)) (AddZeroClass.toAdd.{u3} (β₂ i) (_inst_3 i)) (e i)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.map_range.add_equiv_symm Dfinsupp.mapRange.addEquiv_symmₓ'. -/
@[simp]
theorem mapRange.addEquiv_symm (e : ∀ i, β₁ i ≃+ β₂ i) :
    (mapRange.addEquiv e).symm = mapRange.addEquiv fun i => (e i).symm :=
  rfl
#align dfinsupp.map_range.add_equiv_symm Dfinsupp.mapRange.addEquiv_symm

end MapRange

end Dfinsupp

/-! ### Product and sum lemmas for bundled morphisms.

In this section, we provide analogues of `add_monoid_hom.map_sum`, `add_monoid_hom.coe_finset_sum`,
and `add_monoid_hom.finset_sum_apply` for `dfinsupp.sum` and `dfinsupp.sum_add_hom` instead of
`finset.sum`.

We provide these for `add_monoid_hom`, `monoid_hom`, `ring_hom`, `add_equiv`, and `mul_equiv`.

Lemmas for `linear_map` and `linear_equiv` are in another file.
-/


section

variable [DecidableEq ι]

namespace MonoidHom

variable {R S : Type _}

variable [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]

/- warning: monoid_hom.map_dfinsupp_prod -> MonoidHom.map_dfinsupp_prod is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : forall (i : ι), Zero.{u2} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_2 i)))))] [_inst_4 : CommMonoid.{u3} R] [_inst_5 : CommMonoid.{u4} S] (h : MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4)) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> R), Eq.{succ u4} S (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4)) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (fun (_x : MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4)) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) => R -> S) (MonoidHom.hasCoeToFun.{u3, u4} R S (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4)) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) h (Dfinsupp.prod.{u1, u2, u3} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f g)) (Dfinsupp.prod.{u1, u2, u4} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_5 f (fun (a : ι) (b : β a) => coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4)) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (fun (_x : MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4)) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) => R -> S) (MonoidHom.hasCoeToFun.{u3, u4} R S (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4)) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) h (g a b)))
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : forall (i : ι), Zero.{u4} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u4} (β i) x (OfNat.ofNat.{u4} (β i) 0 (Zero.toOfNat0.{u4} (β i) (_inst_2 i))))] [_inst_4 : CommMonoid.{u2} R] [_inst_5 : CommMonoid.{u1} S] (h : MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) (Dfinsupp.prod.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)) (MonoidHom.monoidHomClass.{u2, u1} R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))))) h (Dfinsupp.prod.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f g)) (Dfinsupp.prod.{u3, u4, u1} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_5 f (fun (a : ι) (b : β a) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)) (MonoidHom.monoidHomClass.{u2, u1} R S (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4)) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))))) h (g a b)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.map_dfinsupp_prod MonoidHom.map_dfinsupp_prodₓ'. -/
@[simp, to_additive]
theorem map_dfinsupp_prod [CommMonoid R] [CommMonoid S] (h : R →* S) (f : Π₀ i, β i)
    (g : ∀ i, β i → R) : h (f.Prod g) = f.Prod fun a b => h (g a b) :=
  h.map_prod _ _
#align monoid_hom.map_dfinsupp_prod MonoidHom.map_dfinsupp_prod
#align add_monoid_hom.map_dfinsupp_sum AddMonoidHom.map_dfinsupp_sum

/- warning: monoid_hom.coe_dfinsupp_prod -> MonoidHom.coe_dfinsupp_prod is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : forall (i : ι), Zero.{u2} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_2 i)))))] [_inst_4 : Monoid.{u3} R] [_inst_5 : CommMonoid.{u4} S] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5)))), Eq.{succ (max u3 u4)} (R -> S) (coeFn.{succ (max u4 u3), succ (max u3 u4)} (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (fun (_x : MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) => R -> S) (MonoidHom.hasCoeToFun.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (Dfinsupp.prod.{u1, u2, max u4 u3} ι (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (MonoidHom.commMonoid.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) _inst_5) f g)) (Dfinsupp.prod.{u1, u2, max u3 u4} ι (R -> S) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (Pi.commMonoid.{u3, u4} R (fun (ᾰ : R) => S) (fun (i : R) => _inst_5)) f (fun (a : ι) (b : β a) => coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (fun (_x : MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) => R -> S) (MonoidHom.hasCoeToFun.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (g a b)))
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : forall (i : ι), Zero.{u4} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u4} (β i) x (OfNat.ofNat.{u4} (β i) 0 (Zero.toOfNat0.{u4} (β i) (_inst_2 i))))] [_inst_4 : Monoid.{u2} R] [_inst_5 : CommMonoid.{u1} S] (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_4)) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)) (MonoidHom.monoidHomClass.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))))) (Dfinsupp.prod.{u3, u4, max u2 u1} ι (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (MonoidHom.commMonoid.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) _inst_5) f g)) (Dfinsupp.prod.{u3, u4, max u2 u1} ι (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) ᾰ) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (Pi.commMonoid.{u2, u1} R (fun (ᾰ : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) ᾰ) (fun (i : R) => _inst_5)) f (fun (a : ι) (b : β a) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_4)) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)) (MonoidHom.monoidHomClass.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))))) (g a b)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.coe_dfinsupp_prod MonoidHom.coe_dfinsupp_prodₓ'. -/
@[to_additive]
theorem coe_dfinsupp_prod [Monoid R] [CommMonoid S] (f : Π₀ i, β i) (g : ∀ i, β i → R →* S) :
    ⇑(f.Prod g) = f.Prod fun a b => g a b :=
  coe_finset_prod _ _
#align monoid_hom.coe_dfinsupp_prod MonoidHom.coe_dfinsupp_prod
#align add_monoid_hom.coe_dfinsupp_sum AddMonoidHom.coe_dfinsupp_sum

/- warning: monoid_hom.dfinsupp_prod_apply -> MonoidHom.dfinsupp_prod_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : forall (i : ι), Zero.{u2} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_2 i)))))] [_inst_4 : Monoid.{u3} R] [_inst_5 : CommMonoid.{u4} S] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5)))) (r : R), Eq.{succ u4} S (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (fun (_x : MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) => R -> S) (MonoidHom.hasCoeToFun.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (Dfinsupp.prod.{u1, u2, max u4 u3} ι (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (MonoidHom.commMonoid.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) _inst_5) f g) r) (Dfinsupp.prod.{u1, u2, u4} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_5 f (fun (a : ι) (b : β a) => coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (fun (_x : MonoidHom.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) => R -> S) (MonoidHom.hasCoeToFun.{u3, u4} R S (Monoid.toMulOneClass.{u3} R _inst_4) (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5))) (g a b) r))
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : forall (i : ι), Zero.{u4} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u4} (β i) x (OfNat.ofNat.{u4} (β i) 0 (Zero.toOfNat0.{u4} (β i) (_inst_2 i))))] [_inst_4 : Monoid.{u2} R] [_inst_5 : CommMonoid.{u1} S] (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_4)) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)) (MonoidHom.monoidHomClass.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))))) (Dfinsupp.prod.{u3, u4, max u2 u1} ι (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (MonoidHom.commMonoid.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) _inst_5) f g) r) (Dfinsupp.prod.{u3, u4, u1} ι ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) r) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_5 f (fun (a : ι) (b : β a) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R _inst_4)) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)) (MonoidHom.monoidHomClass.{u2, u1} R S (Monoid.toMulOneClass.{u2} R _inst_4) (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))))) (g a b) r))
Case conversion may be inaccurate. Consider using '#align monoid_hom.dfinsupp_prod_apply MonoidHom.dfinsupp_prod_applyₓ'. -/
@[simp, to_additive]
theorem dfinsupp_prod_apply [Monoid R] [CommMonoid S] (f : Π₀ i, β i) (g : ∀ i, β i → R →* S)
    (r : R) : (f.Prod g) r = f.Prod fun a b => (g a b) r :=
  finset_prod_apply _ _ _
#align monoid_hom.dfinsupp_prod_apply MonoidHom.dfinsupp_prod_apply
#align add_monoid_hom.dfinsupp_sum_apply AddMonoidHom.dfinsupp_sum_apply

end MonoidHom

namespace RingHom

variable {R S : Type _}

variable [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]

/- warning: ring_hom.map_dfinsupp_prod -> RingHom.map_dfinsupp_prod is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : forall (i : ι), Zero.{u2} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_2 i)))))] [_inst_4 : CommSemiring.{u3} R] [_inst_5 : CommSemiring.{u4} S] (h : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_4)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_5))) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> R), Eq.{succ u4} S (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_4)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_5))) (fun (_x : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_4)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_5))) => R -> S) (RingHom.hasCoeToFun.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_4)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_5))) h (Dfinsupp.prod.{u1, u2, u3} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (CommSemiring.toCommMonoid.{u3} R _inst_4) f g)) (Dfinsupp.prod.{u1, u2, u4} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (CommSemiring.toCommMonoid.{u4} S _inst_5) f (fun (a : ι) (b : β a) => coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_4)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_5))) (fun (_x : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_4)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_5))) => R -> S) (RingHom.hasCoeToFun.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_4)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_5))) h (g a b)))
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : forall (i : ι), Zero.{u4} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u4} (β i) x (OfNat.ofNat.{u4} (β i) 0 (Zero.toOfNat0.{u4} (β i) (_inst_2 i))))] [_inst_4 : CommSemiring.{u2} R] [_inst_5 : CommSemiring.{u1} S] (h : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) (Dfinsupp.prod.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (CommSemiring.toCommMonoid.{u2} R _inst_4) f g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5)))))) h (Dfinsupp.prod.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (CommSemiring.toCommMonoid.{u2} R _inst_4) f g)) (Dfinsupp.prod.{u3, u4, u1} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (CommSemiring.toCommMonoid.{u1} S _inst_5) f (fun (a : ι) (b : β a) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5))) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5)) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_4)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_5)))))) h (g a b)))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_dfinsupp_prod RingHom.map_dfinsupp_prodₓ'. -/
@[simp]
theorem map_dfinsupp_prod [CommSemiring R] [CommSemiring S] (h : R →+* S) (f : Π₀ i, β i)
    (g : ∀ i, β i → R) : h (f.Prod g) = f.Prod fun a b => h (g a b) :=
  h.map_prod _ _
#align ring_hom.map_dfinsupp_prod RingHom.map_dfinsupp_prod

/- warning: ring_hom.map_dfinsupp_sum -> RingHom.map_dfinsupp_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : forall (i : ι), Zero.{u2} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_2 i)))))] [_inst_4 : NonAssocSemiring.{u3} R] [_inst_5 : NonAssocSemiring.{u4} S] (h : RingHom.{u3, u4} R S _inst_4 _inst_5) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> R), Eq.{succ u4} S (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} R S _inst_4 _inst_5) (fun (_x : RingHom.{u3, u4} R S _inst_4 _inst_5) => R -> S) (RingHom.hasCoeToFun.{u3, u4} R S _inst_4 _inst_5) h (Dfinsupp.sum.{u1, u2, u3} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R _inst_4)) f g)) (Dfinsupp.sum.{u1, u2, u4} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S _inst_5)) f (fun (a : ι) (b : β a) => coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} R S _inst_4 _inst_5) (fun (_x : RingHom.{u3, u4} R S _inst_4 _inst_5) => R -> S) (RingHom.hasCoeToFun.{u3, u4} R S _inst_4 _inst_5) h (g a b)))
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : forall (i : ι), Zero.{u4} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u4} (β i) x (OfNat.ofNat.{u4} (β i) 0 (Zero.toOfNat0.{u4} (β i) (_inst_2 i))))] [_inst_4 : NonAssocSemiring.{u2} R] [_inst_5 : NonAssocSemiring.{u1} S] (h : RingHom.{u2, u1} R S _inst_4 _inst_5) (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) (Dfinsupp.sum.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) f g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S _inst_4 _inst_5) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_4 _inst_5) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_4 _inst_5) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_4 _inst_5) R S _inst_4 _inst_5 (RingHom.instRingHomClassRingHom.{u2, u1} R S _inst_4 _inst_5)))) h (Dfinsupp.sum.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) f g)) (Dfinsupp.sum.{u3, u4, u1} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) f (fun (a : ι) (b : β a) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S _inst_4 _inst_5) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_4 _inst_5) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_4 _inst_5) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_4) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_5) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_4 _inst_5) R S _inst_4 _inst_5 (RingHom.instRingHomClassRingHom.{u2, u1} R S _inst_4 _inst_5)))) h (g a b)))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_dfinsupp_sum RingHom.map_dfinsupp_sumₓ'. -/
@[simp]
theorem map_dfinsupp_sum [NonAssocSemiring R] [NonAssocSemiring S] (h : R →+* S) (f : Π₀ i, β i)
    (g : ∀ i, β i → R) : h (f.Sum g) = f.Sum fun a b => h (g a b) :=
  h.map_sum _ _
#align ring_hom.map_dfinsupp_sum RingHom.map_dfinsupp_sum

end RingHom

namespace MulEquiv

variable {R S : Type _}

variable [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]

/- warning: mul_equiv.map_dfinsupp_prod -> MulEquiv.map_dfinsupp_prod is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : forall (i : ι), Zero.{u2} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (_inst_2 i)))))] [_inst_4 : CommMonoid.{u3} R] [_inst_5 : CommMonoid.{u4} S] (h : MulEquiv.{u3, u4} R S (MulOneClass.toHasMul.{u3} R (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4))) (MulOneClass.toHasMul.{u4} S (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5)))) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> R), Eq.{succ u4} S (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (MulEquiv.{u3, u4} R S (MulOneClass.toHasMul.{u3} R (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4))) (MulOneClass.toHasMul.{u4} S (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5)))) (fun (_x : MulEquiv.{u3, u4} R S (MulOneClass.toHasMul.{u3} R (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4))) (MulOneClass.toHasMul.{u4} S (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5)))) => R -> S) (MulEquiv.hasCoeToFun.{u3, u4} R S (MulOneClass.toHasMul.{u3} R (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4))) (MulOneClass.toHasMul.{u4} S (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5)))) h (Dfinsupp.prod.{u1, u2, u3} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f g)) (Dfinsupp.prod.{u1, u2, u4} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_5 f (fun (a : ι) (b : β a) => coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (MulEquiv.{u3, u4} R S (MulOneClass.toHasMul.{u3} R (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4))) (MulOneClass.toHasMul.{u4} S (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5)))) (fun (_x : MulEquiv.{u3, u4} R S (MulOneClass.toHasMul.{u3} R (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4))) (MulOneClass.toHasMul.{u4} S (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5)))) => R -> S) (MulEquiv.hasCoeToFun.{u3, u4} R S (MulOneClass.toHasMul.{u3} R (Monoid.toMulOneClass.{u3} R (CommMonoid.toMonoid.{u3} R _inst_4))) (MulOneClass.toHasMul.{u4} S (Monoid.toMulOneClass.{u4} S (CommMonoid.toMonoid.{u4} S _inst_5)))) h (g a b)))
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : forall (i : ι), Zero.{u4} (β i)] [_inst_3 : forall (i : ι) (x : β i), Decidable (Ne.{succ u4} (β i) x (OfNat.ofNat.{u4} (β i) 0 (Zero.toOfNat0.{u4} (β i) (_inst_2 i))))] [_inst_4 : CommMonoid.{u2} R] [_inst_5 : CommMonoid.{u1} S] (h : MulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_2 i)) (g : forall (i : ι), (β i) -> R), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : R) => S) (Dfinsupp.prod.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))))))) h (Dfinsupp.prod.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_4 f g)) (Dfinsupp.prod.{u3, u4, u1} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2 i) (fun (i : ι) (x : β i) => _inst_3 i x) _inst_5 f (fun (a : ι) (b : β a) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (MulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) R S (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (MulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5)))) R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))) (MulEquiv.instMulEquivClassMulEquiv.{u2, u1} R S (MulOneClass.toMul.{u2} R (Monoid.toMulOneClass.{u2} R (CommMonoid.toMonoid.{u2} R _inst_4))) (MulOneClass.toMul.{u1} S (Monoid.toMulOneClass.{u1} S (CommMonoid.toMonoid.{u1} S _inst_5))))))) h (g a b)))
Case conversion may be inaccurate. Consider using '#align mul_equiv.map_dfinsupp_prod MulEquiv.map_dfinsupp_prodₓ'. -/
@[simp, to_additive]
theorem map_dfinsupp_prod [CommMonoid R] [CommMonoid S] (h : R ≃* S) (f : Π₀ i, β i)
    (g : ∀ i, β i → R) : h (f.Prod g) = f.Prod fun a b => h (g a b) :=
  h.map_prod _ _
#align mul_equiv.map_dfinsupp_prod MulEquiv.map_dfinsupp_prod
#align add_equiv.map_dfinsupp_sum AddEquiv.map_dfinsupp_sum

end MulEquiv

/-! The above lemmas, repeated for `dfinsupp.sum_add_hom`. -/


namespace AddMonoidHom

variable {R S : Type _}

open Dfinsupp

/- warning: add_monoid_hom.map_dfinsupp_sum_add_hom -> AddMonoidHom.map_dfinsupp_sumAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : AddCommMonoid.{u3} R] [_inst_3 : AddCommMonoid.{u4} S] [_inst_4 : forall (i : ι), AddZeroClass.{u2} (β i)] (h : AddMonoidHom.{u3, u4} R S (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u2, u3} (β i) R (_inst_4 i) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))), Eq.{succ u4} S (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (AddMonoidHom.{u3, u4} R S (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (fun (_x : AddMonoidHom.{u3, u4} R S (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) => R -> S) (AddMonoidHom.hasCoeToFun.{u3, u4} R S (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) h (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) R (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) R (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> R) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) R (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_2 g) f)) (coeFn.{max (succ u4) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u4)} (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (fun (_x : AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> S) (AddMonoidHom.hasCoeToFun.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (Dfinsupp.sumAddHom.{u1, u2, u4} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_3 (fun (i : ι) => AddMonoidHom.comp.{u2, u3, u4} (β i) R S (_inst_4 i) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)) h (g i))) f)
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} R] [_inst_3 : AddCommMonoid.{u1} S] [_inst_4 : forall (i : ι), AddZeroClass.{u4} (β i)] (h : AddMonoidHom.{u2, u1} R S (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u4, u2} (β i) R (_inst_4 i) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => S) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u4), succ u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (a : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => R) a) (AddHomClass.toFunLike.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))))) (Dfinsupp.sumAddHom.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_2 g) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} R S (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => S) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} R S (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) R S (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} R S (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) R S (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) (AddMonoidHom.addMonoidHomClass.{u2, u1} R S (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))))) h (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u4), succ u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => R) _x) (AddHomClass.toFunLike.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))))) (Dfinsupp.sumAddHom.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_2 g) f)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u1), max (succ u3) (succ u4), succ u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => S) _x) (AddHomClass.toFunLike.{max (max u3 u4) u1, max u3 u4, u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u1, max u3 u4, u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))))) (Dfinsupp.sumAddHom.{u3, u4, u1} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_3 (fun (i : ι) => AddMonoidHom.comp.{u4, u2, u1} (β i) R S (_inst_4 i) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) h (g i))) f)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.map_dfinsupp_sum_add_hom AddMonoidHom.map_dfinsupp_sumAddHomₓ'. -/
@[simp]
theorem map_dfinsupp_sumAddHom [AddCommMonoid R] [AddCommMonoid S] [∀ i, AddZeroClass (β i)]
    (h : R →+ S) (f : Π₀ i, β i) (g : ∀ i, β i →+ R) :
    h (sumAddHom g f) = sumAddHom (fun i => h.comp (g i)) f :=
  congr_fun (comp_liftAddHom h g) f
#align add_monoid_hom.map_dfinsupp_sum_add_hom AddMonoidHom.map_dfinsupp_sumAddHom

/- warning: add_monoid_hom.dfinsupp_sum_add_hom_apply -> AddMonoidHom.dfinsupp_sumAddHom_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : AddZeroClass.{u3} R] [_inst_3 : AddCommMonoid.{u4} S] [_inst_4 : forall (i : ι), AddZeroClass.{u2} (β i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u2, max u4 u3} (β i) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (_inst_4 i) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3)))) (r : R), Eq.{succ u4} S (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (fun (_x : AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) => R -> S) (AddMonoidHom.hasCoeToFun.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (coeFn.{max (succ (max u4 u3)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ (max u4 u3))} (AddMonoidHom.{max u1 u2, max u4 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3)))) (fun (_x : AddMonoidHom.{max u1 u2, max u4 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3)))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)))) (AddMonoidHom.hasCoeToFun.{max u1 u2, max u4 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3)))) (Dfinsupp.sumAddHom.{u1, u2, max u4 u3} ι (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3) g) f) r) (coeFn.{max (succ u4) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u4)} (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (fun (_x : AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> S) (AddMonoidHom.hasCoeToFun.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (Dfinsupp.sumAddHom.{u1, u2, u4} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_3 (fun (i : ι) => AddMonoidHom.comp.{u2, max u4 u3, u4} (β i) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (_inst_4 i) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)) (coeFn.{max (succ (max u4 u3)) (succ u3), max (succ u3) (succ (max u4 u3))} (AddMonoidHom.{u3, max u4 u3} R (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) _inst_2 (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) _inst_3)))) (fun (_x : AddMonoidHom.{u3, max u4 u3} R (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) _inst_2 (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) _inst_3)))) => R -> (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)))) (AddMonoidHom.hasCoeToFun.{u3, max u4 u3} R (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) _inst_2 (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{max u4 u3, u4} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) _inst_3)))) (AddMonoidHom.eval.{u3, u4} R S _inst_2 _inst_3) r) (g i))) f)
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : AddZeroClass.{u2} R] [_inst_3 : AddCommMonoid.{u1} S] [_inst_4 : forall (i : ι), AddZeroClass.{u4} (β i)] (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u4, max u1 u2} (β i) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (_inst_4 i) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))) (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => S) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) f) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => S) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) f) R S (AddZeroClass.toAdd.{u2} R _inst_2) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) f) R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) (AddMonoidHom.addMonoidHomClass.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))))) (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u2)) (succ u1), max (succ u3) (succ u4), max (succ u2) (succ u1)} (AddMonoidHom.{max u4 u3, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) _x) (AddHomClass.toFunLike.{max (max (max u3 u4) u2) u1, max u3 u4, max u2 u1} (AddMonoidHom.{max u4 u3, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))) (AddMonoidHomClass.toAddHomClass.{max (max (max u3 u4) u2) u1, max u3 u4, max u2 u1} (AddMonoidHom.{max u4 u3, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoidHom.addMonoidHomClass.{max u3 u4, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))))) (Dfinsupp.sumAddHom.{u3, u4, max u2 u1} ι (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3) g) f) r) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u1), max (succ u3) (succ u4), succ u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => S) _x) (AddHomClass.toFunLike.{max (max u3 u4) u1, max u3 u4, u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u1, max u3 u4, u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))))) (Dfinsupp.sumAddHom.{u3, u4, u1} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_3 (fun (i : ι) => AddMonoidHom.comp.{u4, max u2 u1, u1} (β i) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (_inst_4 i) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (AddMonoidHom.{u2, max u1 u2} R (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) _inst_2 (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{max u2 u1, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) _inst_3)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) _x) (AddHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u1 u2} R (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) _inst_2 (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{max u2 u1, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) _inst_3)))) R (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddZeroClass.toAdd.{u2} R _inst_2) (AddZeroClass.toAdd.{max u1 u2} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{max u2 u1, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) _inst_3)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u1 u2} R (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) _inst_2 (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{max u2 u1, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) _inst_3)))) R (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) _inst_2 (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{max u2 u1, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) _inst_3))) (AddMonoidHom.addMonoidHomClass.{u2, max u1 u2} R (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) _inst_2 (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{max u1 u2, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{max u2 u1, u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) S (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) _inst_3)))))) (AddMonoidHom.eval.{u2, u1} R S _inst_2 _inst_3) r) (g i))) f)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.dfinsupp_sum_add_hom_apply AddMonoidHom.dfinsupp_sumAddHom_applyₓ'. -/
@[simp]
theorem dfinsupp_sumAddHom_apply [AddZeroClass R] [AddCommMonoid S] [∀ i, AddZeroClass (β i)]
    (f : Π₀ i, β i) (g : ∀ i, β i →+ R →+ S) (r : R) :
    (sumAddHom g f) r = sumAddHom (fun i => (eval r).comp (g i)) f :=
  map_dfinsupp_sumAddHom (eval r) f g
#align add_monoid_hom.dfinsupp_sum_add_hom_apply AddMonoidHom.dfinsupp_sumAddHom_apply

/- warning: add_monoid_hom.coe_dfinsupp_sum_add_hom -> AddMonoidHom.coe_dfinsupp_sumAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : AddZeroClass.{u3} R] [_inst_3 : AddCommMonoid.{u4} S] [_inst_4 : forall (i : ι), AddZeroClass.{u2} (β i)] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u2, max u4 u3} (β i) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (_inst_4 i) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3)))), Eq.{max (succ u3) (succ u4)} (R -> S) (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (fun (_x : AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) => R -> S) (AddMonoidHom.hasCoeToFun.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (coeFn.{max (succ (max u4 u3)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ (max u4 u3))} (AddMonoidHom.{max u1 u2, max u4 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3)))) (fun (_x : AddMonoidHom.{max u1 u2, max u4 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3)))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)))) (AddMonoidHom.hasCoeToFun.{max u1 u2, max u4 u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3)))) (Dfinsupp.sumAddHom.{u1, u2, max u4 u3} ι (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3) g) f)) (coeFn.{max (succ (max u3 u4)) (succ (max u1 u2)), max (succ (max u1 u2)) (succ (max u3 u4))} (AddMonoidHom.{max u1 u2, max u3 u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) (R -> S) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{max u3 u4} (R -> S) (AddCommMonoid.toAddMonoid.{max u3 u4} (R -> S) (Pi.addCommMonoid.{u3, u4} R (fun (ᾰ : R) => S) (fun (i : R) => _inst_3))))) (fun (_x : AddMonoidHom.{max u1 u2, max u3 u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) (R -> S) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{max u3 u4} (R -> S) (AddCommMonoid.toAddMonoid.{max u3 u4} (R -> S) (Pi.addCommMonoid.{u3, u4} R (fun (ᾰ : R) => S) (fun (i : R) => _inst_3))))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> R -> S) (AddMonoidHom.hasCoeToFun.{max u1 u2, max u3 u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) (R -> S) (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{max u3 u4} (R -> S) (AddCommMonoid.toAddMonoid.{max u3 u4} (R -> S) (Pi.addCommMonoid.{u3, u4} R (fun (ᾰ : R) => S) (fun (i : R) => _inst_3))))) (Dfinsupp.sumAddHom.{u1, u2, max u3 u4} ι (R -> S) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (Pi.addCommMonoid.{u3, u4} R (fun (ᾰ : R) => S) (fun (i : R) => _inst_3)) (fun (i : ι) => AddMonoidHom.comp.{u2, max u4 u3, max u3 u4} (β i) (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (R -> S) (_inst_4 i) (AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u3, u4} R S _inst_2 (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.addCommMonoid.{u3, u4} R S _inst_2 _inst_3))) (Pi.addZeroClass.{u3, u4} R (fun (ᾰ : R) => S) (fun (i : R) => AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (AddMonoidHom.coeFn.{u3, u4} R S _inst_2 _inst_3) (g i))) f)
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : AddZeroClass.{u2} R] [_inst_3 : AddCommMonoid.{u1} S] [_inst_4 : forall (i : ι), AddZeroClass.{u4} (β i)] (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u4, max u1 u2} (β i) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (_inst_4 i) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) f) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : R) => S) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) f) R S (AddZeroClass.toAdd.{u2} R _inst_2) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) f) R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) (AddMonoidHom.addMonoidHomClass.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))))) (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u2)) (succ u1), max (succ u3) (succ u4), max (succ u2) (succ u1)} (AddMonoidHom.{max u4 u3, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) _x) (AddHomClass.toFunLike.{max (max (max u3 u4) u2) u1, max u3 u4, max u2 u1} (AddMonoidHom.{max u4 u3, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))) (AddMonoidHomClass.toAddHomClass.{max (max (max u3 u4) u2) u1, max u3 u4, max u2 u1} (AddMonoidHom.{max u4 u3, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (AddMonoidHom.addMonoidHomClass.{max u3 u4, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3)))))) (Dfinsupp.sumAddHom.{u3, u4, max u2 u1} ι (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3) g) f)) (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u2)) (succ u1), max (succ u3) (succ u4), max (succ u2) (succ u1)} (AddMonoidHom.{max u4 u3, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (R -> S) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (R -> S) (AddCommMonoid.toAddMonoid.{max u2 u1} (R -> S) (Pi.addCommMonoid.{u2, u1} R (fun (a._@.Mathlib.Algebra.Group.Pi._hyg.2939 : R) => S) (fun (i : R) => _inst_3))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => R -> S) _x) (AddHomClass.toFunLike.{max (max (max u3 u4) u2) u1, max u3 u4, max u2 u1} (AddMonoidHom.{max u4 u3, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (R -> S) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (R -> S) (AddCommMonoid.toAddMonoid.{max u2 u1} (R -> S) (Pi.addCommMonoid.{u2, u1} R (fun (a._@.Mathlib.Algebra.Group.Pi._hyg.2939 : R) => S) (fun (i : R) => _inst_3))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (R -> S) (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{max u2 u1} (R -> S) (AddMonoid.toAddZeroClass.{max u2 u1} (R -> S) (AddCommMonoid.toAddMonoid.{max u2 u1} (R -> S) (Pi.addCommMonoid.{u2, u1} R (fun (a._@.Mathlib.Algebra.Group.Pi._hyg.2939 : R) => S) (fun (i : R) => _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max (max (max u3 u4) u2) u1, max u3 u4, max u2 u1} (AddMonoidHom.{max u4 u3, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (R -> S) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (R -> S) (AddCommMonoid.toAddMonoid.{max u2 u1} (R -> S) (Pi.addCommMonoid.{u2, u1} R (fun (a._@.Mathlib.Algebra.Group.Pi._hyg.2939 : R) => S) (fun (i : R) => _inst_3))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (R -> S) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (R -> S) (AddCommMonoid.toAddMonoid.{max u2 u1} (R -> S) (Pi.addCommMonoid.{u2, u1} R (fun (a._@.Mathlib.Algebra.Group.Pi._hyg.2939 : R) => S) (fun (i : R) => _inst_3)))) (AddMonoidHom.addMonoidHomClass.{max u3 u4, max u2 u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (R -> S) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{max u2 u1} (R -> S) (AddCommMonoid.toAddMonoid.{max u2 u1} (R -> S) (Pi.addCommMonoid.{u2, u1} R (fun (a._@.Mathlib.Algebra.Group.Pi._hyg.2939 : R) => S) (fun (i : R) => _inst_3))))))) (Dfinsupp.sumAddHom.{u3, u4, max u2 u1} ι (R -> S) (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (Pi.addCommMonoid.{u2, u1} R (fun (ᾰ : R) => S) (fun (i : R) => _inst_3)) (fun (i : ι) => AddMonoidHom.comp.{u4, max u2 u1, max u2 u1} (β i) (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (R -> S) (_inst_4 i) (AddMonoid.toAddZeroClass.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u1} (AddMonoidHom.{u2, u1} R S _inst_2 (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.addCommMonoid.{u2, u1} R S _inst_2 _inst_3))) (Pi.addZeroClass.{u2, u1} R (fun (ᾰ : R) => S) (fun (i : R) => AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHom.coeFn.{u2, u1} R S _inst_2 _inst_3) (g i))) f)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.coe_dfinsupp_sum_add_hom AddMonoidHom.coe_dfinsupp_sumAddHomₓ'. -/
theorem coe_dfinsupp_sumAddHom [AddZeroClass R] [AddCommMonoid S] [∀ i, AddZeroClass (β i)]
    (f : Π₀ i, β i) (g : ∀ i, β i →+ R →+ S) :
    ⇑(sumAddHom g f) = sumAddHom (fun i => (coeFn R S).comp (g i)) f :=
  map_dfinsupp_sumAddHom (coeFn R S) f g
#align add_monoid_hom.coe_dfinsupp_sum_add_hom AddMonoidHom.coe_dfinsupp_sumAddHom

end AddMonoidHom

namespace RingHom

variable {R S : Type _}

open Dfinsupp

/- warning: ring_hom.map_dfinsupp_sum_add_hom -> RingHom.map_dfinsupp_sumAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : NonAssocSemiring.{u3} R] [_inst_3 : NonAssocSemiring.{u4} S] [_inst_4 : forall (i : ι), AddZeroClass.{u2} (β i)] (h : RingHom.{u3, u4} R S _inst_2 _inst_3) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u2, u3} (β i) R (_inst_4 i) (AddMonoid.toAddZeroClass.{u3} R (AddMonoidWithOne.toAddMonoid.{u3} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} R (NonAssocSemiring.toAddCommMonoidWithOne.{u3} R _inst_2))))), Eq.{succ u4} S (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} R S _inst_2 _inst_3) (fun (_x : RingHom.{u3, u4} R S _inst_2 _inst_3) => R -> S) (RingHom.hasCoeToFun.{u3, u4} R S _inst_2 _inst_3) h (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) R (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R _inst_2))))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) R (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R _inst_2))))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> R) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) R (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R _inst_2))))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R _inst_2)) g) f)) (coeFn.{max (succ u4) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u4)} (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S _inst_3))))) (fun (_x : AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S _inst_3))))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> S) (AddMonoidHom.hasCoeToFun.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S _inst_3))))) (Dfinsupp.sumAddHom.{u1, u2, u4} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S _inst_3)) (fun (i : ι) => AddMonoidHom.comp.{u2, u3, u4} (β i) R S (_inst_4 i) (AddMonoid.toAddZeroClass.{u3} R (AddMonoidWithOne.toAddMonoid.{u3} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} R (NonAssocSemiring.toAddCommMonoidWithOne.{u3} R _inst_2)))) (AddMonoid.toAddZeroClass.{u4} S (AddMonoidWithOne.toAddMonoid.{u4} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u4} S (NonAssocSemiring.toAddCommMonoidWithOne.{u4} S _inst_3)))) (RingHom.toAddMonoidHom.{u3, u4} R S _inst_2 _inst_3 h) (g i))) f)
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : NonAssocSemiring.{u2} R] [_inst_3 : NonAssocSemiring.{u1} S] [_inst_4 : forall (i : ι), AddZeroClass.{u4} (β i)] (h : RingHom.{u2, u1} R S _inst_2 _inst_3) (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u4, u2} (β i) R (_inst_4 i) (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R _inst_2))))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u4), succ u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (a : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => R) a) (AddHomClass.toFunLike.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2)))) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))))) (Dfinsupp.sumAddHom.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2)) g) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S _inst_2 _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_2 _inst_3) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_3)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_2 _inst_3) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_3) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S _inst_2 _inst_3) R S _inst_2 _inst_3 (RingHom.instRingHomClassRingHom.{u2, u1} R S _inst_2 _inst_3)))) h (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u4), succ u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => R) _x) (AddHomClass.toFunLike.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2)))) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2))))))) (Dfinsupp.sumAddHom.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R _inst_2)) g) f)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u1), max (succ u3) (succ u4), succ u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_3))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => S) _x) (AddHomClass.toFunLike.{max (max u3 u4) u1, max u3 u4, u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_3))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u1, max u3 u4, u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_3))))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_3)))) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_3))))))) (Dfinsupp.sumAddHom.{u3, u4, u1} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S _inst_3)) (fun (i : ι) => AddMonoidHom.comp.{u4, u2, u1} (β i) R S (_inst_4 i) (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R _inst_2)))) (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S _inst_3)))) (RingHom.toAddMonoidHom.{u2, u1} R S _inst_2 _inst_3 h) (g i))) f)
Case conversion may be inaccurate. Consider using '#align ring_hom.map_dfinsupp_sum_add_hom RingHom.map_dfinsupp_sumAddHomₓ'. -/
@[simp]
theorem map_dfinsupp_sumAddHom [NonAssocSemiring R] [NonAssocSemiring S] [∀ i, AddZeroClass (β i)]
    (h : R →+* S) (f : Π₀ i, β i) (g : ∀ i, β i →+ R) :
    h (sumAddHom g f) = sumAddHom (fun i => h.toAddMonoidHom.comp (g i)) f :=
  AddMonoidHom.congr_fun (comp_liftAddHom h.toAddMonoidHom g) f
#align ring_hom.map_dfinsupp_sum_add_hom RingHom.map_dfinsupp_sumAddHom

end RingHom

namespace AddEquiv

variable {R S : Type _}

open Dfinsupp

/- warning: add_equiv.map_dfinsupp_sum_add_hom -> AddEquiv.map_dfinsupp_sumAddHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] {R : Type.{u3}} {S : Type.{u4}} [_inst_2 : AddCommMonoid.{u3} R] [_inst_3 : AddCommMonoid.{u4} S] [_inst_4 : forall (i : ι), AddZeroClass.{u2} (β i)] (h : AddEquiv.{u3, u4} R S (AddZeroClass.toHasAdd.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) (AddZeroClass.toHasAdd.{u4} S (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)))) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u2, u3} (β i) R (_inst_4 i) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))), Eq.{succ u4} S (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (AddEquiv.{u3, u4} R S (AddZeroClass.toHasAdd.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) (AddZeroClass.toHasAdd.{u4} S (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)))) (fun (_x : AddEquiv.{u3, u4} R S (AddZeroClass.toHasAdd.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) (AddZeroClass.toHasAdd.{u4} S (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)))) => R -> S) (AddEquiv.hasCoeToFun.{u3, u4} R S (AddZeroClass.toHasAdd.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) (AddZeroClass.toHasAdd.{u4} S (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)))) h (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) R (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) R (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> R) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) R (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2))) (Dfinsupp.sumAddHom.{u1, u2, u3} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_2 g) f)) (coeFn.{max (succ u4) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u4)} (AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (fun (_x : AddMonoidHom.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) => (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) -> S) (AddMonoidHom.hasCoeToFun.{max u1 u2, u4} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_4 i) i))) S (Dfinsupp.addZeroClass.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3))) (Dfinsupp.sumAddHom.{u1, u2, u4} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_3 (fun (i : ι) => AddMonoidHom.comp.{u2, u3, u4} (β i) R S (_inst_4 i) (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)) (AddEquiv.toAddMonoidHom.{u3, u4} R S (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R _inst_2)) (AddMonoid.toAddZeroClass.{u4} S (AddCommMonoid.toAddMonoid.{u4} S _inst_3)) h) (g i))) f)
but is expected to have type
  forall {ι : Type.{u3}} {β : ι -> Type.{u4}} [_inst_1 : DecidableEq.{succ u3} ι] {R : Type.{u2}} {S : Type.{u1}} [_inst_2 : AddCommMonoid.{u2} R] [_inst_3 : AddCommMonoid.{u1} S] [_inst_4 : forall (i : ι), AddZeroClass.{u4} (β i)] (h : AddEquiv.{u2, u1} R S (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)))) (f : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (g : forall (i : ι), AddMonoidHom.{u4, u2} (β i) R (_inst_4 i) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : R) => S) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u4), succ u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (a : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => R) a) (AddHomClass.toFunLike.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))))) (Dfinsupp.sumAddHom.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_2 g) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} R S (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} R S (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (AddEquiv.{u2, u1} R S (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)))) R S (AddEquivClass.toEquivLike.{max u2 u1, u2, u1} (AddEquiv.{u2, u1} R S (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)))) R S (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{u2, u1} R S (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))))))) h (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u4), succ u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => R) _x) (AddHomClass.toFunLike.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u2, max u3 u4, u2} (AddMonoidHom.{max u4 u3, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u2} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) R (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2))))) (Dfinsupp.sumAddHom.{u3, u4, u2} ι R (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_2 g) f)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u1), max (succ u3) (succ u4), succ u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (fun (_x : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) => S) _x) (AddHomClass.toFunLike.{max (max u3 u4) u1, max u3 u4, u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (AddZeroClass.toAdd.{max u3 u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i))) (AddZeroClass.toAdd.{u1} S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (AddMonoidHomClass.toAddHomClass.{max (max u3 u4) u1, max u3 u4, u1} (AddMonoidHom.{max u4 u3, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))) (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) (AddMonoidHom.addMonoidHomClass.{max u3 u4, u1} (Dfinsupp.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => AddZeroClass.toZero.{u4} ((fun (i : ι) => β i) i) (_inst_4 i))) S (Dfinsupp.instAddZeroClassDfinsuppToZero.{u3, u4} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_4 i)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3))))) (Dfinsupp.sumAddHom.{u3, u4, u1} ι S (fun (i : ι) => β i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_4 i) _inst_3 (fun (i : ι) => AddMonoidHom.comp.{u4, u2, u1} (β i) R S (_inst_4 i) (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) (AddEquiv.toAddMonoidHom.{u2, u1} R S (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R _inst_2)) (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S _inst_3)) h) (g i))) f)
Case conversion may be inaccurate. Consider using '#align add_equiv.map_dfinsupp_sum_add_hom AddEquiv.map_dfinsupp_sumAddHomₓ'. -/
@[simp]
theorem map_dfinsupp_sumAddHom [AddCommMonoid R] [AddCommMonoid S] [∀ i, AddZeroClass (β i)]
    (h : R ≃+ S) (f : Π₀ i, β i) (g : ∀ i, β i →+ R) :
    h (sumAddHom g f) = sumAddHom (fun i => h.toAddMonoidHom.comp (g i)) f :=
  AddMonoidHom.congr_fun (comp_liftAddHom h.toAddMonoidHom g) f
#align add_equiv.map_dfinsupp_sum_add_hom AddEquiv.map_dfinsupp_sumAddHom

end AddEquiv

end

section FiniteInfinite

#print Dfinsupp.fintype /-
instance Dfinsupp.fintype {ι : Sort _} {π : ι → Sort _} [DecidableEq ι] [∀ i, Zero (π i)]
    [Fintype ι] [∀ i, Fintype (π i)] : Fintype (Π₀ i, π i) :=
  Fintype.ofEquiv (∀ i, π i) Dfinsupp.equivFunOnFintype.symm
#align dfinsupp.fintype Dfinsupp.fintype
-/

#print Dfinsupp.infinite_of_left /-
instance Dfinsupp.infinite_of_left {ι : Sort _} {π : ι → Sort _} [∀ i, Nontrivial (π i)]
    [∀ i, Zero (π i)] [Infinite ι] : Infinite (Π₀ i, π i) := by
  letI := Classical.decEq ι <;> choose m hm using fun i => exists_ne (0 : π i) <;>
    exact Infinite.of_injective _ (Dfinsupp.single_left_injective hm)
#align dfinsupp.infinite_of_left Dfinsupp.infinite_of_left
-/

/- warning: dfinsupp.infinite_of_exists_right -> Dfinsupp.infinite_of_exists_right is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {π : ι -> Type.{u2}} (i : ι) [_inst_1 : Infinite.{succ u2} (π i)] [_inst_2 : forall (i : ι), Zero.{u2} (π i)], Infinite.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => π i) (fun (i : ι) => _inst_2 i))
but is expected to have type
  forall {ι : Type.{u2}} {π : ι -> Type.{u1}} (i : ι) [_inst_1 : Infinite.{succ u1} (π i)] [_inst_2 : forall (i : ι), Zero.{u1} (π i)], Infinite.{max (succ u1) (succ u2)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => π i) (fun (i : ι) => _inst_2 i))
Case conversion may be inaccurate. Consider using '#align dfinsupp.infinite_of_exists_right Dfinsupp.infinite_of_exists_rightₓ'. -/
/-- See `dfinsupp.infinite_of_right` for this in instance form, with the drawback that
it needs all `π i` to be infinite. -/
theorem Dfinsupp.infinite_of_exists_right {ι : Sort _} {π : ι → Sort _} (i : ι) [Infinite (π i)]
    [∀ i, Zero (π i)] : Infinite (Π₀ i, π i) :=
  letI := Classical.decEq ι
  Infinite.of_injective (fun j => Dfinsupp.single i j) Dfinsupp.single_injective
#align dfinsupp.infinite_of_exists_right Dfinsupp.infinite_of_exists_right

#print Dfinsupp.infinite_of_right /-
/-- See `dfinsupp.infinite_of_exists_right` for the case that only one `π ι` is infinite. -/
instance Dfinsupp.infinite_of_right {ι : Sort _} {π : ι → Sort _} [∀ i, Infinite (π i)]
    [∀ i, Zero (π i)] [Nonempty ι] : Infinite (Π₀ i, π i) :=
  Dfinsupp.infinite_of_exists_right (Classical.arbitrary ι)
#align dfinsupp.infinite_of_right Dfinsupp.infinite_of_right
-/

end FiniteInfinite

