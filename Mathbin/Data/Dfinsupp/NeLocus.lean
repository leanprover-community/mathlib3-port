/-
Copyright (c) 2022 Junyan Xu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa, Junyan Xu

! This file was ported from Lean 3 source module data.dfinsupp.ne_locus
! leanprover-community/mathlib commit d101e93197bb5f6ea89bd7ba386b7f7dff1f3903
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Dfinsupp.Basic

/-!
# Locus of unequal values of finitely supported dependent functions

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Let `N : α → Type*` be a type family, assume that `N a` has a `0` for all `a : α` and let
`f g : Π₀ a, N a` be finitely supported dependent functions.

## Main definition

* `dfinsupp.ne_locus f g : finset α`, the finite subset of `α` where `f` and `g` differ.
In the case in which `N a` is an additive group for all `a`, `dfinsupp.ne_locus f g` coincides with
`dfinsupp.support (f - g)`.
-/


variable {α : Type _} {N : α → Type _}

namespace Dfinsupp

variable [DecidableEq α]

section NHasZero

variable [∀ a, DecidableEq (N a)] [∀ a, Zero (N a)] (f g : Π₀ a, N a)

#print Dfinsupp.neLocus /-
/-- Given two finitely supported functions `f g : α →₀ N`, `finsupp.ne_locus f g` is the `finset`
where `f` and `g` differ. This generalizes `(f - g).support` to situations without subtraction. -/
def neLocus (f g : Π₀ a, N a) : Finset α :=
  (f.support ∪ g.support).filterₓ fun x => f x ≠ g x
#align dfinsupp.ne_locus Dfinsupp.neLocus
-/

/- warning: dfinsupp.mem_ne_locus -> Dfinsupp.mem_neLocus is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (N a)] {f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {a : α}, Iff (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g)) (Ne.{succ u2} (N a) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (fun (_x : Dfinsupp.{u1, u2} α (fun (i : α) => N i) (fun (i : α) => _inst_3 i)) => forall (i : α), N i) (Dfinsupp.hasCoeToFun.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f a) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (fun (_x : Dfinsupp.{u1, u2} α (fun (i : α) => N i) (fun (i : α) => _inst_3 i)) => forall (i : α), N i) (Dfinsupp.hasCoeToFun.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) g a))
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), Zero.{u1} (N a)] {f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {a : α}, Iff (Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) a (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g)) (Ne.{succ u1} ((fun (i : α) => (fun (a : α) => N a) i) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} α (fun (i : α) => (fun (a : α) => N a) i) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) α (fun (_x : α) => (fun (i : α) => (fun (a : α) => N a) i) _x) (Dfinsupp.funLike.{u2, u1} α (fun (a : α) => (fun (a : α) => N a) a) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} α (fun (i : α) => (fun (a : α) => N a) i) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) α (fun (_x : α) => (fun (i : α) => (fun (a : α) => N a) i) _x) (Dfinsupp.funLike.{u2, u1} α (fun (a : α) => (fun (a : α) => N a) a) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) g a))
Case conversion may be inaccurate. Consider using '#align dfinsupp.mem_ne_locus Dfinsupp.mem_neLocusₓ'. -/
@[simp]
theorem mem_neLocus {f g : Π₀ a, N a} {a : α} : a ∈ f.neLocus g ↔ f a ≠ g a := by
  simpa only [ne_locus, Finset.mem_filter, Finset.mem_union, mem_support_iff,
    and_iff_right_iff_imp] using Ne.ne_or_ne _
#align dfinsupp.mem_ne_locus Dfinsupp.mem_neLocus

/- warning: dfinsupp.not_mem_ne_locus -> Dfinsupp.not_mem_neLocus is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (N a)] {f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {a : α}, Iff (Not (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g))) (Eq.{succ u2} (N a) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (fun (_x : Dfinsupp.{u1, u2} α (fun (i : α) => N i) (fun (i : α) => _inst_3 i)) => forall (i : α), N i) (Dfinsupp.hasCoeToFun.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f a) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (fun (_x : Dfinsupp.{u1, u2} α (fun (i : α) => N i) (fun (i : α) => _inst_3 i)) => forall (i : α), N i) (Dfinsupp.hasCoeToFun.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) g a))
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), Zero.{u1} (N a)] {f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {a : α}, Iff (Not (Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) a (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g))) (Eq.{succ u1} ((fun (i : α) => (fun (a : α) => N a) i) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} α (fun (i : α) => (fun (a : α) => N a) i) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) α (fun (_x : α) => (fun (i : α) => (fun (a : α) => N a) i) _x) (Dfinsupp.funLike.{u2, u1} α (fun (a : α) => (fun (a : α) => N a) a) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} α (fun (i : α) => (fun (a : α) => N a) i) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) α (fun (_x : α) => (fun (i : α) => (fun (a : α) => N a) i) _x) (Dfinsupp.funLike.{u2, u1} α (fun (a : α) => (fun (a : α) => N a) a) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) g a))
Case conversion may be inaccurate. Consider using '#align dfinsupp.not_mem_ne_locus Dfinsupp.not_mem_neLocusₓ'. -/
theorem not_mem_neLocus {f g : Π₀ a, N a} {a : α} : a ∉ f.neLocus g ↔ f a = g a :=
  mem_neLocus.Not.trans not_ne_iff
#align dfinsupp.not_mem_ne_locus Dfinsupp.not_mem_neLocus

/- warning: dfinsupp.coe_ne_locus -> Dfinsupp.coe_neLocus is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)), Eq.{succ u1} (Set.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g)) (setOf.{u1} α (fun (x : α) => Ne.{succ u2} (N x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (fun (_x : Dfinsupp.{u1, u2} α (fun (i : α) => N i) (fun (i : α) => _inst_3 i)) => forall (i : α), N i) (Dfinsupp.hasCoeToFun.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f x) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (fun (_x : Dfinsupp.{u1, u2} α (fun (i : α) => N i) (fun (i : α) => _inst_3 i)) => forall (i : α), N i) (Dfinsupp.hasCoeToFun.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) g x)))
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), Zero.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)), Eq.{succ u2} (Set.{u2} α) (Finset.toSet.{u2} α (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g)) (setOf.{u2} α (fun (x : α) => Ne.{succ u1} ((fun (i : α) => (fun (a : α) => N a) i) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} α (fun (i : α) => (fun (a : α) => N a) i) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) α (fun (_x : α) => (fun (i : α) => (fun (a : α) => N a) i) _x) (Dfinsupp.funLike.{u2, u1} α (fun (a : α) => (fun (a : α) => N a) a) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} α (fun (i : α) => (fun (a : α) => N a) i) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) α (fun (_x : α) => (fun (i : α) => (fun (a : α) => N a) i) _x) (Dfinsupp.funLike.{u2, u1} α (fun (a : α) => (fun (a : α) => N a) a) (fun (i : α) => (fun (i : α) => _inst_3 i) i)) g x)))
Case conversion may be inaccurate. Consider using '#align dfinsupp.coe_ne_locus Dfinsupp.coe_neLocusₓ'. -/
@[simp]
theorem coe_neLocus : ↑(f.neLocus g) = { x | f x ≠ g x } :=
  Set.ext fun x => mem_neLocus
#align dfinsupp.coe_ne_locus Dfinsupp.coe_neLocus

/- warning: dfinsupp.ne_locus_eq_empty -> Dfinsupp.neLocus_eq_empty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (N a)] {f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)}, Iff (Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g) (EmptyCollection.emptyCollection.{u1} (Finset.{u1} α) (Finset.hasEmptyc.{u1} α))) (Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f g)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), Zero.{u1} (N a)] {f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)}, Iff (Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g) (EmptyCollection.emptyCollection.{u2} (Finset.{u2} α) (Finset.instEmptyCollectionFinset.{u2} α))) (Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_eq_empty Dfinsupp.neLocus_eq_emptyₓ'. -/
@[simp]
theorem neLocus_eq_empty {f g : Π₀ a, N a} : f.neLocus g = ∅ ↔ f = g :=
  ⟨fun h =>
    ext fun a =>
      Classical.not_not.mp (mem_neLocus.Not.mp (Finset.eq_empty_iff_forall_not_mem.mp h a)),
    fun h => h ▸ by simp only [ne_locus, Ne.def, eq_self_iff_true, not_true, Finset.filter_False]⟩
#align dfinsupp.ne_locus_eq_empty Dfinsupp.neLocus_eq_empty

/- warning: dfinsupp.nonempty_ne_locus_iff -> Dfinsupp.nonempty_neLocus_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (N a)] {f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)}, Iff (Finset.Nonempty.{u1} α (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g)) (Ne.{succ (max u1 u2)} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f g)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), Zero.{u1} (N a)] {f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)} {g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)}, Iff (Finset.Nonempty.{u2} α (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g)) (Ne.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.nonempty_ne_locus_iff Dfinsupp.nonempty_neLocus_iffₓ'. -/
@[simp]
theorem nonempty_neLocus_iff {f g : Π₀ a, N a} : (f.neLocus g).Nonempty ↔ f ≠ g :=
  Finset.nonempty_iff_ne_empty.trans neLocus_eq_empty.Not
#align dfinsupp.nonempty_ne_locus_iff Dfinsupp.nonempty_neLocus_iff

/- warning: dfinsupp.ne_locus_comm -> Dfinsupp.neLocus_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) g f)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), Zero.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f g) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) g f)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_comm Dfinsupp.neLocus_commₓ'. -/
theorem neLocus_comm : f.neLocus g = g.neLocus f := by
  simp_rw [ne_locus, Finset.union_comm, ne_comm]
#align dfinsupp.ne_locus_comm Dfinsupp.neLocus_comm

/- warning: dfinsupp.ne_locus_zero_right -> Dfinsupp.neLocus_zero_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (Dfinsupp.hasZero.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)))))) (Dfinsupp.support.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => _inst_3 i) (fun (i : α) (x : N i) => Ne.decidable.{succ u2} (N i) (fun (a : N i) (b : N i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (N i) 0 (OfNat.mk.{u2} (N i) 0 (Zero.zero.{u2} (N i) (_inst_3 i))))) f)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), Zero.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) f (OfNat.ofNat.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) 0 (Zero.toOfNat0.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (Dfinsupp.instZeroDfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))))) (Dfinsupp.support.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => _inst_3 i) (fun (i : α) (x : N i) => instDecidableNot (Eq.{succ u1} (N i) x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (_inst_3 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (_inst_3 i))))) f)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_zero_right Dfinsupp.neLocus_zero_rightₓ'. -/
@[simp]
theorem neLocus_zero_right : f.neLocus 0 = f.support :=
  by
  ext
  rw [mem_ne_locus, mem_support_iff, coe_zero, Pi.zero_apply]
#align dfinsupp.ne_locus_zero_right Dfinsupp.neLocus_zero_right

/- warning: dfinsupp.ne_locus_zero_left -> Dfinsupp.neLocus_zero_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) (OfNat.ofNat.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) 0 (OfNat.mk.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) 0 (Zero.zero.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (Dfinsupp.hasZero.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))))) f) (Dfinsupp.support.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => _inst_3 i) (fun (i : α) (x : N i) => Ne.decidable.{succ u2} (N i) (fun (a : N i) (b : N i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (N i) 0 (OfNat.mk.{u2} (N i) 0 (Zero.zero.{u2} (N i) (_inst_3 i))))) f)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), Zero.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => _inst_3 i) (OfNat.ofNat.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) 0 (Zero.toOfNat0.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) (Dfinsupp.instZeroDfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)))) f) (Dfinsupp.support.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => _inst_3 i) (fun (i : α) (x : N i) => instDecidableNot (Eq.{succ u1} (N i) x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (_inst_3 i)))) (_inst_2 i x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (_inst_3 i))))) f)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_zero_left Dfinsupp.neLocus_zero_leftₓ'. -/
@[simp]
theorem neLocus_zero_left : (0 : Π₀ a, N a).neLocus f = f.support :=
  (neLocus_comm _ _).trans (neLocus_zero_right _)
#align dfinsupp.ne_locus_zero_left Dfinsupp.neLocus_zero_left

end NHasZero

section NeLocusAndMaps

variable {M P : α → Type _} [∀ a, Zero (N a)] [∀ a, Zero (M a)] [∀ a, Zero (P a)]

/- warning: dfinsupp.subset_map_range_ne_locus -> Dfinsupp.subset_mapRange_neLocus is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] {M : α -> Type.{u3}} [_inst_2 : forall (a : α), Zero.{u2} (N a)] [_inst_3 : forall (a : α), Zero.{u3} (M a)] [_inst_5 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_6 : forall (a : α), DecidableEq.{succ u3} (M a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) {F : forall (a : α), (N a) -> (M a)} (F0 : forall (a : α), Eq.{succ u3} (M a) (F a (OfNat.ofNat.{u2} (N a) 0 (OfNat.mk.{u2} (N a) 0 (Zero.zero.{u2} (N a) (_inst_2 a))))) (OfNat.ofNat.{u3} (M a) 0 (OfNat.mk.{u3} (M a) 0 (Zero.zero.{u3} (M a) (_inst_3 a))))), HasSubset.Subset.{u1} (Finset.{u1} α) (Finset.hasSubset.{u1} α) (Dfinsupp.neLocus.{u1, u3} α (fun (i : α) => M i) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : M a) (b : M a) => _inst_6 a a_1 b) (fun (i : α) => _inst_3 i) (Dfinsupp.mapRange.{u1, u2, u3} α (fun (a : α) => N a) (fun (a : α) => M a) (fun (a : α) => _inst_2 a) (fun (a : α) => _inst_3 a) F F0 f) (Dfinsupp.mapRange.{u1, u2, u3} α (fun (a : α) => N a) (fun (a : α) => M a) (fun (i : α) => _inst_2 i) (fun (i : α) => _inst_3 i) F F0 g)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_5 a a_1 b) (fun (i : α) => _inst_2 i) f g)
but is expected to have type
  forall {α : Type.{u1}} {N : α -> Type.{u3}} [_inst_1 : DecidableEq.{succ u1} α] {M : α -> Type.{u2}} [_inst_2 : forall (a : α), Zero.{u3} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (M a)] [_inst_5 : forall (a : α), DecidableEq.{succ u3} (N a)] [_inst_6 : forall (a : α), DecidableEq.{succ u2} (M a)] (f : Dfinsupp.{u1, u3} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) (g : Dfinsupp.{u1, u3} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) {F : forall (a : α), (N a) -> (M a)} (F0 : forall (a : α), Eq.{succ u2} (M a) (F a (OfNat.ofNat.{u3} (N a) 0 (Zero.toOfNat0.{u3} (N a) (_inst_2 a)))) (OfNat.ofNat.{u2} (M a) 0 (Zero.toOfNat0.{u2} (M a) (_inst_3 a)))), HasSubset.Subset.{u1} (Finset.{u1} α) (Finset.instHasSubsetFinset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (i : α) => M i) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : M a) (b : M a) => _inst_6 a a_1 b) (fun (i : α) => _inst_3 i) (Dfinsupp.mapRange.{u1, u3, u2} α (fun (a : α) => N a) (fun (a : α) => M a) (fun (a : α) => _inst_2 a) (fun (a : α) => _inst_3 a) F F0 f) (Dfinsupp.mapRange.{u1, u3, u2} α (fun (a : α) => N a) (fun (a : α) => M a) (fun (i : α) => _inst_2 i) (fun (i : α) => _inst_3 i) F F0 g)) (Dfinsupp.neLocus.{u1, u3} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_5 a a_1 b) (fun (i : α) => _inst_2 i) f g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.subset_map_range_ne_locus Dfinsupp.subset_mapRange_neLocusₓ'. -/
theorem subset_mapRange_neLocus [∀ a, DecidableEq (N a)] [∀ a, DecidableEq (M a)] (f g : Π₀ a, N a)
    {F : ∀ a, N a → M a} (F0 : ∀ a, F a 0 = 0) :
    (f.mapRange F F0).neLocus (g.mapRange F F0) ⊆ f.neLocus g := fun a => by
  simpa only [mem_ne_locus, map_range_apply, not_imp_not] using congr_arg (F a)
#align dfinsupp.subset_map_range_ne_locus Dfinsupp.subset_mapRange_neLocus

/- warning: dfinsupp.zip_with_ne_locus_eq_left -> Dfinsupp.zipWith_neLocus_eq_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] {M : α -> Type.{u3}} {P : α -> Type.{u4}} [_inst_2 : forall (a : α), Zero.{u2} (N a)] [_inst_3 : forall (a : α), Zero.{u3} (M a)] [_inst_4 : forall (a : α), Zero.{u4} (P a)] [_inst_5 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_6 : forall (a : α), DecidableEq.{succ u4} (P a)] {F : forall (a : α), (M a) -> (N a) -> (P a)} (F0 : forall (a : α), Eq.{succ u4} (P a) (F a (OfNat.ofNat.{u3} (M a) 0 (OfNat.mk.{u3} (M a) 0 (Zero.zero.{u3} (M a) (_inst_3 a)))) (OfNat.ofNat.{u2} (N a) 0 (OfNat.mk.{u2} (N a) 0 (Zero.zero.{u2} (N a) (_inst_2 a))))) (OfNat.ofNat.{u4} (P a) 0 (OfNat.mk.{u4} (P a) 0 (Zero.zero.{u4} (P a) (_inst_4 a))))) (f : Dfinsupp.{u1, u3} α (fun (a : α) => M a) (fun (i : α) => _inst_3 i)) (g₁ : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) (g₂ : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)), (forall (a : α) (f : M a), Function.Injective.{succ u2, succ u4} (N a) (P a) (fun (g : N a) => F a f g)) -> (Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u4} α (fun (i : α) => P i) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : P a) (b : P a) => _inst_6 a a_1 b) (fun (i : α) => _inst_4 i) (Dfinsupp.zipWith.{u1, u4, u3, u2} α (fun (a : α) => P a) (fun (a : α) => M a) (fun (a : α) => N a) (fun (a : α) => _inst_4 a) (fun (a : α) => _inst_3 a) (fun (a : α) => _inst_2 a) F F0 f g₁) (Dfinsupp.zipWith.{u1, u4, u3, u2} α (fun (a : α) => P a) (fun (a : α) => M a) (fun (a : α) => N a) (fun (i : α) => _inst_4 i) (fun (a : α) => _inst_3 a) (fun (a : α) => _inst_2 a) F F0 f g₂)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_5 a a_1 b) (fun (i : α) => _inst_2 i) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {N : α -> Type.{u4}} [_inst_1 : DecidableEq.{succ u1} α] {M : α -> Type.{u2}} {P : α -> Type.{u3}} [_inst_2 : forall (a : α), Zero.{u4} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (M a)] [_inst_4 : forall (a : α), Zero.{u3} (P a)] [_inst_5 : forall (a : α), DecidableEq.{succ u4} (N a)] [_inst_6 : forall (a : α), DecidableEq.{succ u3} (P a)] {F : forall (a : α), (M a) -> (N a) -> (P a)} (F0 : forall (a : α), Eq.{succ u3} (P a) (F a (OfNat.ofNat.{u2} (M a) 0 (Zero.toOfNat0.{u2} (M a) (_inst_3 a))) (OfNat.ofNat.{u4} (N a) 0 (Zero.toOfNat0.{u4} (N a) (_inst_2 a)))) (OfNat.ofNat.{u3} (P a) 0 (Zero.toOfNat0.{u3} (P a) (_inst_4 a)))) (f : Dfinsupp.{u1, u2} α (fun (a : α) => M a) (fun (i : α) => _inst_3 i)) (g₁ : Dfinsupp.{u1, u4} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) (g₂ : Dfinsupp.{u1, u4} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)), (forall (a : α) (f : M a), Function.Injective.{succ u4, succ u3} (N a) (P a) (fun (g : N a) => F a f g)) -> (Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u3} α (fun (i : α) => P i) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : P a) (b : P a) => _inst_6 a a_1 b) (fun (i : α) => _inst_4 i) (Dfinsupp.zipWith.{u1, u3, u2, u4} α (fun (a : α) => P a) (fun (a : α) => M a) (fun (a : α) => N a) (fun (a : α) => _inst_4 a) (fun (a : α) => _inst_3 a) (fun (a : α) => _inst_2 a) F F0 f g₁) (Dfinsupp.zipWith.{u1, u3, u2, u4} α (fun (a : α) => P a) (fun (a : α) => M a) (fun (a : α) => N a) (fun (i : α) => _inst_4 i) (fun (a : α) => _inst_3 a) (fun (a : α) => _inst_2 a) F F0 f g₂)) (Dfinsupp.neLocus.{u1, u4} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_5 a a_1 b) (fun (i : α) => _inst_2 i) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.zip_with_ne_locus_eq_left Dfinsupp.zipWith_neLocus_eq_leftₓ'. -/
theorem zipWith_neLocus_eq_left [∀ a, DecidableEq (N a)] [∀ a, DecidableEq (P a)]
    {F : ∀ a, M a → N a → P a} (F0 : ∀ a, F a 0 0 = 0) (f : Π₀ a, M a) (g₁ g₂ : Π₀ a, N a)
    (hF : ∀ a f, Function.Injective fun g => F a f g) :
    (zipWith F F0 f g₁).neLocus (zipWith F F0 f g₂) = g₁.neLocus g₂ :=
  by
  ext
  simpa only [mem_ne_locus] using (hF a _).ne_iff
#align dfinsupp.zip_with_ne_locus_eq_left Dfinsupp.zipWith_neLocus_eq_left

/- warning: dfinsupp.zip_with_ne_locus_eq_right -> Dfinsupp.zipWith_neLocus_eq_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] {M : α -> Type.{u3}} {P : α -> Type.{u4}} [_inst_2 : forall (a : α), Zero.{u2} (N a)] [_inst_3 : forall (a : α), Zero.{u3} (M a)] [_inst_4 : forall (a : α), Zero.{u4} (P a)] [_inst_5 : forall (a : α), DecidableEq.{succ u3} (M a)] [_inst_6 : forall (a : α), DecidableEq.{succ u4} (P a)] {F : forall (a : α), (M a) -> (N a) -> (P a)} (F0 : forall (a : α), Eq.{succ u4} (P a) (F a (OfNat.ofNat.{u3} (M a) 0 (OfNat.mk.{u3} (M a) 0 (Zero.zero.{u3} (M a) (_inst_3 a)))) (OfNat.ofNat.{u2} (N a) 0 (OfNat.mk.{u2} (N a) 0 (Zero.zero.{u2} (N a) (_inst_2 a))))) (OfNat.ofNat.{u4} (P a) 0 (OfNat.mk.{u4} (P a) 0 (Zero.zero.{u4} (P a) (_inst_4 a))))) (f₁ : Dfinsupp.{u1, u3} α (fun (a : α) => M a) (fun (i : α) => _inst_3 i)) (f₂ : Dfinsupp.{u1, u3} α (fun (a : α) => M a) (fun (i : α) => _inst_3 i)) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)), (forall (a : α) (g : N a), Function.Injective.{succ u3, succ u4} (M a) (P a) (fun (f : M a) => F a f g)) -> (Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u4} α (fun (i : α) => P i) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : P a) (b : P a) => _inst_6 a a_1 b) (fun (i : α) => _inst_4 i) (Dfinsupp.zipWith.{u1, u4, u3, u2} α (fun (a : α) => P a) (fun (a : α) => M a) (fun (a : α) => N a) (fun (a : α) => _inst_4 a) (fun (a : α) => _inst_3 a) (fun (a : α) => _inst_2 a) F F0 f₁ g) (Dfinsupp.zipWith.{u1, u4, u3, u2} α (fun (a : α) => P a) (fun (a : α) => M a) (fun (a : α) => N a) (fun (i : α) => _inst_4 i) (fun (a : α) => _inst_3 a) (fun (a : α) => _inst_2 a) F F0 f₂ g)) (Dfinsupp.neLocus.{u1, u3} α (fun (a : α) => M a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : M a) (b : M a) => _inst_5 a a_1 b) (fun (i : α) => _inst_3 i) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] {M : α -> Type.{u4}} {P : α -> Type.{u3}} [_inst_2 : forall (a : α), Zero.{u2} (N a)] [_inst_3 : forall (a : α), Zero.{u4} (M a)] [_inst_4 : forall (a : α), Zero.{u3} (P a)] [_inst_5 : forall (a : α), DecidableEq.{succ u4} (M a)] [_inst_6 : forall (a : α), DecidableEq.{succ u3} (P a)] {F : forall (a : α), (M a) -> (N a) -> (P a)} (F0 : forall (a : α), Eq.{succ u3} (P a) (F a (OfNat.ofNat.{u4} (M a) 0 (Zero.toOfNat0.{u4} (M a) (_inst_3 a))) (OfNat.ofNat.{u2} (N a) 0 (Zero.toOfNat0.{u2} (N a) (_inst_2 a)))) (OfNat.ofNat.{u3} (P a) 0 (Zero.toOfNat0.{u3} (P a) (_inst_4 a)))) (f₁ : Dfinsupp.{u1, u4} α (fun (a : α) => M a) (fun (i : α) => _inst_3 i)) (f₂ : Dfinsupp.{u1, u4} α (fun (a : α) => M a) (fun (i : α) => _inst_3 i)) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)), (forall (a : α) (g : N a), Function.Injective.{succ u4, succ u3} (M a) (P a) (fun (f : M a) => F a f g)) -> (Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u3} α (fun (i : α) => P i) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : P a) (b : P a) => _inst_6 a a_1 b) (fun (i : α) => _inst_4 i) (Dfinsupp.zipWith.{u1, u3, u4, u2} α (fun (a : α) => P a) (fun (a : α) => M a) (fun (a : α) => N a) (fun (a : α) => _inst_4 a) (fun (a : α) => _inst_3 a) (fun (a : α) => _inst_2 a) F F0 f₁ g) (Dfinsupp.zipWith.{u1, u3, u4, u2} α (fun (a : α) => P a) (fun (a : α) => M a) (fun (a : α) => N a) (fun (i : α) => _inst_4 i) (fun (a : α) => _inst_3 a) (fun (a : α) => _inst_2 a) F F0 f₂ g)) (Dfinsupp.neLocus.{u1, u4} α (fun (a : α) => M a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : M a) (b : M a) => _inst_5 a a_1 b) (fun (i : α) => _inst_3 i) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align dfinsupp.zip_with_ne_locus_eq_right Dfinsupp.zipWith_neLocus_eq_rightₓ'. -/
theorem zipWith_neLocus_eq_right [∀ a, DecidableEq (M a)] [∀ a, DecidableEq (P a)]
    {F : ∀ a, M a → N a → P a} (F0 : ∀ a, F a 0 0 = 0) (f₁ f₂ : Π₀ a, M a) (g : Π₀ a, N a)
    (hF : ∀ a g, Function.Injective fun f => F a f g) :
    (zipWith F F0 f₁ g).neLocus (zipWith F F0 f₂ g) = f₁.neLocus f₂ :=
  by
  ext
  simpa only [mem_ne_locus] using (hF a _).ne_iff
#align dfinsupp.zip_with_ne_locus_eq_right Dfinsupp.zipWith_neLocus_eq_right

/- warning: dfinsupp.map_range_ne_locus_eq -> Dfinsupp.mapRange_neLocus_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] {M : α -> Type.{u3}} [_inst_2 : forall (a : α), Zero.{u2} (N a)] [_inst_3 : forall (a : α), Zero.{u3} (M a)] [_inst_5 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_6 : forall (a : α), DecidableEq.{succ u3} (M a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) {F : forall (a : α), (N a) -> (M a)} (F0 : forall (a : α), Eq.{succ u3} (M a) (F a (OfNat.ofNat.{u2} (N a) 0 (OfNat.mk.{u2} (N a) 0 (Zero.zero.{u2} (N a) (_inst_2 a))))) (OfNat.ofNat.{u3} (M a) 0 (OfNat.mk.{u3} (M a) 0 (Zero.zero.{u3} (M a) (_inst_3 a))))), (forall (a : α), Function.Injective.{succ u2, succ u3} (N a) (M a) (F a)) -> (Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u3} α (fun (i : α) => M i) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : M a) (b : M a) => _inst_6 a a_1 b) (fun (i : α) => _inst_3 i) (Dfinsupp.mapRange.{u1, u2, u3} α (fun (a : α) => N a) (fun (a : α) => M a) (fun (a : α) => _inst_2 a) (fun (a : α) => _inst_3 a) F F0 f) (Dfinsupp.mapRange.{u1, u2, u3} α (fun (a : α) => N a) (fun (a : α) => M a) (fun (i : α) => _inst_2 i) (fun (i : α) => _inst_3 i) F F0 g)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_5 a a_1 b) (fun (i : α) => _inst_2 i) f g))
but is expected to have type
  forall {α : Type.{u1}} {N : α -> Type.{u3}} [_inst_1 : DecidableEq.{succ u1} α] {M : α -> Type.{u2}} [_inst_2 : forall (a : α), Zero.{u3} (N a)] [_inst_3 : forall (a : α), Zero.{u2} (M a)] [_inst_5 : forall (a : α), DecidableEq.{succ u3} (N a)] [_inst_6 : forall (a : α), DecidableEq.{succ u2} (M a)] (f : Dfinsupp.{u1, u3} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) (g : Dfinsupp.{u1, u3} α (fun (a : α) => N a) (fun (i : α) => _inst_2 i)) {F : forall (a : α), (N a) -> (M a)} (F0 : forall (a : α), Eq.{succ u2} (M a) (F a (OfNat.ofNat.{u3} (N a) 0 (Zero.toOfNat0.{u3} (N a) (_inst_2 a)))) (OfNat.ofNat.{u2} (M a) 0 (Zero.toOfNat0.{u2} (M a) (_inst_3 a)))), (forall (a : α), Function.Injective.{succ u3, succ u2} (N a) (M a) (F a)) -> (Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (i : α) => M i) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : M a) (b : M a) => _inst_6 a a_1 b) (fun (i : α) => _inst_3 i) (Dfinsupp.mapRange.{u1, u3, u2} α (fun (a : α) => N a) (fun (a : α) => M a) (fun (a : α) => _inst_2 a) (fun (a : α) => _inst_3 a) F F0 f) (Dfinsupp.mapRange.{u1, u3, u2} α (fun (a : α) => N a) (fun (a : α) => M a) (fun (i : α) => _inst_2 i) (fun (i : α) => _inst_3 i) F F0 g)) (Dfinsupp.neLocus.{u1, u3} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_5 a a_1 b) (fun (i : α) => _inst_2 i) f g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.map_range_ne_locus_eq Dfinsupp.mapRange_neLocus_eqₓ'. -/
theorem mapRange_neLocus_eq [∀ a, DecidableEq (N a)] [∀ a, DecidableEq (M a)] (f g : Π₀ a, N a)
    {F : ∀ a, N a → M a} (F0 : ∀ a, F a 0 = 0) (hF : ∀ a, Function.Injective (F a)) :
    (f.mapRange F F0).neLocus (g.mapRange F F0) = f.neLocus g :=
  by
  ext
  simpa only [mem_ne_locus] using (hF a).ne_iff
#align dfinsupp.map_range_ne_locus_eq Dfinsupp.mapRange_neLocus_eq

end NeLocusAndMaps

variable [∀ a, DecidableEq (N a)]

/- warning: dfinsupp.ne_locus_add_left -> Dfinsupp.neLocus_add_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddLeftCancelMonoid.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (h : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i)))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.hasAdd.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) f g) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.hasAdd.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) f h)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddLeftCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i)))) g h)
but is expected to have type
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddLeftCancelMonoid.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (h : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} (N i) (AddLeftCancelMonoid.toAddMonoid.{u2} (N i) (_inst_3 i))))) f g) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} (N i) (AddLeftCancelMonoid.toAddMonoid.{u2} (N i) (_inst_3 i))))) f h)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddLeftCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i)) g h)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_add_left Dfinsupp.neLocus_add_leftₓ'. -/
@[simp]
theorem neLocus_add_left [∀ a, AddLeftCancelMonoid (N a)] (f g h : Π₀ a, N a) :
    (f + g).neLocus (f + h) = g.neLocus h :=
  zipWith_neLocus_eq_left _ _ _ _ fun a => add_right_injective
#align dfinsupp.ne_locus_add_left Dfinsupp.neLocus_add_left

/- warning: dfinsupp.ne_locus_add_right -> Dfinsupp.neLocus_add_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddRightCancelMonoid.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (h : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i)))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.hasAdd.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) f h) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) (Dfinsupp.hasAdd.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i))))) g h)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} ((fun (a : α) => N a) i) (AddMonoid.toAddZeroClass.{u2} ((fun (a : α) => N a) i) (AddRightCancelMonoid.toAddMonoid.{u2} ((fun (a : α) => N a) i) (_inst_3 i)))) f g)
but is expected to have type
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddRightCancelMonoid.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (h : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} (N i) (AddRightCancelMonoid.toAddMonoid.{u2} (N i) (_inst_3 i))))) f h) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i))) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} (N i) (AddRightCancelMonoid.toAddMonoid.{u2} (N i) (_inst_3 i))))) g h)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddRightCancelMonoid.toZero.{u2} ((fun (a : α) => N a) i) (_inst_3 i)) f g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_add_right Dfinsupp.neLocus_add_rightₓ'. -/
@[simp]
theorem neLocus_add_right [∀ a, AddRightCancelMonoid (N a)] (f g h : Π₀ a, N a) :
    (f + h).neLocus (g + h) = f.neLocus g :=
  zipWith_neLocus_eq_right _ _ _ _ fun a => add_left_injective
#align dfinsupp.ne_locus_add_right Dfinsupp.neLocus_add_right

section AddGroup

variable [∀ a, AddGroup (N a)] (f f₁ f₂ g g₁ g₂ : Π₀ a, N a)

/- warning: dfinsupp.ne_locus_neg_neg -> Dfinsupp.neLocus_neg_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddGroup.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasNeg.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasNeg.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) g)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) f g)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), AddGroup.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (Neg.neg.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f) (Neg.neg.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) g)) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) f g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_neg_neg Dfinsupp.neLocus_neg_negₓ'. -/
@[simp]
theorem neLocus_neg_neg : neLocus (-f) (-g) = f.neLocus g :=
  mapRange_neLocus_eq _ _ (fun a => neg_zero) fun a => neg_injective
#align dfinsupp.ne_locus_neg_neg Dfinsupp.neLocus_neg_neg

/- warning: dfinsupp.ne_locus_neg -> Dfinsupp.neLocus_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddGroup.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasNeg.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f) g) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) f (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasNeg.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) g))
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), AddGroup.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (Neg.neg.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) f) g) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) f (Neg.neg.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i)) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_neg Dfinsupp.neLocus_negₓ'. -/
theorem neLocus_neg : neLocus (-f) g = f.neLocus (-g) := by rw [← ne_locus_neg_neg, neg_neg]
#align dfinsupp.ne_locus_neg Dfinsupp.neLocus_neg

/- warning: dfinsupp.ne_locus_eq_support_sub -> Dfinsupp.neLocus_eq_support_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddGroup.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) f g) (Dfinsupp.support.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (fun (i : α) (x : N i) => Ne.decidable.{succ u2} (N i) (fun (a : N i) (b : N i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (N i) 0 (OfNat.mk.{u2} (N i) 0 (Zero.zero.{u2} (N i) (AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasSub.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g))
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), AddGroup.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) f g) (Dfinsupp.support.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (fun (i : α) (x : N i) => instDecidableNot (Eq.{succ u1} (N i) x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))))) (_inst_2 i x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))))))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_eq_support_sub Dfinsupp.neLocus_eq_support_subₓ'. -/
theorem neLocus_eq_support_sub : f.neLocus g = (f - g).support := by
  rw [← @ne_locus_add_right α N _ _ _ _ _ (-g), add_right_neg, ne_locus_zero_right, sub_eq_add_neg]
#align dfinsupp.ne_locus_eq_support_sub Dfinsupp.neLocus_eq_support_sub

/- warning: dfinsupp.ne_locus_sub_left -> Dfinsupp.neLocus_sub_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddGroup.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g₁ : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g₂ : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasSub.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g₁) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasSub.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g₂)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) g₁ g₂)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), AddGroup.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g₁ : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g₂ : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g₁) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g₂)) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) g₁ g₂)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_sub_left Dfinsupp.neLocus_sub_leftₓ'. -/
@[simp]
theorem neLocus_sub_left : neLocus (f - g₁) (f - g₂) = neLocus g₁ g₂ := by
  simp only [sub_eq_add_neg, @ne_locus_add_left α N _ _ _, ne_locus_neg_neg]
#align dfinsupp.ne_locus_sub_left Dfinsupp.neLocus_sub_left

/- warning: dfinsupp.ne_locus_sub_right -> Dfinsupp.neLocus_sub_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddGroup.{u2} (N a)] (f₁ : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (f₂ : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasSub.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f₁ g) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasSub.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f₂ g)) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) f₁ f₂)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), AddGroup.{u1} (N a)] (f₁ : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (f₂ : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f₁ g) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f₂ g)) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) f₁ f₂)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_sub_right Dfinsupp.neLocus_sub_rightₓ'. -/
@[simp]
theorem neLocus_sub_right : neLocus (f₁ - g) (f₂ - g) = neLocus f₁ f₂ := by
  simpa only [sub_eq_add_neg] using @ne_locus_add_right α N _ _ _ _ _ _
#align dfinsupp.ne_locus_sub_right Dfinsupp.neLocus_sub_right

/- warning: dfinsupp.ne_locus_self_add_right -> Dfinsupp.neLocus_self_add_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddGroup.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) f (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasAdd.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) f g)) (Dfinsupp.support.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (fun (i : α) (x : N i) => Ne.decidable.{succ u2} (N i) (fun (a : N i) (b : N i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (N i) 0 (OfNat.mk.{u2} (N i) 0 (Zero.zero.{u2} (N i) (AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))))))) g)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), AddGroup.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) f (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (instHAdd.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instAddDfinsuppToZero.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u1} (N i) (SubNegMonoid.toAddMonoid.{u1} (N i) (AddGroup.toSubNegMonoid.{u1} (N i) (_inst_3 i)))))) f g)) (Dfinsupp.support.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (fun (i : α) (x : N i) => instDecidableNot (Eq.{succ u1} (N i) x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))))) (_inst_2 i x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))))))) g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_self_add_right Dfinsupp.neLocus_self_add_rightₓ'. -/
@[simp]
theorem neLocus_self_add_right : neLocus f (f + g) = g.support := by
  rw [← ne_locus_zero_left, ← @ne_locus_add_left α N _ _ _ f 0 g, add_zero]
#align dfinsupp.ne_locus_self_add_right Dfinsupp.neLocus_self_add_right

/- warning: dfinsupp.ne_locus_self_add_left -> Dfinsupp.neLocus_self_add_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddGroup.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasAdd.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) f g) f) (Dfinsupp.support.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (fun (i : α) (x : N i) => Ne.decidable.{succ u2} (N i) (fun (a : N i) (b : N i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (N i) 0 (OfNat.mk.{u2} (N i) 0 (Zero.zero.{u2} (N i) (AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))))))) g)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), AddGroup.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (instHAdd.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instAddDfinsuppToZero.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => AddMonoid.toAddZeroClass.{u1} (N i) (SubNegMonoid.toAddMonoid.{u1} (N i) (AddGroup.toSubNegMonoid.{u1} (N i) (_inst_3 i)))))) f g) f) (Dfinsupp.support.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (fun (i : α) (x : N i) => instDecidableNot (Eq.{succ u1} (N i) x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))))) (_inst_2 i x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))))))) g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_self_add_left Dfinsupp.neLocus_self_add_leftₓ'. -/
@[simp]
theorem neLocus_self_add_left : neLocus (f + g) f = g.support := by
  rw [ne_locus_comm, ne_locus_self_add_right]
#align dfinsupp.ne_locus_self_add_left Dfinsupp.neLocus_self_add_left

/- warning: dfinsupp.ne_locus_self_sub_right -> Dfinsupp.neLocus_self_sub_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddGroup.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) f (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasSub.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g)) (Dfinsupp.support.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (fun (i : α) (x : N i) => Ne.decidable.{succ u2} (N i) (fun (a : N i) (b : N i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (N i) 0 (OfNat.mk.{u2} (N i) 0 (Zero.zero.{u2} (N i) (AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))))))) g)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), AddGroup.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) f (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g)) (Dfinsupp.support.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (fun (i : α) (x : N i) => instDecidableNot (Eq.{succ u1} (N i) x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))))) (_inst_2 i x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))))))) g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_self_sub_right Dfinsupp.neLocus_self_sub_rightₓ'. -/
@[simp]
theorem neLocus_self_sub_right : neLocus f (f - g) = g.support := by
  rw [sub_eq_add_neg, ne_locus_self_add_right, support_neg]
#align dfinsupp.ne_locus_self_sub_right Dfinsupp.neLocus_self_sub_right

/- warning: dfinsupp.ne_locus_self_sub_left -> Dfinsupp.neLocus_self_sub_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : α -> Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : forall (a : α), DecidableEq.{succ u2} (N a)] [_inst_3 : forall (a : α), AddGroup.{u2} (N a)] (f : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (g : Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))), Eq.{succ u1} (Finset.{u1} α) (Dfinsupp.neLocus.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i)))))) (Dfinsupp.hasSub.{u1, u2} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g) f) (Dfinsupp.support.{u1, u2} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))) (fun (i : α) (x : N i) => Ne.decidable.{succ u2} (N i) (fun (a : N i) (b : N i) => _inst_2 i a b) x (OfNat.ofNat.{u2} (N i) 0 (OfNat.mk.{u2} (N i) 0 (Zero.zero.{u2} (N i) (AddZeroClass.toHasZero.{u2} (N i) (AddMonoid.toAddZeroClass.{u2} (N i) (SubNegMonoid.toAddMonoid.{u2} (N i) (AddGroup.toSubNegMonoid.{u2} (N i) (_inst_3 i))))))))) g)
but is expected to have type
  forall {α : Type.{u2}} {N : α -> Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : forall (a : α), DecidableEq.{succ u1} (N a)] [_inst_3 : forall (a : α), AddGroup.{u1} (N a)] (f : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (g : Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))), Eq.{succ u2} (Finset.{u2} α) (Dfinsupp.neLocus.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (a : α) (a_1 : N a) (b : N a) => _inst_2 a a_1 b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (instHSub.{max u2 u1} (Dfinsupp.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u2, u1} α (fun (a : α) => N a) (fun (i : α) => _inst_3 i))) f g) f) (Dfinsupp.support.{u2, u1} α (fun (a : α) => N a) (fun (a : α) (b : α) => _inst_1 a b) (fun (i : α) => NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))) (fun (i : α) (x : N i) => instDecidableNot (Eq.{succ u1} (N i) x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i)))))))) (_inst_2 i x (OfNat.ofNat.{u1} (N i) 0 (Zero.toOfNat0.{u1} (N i) (NegZeroClass.toZero.{u1} ((fun (a : α) => N a) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (a : α) => N a) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (a : α) => N a) i) (AddGroup.toSubtractionMonoid.{u1} ((fun (a : α) => N a) i) (_inst_3 i))))))))) g)
Case conversion may be inaccurate. Consider using '#align dfinsupp.ne_locus_self_sub_left Dfinsupp.neLocus_self_sub_leftₓ'. -/
@[simp]
theorem neLocus_self_sub_left : neLocus (f - g) f = g.support := by
  rw [ne_locus_comm, ne_locus_self_sub_right]
#align dfinsupp.ne_locus_self_sub_left Dfinsupp.neLocus_self_sub_left

end AddGroup

end Dfinsupp

