/-
Copyright (c) 2018 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Robert Y. Lewis

! This file was ported from Lean 3 source module data.real.cau_seq_completion
! leanprover-community/mathlib commit f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Real.CauSeq

/-!
# Cauchy completion

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file generalizes the Cauchy completion of `(ℚ, abs)` to the completion of a ring
with absolute value.
-/


namespace CauSeq.Completion

open CauSeq

section

variable {α : Type _} [LinearOrderedField α]

variable {β : Type _} [Ring β] (abv : β → α) [IsAbsoluteValue abv]

#print CauSeq.Completion.Cauchy /-
/-- The Cauchy completion of a ring with absolute value. -/
def Cauchy :=
  @Quotient (CauSeq _ abv) CauSeq.equiv
#align cau_seq.completion.Cauchy CauSeq.Completion.Cauchy
-/

variable {abv}

#print CauSeq.Completion.mk /-
/-- The map from Cauchy sequences into the Cauchy completion. -/
def mk : CauSeq _ abv → Cauchy abv :=
  Quotient.mk'
#align cau_seq.completion.mk CauSeq.Completion.mk
-/

/- warning: cau_seq.completion.mk_eq_mk -> CauSeq.Completion.mk_eq_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (Quotient.mk'.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u1, u2} α β _inst_1 _inst_2 abv _inst_3) f) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (Quotient.mk.{succ u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u2, u1} α β _inst_1 _inst_2 abv _inst_3) f) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 f)
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mk_eq_mk CauSeq.Completion.mk_eq_mkₓ'. -/
@[simp]
theorem mk_eq_mk (f) : @Eq (Cauchy abv) ⟦f⟧ (mk f) :=
  rfl
#align cau_seq.completion.mk_eq_mk CauSeq.Completion.mk_eq_mk

/- warning: cau_seq.completion.mk_eq -> CauSeq.Completion.mk_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] {f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv} {g : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv}, Iff (Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 g)) (HasEquivₓ.Equiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (setoidHasEquiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f g)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] {f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv} {g : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv}, Iff (Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 f) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 g)) (HasEquiv.Equiv.{succ u1, 0} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHasEquiv.{succ u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f g)
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mk_eq CauSeq.Completion.mk_eqₓ'. -/
theorem mk_eq {f g : CauSeq _ abv} : mk f = mk g ↔ f ≈ g :=
  Quotient.eq'
#align cau_seq.completion.mk_eq CauSeq.Completion.mk_eq

#print CauSeq.Completion.ofRat /-
/-- The map from the original ring into the Cauchy completion. -/
def ofRat (x : β) : Cauchy abv :=
  mk (const abv x)
#align cau_seq.completion.of_rat CauSeq.Completion.ofRat
-/

instance : Zero (Cauchy abv) :=
  ⟨ofRat 0⟩

instance : One (Cauchy abv) :=
  ⟨ofRat 1⟩

instance : Inhabited (Cauchy abv) :=
  ⟨0⟩

/- warning: cau_seq.completion.of_rat_zero -> CauSeq.Completion.ofRat_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv], Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β _inst_2))))))))) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) 0 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) 0 (Zero.zero.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasZero.{u1, u2} α _inst_1 β _inst_2 abv _inst_3))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv], Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (MonoidWithZero.toZero.{u2} β (Semiring.toMonoidWithZero.{u2} β (Ring.toSemiring.{u2} β _inst_2)))))) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) 0 (Zero.toOfNat0.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instZeroCauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.of_rat_zero CauSeq.Completion.ofRat_zeroₓ'. -/
theorem ofRat_zero : (ofRat 0 : Cauchy abv) = 0 :=
  rfl
#align cau_seq.completion.of_rat_zero CauSeq.Completion.ofRat_zero

#print CauSeq.Completion.ofRat_one /-
theorem ofRat_one : (ofRat 1 : Cauchy abv) = 1 :=
  rfl
#align cau_seq.completion.of_rat_one CauSeq.Completion.ofRat_one
-/

/- warning: cau_seq.completion.mk_eq_zero -> CauSeq.Completion.mk_eq_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] {f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv}, Iff (Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) 0 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) 0 (Zero.zero.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasZero.{u1, u2} α _inst_1 β _inst_2 abv _inst_3))))) (CauSeq.LimZero.{u1, u2} α β _inst_1 _inst_2 abv f)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] {f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv}, Iff (Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 f) (OfNat.ofNat.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) 0 (Zero.toOfNat0.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instZeroCauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3)))) (CauSeq.LimZero.{u2, u1} α β _inst_1 _inst_2 abv f)
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mk_eq_zero CauSeq.Completion.mk_eq_zeroₓ'. -/
@[simp]
theorem mk_eq_zero {f : CauSeq _ abv} : mk f = 0 ↔ LimZero f := by
  have : mk f = 0 ↔ lim_zero (f - 0) := Quotient.eq' <;> rwa [sub_zero] at this
#align cau_seq.completion.mk_eq_zero CauSeq.Completion.mk_eq_zero

instance : Add (Cauchy abv) :=
  ⟨Quotient.map₂ (· + ·) fun f₁ g₁ hf f₂ g₂ hg => add_equiv_add hf hg⟩

/- warning: cau_seq.completion.mk_add -> CauSeq.Completion.mk_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (g : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (HAdd.hAdd.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHAdd.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasAdd.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 g)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HAdd.hAdd.{u2, u2, u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (instHAdd.{u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.hasAdd.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f g))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (g : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (HAdd.hAdd.{u1, u1, u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (instHAdd.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instAddCauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 f) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 g)) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 (HAdd.hAdd.{u1, u1, u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHAdd.{u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.instAddCauSeq.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f g))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mk_add CauSeq.Completion.mk_addₓ'. -/
@[simp]
theorem mk_add (f g : CauSeq β abv) : mk f + mk g = mk (f + g) :=
  rfl
#align cau_seq.completion.mk_add CauSeq.Completion.mk_add

instance : Neg (Cauchy abv) :=
  ⟨Quotient.map Neg.neg fun f₁ f₂ hf => neg_equiv_neg hf⟩

/- warning: cau_seq.completion.mk_neg -> CauSeq.Completion.mk_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (Neg.neg.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasNeg.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (Neg.neg.{u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.hasNeg.{u1, u2} α β _inst_1 _inst_2 abv _inst_3) f))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (Neg.neg.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instNegCauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 f)) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 (Neg.neg.{u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.instNegCauSeq.{u2, u1} α β _inst_1 _inst_2 abv _inst_3) f))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mk_neg CauSeq.Completion.mk_negₓ'. -/
@[simp]
theorem mk_neg (f : CauSeq β abv) : -mk f = mk (-f) :=
  rfl
#align cau_seq.completion.mk_neg CauSeq.Completion.mk_neg

instance : Mul (Cauchy abv) :=
  ⟨Quotient.map₂ (· * ·) fun f₁ g₁ hf f₂ g₂ hg => mul_equiv_mul hf hg⟩

/- warning: cau_seq.completion.mk_mul -> CauSeq.Completion.mk_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (g : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (HMul.hMul.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHMul.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasMul.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 g)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HMul.hMul.{u2, u2, u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (instHMul.{u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.hasMul.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f g))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (g : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (HMul.hMul.{u1, u1, u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (instHMul.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instMulCauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 f) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 g)) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 (HMul.hMul.{u1, u1, u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHMul.{u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.instMulCauSeq.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f g))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mk_mul CauSeq.Completion.mk_mulₓ'. -/
@[simp]
theorem mk_mul (f g : CauSeq β abv) : mk f * mk g = mk (f * g) :=
  rfl
#align cau_seq.completion.mk_mul CauSeq.Completion.mk_mul

instance : Sub (Cauchy abv) :=
  ⟨Quotient.map₂ Sub.sub fun f₁ g₁ hf f₂ g₂ hg => sub_equiv_sub hf hg⟩

/- warning: cau_seq.completion.mk_sub -> CauSeq.Completion.mk_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (g : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (HSub.hSub.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHSub.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasSub.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 g)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HSub.hSub.{u2, u2, u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (instHSub.{u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.hasSub.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f g))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (g : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (HSub.hSub.{u1, u1, u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (instHSub.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instSubCauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 f) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 g)) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 (HSub.hSub.{u1, u1, u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHSub.{u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.instSubCauSeq.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f g))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mk_sub CauSeq.Completion.mk_subₓ'. -/
@[simp]
theorem mk_sub (f g : CauSeq β abv) : mk f - mk g = mk (f - g) :=
  rfl
#align cau_seq.completion.mk_sub CauSeq.Completion.mk_sub

instance {γ : Type _} [SMul γ β] [IsScalarTower γ β β] : SMul γ (Cauchy abv) :=
  ⟨fun c => Quotient.map ((· • ·) c) fun f₁ g₁ hf => smul_equiv_smul _ hf⟩

/- warning: cau_seq.completion.mk_smul -> CauSeq.Completion.mk_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] {γ : Type.{u3}} [_inst_4 : SMul.{u3, u2} γ β] [_inst_5 : IsScalarTower.{u3, u2, u2} γ β β _inst_4 (Mul.toSMul.{u2} β (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β _inst_2))) _inst_4] (c : γ) (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (SMul.smul.{u3, u2} γ (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasSmul.{u1, u2, u3} α _inst_1 β _inst_2 abv _inst_3 γ _inst_4 _inst_5) c (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (SMul.smul.{u3, u2} γ (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.hasSmul.{u3, u1, u2} γ α β _inst_1 _inst_2 abv _inst_3 _inst_4 _inst_5) c f))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] {γ : Type.{u3}} [_inst_4 : SMul.{u3, u2} γ β] [_inst_5 : IsScalarTower.{u3, u2, u2} γ β β _inst_4 (MulAction.toSMul.{u2, u2} β β (MonoidWithZero.toMonoid.{u2} β (Semiring.toMonoidWithZero.{u2} β (Ring.toSemiring.{u2} β _inst_2))) (Monoid.toMulAction.{u2} β (MonoidWithZero.toMonoid.{u2} β (Semiring.toMonoidWithZero.{u2} β (Ring.toSemiring.{u2} β _inst_2))))) _inst_4] (c : γ) (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (HSMul.hSMul.{u3, u2, u2} γ (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHSMul.{u3, u2} γ (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instSMulCauchy.{u1, u2, u3} α _inst_1 β _inst_2 abv _inst_3 γ _inst_4 _inst_5)) c (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HSMul.hSMul.{u3, u2, u2} γ (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (instHSMul.{u3, u2} γ (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.instSMulCauSeq.{u1, u2, u3} α β γ _inst_1 _inst_2 abv _inst_3 _inst_4 _inst_5)) c f))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mk_smul CauSeq.Completion.mk_smulₓ'. -/
@[simp]
theorem mk_smul {γ : Type _} [SMul γ β] [IsScalarTower γ β β] (c : γ) (f : CauSeq β abv) :
    c • mk f = mk (c • f) :=
  rfl
#align cau_seq.completion.mk_smul CauSeq.Completion.mk_smul

instance : Pow (Cauchy abv) ℕ :=
  ⟨fun x n => Quotient.map (· ^ n) (fun f₁ g₁ hf => pow_equiv_pow hf _) x⟩

/- warning: cau_seq.completion.mk_pow -> CauSeq.Completion.mk_pow is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (n : Nat) (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (HPow.hPow.{u2, 0, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) Nat (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHPow.{u2, 0} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) Nat (CauSeq.Completion.Nat.hasPow.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 f) n) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HPow.hPow.{u2, 0, u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) Nat (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (instHPow.{u2, 0} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) Nat (CauSeq.Nat.hasPow.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f n))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] (n : Nat) (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (HPow.hPow.{u1, 0, u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) Nat (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (instHPow.{u1, 0} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) Nat (CauSeq.Completion.instPowCauchyNat.{u2, u1} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 f) n) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 (HPow.hPow.{u1, 0, u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) Nat (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHPow.{u1, 0} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) Nat (CauSeq.instPowCauSeqNat.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f n))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mk_pow CauSeq.Completion.mk_powₓ'. -/
@[simp]
theorem mk_pow (n : ℕ) (f : CauSeq β abv) : mk f ^ n = mk (f ^ n) :=
  rfl
#align cau_seq.completion.mk_pow CauSeq.Completion.mk_pow

instance : NatCast (Cauchy abv) :=
  ⟨fun n => mk n⟩

instance : IntCast (Cauchy abv) :=
  ⟨fun n => mk n⟩

#print CauSeq.Completion.ofRat_natCast /-
@[simp]
theorem ofRat_natCast (n : ℕ) : (ofRat n : Cauchy abv) = n :=
  rfl
#align cau_seq.completion.of_rat_nat_cast CauSeq.Completion.ofRat_natCast
-/

/- warning: cau_seq.completion.of_rat_int_cast -> CauSeq.Completion.ofRat_intCast is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (z : Int), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β (AddGroupWithOne.toHasIntCast.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β _inst_2)))))) z)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (HasLiftT.mk.{1, succ u2} Int (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CoeTCₓ.coe.{1, succ u2} Int (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (Int.castCoe.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasIntCast.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)))) z)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (z : Int), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (Int.cast.{u2} β (Ring.toIntCast.{u2} β _inst_2) z)) (Int.cast.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instIntCastCauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) z)
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.of_rat_int_cast CauSeq.Completion.ofRat_intCastₓ'. -/
@[simp]
theorem ofRat_intCast (z : ℤ) : (ofRat z : Cauchy abv) = z :=
  rfl
#align cau_seq.completion.of_rat_int_cast CauSeq.Completion.ofRat_intCast

/- warning: cau_seq.completion.of_rat_add -> CauSeq.Completion.ofRat_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (x : β) (y : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (Distrib.toHasAdd.{u2} β (Ring.toDistrib.{u2} β _inst_2))) x y)) (HAdd.hAdd.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHAdd.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasAdd.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 x) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (x : β) (y : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (Distrib.toAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β _inst_2)))))) x y)) (HAdd.hAdd.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHAdd.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instAddCauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 x) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 y))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.of_rat_add CauSeq.Completion.ofRat_addₓ'. -/
theorem ofRat_add (x y : β) : ofRat (x + y) = (ofRat x + ofRat y : Cauchy abv) :=
  congr_arg mk (const_add _ _)
#align cau_seq.completion.of_rat_add CauSeq.Completion.ofRat_add

/- warning: cau_seq.completion.of_rat_neg -> CauSeq.Completion.ofRat_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (x : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (Neg.neg.{u2} β (SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddGroupWithOne.toAddGroup.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β _inst_2))))) x)) (Neg.neg.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasNeg.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 x))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (x : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (Neg.neg.{u2} β (Ring.toNeg.{u2} β _inst_2) x)) (Neg.neg.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instNegCauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 x))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.of_rat_neg CauSeq.Completion.ofRat_negₓ'. -/
theorem ofRat_neg (x : β) : ofRat (-x) = (-ofRat x : Cauchy abv) :=
  congr_arg mk (const_neg _)
#align cau_seq.completion.of_rat_neg CauSeq.Completion.ofRat_neg

/- warning: cau_seq.completion.of_rat_mul -> CauSeq.Completion.ofRat_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (x : β) (y : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β _inst_2))) x y)) (HMul.hMul.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHMul.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasMul.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 x) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (x : β) (y : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (NonUnitalNonAssocRing.toMul.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β _inst_2)))) x y)) (HMul.hMul.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHMul.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instMulCauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 x) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 y))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.of_rat_mul CauSeq.Completion.ofRat_mulₓ'. -/
theorem ofRat_mul (x y : β) : ofRat (x * y) = (ofRat x * ofRat y : Cauchy abv) :=
  congr_arg mk (const_mul _ _)
#align cau_seq.completion.of_rat_mul CauSeq.Completion.ofRat_mul

private theorem zero_def : 0 = (mk 0 : Cauchy abv) :=
  rfl
#align cau_seq.completion.zero_def cau_seq.completion.zero_def

private theorem one_def : 1 = (mk 1 : Cauchy abv) :=
  rfl
#align cau_seq.completion.one_def cau_seq.completion.one_def

instance : Ring (Cauchy abv) :=
  Function.Surjective.ring mk (surjective_quotient_mk' _) zero_def.symm one_def.symm
    (fun _ _ => (mk_add _ _).symm) (fun _ _ => (mk_mul _ _).symm) (fun _ => (mk_neg _).symm)
    (fun _ _ => (mk_sub _ _).symm) (fun _ _ => (mk_smul _ _).symm) (fun _ _ => (mk_smul _ _).symm)
    (fun _ _ => (mk_pow _ _).symm) (fun _ => rfl) fun _ => rfl

#print CauSeq.Completion.ofRatRingHom /-
/-- `cau_seq.completion.of_rat` as a `ring_hom`  -/
@[simps]
def ofRatRingHom : β →+* Cauchy abv where
  toFun := ofRat
  map_zero' := ofRat_zero
  map_one' := ofRat_one
  map_add' := ofRat_add
  map_mul' := ofRat_mul
#align cau_seq.completion.of_rat_ring_hom CauSeq.Completion.ofRatRingHom
-/

/- warning: cau_seq.completion.of_rat_sub -> CauSeq.Completion.ofRat_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (x : β) (y : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β (SubNegMonoid.toHasSub.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddGroupWithOne.toAddGroup.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β _inst_2)))))) x y)) (HSub.hSub.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHSub.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.hasSub.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 x) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] (x : β) (y : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β (Ring.toSub.{u2} β _inst_2)) x y)) (HSub.hSub.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (instHSub.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.instSubCauchy.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 x) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 y))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.of_rat_sub CauSeq.Completion.ofRat_subₓ'. -/
theorem ofRat_sub (x y : β) : ofRat (x - y) = (ofRat x - ofRat y : Cauchy abv) :=
  congr_arg mk (const_sub _ _)
#align cau_seq.completion.of_rat_sub CauSeq.Completion.ofRat_sub

end

section

variable {α : Type _} [LinearOrderedField α]

variable {β : Type _} [CommRing β] {abv : β → α} [IsAbsoluteValue abv]

instance : CommRing (Cauchy abv) :=
  Function.Surjective.commRing mk (surjective_quotient_mk' _) zero_def.symm one_def.symm
    (fun _ _ => (mk_add _ _).symm) (fun _ _ => (mk_mul _ _).symm) (fun _ => (mk_neg _).symm)
    (fun _ _ => (mk_sub _ _).symm) (fun _ _ => (mk_smul _ _).symm) (fun _ _ => (mk_smul _ _).symm)
    (fun _ _ => (mk_pow _ _).symm) (fun _ => rfl) fun _ => rfl

end

open Classical

section

variable {α : Type _} [LinearOrderedField α]

variable {β : Type _} [DivisionRing β] {abv : β → α} [IsAbsoluteValue abv]

instance : RatCast (Cauchy abv) :=
  ⟨fun q => ofRat q⟩

/- warning: cau_seq.completion.of_rat_rat_cast -> CauSeq.Completion.ofRat_ratCast is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β _inst_2)) abv] (q : Rat), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Rat β (HasLiftT.mk.{1, succ u2} Rat β (CoeTCₓ.coe.{1, succ u2} Rat β (Rat.castCoe.{u2} β (DivisionRing.toHasRatCast.{u2} β _inst_2)))) q)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Rat (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (HasLiftT.mk.{1, succ u2} Rat (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CoeTCₓ.coe.{1, succ u2} Rat (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (Rat.castCoe.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasRatCast.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)))) q)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (DivisionSemiring.toSemiring.{u2} β (DivisionRing.toDivisionSemiring.{u2} β _inst_2)) abv] (q : Rat), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 (RatCast.ratCast.{u2} β (DivisionRing.toRatCast.{u2} β _inst_2) q)) (RatCast.ratCast.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.instRatCastCauchyToRing.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) q)
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.of_rat_rat_cast CauSeq.Completion.ofRat_ratCastₓ'. -/
@[simp]
theorem ofRat_ratCast (q : ℚ) : ofRat (↑q : β) = (q : Cauchy abv) :=
  rfl
#align cau_seq.completion.of_rat_rat_cast CauSeq.Completion.ofRat_ratCast

noncomputable instance : Inv (Cauchy abv) :=
  ⟨fun x =>
    Quotient.liftOn x (fun f => mk <| if h : LimZero f then 0 else inv f h) fun f g fg =>
      by
      have := lim_zero_congr fg
      by_cases hf : lim_zero f
      · simp [hf, this.1 hf, Setoid.refl]
      · have hg := mt this.2 hf
        simp [hf, hg]
        have If : mk (inv f hf) * mk f = 1 := mk_eq.2 (inv_mul_cancel hf)
        have Ig : mk (inv g hg) * mk g = 1 := mk_eq.2 (inv_mul_cancel hg)
        have Ig' : mk g * mk (inv g hg) = 1 := mk_eq.2 (mul_inv_cancel hg)
        rw [mk_eq.2 fg, ← Ig] at If
        rw [← mul_one (mk (inv f hf)), ← Ig', ← mul_assoc, If, mul_assoc, Ig', mul_one]⟩

/- warning: cau_seq.completion.inv_zero -> CauSeq.Completion.inv_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β _inst_2)) abv], Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (Inv.inv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasInv.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (Zero.zero.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasZero.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3))))) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (Zero.zero.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasZero.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (DivisionSemiring.toSemiring.{u2} β (DivisionRing.toDivisionSemiring.{u2} β _inst_2)) abv], Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (Inv.inv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.instInvCauchyToRing.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (Zero.toOfNat0.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.instZeroCauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)))) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (Zero.toOfNat0.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.instZeroCauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.inv_zero CauSeq.Completion.inv_zeroₓ'. -/
@[simp]
theorem inv_zero : (0 : Cauchy abv)⁻¹ = 0 :=
  congr_arg mk <| by rw [dif_pos] <;> [rfl, exact zero_lim_zero]
#align cau_seq.completion.inv_zero CauSeq.Completion.inv_zero

/- warning: cau_seq.completion.inv_mk -> CauSeq.Completion.inv_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β _inst_2)) abv] {f : CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv} (hf : Not (CauSeq.LimZero.{u1, u2} α β _inst_1 (DivisionRing.toRing.{u2} β _inst_2) abv f)), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (Inv.inv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasInv.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 f)) (CauSeq.Completion.mk.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 (CauSeq.inv.{u1, u2} α β _inst_1 _inst_2 abv _inst_3 f hf))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : DivisionRing.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (DivisionSemiring.toSemiring.{u1} β (DivisionRing.toDivisionSemiring.{u1} β _inst_2)) abv] {f : CauSeq.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv} (hf : Not (CauSeq.LimZero.{u2, u1} α β _inst_1 (DivisionRing.toRing.{u1} β _inst_2) abv f)), Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (Inv.inv.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.instInvCauchyToRing.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3 f)) (CauSeq.Completion.mk.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3 (CauSeq.inv.{u2, u1} α β _inst_1 _inst_2 abv _inst_3 f hf))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.inv_mk CauSeq.Completion.inv_mkₓ'. -/
@[simp]
theorem inv_mk {f} (hf) : (@mk α _ β _ abv _ f)⁻¹ = mk (inv f hf) :=
  congr_arg mk <| by rw [dif_neg]
#align cau_seq.completion.inv_mk CauSeq.Completion.inv_mk

/- warning: cau_seq.completion.cau_seq_zero_ne_one -> CauSeq.Completion.cau_seq_zero_ne_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β _inst_2)) abv], Not (HasEquivₓ.Equiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) (setoidHasEquiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) (CauSeq.equiv.{u1, u2} α β _inst_1 (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)) (OfNat.ofNat.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) 0 (OfNat.mk.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) 0 (Zero.zero.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) (CauSeq.hasZero.{u1, u2} α β _inst_1 (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)))) (OfNat.ofNat.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) 1 (OfNat.mk.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) 1 (One.one.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) (CauSeq.hasOne.{u1, u2} α β _inst_1 (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (DivisionSemiring.toSemiring.{u2} β (DivisionRing.toDivisionSemiring.{u2} β _inst_2)) abv], Not (HasEquiv.Equiv.{succ u2, 0} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) (instHasEquiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) (CauSeq.equiv.{u1, u2} α β _inst_1 (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)) (OfNat.ofNat.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) 0 (Zero.toOfNat0.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) (CauSeq.instZeroCauSeq.{u1, u2} α β _inst_1 (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3))) (OfNat.ofNat.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) 1 (One.toOfNat1.{u2} (CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv) (CauSeq.instOneCauSeq.{u1, u2} α β _inst_1 (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3))))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.cau_seq_zero_ne_one CauSeq.Completion.cau_seq_zero_ne_oneₓ'. -/
theorem cau_seq_zero_ne_one : ¬(0 : CauSeq _ abv) ≈ 1 := fun h =>
  have : LimZero (1 - 0) := Setoid.symm h
  have : LimZero 1 := by simpa
  one_neZero <| const_limZero.1 this
#align cau_seq.completion.cau_seq_zero_ne_one CauSeq.Completion.cau_seq_zero_ne_one

/- warning: cau_seq.completion.zero_ne_one -> CauSeq.Completion.zero_ne_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β _inst_2)) abv], Ne.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (Zero.zero.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasZero.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)))) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 1 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 1 (One.one.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasOne.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (DivisionSemiring.toSemiring.{u2} β (DivisionRing.toDivisionSemiring.{u2} β _inst_2)) abv], Ne.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (Zero.toOfNat0.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.instZeroCauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3))) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 1 (One.toOfNat1.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.instOneCauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.zero_ne_one CauSeq.Completion.zero_ne_oneₓ'. -/
theorem zero_ne_one : (0 : Cauchy abv) ≠ 1 := fun h => cau_seq_zero_ne_one <| mk_eq.1 h
#align cau_seq.completion.zero_ne_one CauSeq.Completion.zero_ne_one

/- warning: cau_seq.completion.inv_mul_cancel -> CauSeq.Completion.inv_mul_cancel is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β _inst_2)) abv] {x : CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3}, (Ne.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) x (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (Zero.zero.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasZero.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3))))) -> (Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (HMul.hMul.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (instHMul.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasMul.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)) (Inv.inv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasInv.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) x) x) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 1 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 1 (One.one.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasOne.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)))))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : DivisionRing.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (DivisionSemiring.toSemiring.{u1} β (DivisionRing.toDivisionSemiring.{u1} β _inst_2)) abv] {x : CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3}, (Ne.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) x (OfNat.ofNat.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) 0 (Zero.toOfNat0.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.instZeroCauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3)))) -> (Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (HMul.hMul.{u1, u1, u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (instHMul.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.instMulCauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3)) (Inv.inv.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.instInvCauchyToRing.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) x) x) (OfNat.ofNat.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) 1 (One.toOfNat1.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.instOneCauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3))))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.inv_mul_cancel CauSeq.Completion.inv_mul_cancelₓ'. -/
protected theorem inv_mul_cancel {x : Cauchy abv} : x ≠ 0 → x⁻¹ * x = 1 :=
  Quotient.inductionOn x fun f hf => by
    simp at hf; simp [hf]
    exact Quotient.sound (CauSeq.inv_mul_cancel hf)
#align cau_seq.completion.inv_mul_cancel CauSeq.Completion.inv_mul_cancel

/- warning: cau_seq.completion.mul_inv_cancel -> CauSeq.Completion.mul_inv_cancel is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β _inst_2)) abv] {x : CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3}, (Ne.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) x (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 0 (Zero.zero.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasZero.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3))))) -> (Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (HMul.hMul.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (instHMul.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasMul.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)) x (Inv.inv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasInv.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) x)) (OfNat.ofNat.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 1 (OfNat.mk.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) 1 (One.one.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasOne.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3)))))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : DivisionRing.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (DivisionSemiring.toSemiring.{u1} β (DivisionRing.toDivisionSemiring.{u1} β _inst_2)) abv] {x : CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3}, (Ne.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) x (OfNat.ofNat.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) 0 (Zero.toOfNat0.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.instZeroCauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3)))) -> (Eq.{succ u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (HMul.hMul.{u1, u1, u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (instHMul.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.instMulCauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3)) x (Inv.inv.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.instInvCauchyToRing.{u2, u1} α _inst_1 β _inst_2 abv _inst_3) x)) (OfNat.ofNat.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) 1 (One.toOfNat1.{u1} (CauSeq.Completion.Cauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3) (CauSeq.Completion.instOneCauchy.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β _inst_2) abv _inst_3))))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.mul_inv_cancel CauSeq.Completion.mul_inv_cancelₓ'. -/
protected theorem mul_inv_cancel {x : Cauchy abv} : x ≠ 0 → x * x⁻¹ = 1 :=
  Quotient.inductionOn x fun f hf => by
    simp at hf; simp [hf]
    exact Quotient.sound (CauSeq.mul_inv_cancel hf)
#align cau_seq.completion.mul_inv_cancel CauSeq.Completion.mul_inv_cancel

/- warning: cau_seq.completion.of_rat_inv -> CauSeq.Completion.ofRat_inv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β _inst_2)) abv] (x : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 (Inv.inv.{u2} β (DivInvMonoid.toHasInv.{u2} β (DivisionRing.toDivInvMonoid.{u2} β _inst_2)) x)) (Inv.inv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.hasInv.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 x))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (DivisionSemiring.toSemiring.{u2} β (DivisionRing.toDivisionSemiring.{u2} β _inst_2)) abv] (x : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 (Inv.inv.{u2} β (DivisionRing.toInv.{u2} β _inst_2) x)) (Inv.inv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.instInvCauchyToRing.{u1, u2} α _inst_1 β _inst_2 abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 x))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.of_rat_inv CauSeq.Completion.ofRat_invₓ'. -/
theorem ofRat_inv (x : β) : ofRat x⁻¹ = ((ofRat x)⁻¹ : Cauchy abv) :=
  congr_arg mk <| by split_ifs with h <;> [simp [const_lim_zero.1 h], rfl]
#align cau_seq.completion.of_rat_inv CauSeq.Completion.ofRat_inv

/-- The Cauchy completion forms a division ring. -/
noncomputable instance : DivisionRing (Cauchy abv) :=
  { Cauchy.ring with
    inv := Inv.inv
    mul_inv_cancel := fun x => CauSeq.Completion.mul_inv_cancel
    exists_pair_ne := ⟨0, 1, zero_ne_one⟩
    inv_zero := inv_zero
    ratCast := fun q => ofRat q
    rat_cast_mk := fun n d hd hnd => by
      rw [Rat.cast_mk', of_rat_mul, of_rat_int_cast, of_rat_inv, of_rat_nat_cast] }

/- warning: cau_seq.completion.of_rat_div -> CauSeq.Completion.ofRat_div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β _inst_2)) abv] (x : β) (y : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 (HDiv.hDiv.{u2, u2, u2} β β β (instHDiv.{u2} β (DivInvMonoid.toHasDiv.{u2} β (DivisionRing.toDivInvMonoid.{u2} β _inst_2))) x y)) (HDiv.hDiv.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (instHDiv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (DivInvMonoid.toHasDiv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (DivisionRing.toDivInvMonoid.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.divisionRing.{u1, u2} α _inst_1 β _inst_2 abv _inst_3)))) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 x) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : DivisionRing.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))) β (DivisionSemiring.toSemiring.{u2} β (DivisionRing.toDivisionSemiring.{u2} β _inst_2)) abv] (x : β) (y : β), Eq.{succ u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 (HDiv.hDiv.{u2, u2, u2} β β β (instHDiv.{u2} β (DivisionRing.toDiv.{u2} β _inst_2)) x y)) (HDiv.hDiv.{u2, u2, u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (instHDiv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (DivisionRing.toDiv.{u2} (CauSeq.Completion.Cauchy.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3) (CauSeq.Completion.Cauchy.divisionRing.{u1, u2} α _inst_1 β _inst_2 abv _inst_3))) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 x) (CauSeq.Completion.ofRat.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β _inst_2) abv _inst_3 y))
Case conversion may be inaccurate. Consider using '#align cau_seq.completion.of_rat_div CauSeq.Completion.ofRat_divₓ'. -/
theorem ofRat_div (x y : β) : ofRat (x / y) = (ofRat x / ofRat y : Cauchy abv) := by
  simp only [div_eq_mul_inv, of_rat_inv, of_rat_mul]
#align cau_seq.completion.of_rat_div CauSeq.Completion.ofRat_div

/-- Show the first 10 items of a representative of this equivalence class of cauchy sequences.

The representative chosen is the one passed in the VM to `quot.mk`, so two cauchy sequences
converging to the same number may be printed differently.
-/
unsafe instance [Repr β] : Repr (Cauchy abv)
    where repr r :=
    let N := 10
    let seq := r.unquot
    "(sorry /- " ++ (", ".intercalate <| (List.range N).map <| repr ∘ seq) ++ ", ... -/)"

end

section

variable {α : Type _} [LinearOrderedField α]

variable {β : Type _} [Field β] {abv : β → α} [IsAbsoluteValue abv]

/-- The Cauchy completion forms a field. -/
noncomputable instance : Field (Cauchy abv) :=
  { Cauchy.divisionRing, Cauchy.commRing with }

end

end CauSeq.Completion

variable {α : Type _} [LinearOrderedField α]

namespace CauSeq

section

variable (β : Type _) [Ring β] (abv : β → α) [IsAbsoluteValue abv]

#print CauSeq.IsComplete /-
/-- A class stating that a ring with an absolute value is complete, i.e. every Cauchy
sequence has a limit. -/
class IsComplete : Prop where
  IsComplete : ∀ s : CauSeq β abv, ∃ b : β, s ≈ const abv b
#align cau_seq.is_complete CauSeq.IsComplete
-/

end

section

variable {β : Type _} [Ring β] {abv : β → α} [IsAbsoluteValue abv]

variable [IsComplete β abv]

/- warning: cau_seq.complete -> CauSeq.complete is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] (s : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Exists.{succ u2} β (fun (b : β) => HasEquivₓ.Equiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (setoidHasEquiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) s (CauSeq.const.{u1, u2} α β _inst_1 _inst_2 abv _inst_3 b))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] (s : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Exists.{succ u1} β (fun (b : β) => HasEquiv.Equiv.{succ u1, 0} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHasEquiv.{succ u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) s (CauSeq.const.{u2, u1} α β _inst_1 _inst_2 abv _inst_3 b))
Case conversion may be inaccurate. Consider using '#align cau_seq.complete CauSeq.completeₓ'. -/
theorem complete : ∀ s : CauSeq β abv, ∃ b : β, s ≈ const abv b :=
  is_complete.is_complete
#align cau_seq.complete CauSeq.complete

#print CauSeq.lim /-
/-- The limit of a Cauchy sequence in a complete ring. Chosen non-computably. -/
noncomputable def lim (s : CauSeq β abv) : β :=
  Classical.choose (complete s)
#align cau_seq.lim CauSeq.lim
-/

/- warning: cau_seq.equiv_lim -> CauSeq.equiv_lim is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] (s : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), HasEquivₓ.Equiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (setoidHasEquiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) s (CauSeq.const.{u1, u2} α β _inst_1 _inst_2 abv _inst_3 (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 s))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] (s : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), HasEquiv.Equiv.{succ u1, 0} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHasEquiv.{succ u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) s (CauSeq.const.{u2, u1} α β _inst_1 _inst_2 abv _inst_3 (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align cau_seq.equiv_lim CauSeq.equiv_limₓ'. -/
theorem equiv_lim (s : CauSeq β abv) : s ≈ const abv (lim s) :=
  Classical.choose_spec (complete s)
#align cau_seq.equiv_lim CauSeq.equiv_lim

/- warning: cau_seq.eq_lim_of_const_equiv -> CauSeq.eq_lim_of_const_equiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] {f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv} {x : β}, (HasEquivₓ.Equiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (setoidHasEquiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) (CauSeq.const.{u1, u2} α β _inst_1 _inst_2 abv _inst_3 x) f) -> (Eq.{succ u2} β x (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] {f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv} {x : β}, (HasEquiv.Equiv.{succ u1, 0} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHasEquiv.{succ u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) (CauSeq.const.{u2, u1} α β _inst_1 _inst_2 abv _inst_3 x) f) -> (Eq.{succ u1} β x (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f))
Case conversion may be inaccurate. Consider using '#align cau_seq.eq_lim_of_const_equiv CauSeq.eq_lim_of_const_equivₓ'. -/
theorem eq_lim_of_const_equiv {f : CauSeq β abv} {x : β} (h : CauSeq.const abv x ≈ f) : x = lim f :=
  const_equiv.mp <| Setoid.trans h <| equiv_lim f
#align cau_seq.eq_lim_of_const_equiv CauSeq.eq_lim_of_const_equiv

/- warning: cau_seq.lim_eq_of_equiv_const -> CauSeq.lim_eq_of_equiv_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] {f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv} {x : β}, (HasEquivₓ.Equiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (setoidHasEquiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f (CauSeq.const.{u1, u2} α β _inst_1 _inst_2 abv _inst_3 x)) -> (Eq.{succ u2} β (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) x)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] {f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv} {x : β}, (HasEquiv.Equiv.{succ u1, 0} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHasEquiv.{succ u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f (CauSeq.const.{u2, u1} α β _inst_1 _inst_2 abv _inst_3 x)) -> (Eq.{succ u1} β (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) x)
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_eq_of_equiv_const CauSeq.lim_eq_of_equiv_constₓ'. -/
theorem lim_eq_of_equiv_const {f : CauSeq β abv} {x : β} (h : f ≈ CauSeq.const abv x) : lim f = x :=
  (eq_lim_of_const_equiv <| Setoid.symm h).symm
#align cau_seq.lim_eq_of_equiv_const CauSeq.lim_eq_of_equiv_const

/- warning: cau_seq.lim_eq_lim_of_equiv -> CauSeq.lim_eq_lim_of_equiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] {f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv} {g : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv}, (HasEquivₓ.Equiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (setoidHasEquiv.{succ u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f g) -> (Eq.{succ u2} β (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 g))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] {f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv} {g : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv}, (HasEquiv.Equiv.{succ u1, 0} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHasEquiv.{succ u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.equiv.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f g) -> (Eq.{succ u1} β (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 g))
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_eq_lim_of_equiv CauSeq.lim_eq_lim_of_equivₓ'. -/
theorem lim_eq_lim_of_equiv {f g : CauSeq β abv} (h : f ≈ g) : lim f = lim g :=
  lim_eq_of_equiv_const <| Setoid.trans h <| equiv_lim g
#align cau_seq.lim_eq_lim_of_equiv CauSeq.lim_eq_lim_of_equiv

#print CauSeq.lim_const /-
@[simp]
theorem lim_const (x : β) : lim (const abv x) = x :=
  lim_eq_of_equiv_const <| Setoid.refl _
#align cau_seq.lim_const CauSeq.lim_const
-/

/- warning: cau_seq.lim_add -> CauSeq.lim_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (g : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} β (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (Distrib.toHasAdd.{u2} β (Ring.toDistrib.{u2} β _inst_2))) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 g)) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 (HAdd.hAdd.{u2, u2, u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (instHAdd.{u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.hasAdd.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f g))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (g : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Eq.{succ u1} β (HAdd.hAdd.{u1, u1, u1} β β β (instHAdd.{u1} β (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β _inst_2)))))) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 g)) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 (HAdd.hAdd.{u1, u1, u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHAdd.{u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.instAddCauSeq.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f g))
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_add CauSeq.lim_addₓ'. -/
theorem lim_add (f g : CauSeq β abv) : lim f + lim g = lim (f + g) :=
  eq_lim_of_const_equiv <|
    show LimZero (const abv (lim f + lim g) - (f + g)) by
      rw [const_add, add_sub_add_comm] <;>
        exact add_lim_zero (Setoid.symm (equiv_lim f)) (Setoid.symm (equiv_lim g))
#align cau_seq.lim_add CauSeq.lim_add

/- warning: cau_seq.lim_mul_lim -> CauSeq.lim_mul_lim is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (g : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} β (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β _inst_2))) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 g)) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 (HMul.hMul.{u2, u2, u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (instHMul.{u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.hasMul.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f g))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (g : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Eq.{succ u1} β (HMul.hMul.{u1, u1, u1} β β β (instHMul.{u1} β (NonUnitalNonAssocRing.toMul.{u1} β (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β _inst_2)))) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 g)) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 (HMul.hMul.{u1, u1, u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHMul.{u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.instMulCauSeq.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f g))
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_mul_lim CauSeq.lim_mul_limₓ'. -/
theorem lim_mul_lim (f g : CauSeq β abv) : lim f * lim g = lim (f * g) :=
  eq_lim_of_const_equiv <|
    show LimZero (const abv (lim f * lim g) - f * g)
      by
      have h :
        const abv (lim f * lim g) - f * g =
          (const abv (lim f) - f) * g + const abv (lim f) * (const abv (lim g) - g) :=
        by simp [const_mul (limUnder f), mul_add, add_mul, sub_eq_add_neg, add_comm, add_left_comm]
      rw [h] <;>
        exact
          add_lim_zero (mul_lim_zero_left _ (Setoid.symm (equiv_lim _)))
            (mul_lim_zero_right _ (Setoid.symm (equiv_lim _)))
#align cau_seq.lim_mul_lim CauSeq.lim_mul_lim

/- warning: cau_seq.lim_mul -> CauSeq.lim_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (x : β), Eq.{succ u2} β (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β _inst_2))) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) x) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 (HMul.hMul.{u2, u2, u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (instHMul.{u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.hasMul.{u1, u2} α β _inst_1 _inst_2 abv _inst_3)) f (CauSeq.const.{u1, u2} α β _inst_1 _inst_2 abv _inst_3 x)))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (x : β), Eq.{succ u1} β (HMul.hMul.{u1, u1, u1} β β β (instHMul.{u1} β (NonUnitalNonAssocRing.toMul.{u1} β (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β _inst_2)))) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) x) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 (HMul.hMul.{u1, u1, u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (instHMul.{u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.instMulCauSeq.{u2, u1} α β _inst_1 _inst_2 abv _inst_3)) f (CauSeq.const.{u2, u1} α β _inst_1 _inst_2 abv _inst_3 x)))
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_mul CauSeq.lim_mulₓ'. -/
theorem lim_mul (f : CauSeq β abv) (x : β) : lim f * x = lim (f * const abv x) := by
  rw [← lim_mul_lim, lim_const]
#align cau_seq.lim_mul CauSeq.lim_mul

/- warning: cau_seq.lim_neg -> CauSeq.lim_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Eq.{succ u2} β (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 (Neg.neg.{u2} (CauSeq.{u1, u2} α _inst_1 β _inst_2 abv) (CauSeq.hasNeg.{u1, u2} α β _inst_1 _inst_2 abv _inst_3) f)) (Neg.neg.{u2} β (SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddGroupWithOne.toAddGroup.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β _inst_2))))) (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Eq.{succ u1} β (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 (Neg.neg.{u1} (CauSeq.{u2, u1} α _inst_1 β _inst_2 abv) (CauSeq.instNegCauSeq.{u2, u1} α β _inst_1 _inst_2 abv _inst_3) f)) (Neg.neg.{u1} β (Ring.toNeg.{u1} β _inst_2) (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f))
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_neg CauSeq.lim_negₓ'. -/
theorem lim_neg (f : CauSeq β abv) : lim (-f) = -lim f :=
  lim_eq_of_equiv_const
    (show LimZero (-f - const abv (-lim f)) by
      rw [const_neg, sub_neg_eq_add, add_comm, ← sub_eq_add_neg] <;>
        exact Setoid.symm (equiv_lim f))
#align cau_seq.lim_neg CauSeq.lim_neg

/- warning: cau_seq.lim_eq_zero_iff -> CauSeq.lim_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Ring.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u1, u2} α _inst_1 β _inst_2 abv), Iff (Eq.{succ u2} β (CauSeq.lim.{u1, u2} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β _inst_2))))))))) (CauSeq.LimZero.{u1, u2} α β _inst_1 _inst_2 abv f)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Ring.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (Ring.toSemiring.{u1} β _inst_2) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β _inst_2 abv _inst_3] (f : CauSeq.{u2, u1} α _inst_1 β _inst_2 abv), Iff (Eq.{succ u1} β (CauSeq.lim.{u2, u1} α _inst_1 β _inst_2 abv _inst_3 _inst_4 f) (OfNat.ofNat.{u1} β 0 (Zero.toOfNat0.{u1} β (MonoidWithZero.toZero.{u1} β (Semiring.toMonoidWithZero.{u1} β (Ring.toSemiring.{u1} β _inst_2)))))) (CauSeq.LimZero.{u2, u1} α β _inst_1 _inst_2 abv f)
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_eq_zero_iff CauSeq.lim_eq_zero_iffₓ'. -/
theorem lim_eq_zero_iff (f : CauSeq β abv) : lim f = 0 ↔ LimZero f :=
  ⟨fun h => by
    have hf := equiv_lim f <;> rw [h] at hf <;>
      exact (lim_zero_congr hf).mpr (const_lim_zero.mpr rfl),
    fun h =>
    by
    have h₁ : f = f - const abv 0 := ext fun n => by simp [sub_apply, const_apply]
    rw [h₁] at h <;> exact lim_eq_of_equiv_const h⟩
#align cau_seq.lim_eq_zero_iff CauSeq.lim_eq_zero_iff

end

section

variable {β : Type _} [Field β] {abv : β → α} [IsAbsoluteValue abv] [IsComplete β abv]

/- warning: cau_seq.lim_inv -> CauSeq.lim_inv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] {β : Type.{u2}} [_inst_2 : Field.{u2} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u1, u2} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) β (Ring.toSemiring.{u2} β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β _inst_2))) abv] [_inst_4 : CauSeq.IsComplete.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β _inst_2)) abv _inst_3] {f : CauSeq.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β _inst_2)) abv} (hf : Not (CauSeq.LimZero.{u1, u2} α β _inst_1 (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β _inst_2)) abv f)), Eq.{succ u2} β (CauSeq.lim.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β _inst_2)) abv _inst_3 _inst_4 (CauSeq.inv.{u1, u2} α β _inst_1 (Field.toDivisionRing.{u2} β _inst_2) abv _inst_3 f hf)) (Inv.inv.{u2} β (DivInvMonoid.toHasInv.{u2} β (DivisionRing.toDivInvMonoid.{u2} β (Field.toDivisionRing.{u2} β _inst_2))) (CauSeq.lim.{u1, u2} α _inst_1 β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β _inst_2)) abv _inst_3 _inst_4 f))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LinearOrderedField.{u2} α] {β : Type.{u1}} [_inst_2 : Field.{u1} β] {abv : β -> α} [_inst_3 : IsAbsoluteValue.{u2, u1} α (OrderedCommSemiring.toOrderedSemiring.{u2} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} α (LinearOrderedField.toLinearOrderedSemifield.{u2} α _inst_1))))) β (DivisionSemiring.toSemiring.{u1} β (Semifield.toDivisionSemiring.{u1} β (Field.toSemifield.{u1} β _inst_2))) abv] [_inst_4 : CauSeq.IsComplete.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β (Field.toDivisionRing.{u1} β _inst_2)) abv _inst_3] {f : CauSeq.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β (Field.toDivisionRing.{u1} β _inst_2)) abv} (hf : Not (CauSeq.LimZero.{u2, u1} α β _inst_1 (DivisionRing.toRing.{u1} β (Field.toDivisionRing.{u1} β _inst_2)) abv f)), Eq.{succ u1} β (CauSeq.lim.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β (Field.toDivisionRing.{u1} β _inst_2)) abv _inst_3 _inst_4 (CauSeq.inv.{u2, u1} α β _inst_1 (Field.toDivisionRing.{u1} β _inst_2) abv _inst_3 f hf)) (Inv.inv.{u1} β (Field.toInv.{u1} β _inst_2) (CauSeq.lim.{u2, u1} α _inst_1 β (DivisionRing.toRing.{u1} β (Field.toDivisionRing.{u1} β _inst_2)) abv _inst_3 _inst_4 f))
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_inv CauSeq.lim_invₓ'. -/
theorem lim_inv {f : CauSeq β abv} (hf : ¬LimZero f) : lim (inv f hf) = (lim f)⁻¹ :=
  have hl : lim f ≠ 0 := by rwa [← lim_eq_zero_iff] at hf
  lim_eq_of_equiv_const <|
    show LimZero (inv f hf - const abv (lim f)⁻¹) from
      have h₁ : ∀ (g f : CauSeq β abv) (hf : ¬LimZero f), LimZero (g - f * inv f hf * g) :=
        fun g f hf => by
        rw [← one_mul g, ← mul_assoc, ← sub_mul, mul_one, mul_comm, mul_comm f] <;>
          exact mul_lim_zero_right _ (Setoid.symm (CauSeq.inv_mul_cancel _))
      have h₂ :
        LimZero
          (inv f hf - const abv (lim f)⁻¹ -
            (const abv (lim f) - f) * (inv f hf * const abv (lim f)⁻¹)) :=
        by
        rw [sub_mul, ← sub_add, sub_sub, sub_add_eq_sub_sub, sub_right_comm, sub_add] <;>
          exact
            show
              lim_zero
                (inv f hf - const abv (limUnder f) * (inv f hf * const abv (limUnder f)⁻¹) -
                  (const abv (limUnder f)⁻¹ - f * (inv f hf * const abv (limUnder f)⁻¹)))
              from
              sub_lim_zero (by rw [← mul_assoc, mul_right_comm, const_inv hl] <;> exact h₁ _ _ _)
                (by rw [← mul_assoc] <;> exact h₁ _ _ _)
      (limZero_congr h₂).mpr <| mul_limZero_left _ (Setoid.symm (equiv_lim f))
#align cau_seq.lim_inv CauSeq.lim_inv

end

section

variable [IsComplete α abs]

/- warning: cau_seq.lim_le -> CauSeq.lim_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : CauSeq.IsComplete.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))] {f : CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))} {x : α}, (LE.le.{u1} (CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (CauSeq.hasLe.{u1} α _inst_1) f (CauSeq.const.{u1, u1} α α _inst_1 (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) x)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (StrictOrderedRing.toOrderedAddCommGroup.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))) (CauSeq.lim.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) _inst_2 f) x)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : CauSeq.IsComplete.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))] {f : CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))))} {x : α}, (LE.le.{u1} (CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))))) (CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToHasSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.{u1} α _inst_1) f (CauSeq.const.{u1, u1} α α _inst_1 (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) x)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))) (CauSeq.lim.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) _inst_2 f) x)
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_le CauSeq.lim_leₓ'. -/
theorem lim_le {f : CauSeq α abs} {x : α} (h : f ≤ CauSeq.const abs x) : lim f ≤ x :=
  CauSeq.const_le.1 <| CauSeq.le_of_eq_of_le (Setoid.symm (equiv_lim f)) h
#align cau_seq.lim_le CauSeq.lim_le

/- warning: cau_seq.le_lim -> CauSeq.le_lim is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : CauSeq.IsComplete.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))] {f : CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))} {x : α}, (LE.le.{u1} (CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (CauSeq.hasLe.{u1} α _inst_1) (CauSeq.const.{u1, u1} α α _inst_1 (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) x) f) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (StrictOrderedRing.toOrderedAddCommGroup.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))) x (CauSeq.lim.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) _inst_2 f))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : CauSeq.IsComplete.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))] {f : CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))))} {x : α}, (LE.le.{u1} (CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))))) (CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToHasSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.{u1} α _inst_1) (CauSeq.const.{u1, u1} α α _inst_1 (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) x) f) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))) x (CauSeq.lim.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) _inst_2 f))
Case conversion may be inaccurate. Consider using '#align cau_seq.le_lim CauSeq.le_limₓ'. -/
theorem le_lim {f : CauSeq α abs} {x : α} (h : CauSeq.const abs x ≤ f) : x ≤ lim f :=
  CauSeq.const_le.1 <| CauSeq.le_of_le_of_eq h (equiv_lim f)
#align cau_seq.le_lim CauSeq.le_lim

/- warning: cau_seq.lt_lim -> CauSeq.lt_lim is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : CauSeq.IsComplete.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))] {f : CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))} {x : α}, (LT.lt.{u1} (CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (CauSeq.hasLt.{u1} α _inst_1) (CauSeq.const.{u1, u1} α α _inst_1 (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) x) f) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (StrictOrderedRing.toOrderedAddCommGroup.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))) x (CauSeq.lim.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) _inst_2 f))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : CauSeq.IsComplete.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))] {f : CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))))} {x : α}, (LT.lt.{u1} (CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))))) (CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToHasSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.{u1} α _inst_1) (CauSeq.const.{u1, u1} α α _inst_1 (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) x) f) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))) x (CauSeq.lim.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) _inst_2 f))
Case conversion may be inaccurate. Consider using '#align cau_seq.lt_lim CauSeq.lt_limₓ'. -/
theorem lt_lim {f : CauSeq α abs} {x : α} (h : CauSeq.const abs x < f) : x < lim f :=
  CauSeq.const_lt.1 <| CauSeq.lt_of_lt_of_eq h (equiv_lim f)
#align cau_seq.lt_lim CauSeq.lt_lim

/- warning: cau_seq.lim_lt -> CauSeq.lim_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : CauSeq.IsComplete.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))] {f : CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))} {x : α}, (LT.lt.{u1} (CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (CauSeq.hasLt.{u1} α _inst_1) f (CauSeq.const.{u1, u1} α α _inst_1 (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) x)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (StrictOrderedRing.toOrderedAddCommGroup.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))) (CauSeq.lim.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) _inst_2 f) x)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : CauSeq.IsComplete.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))] {f : CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))))} {x : α}, (LT.lt.{u1} (CauSeq.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))))))) (CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToHasSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.{u1} α _inst_1) f (CauSeq.const.{u1, u1} α α _inst_1 (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) x)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))) (CauSeq.lim.{u1, u1} α _inst_1 α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (Ring.toNeg.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))))) (IsAbsoluteValue.abs_isAbsoluteValue.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))) _inst_2 f) x)
Case conversion may be inaccurate. Consider using '#align cau_seq.lim_lt CauSeq.lim_ltₓ'. -/
theorem lim_lt {f : CauSeq α abs} {x : α} (h : f < CauSeq.const abs x) : lim f < x :=
  CauSeq.const_lt.1 <| CauSeq.lt_of_eq_of_lt (Setoid.symm (equiv_lim f)) h
#align cau_seq.lim_lt CauSeq.lim_lt

end

end CauSeq

