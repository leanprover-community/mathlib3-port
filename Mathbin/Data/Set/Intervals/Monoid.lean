/-
Copyright (c) 2020 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov, Patrick Massot

! This file was ported from Lean 3 source module data.set.intervals.monoid
! leanprover-community/mathlib commit 247a102b14f3cebfee126293341af5f6bed00237
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Set.Intervals.Basic
import Mathbin.Data.Set.Function
import Mathbin.Algebra.Order.Monoid.Cancel.Defs
import Mathbin.Algebra.Order.Monoid.Canonical.Defs
import Mathbin.Algebra.Group.Basic

/-!
# Images of intervals under `(+ d)`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The lemmas in this file state that addition maps intervals bijectively. The typeclass
`has_exists_add_of_le` is defined specifically to make them work when combined with
`ordered_cancel_add_comm_monoid`; the lemmas below therefore apply to all
`ordered_add_comm_group`, but also to `ℕ` and `ℝ≥0`, which are not groups.
-/


namespace Set

variable {M : Type _} [OrderedCancelAddCommMonoid M] [ExistsAddOfLE M] (a b c d : M)

/- warning: set.Ici_add_bij -> Set.Ici_add_bij is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d))
Case conversion may be inaccurate. Consider using '#align set.Ici_add_bij Set.Ici_add_bijₓ'. -/
theorem Ici_add_bij : BijOn (· + d) (Ici a) (Ici (a + d)) :=
  by
  refine'
    ⟨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).InjOn _, fun _ h => _⟩
  obtain ⟨c, rfl⟩ := exists_add_of_le (mem_Ici.mp h)
  rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h
  exact ⟨a + c, h, by rw [add_right_comm]⟩
#align set.Ici_add_bij Set.Ici_add_bij

/- warning: set.Ioi_add_bij -> Set.Ioi_add_bij is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d))
Case conversion may be inaccurate. Consider using '#align set.Ioi_add_bij Set.Ioi_add_bijₓ'. -/
theorem Ioi_add_bij : BijOn (· + d) (Ioi a) (Ioi (a + d)) :=
  by
  refine'
    ⟨fun x h => add_lt_add_right (mem_Ioi.mp h) _, fun _ _ _ _ h => add_right_cancel h, fun _ h =>
      _⟩
  obtain ⟨c, rfl⟩ := exists_add_of_le (mem_Ioi.mp h).le
  rw [mem_Ioi, add_right_comm, add_lt_add_iff_right] at h
  exact ⟨a + c, h, by rw [add_right_comm]⟩
#align set.Ioi_add_bij Set.Ioi_add_bij

/- warning: set.Icc_add_bij -> Set.Icc_add_bij is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a b) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b d))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a b) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b d))
Case conversion may be inaccurate. Consider using '#align set.Icc_add_bij Set.Icc_add_bijₓ'. -/
theorem Icc_add_bij : BijOn (· + d) (Icc a b) (Icc (a + d) (b + d)) :=
  by
  rw [← Ici_inter_Iic, ← Ici_inter_Iic]
  exact
    (Ici_add_bij a d).inter_maps_to (fun x hx => add_le_add_right hx _) fun x hx =>
      le_of_add_le_add_right hx.2
#align set.Icc_add_bij Set.Icc_add_bij

/- warning: set.Ioo_add_bij -> Set.Ioo_add_bij is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a b) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b d))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a b) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b d))
Case conversion may be inaccurate. Consider using '#align set.Ioo_add_bij Set.Ioo_add_bijₓ'. -/
theorem Ioo_add_bij : BijOn (· + d) (Ioo a b) (Ioo (a + d) (b + d)) :=
  by
  rw [← Ioi_inter_Iio, ← Ioi_inter_Iio]
  exact
    (Ioi_add_bij a d).inter_maps_to (fun x hx => add_lt_add_right hx _) fun x hx =>
      lt_of_add_lt_add_right hx.2
#align set.Ioo_add_bij Set.Ioo_add_bij

/- warning: set.Ioc_add_bij -> Set.Ioc_add_bij is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a b) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b d))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a b) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b d))
Case conversion may be inaccurate. Consider using '#align set.Ioc_add_bij Set.Ioc_add_bijₓ'. -/
theorem Ioc_add_bij : BijOn (· + d) (Ioc a b) (Ioc (a + d) (b + d)) :=
  by
  rw [← Ioi_inter_Iic, ← Ioi_inter_Iic]
  exact
    (Ioi_add_bij a d).inter_maps_to (fun x hx => add_le_add_right hx _) fun x hx =>
      le_of_add_le_add_right hx.2
#align set.Ioc_add_bij Set.Ioc_add_bij

/- warning: set.Ico_add_bij -> Set.Ico_add_bij is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a b) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b d))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (d : M), Set.BijOn.{u1, u1} M M (fun (_x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) _x d) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) a b) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a d) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b d))
Case conversion may be inaccurate. Consider using '#align set.Ico_add_bij Set.Ico_add_bijₓ'. -/
theorem Ico_add_bij : BijOn (· + d) (Ico a b) (Ico (a + d) (b + d)) :=
  by
  rw [← Ici_inter_Iio, ← Ici_inter_Iio]
  exact
    (Ici_add_bij a d).inter_maps_to (fun x hx => add_lt_add_right hx _) fun x hx =>
      lt_of_add_lt_add_right hx.2
#align set.Ico_add_bij Set.Ico_add_bij

/-!
### Images under `x ↦ x + a`
-/


/- warning: set.image_add_const_Ici -> Set.image_add_const_Ici is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b)) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b)) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a))
Case conversion may be inaccurate. Consider using '#align set.image_add_const_Ici Set.image_add_const_Iciₓ'. -/
@[simp]
theorem image_add_const_Ici : (fun x => x + a) '' Ici b = Ici (b + a) :=
  (Ici_add_bij _ _).image_eq
#align set.image_add_const_Ici Set.image_add_const_Ici

/- warning: set.image_add_const_Ioi -> Set.image_add_const_Ioi is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b)) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b)) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a))
Case conversion may be inaccurate. Consider using '#align set.image_add_const_Ioi Set.image_add_const_Ioiₓ'. -/
@[simp]
theorem image_add_const_Ioi : (fun x => x + a) '' Ioi b = Ioi (b + a) :=
  (Ioi_add_bij _ _).image_eq
#align set.image_add_const_Ioi Set.image_add_const_Ioi

/- warning: set.image_add_const_Icc -> Set.image_add_const_Icc is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) c a))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) c a))
Case conversion may be inaccurate. Consider using '#align set.image_add_const_Icc Set.image_add_const_Iccₓ'. -/
@[simp]
theorem image_add_const_Icc : (fun x => x + a) '' Icc b c = Icc (b + a) (c + a) :=
  (Icc_add_bij _ _ _).image_eq
#align set.image_add_const_Icc Set.image_add_const_Icc

/- warning: set.image_add_const_Ico -> Set.image_add_const_Ico is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) c a))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) c a))
Case conversion may be inaccurate. Consider using '#align set.image_add_const_Ico Set.image_add_const_Icoₓ'. -/
@[simp]
theorem image_add_const_Ico : (fun x => x + a) '' Ico b c = Ico (b + a) (c + a) :=
  (Ico_add_bij _ _ _).image_eq
#align set.image_add_const_Ico Set.image_add_const_Ico

/- warning: set.image_add_const_Ioc -> Set.image_add_const_Ioc is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) c a))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) c a))
Case conversion may be inaccurate. Consider using '#align set.image_add_const_Ioc Set.image_add_const_Iocₓ'. -/
@[simp]
theorem image_add_const_Ioc : (fun x => x + a) '' Ioc b c = Ioc (b + a) (c + a) :=
  (Ioc_add_bij _ _ _).image_eq
#align set.image_add_const_Ioc Set.image_add_const_Ioc

/- warning: set.image_add_const_Ioo -> Set.image_add_const_Ioo is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) c a))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) x a) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) b a) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) c a))
Case conversion may be inaccurate. Consider using '#align set.image_add_const_Ioo Set.image_add_const_Iooₓ'. -/
@[simp]
theorem image_add_const_Ioo : (fun x => x + a) '' Ioo b c = Ioo (b + a) (c + a) :=
  (Ioo_add_bij _ _ _).image_eq
#align set.image_add_const_Ioo Set.image_add_const_Ioo

/-!
### Images under `x ↦ a + x`
-/


/- warning: set.image_const_add_Ici -> Set.image_const_add_Ici is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b)) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b)) (Set.Ici.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b))
Case conversion may be inaccurate. Consider using '#align set.image_const_add_Ici Set.image_const_add_Iciₓ'. -/
@[simp]
theorem image_const_add_Ici : (fun x => a + x) '' Ici b = Ici (a + b) := by
  simp only [add_comm a, image_add_const_Ici]
#align set.image_const_add_Ici Set.image_const_add_Ici

/- warning: set.image_const_add_Ioi -> Set.image_const_add_Ioi is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b)) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b)) (Set.Ioi.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b))
Case conversion may be inaccurate. Consider using '#align set.image_const_add_Ioi Set.image_const_add_Ioiₓ'. -/
@[simp]
theorem image_const_add_Ioi : (fun x => a + x) '' Ioi b = Ioi (a + b) := by
  simp only [add_comm a, image_add_const_Ioi]
#align set.image_const_add_Ioi Set.image_const_add_Ioi

/- warning: set.image_const_add_Icc -> Set.image_const_add_Icc is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a c))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Icc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a c))
Case conversion may be inaccurate. Consider using '#align set.image_const_add_Icc Set.image_const_add_Iccₓ'. -/
@[simp]
theorem image_const_add_Icc : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) := by
  simp only [add_comm a, image_add_const_Icc]
#align set.image_const_add_Icc Set.image_const_add_Icc

/- warning: set.image_const_add_Ico -> Set.image_const_add_Ico is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a c))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ico.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a c))
Case conversion may be inaccurate. Consider using '#align set.image_const_add_Ico Set.image_const_add_Icoₓ'. -/
@[simp]
theorem image_const_add_Ico : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c) := by
  simp only [add_comm a, image_add_const_Ico]
#align set.image_const_add_Ico Set.image_const_add_Ico

/- warning: set.image_const_add_Ioc -> Set.image_const_add_Ioc is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a c))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ioc.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a c))
Case conversion may be inaccurate. Consider using '#align set.image_const_add_Ioc Set.image_const_add_Iocₓ'. -/
@[simp]
theorem image_const_add_Ioc : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c) := by
  simp only [add_comm a, image_add_const_Ioc]
#align set.image_const_add_Ioc Set.image_const_add_Ioc

/- warning: set.image_const_add_Ioo -> Set.image_const_add_Ioo is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a c))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : OrderedCancelAddCommMonoid.{u1} M] [_inst_2 : ExistsAddOfLE.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1)))))) (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)))] (a : M) (b : M) (c : M), Eq.{succ u1} (Set.{u1} M) (Set.image.{u1, u1} M M (fun (x : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a x) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) b c)) (Set.Ioo.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedCancelAddCommMonoid.toPartialOrder.{u1} M _inst_1)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a b) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (CancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M _inst_1))))))) a c))
Case conversion may be inaccurate. Consider using '#align set.image_const_add_Ioo Set.image_const_add_Iooₓ'. -/
@[simp]
theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) := by
  simp only [add_comm a, image_add_const_Ioo]
#align set.image_const_add_Ioo Set.image_const_add_Ioo

end Set

