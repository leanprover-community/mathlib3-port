/-
Copyright (c) 2021 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies

! This file was ported from Lean 3 source module data.sum.order
! leanprover-community/mathlib commit 1e05171a5e8cf18d98d9cf7b207540acb044acae
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Order.Hom.Basic

/-!
# Orders on a sum type

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> https://github.com/leanprover-community/mathlib4/pull/880
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the disjoint sum and the linear (aka lexicographic) sum of two orders and provides
relation instances for `sum.lift_rel` and `sum.lex`.

We declare the disjoint sum of orders as the default set of instances. The linear order goes on a
type synonym.

## Main declarations

* `sum.has_le`, `sum.has_lt`: Disjoint sum of orders.
* `sum.lex.has_le`, `sum.lex.has_lt`: Lexicographic/linear sum of orders.

## Notation

* `α ⊕ₗ β`:  The linear sum of `α` and `β`.
-/


variable {α β γ δ : Type _}

namespace Sum

/-! ### Unbundled relation classes -/


section LiftRel

variable (r : α → α → Prop) (s : β → β → Prop)

/- warning: sum.lift_rel.refl -> Sum.LiftRel.refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (r : α -> α -> Prop) (s : β -> β -> Prop) [_inst_1 : IsRefl.{u1} α r] [_inst_2 : IsRefl.{u2} β s] (x : Sum.{u1, u2} α β), Sum.LiftRel.{u1, u2, u1, u2} α β α β r s x x
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} (r : α -> α -> Prop) (s : β -> β -> Prop) [_inst_1 : IsRefl.{u2} α r] [_inst_2 : IsRefl.{u1} β s] (x : Sum.{u2, u1} α β), Sum.LiftRel.{u2, u1, u2, u1} α β α β r s x x
Case conversion may be inaccurate. Consider using '#align sum.lift_rel.refl Sum.LiftRel.reflₓ'. -/
@[refl]
theorem LiftRel.refl [IsRefl α r] [IsRefl β s] : ∀ x, LiftRel r s x x
  | inl a => LiftRel.inl (refl _)
  | inr a => LiftRel.inr (refl _)
#align sum.lift_rel.refl Sum.LiftRel.refl

instance [IsRefl α r] [IsRefl β s] : IsRefl (Sum α β) (LiftRel r s) :=
  ⟨LiftRel.refl _ _⟩

instance [IsIrrefl α r] [IsIrrefl β s] : IsIrrefl (Sum α β) (LiftRel r s) :=
  ⟨by rintro _ (⟨h⟩ | ⟨h⟩) <;> exact irrefl _ h⟩

/- warning: sum.lift_rel.trans -> Sum.LiftRel.trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (r : α -> α -> Prop) (s : β -> β -> Prop) [_inst_1 : IsTrans.{u1} α r] [_inst_2 : IsTrans.{u2} β s] {a : Sum.{u1, u2} α β} {b : Sum.{u1, u2} α β} {c : Sum.{u1, u2} α β}, (Sum.LiftRel.{u1, u2, u1, u2} α β α β r s a b) -> (Sum.LiftRel.{u1, u2, u1, u2} α β α β r s b c) -> (Sum.LiftRel.{u1, u2, u1, u2} α β α β r s a c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} (r : α -> α -> Prop) (s : β -> β -> Prop) [_inst_1 : IsTrans.{u2} α r] [_inst_2 : IsTrans.{u1} β s] {a : Sum.{u2, u1} α β} {b : Sum.{u2, u1} α β} {c : Sum.{u2, u1} α β}, (Sum.LiftRel.{u2, u1, u2, u1} α β α β r s a b) -> (Sum.LiftRel.{u2, u1, u2, u1} α β α β r s b c) -> (Sum.LiftRel.{u2, u1, u2, u1} α β α β r s a c)
Case conversion may be inaccurate. Consider using '#align sum.lift_rel.trans Sum.LiftRel.transₓ'. -/
@[trans]
theorem LiftRel.trans [IsTrans α r] [IsTrans β s] :
    ∀ {a b c}, LiftRel r s a b → LiftRel r s b c → LiftRel r s a c
  | _, _, _, lift_rel.inl hab, lift_rel.inl hbc => lift_rel.inl <| trans hab hbc
  | _, _, _, lift_rel.inr hab, lift_rel.inr hbc => lift_rel.inr <| trans hab hbc
#align sum.lift_rel.trans Sum.LiftRel.trans

instance [IsTrans α r] [IsTrans β s] : IsTrans (Sum α β) (LiftRel r s) :=
  ⟨fun _ _ _ => LiftRel.trans _ _⟩

instance [IsAntisymm α r] [IsAntisymm β s] : IsAntisymm (Sum α β) (LiftRel r s) :=
  ⟨by rintro _ _ (⟨hab⟩ | ⟨hab⟩) (⟨hba⟩ | ⟨hba⟩) <;> rw [antisymm hab hba]⟩

end LiftRel

section Lex

variable (r : α → α → Prop) (s : β → β → Prop)

instance [IsRefl α r] [IsRefl β s] : IsRefl (Sum α β) (Lex r s) :=
  ⟨by
    rintro (a | a)
    exacts[lex.inl (refl _), lex.inr (refl _)]⟩

instance [IsIrrefl α r] [IsIrrefl β s] : IsIrrefl (Sum α β) (Lex r s) :=
  ⟨by rintro _ (⟨h⟩ | ⟨h⟩) <;> exact irrefl _ h⟩

instance [IsTrans α r] [IsTrans β s] : IsTrans (Sum α β) (Lex r s) :=
  ⟨by
    rintro _ _ _ (⟨hab⟩ | ⟨hab⟩) (⟨hbc⟩ | ⟨hbc⟩)
    exacts[lex.inl (trans hab hbc), lex.sep _ _, lex.inr (trans hab hbc), lex.sep _ _]⟩

instance [IsAntisymm α r] [IsAntisymm β s] : IsAntisymm (Sum α β) (Lex r s) :=
  ⟨by rintro _ _ (⟨hab⟩ | ⟨hab⟩) (⟨hba⟩ | ⟨hba⟩) <;> rw [antisymm hab hba]⟩

instance [IsTotal α r] [IsTotal β s] : IsTotal (Sum α β) (Lex r s) :=
  ⟨fun a b =>
    match a, b with
    | inl a, inl b => (total_of r a b).imp Lex.inl Lex.inl
    | inl a, inr b => Or.inl (Lex.sep _ _)
    | inr a, inl b => Or.inr (Lex.sep _ _)
    | inr a, inr b => (total_of s a b).imp Lex.inr Lex.inr⟩

instance [IsTrichotomous α r] [IsTrichotomous β s] : IsTrichotomous (Sum α β) (Lex r s) :=
  ⟨fun a b =>
    match a, b with
    | inl a, inl b => (trichotomous_of r a b).imp3 Lex.inl (congr_arg _) Lex.inl
    | inl a, inr b => Or.inl (Lex.sep _ _)
    | inr a, inl b => Or.inr (Or.inr <| Lex.sep _ _)
    | inr a, inr b => (trichotomous_of s a b).imp3 Lex.inr (congr_arg _) Lex.inr⟩

instance [IsWellOrder α r] [IsWellOrder β s] : IsWellOrder (Sum α β) (Sum.Lex r s)
    where wf := Sum.lex_wf IsWellFounded.wf IsWellFounded.wf

end Lex

/-! ### Disjoint sum of two orders -/


section Disjoint

instance [LE α] [LE β] : LE (Sum α β) :=
  ⟨LiftRel (· ≤ ·) (· ≤ ·)⟩

instance [LT α] [LT β] : LT (Sum α β) :=
  ⟨LiftRel (· < ·) (· < ·)⟩

/- warning: sum.le_def -> Sum.le_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : Sum.{u1, u2} α β} {b : Sum.{u1, u2} α β}, Iff (LE.le.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) a b) (Sum.LiftRel.{u1, u2, u1, u2} α β α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2) a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : Sum.{u2, u1} α β} {b : Sum.{u2, u1} α β}, Iff (LE.le.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2) a b) (Sum.LiftRel.{u2, u1, u2, u1} α β α β (fun (x._@.Mathlib.Data.Sum.Order._hyg.1590 : α) (x._@.Mathlib.Data.Sum.Order._hyg.1592 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Data.Sum.Order._hyg.1590 x._@.Mathlib.Data.Sum.Order._hyg.1592) (fun (x._@.Mathlib.Data.Sum.Order._hyg.1605 : β) (x._@.Mathlib.Data.Sum.Order._hyg.1607 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Data.Sum.Order._hyg.1605 x._@.Mathlib.Data.Sum.Order._hyg.1607) a b)
Case conversion may be inaccurate. Consider using '#align sum.le_def Sum.le_defₓ'. -/
theorem le_def [LE α] [LE β] {a b : Sum α β} : a ≤ b ↔ LiftRel (· ≤ ·) (· ≤ ·) a b :=
  Iff.rfl
#align sum.le_def Sum.le_def

/- warning: sum.lt_def -> Sum.lt_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : Sum.{u1, u2} α β} {b : Sum.{u1, u2} α β}, Iff (LT.lt.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLt.{u1, u2} α β _inst_1 _inst_2) a b) (Sum.LiftRel.{u1, u2, u1, u2} α β α β (LT.lt.{u1} α _inst_1) (LT.lt.{u2} β _inst_2) a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : Sum.{u2, u1} α β} {b : Sum.{u2, u1} α β}, Iff (LT.lt.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLTSum.{u2, u1} α β _inst_1 _inst_2) a b) (Sum.LiftRel.{u2, u1, u2, u1} α β α β (fun (x._@.Mathlib.Data.Sum.Order._hyg.1650 : α) (x._@.Mathlib.Data.Sum.Order._hyg.1652 : α) => LT.lt.{u2} α _inst_1 x._@.Mathlib.Data.Sum.Order._hyg.1650 x._@.Mathlib.Data.Sum.Order._hyg.1652) (fun (x._@.Mathlib.Data.Sum.Order._hyg.1665 : β) (x._@.Mathlib.Data.Sum.Order._hyg.1667 : β) => LT.lt.{u1} β _inst_2 x._@.Mathlib.Data.Sum.Order._hyg.1665 x._@.Mathlib.Data.Sum.Order._hyg.1667) a b)
Case conversion may be inaccurate. Consider using '#align sum.lt_def Sum.lt_defₓ'. -/
theorem lt_def [LT α] [LT β] {a b : Sum α β} : a < b ↔ LiftRel (· < ·) (· < ·) a b :=
  Iff.rfl
#align sum.lt_def Sum.lt_def

/- warning: sum.inl_le_inl_iff -> Sum.inl_le_inl_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : α} {b : α}, Iff (LE.le.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) (Sum.inl.{u1, u2} α β a) (Sum.inl.{u1, u2} α β b)) (LE.le.{u1} α _inst_1 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : α} {b : α}, Iff (LE.le.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2) (Sum.inl.{u2, u1} α β a) (Sum.inl.{u2, u1} α β b)) (LE.le.{u2} α _inst_1 a b)
Case conversion may be inaccurate. Consider using '#align sum.inl_le_inl_iff Sum.inl_le_inl_iffₓ'. -/
@[simp]
theorem inl_le_inl_iff [LE α] [LE β] {a b : α} : (inl a : Sum α β) ≤ inl b ↔ a ≤ b :=
  lift_rel_inl_inl
#align sum.inl_le_inl_iff Sum.inl_le_inl_iff

/- warning: sum.inr_le_inr_iff -> Sum.inr_le_inr_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : β} {b : β}, Iff (LE.le.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) (Sum.inr.{u1, u2} α β a) (Sum.inr.{u1, u2} α β b)) (LE.le.{u2} β _inst_2 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : β} {b : β}, Iff (LE.le.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2) (Sum.inr.{u2, u1} α β a) (Sum.inr.{u2, u1} α β b)) (LE.le.{u1} β _inst_2 a b)
Case conversion may be inaccurate. Consider using '#align sum.inr_le_inr_iff Sum.inr_le_inr_iffₓ'. -/
@[simp]
theorem inr_le_inr_iff [LE α] [LE β] {a b : β} : (inr a : Sum α β) ≤ inr b ↔ a ≤ b :=
  lift_rel_inr_inr
#align sum.inr_le_inr_iff Sum.inr_le_inr_iff

/- warning: sum.inl_lt_inl_iff -> Sum.inl_lt_inl_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : α} {b : α}, Iff (LT.lt.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLt.{u1, u2} α β _inst_1 _inst_2) (Sum.inl.{u1, u2} α β a) (Sum.inl.{u1, u2} α β b)) (LT.lt.{u1} α _inst_1 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : α} {b : α}, Iff (LT.lt.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLTSum.{u2, u1} α β _inst_1 _inst_2) (Sum.inl.{u2, u1} α β a) (Sum.inl.{u2, u1} α β b)) (LT.lt.{u2} α _inst_1 a b)
Case conversion may be inaccurate. Consider using '#align sum.inl_lt_inl_iff Sum.inl_lt_inl_iffₓ'. -/
@[simp]
theorem inl_lt_inl_iff [LT α] [LT β] {a b : α} : (inl a : Sum α β) < inl b ↔ a < b :=
  lift_rel_inl_inl
#align sum.inl_lt_inl_iff Sum.inl_lt_inl_iff

/- warning: sum.inr_lt_inr_iff -> Sum.inr_lt_inr_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : β} {b : β}, Iff (LT.lt.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLt.{u1, u2} α β _inst_1 _inst_2) (Sum.inr.{u1, u2} α β a) (Sum.inr.{u1, u2} α β b)) (LT.lt.{u2} β _inst_2 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : β} {b : β}, Iff (LT.lt.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLTSum.{u2, u1} α β _inst_1 _inst_2) (Sum.inr.{u2, u1} α β a) (Sum.inr.{u2, u1} α β b)) (LT.lt.{u1} β _inst_2 a b)
Case conversion may be inaccurate. Consider using '#align sum.inr_lt_inr_iff Sum.inr_lt_inr_iffₓ'. -/
@[simp]
theorem inr_lt_inr_iff [LT α] [LT β] {a b : β} : (inr a : Sum α β) < inr b ↔ a < b :=
  lift_rel_inr_inr
#align sum.inr_lt_inr_iff Sum.inr_lt_inr_iff

/- warning: sum.not_inl_le_inr -> Sum.not_inl_le_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : α} {b : β}, Not (LE.le.{max u2 u1} (Sum.{u2, u1} β α) (Sum.hasLe.{u2, u1} β α _inst_2 _inst_1) (Sum.inl.{u2, u1} β α b) (Sum.inr.{u2, u1} β α a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : α} {b : β}, Not (LE.le.{max u2 u1} (Sum.{u1, u2} β α) (Sum.instLESum.{u1, u2} β α _inst_2 _inst_1) (Sum.inl.{u1, u2} β α b) (Sum.inr.{u1, u2} β α a))
Case conversion may be inaccurate. Consider using '#align sum.not_inl_le_inr Sum.not_inl_le_inrₓ'. -/
@[simp]
theorem not_inl_le_inr [LE α] [LE β] {a : α} {b : β} : ¬inl b ≤ inr a :=
  not_lift_rel_inl_inr
#align sum.not_inl_le_inr Sum.not_inl_le_inr

/- warning: sum.not_inl_lt_inr -> Sum.not_inl_lt_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : α} {b : β}, Not (LT.lt.{max u2 u1} (Sum.{u2, u1} β α) (Sum.hasLt.{u2, u1} β α _inst_2 _inst_1) (Sum.inl.{u2, u1} β α b) (Sum.inr.{u2, u1} β α a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : α} {b : β}, Not (LT.lt.{max u2 u1} (Sum.{u1, u2} β α) (Sum.instLTSum.{u1, u2} β α _inst_2 _inst_1) (Sum.inl.{u1, u2} β α b) (Sum.inr.{u1, u2} β α a))
Case conversion may be inaccurate. Consider using '#align sum.not_inl_lt_inr Sum.not_inl_lt_inrₓ'. -/
@[simp]
theorem not_inl_lt_inr [LT α] [LT β] {a : α} {b : β} : ¬inl b < inr a :=
  not_lift_rel_inl_inr
#align sum.not_inl_lt_inr Sum.not_inl_lt_inr

/- warning: sum.not_inr_le_inl -> Sum.not_inr_le_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : α} {b : β}, Not (LE.le.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) (Sum.inr.{u1, u2} α β b) (Sum.inl.{u1, u2} α β a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : α} {b : β}, Not (LE.le.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2) (Sum.inr.{u2, u1} α β b) (Sum.inl.{u2, u1} α β a))
Case conversion may be inaccurate. Consider using '#align sum.not_inr_le_inl Sum.not_inr_le_inlₓ'. -/
@[simp]
theorem not_inr_le_inl [LE α] [LE β] {a : α} {b : β} : ¬inr b ≤ inl a :=
  not_lift_rel_inr_inl
#align sum.not_inr_le_inl Sum.not_inr_le_inl

/- warning: sum.not_inr_lt_inl -> Sum.not_inr_lt_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : α} {b : β}, Not (LT.lt.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLt.{u1, u2} α β _inst_1 _inst_2) (Sum.inr.{u1, u2} α β b) (Sum.inl.{u1, u2} α β a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : α} {b : β}, Not (LT.lt.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLTSum.{u2, u1} α β _inst_1 _inst_2) (Sum.inr.{u2, u1} α β b) (Sum.inl.{u2, u1} α β a))
Case conversion may be inaccurate. Consider using '#align sum.not_inr_lt_inl Sum.not_inr_lt_inlₓ'. -/
@[simp]
theorem not_inr_lt_inl [LT α] [LT β] {a : α} {b : β} : ¬inr b < inl a :=
  not_lift_rel_inr_inl
#align sum.not_inr_lt_inl Sum.not_inr_lt_inl

section Preorder

variable [Preorder α] [Preorder β]

instance : Preorder (Sum α β) :=
  { Sum.hasLe, Sum.hasLt with
    le_refl := fun _ => refl _
    le_trans := fun _ _ _ => trans
    lt_iff_le_not_le := fun a b =>
      by
      refine' ⟨fun hab => ⟨hab.mono (fun _ _ => le_of_lt) fun _ _ => le_of_lt, _⟩, _⟩
      · rintro (⟨hba⟩ | ⟨hba⟩)
        · exact hba.not_lt (inl_lt_inl_iff.1 hab)
        · exact hba.not_lt (inr_lt_inr_iff.1 hab)
      · rintro ⟨⟨hab⟩ | ⟨hab⟩, hba⟩
        · exact lift_rel.inl (hab.lt_of_not_le fun h => hba <| lift_rel.inl h)
        · exact lift_rel.inr (hab.lt_of_not_le fun h => hba <| lift_rel.inr h) }

/- warning: sum.inl_mono -> Sum.inl_mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], Monotone.{u1, max u1 u2} α (Sum.{u1, u2} α β) _inst_1 (Sum.preorder.{u1, u2} α β _inst_1 _inst_2) (Sum.inl.{u1, u2} α β)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β], Monotone.{u2, max u2 u1} α (Sum.{u2, u1} α β) _inst_1 (Sum.instPreorderSum.{u2, u1} α β _inst_1 _inst_2) (Sum.inl.{u2, u1} α β)
Case conversion may be inaccurate. Consider using '#align sum.inl_mono Sum.inl_monoₓ'. -/
theorem inl_mono : Monotone (inl : α → Sum α β) := fun a b => LiftRel.inl
#align sum.inl_mono Sum.inl_mono

/- warning: sum.inr_mono -> Sum.inr_mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], Monotone.{u2, max u1 u2} β (Sum.{u1, u2} α β) _inst_2 (Sum.preorder.{u1, u2} α β _inst_1 _inst_2) (Sum.inr.{u1, u2} α β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], Monotone.{u2, max u1 u2} β (Sum.{u1, u2} α β) _inst_2 (Sum.instPreorderSum.{u1, u2} α β _inst_1 _inst_2) (Sum.inr.{u1, u2} α β)
Case conversion may be inaccurate. Consider using '#align sum.inr_mono Sum.inr_monoₓ'. -/
theorem inr_mono : Monotone (inr : β → Sum α β) := fun a b => LiftRel.inr
#align sum.inr_mono Sum.inr_mono

/- warning: sum.inl_strict_mono -> Sum.inl_strictMono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], StrictMono.{u1, max u1 u2} α (Sum.{u1, u2} α β) _inst_1 (Sum.preorder.{u1, u2} α β _inst_1 _inst_2) (Sum.inl.{u1, u2} α β)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β], StrictMono.{u2, max u2 u1} α (Sum.{u2, u1} α β) _inst_1 (Sum.instPreorderSum.{u2, u1} α β _inst_1 _inst_2) (Sum.inl.{u2, u1} α β)
Case conversion may be inaccurate. Consider using '#align sum.inl_strict_mono Sum.inl_strictMonoₓ'. -/
theorem inl_strictMono : StrictMono (inl : α → Sum α β) := fun a b => LiftRel.inl
#align sum.inl_strict_mono Sum.inl_strictMono

/- warning: sum.inr_strict_mono -> Sum.inr_strictMono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], StrictMono.{u2, max u1 u2} β (Sum.{u1, u2} α β) _inst_2 (Sum.preorder.{u1, u2} α β _inst_1 _inst_2) (Sum.inr.{u1, u2} α β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], StrictMono.{u2, max u1 u2} β (Sum.{u1, u2} α β) _inst_2 (Sum.instPreorderSum.{u1, u2} α β _inst_1 _inst_2) (Sum.inr.{u1, u2} α β)
Case conversion may be inaccurate. Consider using '#align sum.inr_strict_mono Sum.inr_strictMonoₓ'. -/
theorem inr_strictMono : StrictMono (inr : β → Sum α β) := fun a b => LiftRel.inr
#align sum.inr_strict_mono Sum.inr_strictMono

end Preorder

instance [PartialOrder α] [PartialOrder β] : PartialOrder (Sum α β) :=
  { Sum.preorder with le_antisymm := fun _ _ => antisymm }

#print Sum.noMinOrder /-
instance noMinOrder [LT α] [LT β] [NoMinOrder α] [NoMinOrder β] : NoMinOrder (Sum α β) :=
  ⟨fun a =>
    match a with
    | inl a =>
      let ⟨b, h⟩ := exists_lt a
      ⟨inl b, inl_lt_inl_iff.2 h⟩
    | inr a =>
      let ⟨b, h⟩ := exists_lt a
      ⟨inr b, inr_lt_inr_iff.2 h⟩⟩
#align sum.no_min_order Sum.noMinOrder
-/

#print Sum.noMaxOrder /-
instance noMaxOrder [LT α] [LT β] [NoMaxOrder α] [NoMaxOrder β] : NoMaxOrder (Sum α β) :=
  ⟨fun a =>
    match a with
    | inl a =>
      let ⟨b, h⟩ := exists_gt a
      ⟨inl b, inl_lt_inl_iff.2 h⟩
    | inr a =>
      let ⟨b, h⟩ := exists_gt a
      ⟨inr b, inr_lt_inr_iff.2 h⟩⟩
#align sum.no_max_order Sum.noMaxOrder
-/

/- warning: sum.no_min_order_iff -> Sum.noMinOrder_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β], Iff (NoMinOrder.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLt.{u1, u2} α β _inst_1 _inst_2)) (And (NoMinOrder.{u1} α _inst_1) (NoMinOrder.{u2} β _inst_2))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β], Iff (NoMinOrder.{max u1 u2} (Sum.{u2, u1} α β) (Sum.instLTSum.{u2, u1} α β _inst_1 _inst_2)) (And (NoMinOrder.{u2} α _inst_1) (NoMinOrder.{u1} β _inst_2))
Case conversion may be inaccurate. Consider using '#align sum.no_min_order_iff Sum.noMinOrder_iffₓ'. -/
@[simp]
theorem noMinOrder_iff [LT α] [LT β] : NoMinOrder (Sum α β) ↔ NoMinOrder α ∧ NoMinOrder β :=
  ⟨fun _ =>
    ⟨⟨fun a => by
        obtain ⟨b | b, h⟩ := exists_lt (inl a : Sum α β)
        · exact ⟨b, inl_lt_inl_iff.1 h⟩
        · exact (not_inr_lt_inl h).elim⟩,
      ⟨fun a => by
        obtain ⟨b | b, h⟩ := exists_lt (inr a : Sum α β)
        · exact (not_inl_lt_inr h).elim
        · exact ⟨b, inr_lt_inr_iff.1 h⟩⟩⟩,
    fun h => @Sum.noMinOrder _ _ _ _ h.1 h.2⟩
#align sum.no_min_order_iff Sum.noMinOrder_iff

/- warning: sum.no_max_order_iff -> Sum.noMaxOrder_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β], Iff (NoMaxOrder.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLt.{u1, u2} α β _inst_1 _inst_2)) (And (NoMaxOrder.{u1} α _inst_1) (NoMaxOrder.{u2} β _inst_2))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β], Iff (NoMaxOrder.{max u1 u2} (Sum.{u2, u1} α β) (Sum.instLTSum.{u2, u1} α β _inst_1 _inst_2)) (And (NoMaxOrder.{u2} α _inst_1) (NoMaxOrder.{u1} β _inst_2))
Case conversion may be inaccurate. Consider using '#align sum.no_max_order_iff Sum.noMaxOrder_iffₓ'. -/
@[simp]
theorem noMaxOrder_iff [LT α] [LT β] : NoMaxOrder (Sum α β) ↔ NoMaxOrder α ∧ NoMaxOrder β :=
  ⟨fun _ =>
    ⟨⟨fun a => by
        obtain ⟨b | b, h⟩ := exists_gt (inl a : Sum α β)
        · exact ⟨b, inl_lt_inl_iff.1 h⟩
        · exact (not_inl_lt_inr h).elim⟩,
      ⟨fun a => by
        obtain ⟨b | b, h⟩ := exists_gt (inr a : Sum α β)
        · exact (not_inr_lt_inl h).elim
        · exact ⟨b, inr_lt_inr_iff.1 h⟩⟩⟩,
    fun h => @Sum.noMaxOrder _ _ _ _ h.1 h.2⟩
#align sum.no_max_order_iff Sum.noMaxOrder_iff

#print Sum.denselyOrdered /-
instance denselyOrdered [LT α] [LT β] [DenselyOrdered α] [DenselyOrdered β] :
    DenselyOrdered (Sum α β) :=
  ⟨fun a b h =>
    match a, b, h with
    | inl a, inl b, lift_rel.inl h =>
      let ⟨c, ha, hb⟩ := exists_between h
      ⟨toLex (inl c), LiftRel.inl ha, LiftRel.inl hb⟩
    | inr a, inr b, lift_rel.inr h =>
      let ⟨c, ha, hb⟩ := exists_between h
      ⟨toLex (inr c), LiftRel.inr ha, LiftRel.inr hb⟩⟩
#align sum.densely_ordered Sum.denselyOrdered
-/

/- warning: sum.densely_ordered_iff -> Sum.denselyOrdered_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β], Iff (DenselyOrdered.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLt.{u1, u2} α β _inst_1 _inst_2)) (And (DenselyOrdered.{u1} α _inst_1) (DenselyOrdered.{u2} β _inst_2))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β], Iff (DenselyOrdered.{max u1 u2} (Sum.{u2, u1} α β) (Sum.instLTSum.{u2, u1} α β _inst_1 _inst_2)) (And (DenselyOrdered.{u2} α _inst_1) (DenselyOrdered.{u1} β _inst_2))
Case conversion may be inaccurate. Consider using '#align sum.densely_ordered_iff Sum.denselyOrdered_iffₓ'. -/
@[simp]
theorem denselyOrdered_iff [LT α] [LT β] :
    DenselyOrdered (Sum α β) ↔ DenselyOrdered α ∧ DenselyOrdered β :=
  ⟨fun _ =>
    ⟨⟨fun a b h =>
        by
        obtain ⟨c | c, ha, hb⟩ := @exists_between (Sum α β) _ _ _ _ (inl_lt_inl_iff.2 h)
        · exact ⟨c, inl_lt_inl_iff.1 ha, inl_lt_inl_iff.1 hb⟩
        · exact (not_inl_lt_inr ha).elim⟩,
      ⟨fun a b h =>
        by
        obtain ⟨c | c, ha, hb⟩ := @exists_between (Sum α β) _ _ _ _ (inr_lt_inr_iff.2 h)
        · exact (not_inl_lt_inr hb).elim
        · exact ⟨c, inr_lt_inr_iff.1 ha, inr_lt_inr_iff.1 hb⟩⟩⟩,
    fun h => @Sum.denselyOrdered _ _ _ _ h.1 h.2⟩
#align sum.densely_ordered_iff Sum.denselyOrdered_iff

/- warning: sum.swap_le_swap_iff -> Sum.swap_le_swap_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : Sum.{u1, u2} α β} {b : Sum.{u1, u2} α β}, Iff (LE.le.{max u2 u1} (Sum.{u2, u1} β α) (Sum.hasLe.{u2, u1} β α _inst_2 _inst_1) (Sum.swap.{u1, u2} α β a) (Sum.swap.{u1, u2} α β b)) (LE.le.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : Sum.{u2, u1} α β} {b : Sum.{u2, u1} α β}, Iff (LE.le.{max u2 u1} (Sum.{u1, u2} β α) (Sum.instLESum.{u1, u2} β α _inst_2 _inst_1) (Sum.swap.{u2, u1} α β a) (Sum.swap.{u2, u1} α β b)) (LE.le.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2) a b)
Case conversion may be inaccurate. Consider using '#align sum.swap_le_swap_iff Sum.swap_le_swap_iffₓ'. -/
@[simp]
theorem swap_le_swap_iff [LE α] [LE β] {a b : Sum α β} : a.swap ≤ b.swap ↔ a ≤ b :=
  lift_rel_swap_iff
#align sum.swap_le_swap_iff Sum.swap_le_swap_iff

/- warning: sum.swap_lt_swap_iff -> Sum.swap_lt_swap_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : Sum.{u1, u2} α β} {b : Sum.{u1, u2} α β}, Iff (LT.lt.{max u2 u1} (Sum.{u2, u1} β α) (Sum.hasLt.{u2, u1} β α _inst_2 _inst_1) (Sum.swap.{u1, u2} α β a) (Sum.swap.{u1, u2} α β b)) (LT.lt.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLt.{u1, u2} α β _inst_1 _inst_2) a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : Sum.{u2, u1} α β} {b : Sum.{u2, u1} α β}, Iff (LT.lt.{max u2 u1} (Sum.{u1, u2} β α) (Sum.instLTSum.{u1, u2} β α _inst_2 _inst_1) (Sum.swap.{u2, u1} α β a) (Sum.swap.{u2, u1} α β b)) (LT.lt.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLTSum.{u2, u1} α β _inst_1 _inst_2) a b)
Case conversion may be inaccurate. Consider using '#align sum.swap_lt_swap_iff Sum.swap_lt_swap_iffₓ'. -/
@[simp]
theorem swap_lt_swap_iff [LT α] [LT β] {a b : Sum α β} : a.swap < b.swap ↔ a < b :=
  lift_rel_swap_iff
#align sum.swap_lt_swap_iff Sum.swap_lt_swap_iff

end Disjoint

/-! ### Linear sum of two orders -/


namespace Lex

-- mathport name: «expr ⊕ₗ »
notation:30 α " ⊕ₗ " β:29 => Lex (Sum α β)

#print Sum.inlₗ /-
--TODO: Can we make `inlₗ`, `inrₗ` `local notation`?
/-- Lexicographical `sum.inl`. Only used for pattern matching. -/
@[match_pattern]
abbrev Sum.inlₗ (x : α) : α ⊕ₗ β :=
  toLex (Sum.inl x)
#align sum.inlₗ Sum.inlₗ
-/

#print Sum.inrₗ /-
/-- Lexicographical `sum.inr`. Only used for pattern matching. -/
@[match_pattern]
abbrev Sum.inrₗ (x : β) : α ⊕ₗ β :=
  toLex (Sum.inr x)
#align sum.inrₗ Sum.inrₗ
-/

#print Sum.Lex.LE /-
/-- The linear/lexicographical `≤` on a sum. -/
instance LE [LE α] [LE β] : LE (α ⊕ₗ β) :=
  ⟨Lex (· ≤ ·) (· ≤ ·)⟩
#align sum.lex.has_le Sum.Lex.LE
-/

#print Sum.Lex.LT /-
/-- The linear/lexicographical `<` on a sum. -/
instance LT [LT α] [LT β] : LT (α ⊕ₗ β) :=
  ⟨Lex (· < ·) (· < ·)⟩
#align sum.lex.has_lt Sum.Lex.LT
-/

/- warning: sum.lex.to_lex_le_to_lex -> Sum.Lex.toLex_le_toLex is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : Sum.{u1, u2} α β} {b : Sum.{u1, u2} α β}, Iff (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) a) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) b)) (Sum.Lex.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2) a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : Sum.{u2, u1} α β} {b : Sum.{u2, u1} α β}, Iff (LE.le.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) a) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) a) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) b)) (Sum.Lex.{u2, u1} α β (fun (x._@.Mathlib.Data.Sum.Order._hyg.4227 : α) (x._@.Mathlib.Data.Sum.Order._hyg.4229 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Data.Sum.Order._hyg.4227 x._@.Mathlib.Data.Sum.Order._hyg.4229) (fun (x._@.Mathlib.Data.Sum.Order._hyg.4242 : β) (x._@.Mathlib.Data.Sum.Order._hyg.4244 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Data.Sum.Order._hyg.4242 x._@.Mathlib.Data.Sum.Order._hyg.4244) a b)
Case conversion may be inaccurate. Consider using '#align sum.lex.to_lex_le_to_lex Sum.Lex.toLex_le_toLexₓ'. -/
@[simp]
theorem toLex_le_toLex [LE α] [LE β] {a b : Sum α β} :
    toLex a ≤ toLex b ↔ Lex (· ≤ ·) (· ≤ ·) a b :=
  Iff.rfl
#align sum.lex.to_lex_le_to_lex Sum.Lex.toLex_le_toLex

/- warning: sum.lex.to_lex_lt_to_lex -> Sum.Lex.toLex_lt_toLex is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : Sum.{u1, u2} α β} {b : Sum.{u1, u2} α β}, Iff (LT.lt.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LT.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) a) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) b)) (Sum.Lex.{u1, u2} α β (LT.lt.{u1} α _inst_1) (LT.lt.{u2} β _inst_2) a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : Sum.{u2, u1} α β} {b : Sum.{u2, u1} α β}, Iff (LT.lt.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) a) (Sum.Lex.LT.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) a) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) b)) (Sum.Lex.{u2, u1} α β (fun (x._@.Mathlib.Data.Sum.Order._hyg.4289 : α) (x._@.Mathlib.Data.Sum.Order._hyg.4291 : α) => LT.lt.{u2} α _inst_1 x._@.Mathlib.Data.Sum.Order._hyg.4289 x._@.Mathlib.Data.Sum.Order._hyg.4291) (fun (x._@.Mathlib.Data.Sum.Order._hyg.4304 : β) (x._@.Mathlib.Data.Sum.Order._hyg.4306 : β) => LT.lt.{u1} β _inst_2 x._@.Mathlib.Data.Sum.Order._hyg.4304 x._@.Mathlib.Data.Sum.Order._hyg.4306) a b)
Case conversion may be inaccurate. Consider using '#align sum.lex.to_lex_lt_to_lex Sum.Lex.toLex_lt_toLexₓ'. -/
@[simp]
theorem toLex_lt_toLex [LT α] [LT β] {a b : Sum α β} :
    toLex a < toLex b ↔ Lex (· < ·) (· < ·) a b :=
  Iff.rfl
#align sum.lex.to_lex_lt_to_lex Sum.Lex.toLex_lt_toLex

/- warning: sum.lex.le_def -> Sum.Lex.le_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : Lex.{max u1 u2} (Sum.{u1, u2} α β)} {b : Lex.{max u1 u2} (Sum.{u1, u2} α β)}, Iff (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) a b) (Sum.Lex.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) => (Lex.{max u1 u2} (Sum.{u1, u2} α β)) -> (Sum.{u1, u2} α β)) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) (ofLex.{max u1 u2} (Sum.{u1, u2} α β)) a) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) => (Lex.{max u1 u2} (Sum.{u1, u2} α β)) -> (Sum.{u1, u2} α β)) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) (ofLex.{max u1 u2} (Sum.{u1, u2} α β)) b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : Lex.{max u1 u2} (Sum.{u2, u1} α β)} {b : Lex.{max u1 u2} (Sum.{u2, u1} α β)}, Iff (LE.le.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2) a b) (Sum.Lex.{u2, u1} α β (fun (x._@.Mathlib.Data.Sum.Order._hyg.4359 : α) (x._@.Mathlib.Data.Sum.Order._hyg.4361 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Data.Sum.Order._hyg.4359 x._@.Mathlib.Data.Sum.Order._hyg.4361) (fun (x._@.Mathlib.Data.Sum.Order._hyg.4374 : β) (x._@.Mathlib.Data.Sum.Order._hyg.4376 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Data.Sum.Order._hyg.4374 x._@.Mathlib.Data.Sum.Order._hyg.4376) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (fun (_x : Lex.{max u2 u1} (Sum.{u2, u1} α β)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u2, u1} α β)) => Sum.{u2, u1} α β) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)))) (ofLex.{max u2 u1} (Sum.{u2, u1} α β)) a) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (fun (_x : Lex.{max u2 u1} (Sum.{u2, u1} α β)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u2, u1} α β)) => Sum.{u2, u1} α β) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)))) (ofLex.{max u2 u1} (Sum.{u2, u1} α β)) b))
Case conversion may be inaccurate. Consider using '#align sum.lex.le_def Sum.Lex.le_defₓ'. -/
theorem le_def [LE α] [LE β] {a b : α ⊕ₗ β} : a ≤ b ↔ Lex (· ≤ ·) (· ≤ ·) (ofLex a) (ofLex b) :=
  Iff.rfl
#align sum.lex.le_def Sum.Lex.le_def

/- warning: sum.lex.lt_def -> Sum.Lex.lt_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : Lex.{max u1 u2} (Sum.{u1, u2} α β)} {b : Lex.{max u1 u2} (Sum.{u1, u2} α β)}, Iff (LT.lt.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LT.{u1, u2} α β _inst_1 _inst_2) a b) (Sum.Lex.{u1, u2} α β (LT.lt.{u1} α _inst_1) (LT.lt.{u2} β _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) => (Lex.{max u1 u2} (Sum.{u1, u2} α β)) -> (Sum.{u1, u2} α β)) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) (ofLex.{max u1 u2} (Sum.{u1, u2} α β)) a) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) => (Lex.{max u1 u2} (Sum.{u1, u2} α β)) -> (Sum.{u1, u2} α β)) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} α β)) (ofLex.{max u1 u2} (Sum.{u1, u2} α β)) b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : Lex.{max u1 u2} (Sum.{u2, u1} α β)} {b : Lex.{max u1 u2} (Sum.{u2, u1} α β)}, Iff (LT.lt.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LT.{u2, u1} α β _inst_1 _inst_2) a b) (Sum.Lex.{u2, u1} α β (fun (x._@.Mathlib.Data.Sum.Order._hyg.4435 : α) (x._@.Mathlib.Data.Sum.Order._hyg.4437 : α) => LT.lt.{u2} α _inst_1 x._@.Mathlib.Data.Sum.Order._hyg.4435 x._@.Mathlib.Data.Sum.Order._hyg.4437) (fun (x._@.Mathlib.Data.Sum.Order._hyg.4450 : β) (x._@.Mathlib.Data.Sum.Order._hyg.4452 : β) => LT.lt.{u1} β _inst_2 x._@.Mathlib.Data.Sum.Order._hyg.4450 x._@.Mathlib.Data.Sum.Order._hyg.4452) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (fun (_x : Lex.{max u2 u1} (Sum.{u2, u1} α β)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u2, u1} α β)) => Sum.{u2, u1} α β) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)))) (ofLex.{max u2 u1} (Sum.{u2, u1} α β)) a) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (fun (_x : Lex.{max u2 u1} (Sum.{u2, u1} α β)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u2, u1} α β)) => Sum.{u2, u1} α β) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.{u2, u1} α β)))) (ofLex.{max u2 u1} (Sum.{u2, u1} α β)) b))
Case conversion may be inaccurate. Consider using '#align sum.lex.lt_def Sum.Lex.lt_defₓ'. -/
theorem lt_def [LT α] [LT β] {a b : α ⊕ₗ β} : a < b ↔ Lex (· < ·) (· < ·) (ofLex a) (ofLex b) :=
  Iff.rfl
#align sum.lex.lt_def Sum.Lex.lt_def

/- warning: sum.lex.inl_le_inl_iff -> Sum.Lex.inl_le_inl_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : α} {b : α}, Iff (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β b))) (LE.le.{u1} α _inst_1 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : α} {b : α}, Iff (LE.le.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β b))) (LE.le.{u2} α _inst_1 a b)
Case conversion may be inaccurate. Consider using '#align sum.lex.inl_le_inl_iff Sum.Lex.inl_le_inl_iffₓ'. -/
@[simp]
theorem inl_le_inl_iff [LE α] [LE β] {a b : α} : toLex (inl a : Sum α β) ≤ toLex (inl b) ↔ a ≤ b :=
  lex_inl_inl
#align sum.lex.inl_le_inl_iff Sum.Lex.inl_le_inl_iff

/- warning: sum.lex.inr_le_inr_iff -> Sum.Lex.inr_le_inr_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : β} {b : β}, Iff (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β a)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b))) (LE.le.{u2} β _inst_2 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : β} {b : β}, Iff (LE.le.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β a)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β a)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))) (LE.le.{u1} β _inst_2 a b)
Case conversion may be inaccurate. Consider using '#align sum.lex.inr_le_inr_iff Sum.Lex.inr_le_inr_iffₓ'. -/
@[simp]
theorem inr_le_inr_iff [LE α] [LE β] {a b : β} : toLex (inr a : Sum α β) ≤ toLex (inr b) ↔ a ≤ b :=
  lex_inr_inr
#align sum.lex.inr_le_inr_iff Sum.Lex.inr_le_inr_iff

/- warning: sum.lex.inl_lt_inl_iff -> Sum.Lex.inl_lt_inl_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : α} {b : α}, Iff (LT.lt.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LT.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β b))) (LT.lt.{u1} α _inst_1 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : α} {b : α}, Iff (LT.lt.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)) (Sum.Lex.LT.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β b))) (LT.lt.{u2} α _inst_1 a b)
Case conversion may be inaccurate. Consider using '#align sum.lex.inl_lt_inl_iff Sum.Lex.inl_lt_inl_iffₓ'. -/
@[simp]
theorem inl_lt_inl_iff [LT α] [LT β] {a b : α} : toLex (inl a : Sum α β) < toLex (inl b) ↔ a < b :=
  lex_inl_inl
#align sum.lex.inl_lt_inl_iff Sum.Lex.inl_lt_inl_iff

/- warning: sum.lex.inr_lt_inr_iff -> Sum.Lex.inr_lt_inr_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : β} {b : β}, Iff (LT.lt.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LT.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β a)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b))) (LT.lt.{u2} β _inst_2 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : β} {b : β}, Iff (LT.lt.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β a)) (Sum.Lex.LT.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β a)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))) (LT.lt.{u1} β _inst_2 a b)
Case conversion may be inaccurate. Consider using '#align sum.lex.inr_lt_inr_iff Sum.Lex.inr_lt_inr_iffₓ'. -/
@[simp]
theorem inr_lt_inr_iff [LT α] [LT β] {a b : β} : toLex (inr a : α ⊕ₗ β) < toLex (inr b) ↔ a < b :=
  lex_inr_inr
#align sum.lex.inr_lt_inr_iff Sum.Lex.inr_lt_inr_iff

/- warning: sum.lex.inl_le_inr -> Sum.Lex.inl_le_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (a : α) (b : β), LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (a : α) (b : β), LE.le.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))
Case conversion may be inaccurate. Consider using '#align sum.lex.inl_le_inr Sum.Lex.inl_le_inrₓ'. -/
@[simp]
theorem inl_le_inr [LE α] [LE β] (a : α) (b : β) : toLex (inl a) ≤ toLex (inr b) :=
  Lex.sep _ _
#align sum.lex.inl_le_inr Sum.Lex.inl_le_inr

/- warning: sum.lex.inl_lt_inr -> Sum.Lex.inl_lt_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] (a : α) (b : β), LT.lt.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LT.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] (a : α) (b : β), LT.lt.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)) (Sum.Lex.LT.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))
Case conversion may be inaccurate. Consider using '#align sum.lex.inl_lt_inr Sum.Lex.inl_lt_inrₓ'. -/
@[simp]
theorem inl_lt_inr [LT α] [LT β] (a : α) (b : β) : toLex (inl a) < toLex (inr b) :=
  Lex.sep _ _
#align sum.lex.inl_lt_inr Sum.Lex.inl_lt_inr

/- warning: sum.lex.not_inr_le_inl -> Sum.Lex.not_inr_le_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {a : α} {b : β}, Not (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {a : α} {b : β}, Not (LE.le.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)))
Case conversion may be inaccurate. Consider using '#align sum.lex.not_inr_le_inl Sum.Lex.not_inr_le_inlₓ'. -/
@[simp]
theorem not_inr_le_inl [LE α] [LE β] {a : α} {b : β} : ¬toLex (inr b) ≤ toLex (inl a) :=
  lex_inr_inl
#align sum.lex.not_inr_le_inl Sum.Lex.not_inr_le_inl

/- warning: sum.lex.not_inr_lt_inl -> Sum.Lex.not_inr_lt_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LT.{u1} α] [_inst_2 : LT.{u2} β] {a : α} {b : β}, Not (LT.lt.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LT.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LT.{u2} α] [_inst_2 : LT.{u1} β] {a : α} {b : β}, Not (LT.lt.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b)) (Sum.Lex.LT.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a)))
Case conversion may be inaccurate. Consider using '#align sum.lex.not_inr_lt_inl Sum.Lex.not_inr_lt_inlₓ'. -/
@[simp]
theorem not_inr_lt_inl [LT α] [LT β] {a : α} {b : β} : ¬toLex (inr b) < toLex (inl a) :=
  lex_inr_inl
#align sum.lex.not_inr_lt_inl Sum.Lex.not_inr_lt_inl

section Preorder

variable [Preorder α] [Preorder β]

#print Sum.Lex.preorder /-
instance preorder : Preorder (α ⊕ₗ β) :=
  { Lex.LE, Lex.LT with
    le_refl := refl_of (Lex (· ≤ ·) (· ≤ ·))
    le_trans := fun _ _ _ => trans_of (Lex (· ≤ ·) (· ≤ ·))
    lt_iff_le_not_le := fun a b =>
      by
      refine' ⟨fun hab => ⟨hab.mono (fun _ _ => le_of_lt) fun _ _ => le_of_lt, _⟩, _⟩
      · rintro (⟨hba⟩ | ⟨hba⟩ | ⟨b, a⟩)
        · exact hba.not_lt (inl_lt_inl_iff.1 hab)
        · exact hba.not_lt (inr_lt_inr_iff.1 hab)
        · exact not_inr_lt_inl hab
      · rintro ⟨⟨hab⟩ | ⟨hab⟩ | ⟨a, b⟩, hba⟩
        · exact lex.inl (hab.lt_of_not_le fun h => hba <| lex.inl h)
        · exact lex.inr (hab.lt_of_not_le fun h => hba <| lex.inr h)
        · exact lex.sep _ _ }
#align sum.lex.preorder Sum.Lex.preorder
-/

/- warning: sum.lex.to_lex_mono -> Sum.Lex.toLex_mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], Monotone.{max u1 u2, max u1 u2} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.preorder.{u1, u2} α β _inst_1 _inst_2) (Sum.Lex.preorder.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β], Monotone.{max u2 u1, max u2 u1} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.instPreorderSum.{u2, u1} α β _inst_1 _inst_2) (Sum.Lex.preorder.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)))
Case conversion may be inaccurate. Consider using '#align sum.lex.to_lex_mono Sum.Lex.toLex_monoₓ'. -/
theorem toLex_mono : Monotone (@toLex (Sum α β)) := fun a b h => h.Lex
#align sum.lex.to_lex_mono Sum.Lex.toLex_mono

/- warning: sum.lex.to_lex_strict_mono -> Sum.Lex.toLex_strictMono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], StrictMono.{max u1 u2, max u1 u2} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.preorder.{u1, u2} α β _inst_1 _inst_2) (Sum.Lex.preorder.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β], StrictMono.{max u2 u1, max u2 u1} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.instPreorderSum.{u2, u1} α β _inst_1 _inst_2) (Sum.Lex.preorder.{u2, u1} α β _inst_1 _inst_2) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (toLex.{max u1 u2} (Sum.{u2, u1} α β)))
Case conversion may be inaccurate. Consider using '#align sum.lex.to_lex_strict_mono Sum.Lex.toLex_strictMonoₓ'. -/
theorem toLex_strictMono : StrictMono (@toLex (Sum α β)) := fun a b h => h.Lex
#align sum.lex.to_lex_strict_mono Sum.Lex.toLex_strictMono

/- warning: sum.lex.inl_mono -> Sum.Lex.inl_mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], Monotone.{u1, max u1 u2} α (Lex.{max u1 u2} (Sum.{u1, u2} α β)) _inst_1 (Sum.Lex.preorder.{u1, u2} α β _inst_1 _inst_2) (Function.comp.{succ u1, succ (max u1 u2), succ (max u1 u2)} α (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β))) (Sum.inl.{u1, u2} α β))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β], Monotone.{u2, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} α β)) _inst_1 (Sum.Lex.preorder.{u2, u1} α β _inst_1 _inst_2) (Function.comp.{succ u2, succ (max u2 u1), max (succ u2) (succ u1)} α (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.inl.{u2, u1} α β))
Case conversion may be inaccurate. Consider using '#align sum.lex.inl_mono Sum.Lex.inl_monoₓ'. -/
theorem inl_mono : Monotone (toLex ∘ inl : α → α ⊕ₗ β) :=
  toLex_mono.comp inl_mono
#align sum.lex.inl_mono Sum.Lex.inl_mono

#print Sum.Lex.inr_mono /-
theorem inr_mono : Monotone (toLex ∘ inr : β → α ⊕ₗ β) :=
  toLex_mono.comp inr_mono
#align sum.lex.inr_mono Sum.Lex.inr_mono
-/

/- warning: sum.lex.inl_strict_mono -> Sum.Lex.inl_strictMono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], StrictMono.{u1, max u1 u2} α (Lex.{max u1 u2} (Sum.{u1, u2} α β)) _inst_1 (Sum.Lex.preorder.{u1, u2} α β _inst_1 _inst_2) (Function.comp.{succ u1, succ (max u1 u2), succ (max u1 u2)} α (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β))) (Sum.inl.{u1, u2} α β))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β], StrictMono.{u2, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} α β)) _inst_1 (Sum.Lex.preorder.{u2, u1} α β _inst_1 _inst_2) (Function.comp.{succ u2, succ (max u2 u1), max (succ u2) (succ u1)} α (Sum.{u2, u1} α β) (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.inl.{u2, u1} α β))
Case conversion may be inaccurate. Consider using '#align sum.lex.inl_strict_mono Sum.Lex.inl_strictMonoₓ'. -/
theorem inl_strictMono : StrictMono (toLex ∘ inl : α → α ⊕ₗ β) :=
  toLex_strictMono.comp inl_strictMono
#align sum.lex.inl_strict_mono Sum.Lex.inl_strictMono

#print Sum.Lex.inr_strictMono /-
theorem inr_strictMono : StrictMono (toLex ∘ inr : β → α ⊕ₗ β) :=
  toLex_strictMono.comp inr_strictMono
#align sum.lex.inr_strict_mono Sum.Lex.inr_strictMono
-/

end Preorder

#print Sum.Lex.partialOrder /-
instance partialOrder [PartialOrder α] [PartialOrder β] : PartialOrder (α ⊕ₗ β) :=
  { Lex.preorder with le_antisymm := fun _ _ => antisymm_of (Lex (· ≤ ·) (· ≤ ·)) }
#align sum.lex.partial_order Sum.Lex.partialOrder
-/

#print Sum.Lex.linearOrder /-
instance linearOrder [LinearOrder α] [LinearOrder β] : LinearOrder (α ⊕ₗ β) :=
  { Lex.partialOrder with
    le_total := total_of (Lex (· ≤ ·) (· ≤ ·))
    decidableLe := Lex.decidableRel
    DecidableEq := Sum.decidableEq _ _ }
#align sum.lex.linear_order Sum.Lex.linearOrder
-/

#print Sum.Lex.orderBot /-
/-- The lexicographical bottom of a sum is the bottom of the left component. -/
instance orderBot [LE α] [OrderBot α] [LE β] : OrderBot (α ⊕ₗ β)
    where
  bot := inl ⊥
  bot_le := by
    rintro (a | b)
    · exact lex.inl bot_le
    · exact lex.sep _ _
#align sum.lex.order_bot Sum.Lex.orderBot
-/

/- warning: sum.lex.inl_bot -> Sum.Lex.inl_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1] [_inst_3 : LE.{u2} β], Eq.{succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β (Bot.bot.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)))) (Bot.bot.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (OrderBot.toHasBot.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_3) (Sum.Lex.orderBot.{u1, u2} α β _inst_1 _inst_2 _inst_3)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : OrderBot.{u2} α _inst_1] [_inst_3 : LE.{u1} β], Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_2)))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_2)))) (Bot.bot.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_2)))) (OrderBot.toBot.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_2)))) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_3) (Sum.Lex.orderBot.{u2, u1} α β _inst_1 _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align sum.lex.inl_bot Sum.Lex.inl_botₓ'. -/
@[simp]
theorem inl_bot [LE α] [OrderBot α] [LE β] : toLex (inl ⊥ : Sum α β) = ⊥ :=
  rfl
#align sum.lex.inl_bot Sum.Lex.inl_bot

#print Sum.Lex.orderTop /-
/-- The lexicographical top of a sum is the top of the right component. -/
instance orderTop [LE α] [LE β] [OrderTop β] : OrderTop (α ⊕ₗ β)
    where
  top := inr ⊤
  le_top := by
    rintro (a | b)
    · exact lex.sep _ _
    · exact lex.inr le_top
#align sum.lex.order_top Sum.Lex.orderTop
-/

/- warning: sum.lex.inr_top -> Sum.Lex.inr_top is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : OrderTop.{u2} β _inst_2], Eq.{succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β (Top.top.{u2} β (OrderTop.toHasTop.{u2} β _inst_2 _inst_3)))) (Top.top.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (OrderTop.toHasTop.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) (Sum.Lex.orderTop.{u1, u2} α β _inst_1 _inst_2 _inst_3)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] [_inst_3 : OrderTop.{u1} β _inst_2], Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β (Top.top.{u1} β (OrderTop.toTop.{u1} β _inst_2 _inst_3)))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} α β) (Lex.{max u2 u1} (Sum.{u2, u1} α β))))) (toLex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β (Top.top.{u1} β (OrderTop.toTop.{u1} β _inst_2 _inst_3)))) (Top.top.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β (Top.top.{u1} β (OrderTop.toTop.{u1} β _inst_2 _inst_3)))) (OrderTop.toTop.{max u2 u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => Lex.{max u2 u1} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β (Top.top.{u1} β (OrderTop.toTop.{u1} β _inst_2 _inst_3)))) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2) (Sum.Lex.orderTop.{u2, u1} α β _inst_1 _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align sum.lex.inr_top Sum.Lex.inr_topₓ'. -/
@[simp]
theorem inr_top [LE α] [LE β] [OrderTop β] : toLex (inr ⊤ : Sum α β) = ⊤ :=
  rfl
#align sum.lex.inr_top Sum.Lex.inr_top

#print Sum.Lex.boundedOrder /-
instance boundedOrder [LE α] [LE β] [OrderBot α] [OrderTop β] : BoundedOrder (α ⊕ₗ β) :=
  { Lex.orderBot, Lex.orderTop with }
#align sum.lex.bounded_order Sum.Lex.boundedOrder
-/

#print Sum.Lex.noMinOrder /-
instance noMinOrder [LT α] [LT β] [NoMinOrder α] [NoMinOrder β] : NoMinOrder (α ⊕ₗ β) :=
  ⟨fun a =>
    match a with
    | inl a =>
      let ⟨b, h⟩ := exists_lt a
      ⟨toLex (inl b), inl_lt_inl_iff.2 h⟩
    | inr a =>
      let ⟨b, h⟩ := exists_lt a
      ⟨toLex (inr b), inr_lt_inr_iff.2 h⟩⟩
#align sum.lex.no_min_order Sum.Lex.noMinOrder
-/

#print Sum.Lex.noMaxOrder /-
instance noMaxOrder [LT α] [LT β] [NoMaxOrder α] [NoMaxOrder β] : NoMaxOrder (α ⊕ₗ β) :=
  ⟨fun a =>
    match a with
    | inl a =>
      let ⟨b, h⟩ := exists_gt a
      ⟨toLex (inl b), inl_lt_inl_iff.2 h⟩
    | inr a =>
      let ⟨b, h⟩ := exists_gt a
      ⟨toLex (inr b), inr_lt_inr_iff.2 h⟩⟩
#align sum.lex.no_max_order Sum.Lex.noMaxOrder
-/

#print Sum.Lex.noMinOrder_of_nonempty /-
instance noMinOrder_of_nonempty [LT α] [LT β] [NoMinOrder α] [Nonempty α] : NoMinOrder (α ⊕ₗ β) :=
  ⟨fun a =>
    match a with
    | inl a =>
      let ⟨b, h⟩ := exists_lt a
      ⟨toLex (inl b), inl_lt_inl_iff.2 h⟩
    | inr a => ⟨toLex (inl <| Classical.arbitrary α), inl_lt_inr _ _⟩⟩
#align sum.lex.no_min_order_of_nonempty Sum.Lex.noMinOrder_of_nonempty
-/

#print Sum.Lex.noMaxOrder_of_nonempty /-
instance noMaxOrder_of_nonempty [LT α] [LT β] [NoMaxOrder β] [Nonempty β] : NoMaxOrder (α ⊕ₗ β) :=
  ⟨fun a =>
    match a with
    | inl a => ⟨toLex (inr <| Classical.arbitrary β), inl_lt_inr _ _⟩
    | inr a =>
      let ⟨b, h⟩ := exists_gt a
      ⟨toLex (inr b), inr_lt_inr_iff.2 h⟩⟩
#align sum.lex.no_max_order_of_nonempty Sum.Lex.noMaxOrder_of_nonempty
-/

#print Sum.Lex.denselyOrdered_of_noMaxOrder /-
instance denselyOrdered_of_noMaxOrder [LT α] [LT β] [DenselyOrdered α] [DenselyOrdered β]
    [NoMaxOrder α] : DenselyOrdered (α ⊕ₗ β) :=
  ⟨fun a b h =>
    match a, b, h with
    | inl a, inl b, lex.inl h =>
      let ⟨c, ha, hb⟩ := exists_between h
      ⟨toLex (inl c), inl_lt_inl_iff.2 ha, inl_lt_inl_iff.2 hb⟩
    | inl a, inr b, lex.sep _ _ =>
      let ⟨c, h⟩ := exists_gt a
      ⟨toLex (inl c), inl_lt_inl_iff.2 h, inl_lt_inr _ _⟩
    | inr a, inr b, lex.inr h =>
      let ⟨c, ha, hb⟩ := exists_between h
      ⟨toLex (inr c), inr_lt_inr_iff.2 ha, inr_lt_inr_iff.2 hb⟩⟩
#align sum.lex.densely_ordered_of_no_max_order Sum.Lex.denselyOrdered_of_noMaxOrder
-/

#print Sum.Lex.denselyOrdered_of_noMinOrder /-
instance denselyOrdered_of_noMinOrder [LT α] [LT β] [DenselyOrdered α] [DenselyOrdered β]
    [NoMinOrder β] : DenselyOrdered (α ⊕ₗ β) :=
  ⟨fun a b h =>
    match a, b, h with
    | inl a, inl b, lex.inl h =>
      let ⟨c, ha, hb⟩ := exists_between h
      ⟨toLex (inl c), inl_lt_inl_iff.2 ha, inl_lt_inl_iff.2 hb⟩
    | inl a, inr b, lex.sep _ _ =>
      let ⟨c, h⟩ := exists_lt b
      ⟨toLex (inr c), inl_lt_inr _ _, inr_lt_inr_iff.2 h⟩
    | inr a, inr b, lex.inr h =>
      let ⟨c, ha, hb⟩ := exists_between h
      ⟨toLex (inr c), inr_lt_inr_iff.2 ha, inr_lt_inr_iff.2 hb⟩⟩
#align sum.lex.densely_ordered_of_no_min_order Sum.Lex.denselyOrdered_of_noMinOrder
-/

end Lex

end Sum

/-! ### Order isomorphisms -/


open OrderDual Sum

namespace OrderIso

variable [LE α] [LE β] [LE γ] (a : α) (b : β) (c : γ)

#print OrderIso.sumComm /-
/-- `equiv.sum_comm` promoted to an order isomorphism. -/
@[simps apply]
def sumComm (α β : Type _) [LE α] [LE β] : Sum α β ≃o Sum β α :=
  { Equiv.sumComm α β with map_rel_iff' := fun a b => swap_le_swap_iff }
#align order_iso.sum_comm OrderIso.sumComm
-/

/- warning: order_iso.sum_comm_symm -> OrderIso.sumComm_symm is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_4 : LE.{u1} α] [_inst_5 : LE.{u2} β], Eq.{max (succ (max u2 u1)) (succ (max u1 u2))} (OrderIso.{max u2 u1, max u1 u2} (Sum.{u2, u1} β α) (Sum.{u1, u2} α β) (Sum.hasLe.{u2, u1} β α _inst_5 _inst_4) (Sum.hasLe.{u1, u2} α β _inst_4 _inst_5)) (OrderIso.symm.{max u1 u2, max u2 u1} (Sum.{u1, u2} α β) (Sum.{u2, u1} β α) (Sum.hasLe.{u1, u2} α β _inst_4 _inst_5) (Sum.hasLe.{u2, u1} β α _inst_5 _inst_4) (OrderIso.sumComm.{u1, u2} α β _inst_4 _inst_5)) (OrderIso.sumComm.{u2, u1} β α _inst_5 _inst_4)
but is expected to have type
  forall (α : Type.{u2}) (β : Type.{u1}) [_inst_4 : LE.{u2} α] [_inst_5 : LE.{u1} β], Eq.{max (succ u2) (succ u1)} (OrderIso.{max u2 u1, max u2 u1} (Sum.{u1, u2} β α) (Sum.{u2, u1} α β) (Sum.instLESum.{u1, u2} β α _inst_5 _inst_4) (Sum.instLESum.{u2, u1} α β _inst_4 _inst_5)) (OrderIso.symm.{max u2 u1, max u2 u1} (Sum.{u2, u1} α β) (Sum.{u1, u2} β α) (Sum.instLESum.{u2, u1} α β _inst_4 _inst_5) (Sum.instLESum.{u1, u2} β α _inst_5 _inst_4) (OrderIso.sumComm.{u2, u1} α β _inst_4 _inst_5)) (OrderIso.sumComm.{u1, u2} β α _inst_5 _inst_4)
Case conversion may be inaccurate. Consider using '#align order_iso.sum_comm_symm OrderIso.sumComm_symmₓ'. -/
@[simp]
theorem sumComm_symm (α β : Type _) [LE α] [LE β] :
    (OrderIso.sumComm α β).symm = OrderIso.sumComm β α :=
  rfl
#align order_iso.sum_comm_symm OrderIso.sumComm_symm

#print OrderIso.sumAssoc /-
/-- `equiv.sum_assoc` promoted to an order isomorphism. -/
def sumAssoc (α β γ : Type _) [LE α] [LE β] [LE γ] : Sum (Sum α β) γ ≃o Sum α (Sum β γ) :=
  { Equiv.sumAssoc α β γ with map_rel_iff' := by rintro ((a | a) | a) ((b | b) | b) <;> simp }
#align order_iso.sum_assoc OrderIso.sumAssoc
-/

/- warning: order_iso.sum_assoc_apply_inl_inl -> OrderIso.sumAssoc_apply_inl_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (a : α), Eq.{max (succ u1) (succ (max u2 u3))} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (coeFn.{max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3)), max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3))} (OrderIso.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3))) (fun (_x : RelIso.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)))) => (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) -> (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ))) (RelIso.hasCoeToFun.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)))) (OrderIso.sumAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3) (Sum.inl.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.inl.{u1, u2} α β a))) (Sum.inl.{u1, max u2 u3} α (Sum.{u2, u3} β γ) a)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (a : α), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.inl.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.inl.{u3, u2} α β a))) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ))) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (fun (_x : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ))) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3))) (Sum.inl.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.inl.{u3, u2} α β a))) (Sum.inl.{u3, max u2 u1} α (Sum.{u2, u1} β γ) a)
Case conversion may be inaccurate. Consider using '#align order_iso.sum_assoc_apply_inl_inl OrderIso.sumAssoc_apply_inl_inlₓ'. -/
@[simp]
theorem sumAssoc_apply_inl_inl : sumAssoc α β γ (inl (inl a)) = inl a :=
  rfl
#align order_iso.sum_assoc_apply_inl_inl OrderIso.sumAssoc_apply_inl_inl

/- warning: order_iso.sum_assoc_apply_inl_inr -> OrderIso.sumAssoc_apply_inl_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (b : β), Eq.{max (succ u1) (succ (max u2 u3))} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (coeFn.{max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3)), max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3))} (OrderIso.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3))) (fun (_x : RelIso.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)))) => (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) -> (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ))) (RelIso.hasCoeToFun.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)))) (OrderIso.sumAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3) (Sum.inl.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.inr.{u1, u2} α β b))) (Sum.inr.{u1, max u2 u3} α (Sum.{u2, u3} β γ) (Sum.inl.{u2, u3} β γ b))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (b : β), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.inl.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.inr.{u3, u2} α β b))) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ))) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (fun (_x : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ))) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3))) (Sum.inl.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.inr.{u3, u2} α β b))) (Sum.inr.{u3, max u1 u2} α (Sum.{u2, u1} β γ) (Sum.inl.{u2, u1} β γ b))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_assoc_apply_inl_inr OrderIso.sumAssoc_apply_inl_inrₓ'. -/
@[simp]
theorem sumAssoc_apply_inl_inr : sumAssoc α β γ (inl (inr b)) = inr (inl b) :=
  rfl
#align order_iso.sum_assoc_apply_inl_inr OrderIso.sumAssoc_apply_inl_inr

/- warning: order_iso.sum_assoc_apply_inr -> OrderIso.sumAssoc_apply_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (c : γ), Eq.{max (succ u1) (succ (max u2 u3))} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (coeFn.{max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3)), max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3))} (OrderIso.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3))) (fun (_x : RelIso.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)))) => (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) -> (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ))) (RelIso.hasCoeToFun.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)))) (OrderIso.sumAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3) (Sum.inr.{max u1 u2, u3} (Sum.{u1, u2} α β) γ c)) (Sum.inr.{u1, max u2 u3} α (Sum.{u2, u3} β γ) (Sum.inr.{u2, u3} β γ c))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (c : γ), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.inr.{max u3 u2, u1} (Sum.{u3, u2} α β) γ c)) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ))) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (fun (_x : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ))) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3))) (Sum.inr.{max u3 u2, u1} (Sum.{u3, u2} α β) γ c)) (Sum.inr.{u3, max u1 u2} α (Sum.{u2, u1} β γ) (Sum.inr.{u2, u1} β γ c))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_assoc_apply_inr OrderIso.sumAssoc_apply_inrₓ'. -/
@[simp]
theorem sumAssoc_apply_inr : sumAssoc α β γ (inr c) = inr (inr c) :=
  rfl
#align order_iso.sum_assoc_apply_inr OrderIso.sumAssoc_apply_inr

/- warning: order_iso.sum_assoc_symm_apply_inl -> OrderIso.sumAssoc_symm_apply_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (a : α), Eq.{max (succ (max u1 u2)) (succ u3)} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (OrderIso.{max u1 u2 u3, max (max u1 u2) u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (fun (_x : RelIso.{max u1 u2 u3, max (max u1 u2) u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3))) => (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) -> (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ)) (RelIso.hasCoeToFun.{max u1 u2 u3, max (max u1 u2) u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3))) (OrderIso.symm.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)) (OrderIso.sumAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3)) (Sum.inl.{u1, max u2 u3} α (Sum.{u2, u3} β γ) a)) (Sum.inl.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.inl.{u1, u2} α β a))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (a : α), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.inl.{u3, max u2 u1} α (Sum.{u2, u1} β γ) a)) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ)) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (fun (_x : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ)) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) (OrderIso.sumAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3)))) (Sum.inl.{u3, max u2 u1} α (Sum.{u2, u1} β γ) a)) (Sum.inl.{max u2 u3, u1} (Sum.{u3, u2} α β) γ (Sum.inl.{u3, u2} α β a))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_assoc_symm_apply_inl OrderIso.sumAssoc_symm_apply_inlₓ'. -/
@[simp]
theorem sumAssoc_symm_apply_inl : (sumAssoc α β γ).symm (inl a) = inl (inl a) :=
  rfl
#align order_iso.sum_assoc_symm_apply_inl OrderIso.sumAssoc_symm_apply_inl

/- warning: order_iso.sum_assoc_symm_apply_inr_inl -> OrderIso.sumAssoc_symm_apply_inr_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (b : β), Eq.{max (succ (max u1 u2)) (succ u3)} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (OrderIso.{max u1 u2 u3, max (max u1 u2) u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (fun (_x : RelIso.{max u1 u2 u3, max (max u1 u2) u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3))) => (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) -> (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ)) (RelIso.hasCoeToFun.{max u1 u2 u3, max (max u1 u2) u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3))) (OrderIso.symm.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)) (OrderIso.sumAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3)) (Sum.inr.{u1, max u2 u3} α (Sum.{u2, u3} β γ) (Sum.inl.{u2, u3} β γ b))) (Sum.inl.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.inr.{u1, u2} α β b))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (b : β), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.inr.{u3, max u2 u1} α (Sum.{u2, u1} β γ) (Sum.inl.{u2, u1} β γ b))) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ)) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (fun (_x : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ)) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) (OrderIso.sumAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3)))) (Sum.inr.{u3, max u2 u1} α (Sum.{u2, u1} β γ) (Sum.inl.{u2, u1} β γ b))) (Sum.inl.{max u2 u3, u1} (Sum.{u3, u2} α β) γ (Sum.inr.{u3, u2} α β b))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_assoc_symm_apply_inr_inl OrderIso.sumAssoc_symm_apply_inr_inlₓ'. -/
@[simp]
theorem sumAssoc_symm_apply_inr_inl : (sumAssoc α β γ).symm (inr (inl b)) = inl (inr b) :=
  rfl
#align order_iso.sum_assoc_symm_apply_inr_inl OrderIso.sumAssoc_symm_apply_inr_inl

/- warning: order_iso.sum_assoc_symm_apply_inr_inr -> OrderIso.sumAssoc_symm_apply_inr_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (c : γ), Eq.{max (succ (max u1 u2)) (succ u3)} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (OrderIso.{max u1 u2 u3, max (max u1 u2) u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (fun (_x : RelIso.{max u1 u2 u3, max (max u1 u2) u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3))) => (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) -> (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ)) (RelIso.hasCoeToFun.{max u1 u2 u3, max (max u1 u2) u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (LE.le.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3))) (OrderIso.symm.{max (max u1 u2) u3, max u1 u2 u3} (Sum.{max u1 u2, u3} (Sum.{u1, u2} α β) γ) (Sum.{u1, max u2 u3} α (Sum.{u2, u3} β γ)) (Sum.hasLe.{max u1 u2, u3} (Sum.{u1, u2} α β) γ (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.hasLe.{u1, max u2 u3} α (Sum.{u2, u3} β γ) _inst_1 (Sum.hasLe.{u2, u3} β γ _inst_2 _inst_3)) (OrderIso.sumAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3)) (Sum.inr.{u1, max u2 u3} α (Sum.{u2, u3} β γ) (Sum.inr.{u2, u3} β γ c))) (Sum.inr.{max u1 u2, u3} (Sum.{u1, u2} α β) γ c)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (c : γ), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.inr.{u3, max u2 u1} α (Sum.{u2, u1} β γ) (Sum.inr.{u2, u1} β γ c))) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ)) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (fun (_x : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ)) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) => LE.le.{max (max u3 u2) u1} (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) => LE.le.{max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max (max u3 u2) u1, max (max u3 u2) u1} (Sum.{max u2 u3, u1} (Sum.{u3, u2} α β) γ) (Sum.{u3, max u1 u2} α (Sum.{u2, u1} β γ)) (Sum.instLESum.{max u3 u2, u1} (Sum.{u3, u2} α β) γ (Sum.instLESum.{u3, u2} α β _inst_1 _inst_2) _inst_3) (Sum.instLESum.{u3, max u2 u1} α (Sum.{u2, u1} β γ) _inst_1 (Sum.instLESum.{u2, u1} β γ _inst_2 _inst_3)) (OrderIso.sumAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3)))) (Sum.inr.{u3, max u2 u1} α (Sum.{u2, u1} β γ) (Sum.inr.{u2, u1} β γ c))) (Sum.inr.{max u3 u2, u1} (Sum.{u3, u2} α β) γ c)
Case conversion may be inaccurate. Consider using '#align order_iso.sum_assoc_symm_apply_inr_inr OrderIso.sumAssoc_symm_apply_inr_inrₓ'. -/
@[simp]
theorem sumAssoc_symm_apply_inr_inr : (sumAssoc α β γ).symm (inr (inr c)) = inr c :=
  rfl
#align order_iso.sum_assoc_symm_apply_inr_inr OrderIso.sumAssoc_symm_apply_inr_inr

#print OrderIso.sumDualDistrib /-
/-- `order_dual` is distributive over `⊕` up to an order isomorphism. -/
def sumDualDistrib (α β : Type _) [LE α] [LE β] : (Sum α β)ᵒᵈ ≃o Sum αᵒᵈ βᵒᵈ :=
  { Equiv.refl _ with
    map_rel_iff' := by
      rintro (a | a) (b | b)
      · change inl (to_dual a) ≤ inl (to_dual b) ↔ to_dual (inl a) ≤ to_dual (inl b)
        simp only [to_dual_le_to_dual, inl_le_inl_iff]
      · exact iff_of_false not_inl_le_inr not_inr_le_inl
      · exact iff_of_false not_inr_le_inl not_inl_le_inr
      · change inr (to_dual a) ≤ inr (to_dual b) ↔ to_dual (inr a) ≤ to_dual (inr b)
        simp only [to_dual_le_to_dual, inr_le_inr_iff] }
#align order_iso.sum_dual_distrib OrderIso.sumDualDistrib
-/

/- warning: order_iso.sum_dual_distrib_inl -> OrderIso.sumDualDistrib_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (a : α), Eq.{max (succ u1) (succ u2)} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (OrderIso.{max u1 u2, max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2))) (fun (_x : RelIso.{max u1 u2, max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2))) (LE.le.{max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2)))) => (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) -> (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β))) (RelIso.hasCoeToFun.{max u1 u2, max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2))) (LE.le.{max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2)))) (OrderIso.sumDualDistrib.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.toDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a))) (Sum.inl.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α) a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (a : α), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (a : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) a) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β))) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (fun (_x : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β))) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Function.instEmbeddingLikeEmbedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)))) (RelEmbedding.toEmbedding.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => LE.le.{max u1 u2} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => LE.le.{max u1 u2} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumDualDistrib.{u2, u1} α β _inst_1 _inst_2))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a))) (Sum.inl.{u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : α) => OrderDual.{u2} α) a) (OrderDual.{u1} β) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : α) => OrderDual.{u2} α) _x) (EmbeddingLike.toFunLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (EquivLike.toEmbeddingLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (Equiv.instEquivLikeEquiv.{succ u2, succ u2} α (OrderDual.{u2} α)))) (OrderDual.toDual.{u2} α) a))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_dual_distrib_inl OrderIso.sumDualDistrib_inlₓ'. -/
@[simp]
theorem sumDualDistrib_inl : sumDualDistrib α β (toDual (inl a)) = inl (toDual a) :=
  rfl
#align order_iso.sum_dual_distrib_inl OrderIso.sumDualDistrib_inl

/- warning: order_iso.sum_dual_distrib_inr -> OrderIso.sumDualDistrib_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (b : β), Eq.{max (succ u1) (succ u2)} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (OrderIso.{max u1 u2, max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2))) (fun (_x : RelIso.{max u1 u2, max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2))) (LE.le.{max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2)))) => (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) -> (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β))) (RelIso.hasCoeToFun.{max u1 u2, max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2))) (LE.le.{max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2)))) (OrderIso.sumDualDistrib.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.toDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b))) (Sum.inr.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} β (OrderDual.{u2} β)) (fun (_x : Equiv.{succ u2, succ u2} β (OrderDual.{u2} β)) => β -> (OrderDual.{u2} β)) (Equiv.hasCoeToFun.{succ u2, succ u2} β (OrderDual.{u2} β)) (OrderDual.toDual.{u2} β) b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (b : β), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (a : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) a) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β))) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (fun (_x : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β))) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Function.instEmbeddingLikeEmbedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)))) (RelEmbedding.toEmbedding.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => LE.le.{max u1 u2} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => LE.le.{max u1 u2} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumDualDistrib.{u2, u1} α β _inst_1 _inst_2))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))) (Sum.inr.{u2, u1} (OrderDual.{u2} α) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : β) => OrderDual.{u1} β) b) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : β) => OrderDual.{u1} β) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} β (OrderDual.{u1} β)))) (OrderDual.toDual.{u1} β) b))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_dual_distrib_inr OrderIso.sumDualDistrib_inrₓ'. -/
@[simp]
theorem sumDualDistrib_inr : sumDualDistrib α β (toDual (inr b)) = inr (toDual b) :=
  rfl
#align order_iso.sum_dual_distrib_inr OrderIso.sumDualDistrib_inr

/- warning: order_iso.sum_dual_distrib_symm_inl -> OrderIso.sumDualDistrib_symm_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (a : α), Eq.{succ (max u1 u2)} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (OrderIso.{max u1 u2, max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2))) (fun (_x : RelIso.{max u1 u2, max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (LE.le.{max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2)))) => (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (RelIso.hasCoeToFun.{max u1 u2, max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (LE.le.{max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2)))) (OrderIso.symm.{max u1 u2, max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2)) (OrderIso.sumDualDistrib.{u1, u2} α β _inst_1 _inst_2)) (Sum.inl.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α) a))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.toDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (a : α), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (fun (a : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : α) => OrderDual.{u2} α) a) (EmbeddingLike.toFunLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (EquivLike.toEmbeddingLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (Equiv.instEquivLikeEquiv.{succ u2, succ u2} α (OrderDual.{u2} α)))) (OrderDual.toDual.{u2} α) a))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (fun (_x : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Function.instEmbeddingLikeEmbedding.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)))) (RelEmbedding.toEmbedding.{max u2 u1, max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => LE.le.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => LE.le.{max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u2 u1, max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => LE.le.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => LE.le.{max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) (OrderIso.sumDualDistrib.{u2, u1} α β _inst_1 _inst_2)))) (Sum.inl.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : α) => OrderDual.{u2} α) _x) (EmbeddingLike.toFunLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (EquivLike.toEmbeddingLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (Equiv.instEquivLikeEquiv.{succ u2, succ u2} α (OrderDual.{u2} α)))) (OrderDual.toDual.{u2} α) a))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_dual_distrib_symm_inl OrderIso.sumDualDistrib_symm_inlₓ'. -/
@[simp]
theorem sumDualDistrib_symm_inl : (sumDualDistrib α β).symm (inl (toDual a)) = toDual (inl a) :=
  rfl
#align order_iso.sum_dual_distrib_symm_inl OrderIso.sumDualDistrib_symm_inl

/- warning: order_iso.sum_dual_distrib_symm_inr -> OrderIso.sumDualDistrib_symm_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (b : β), Eq.{succ (max u1 u2)} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (OrderIso.{max u1 u2, max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2))) (fun (_x : RelIso.{max u1 u2, max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (LE.le.{max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2)))) => (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (RelIso.hasCoeToFun.{max u1 u2, max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (LE.le.{max u1 u2} (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2)))) (OrderIso.symm.{max u1 u2, max u1 u2} (OrderDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β)) (OrderDual.hasLe.{max u1 u2} (Sum.{u1, u2} α β) (Sum.hasLe.{u1, u2} α β _inst_1 _inst_2)) (Sum.hasLe.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasLe.{u1} α _inst_1) (OrderDual.hasLe.{u2} β _inst_2)) (OrderIso.sumDualDistrib.{u1, u2} α β _inst_1 _inst_2)) (Sum.inr.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} β (OrderDual.{u2} β)) (fun (_x : Equiv.{succ u2, succ u2} β (OrderDual.{u2} β)) => β -> (OrderDual.{u2} β)) (Equiv.hasCoeToFun.{succ u2, succ u2} β (OrderDual.{u2} β)) (OrderDual.toDual.{u2} β) b))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.toDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (b : β), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (fun (a : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : β) => OrderDual.{u1} β) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} β (OrderDual.{u1} β)))) (OrderDual.toDual.{u1} β) b))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (fun (_x : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Function.instEmbeddingLikeEmbedding.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)))) (RelEmbedding.toEmbedding.{max u2 u1, max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => LE.le.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => LE.le.{max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u2 u1, max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) => LE.le.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) => LE.le.{max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β)) (OrderDual.instLEOrderDual.{max u2 u1} (Sum.{u2, u1} α β) (Sum.instLESum.{u2, u1} α β _inst_1 _inst_2)) (Sum.instLESum.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (OrderDual.instLEOrderDual.{u2} α _inst_1) (OrderDual.instLEOrderDual.{u1} β _inst_2)) (OrderIso.sumDualDistrib.{u2, u1} α β _inst_1 _inst_2)))) (Sum.inr.{u2, u1} (OrderDual.{u2} α) (OrderDual.{u1} β) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : β) => OrderDual.{u1} β) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} β (OrderDual.{u1} β)))) (OrderDual.toDual.{u1} β) b))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_dual_distrib_symm_inr OrderIso.sumDualDistrib_symm_inrₓ'. -/
@[simp]
theorem sumDualDistrib_symm_inr : (sumDualDistrib α β).symm (inr (toDual b)) = toDual (inr b) :=
  rfl
#align order_iso.sum_dual_distrib_symm_inr OrderIso.sumDualDistrib_symm_inr

#print OrderIso.sumLexAssoc /-
/-- `equiv.sum_assoc` promoted to an order isomorphism. -/
def sumLexAssoc (α β γ : Type _) [LE α] [LE β] [LE γ] : (α ⊕ₗ β) ⊕ₗ γ ≃o α ⊕ₗ β ⊕ₗ γ :=
  { Equiv.sumAssoc α β γ with
    map_rel_iff' := fun a b =>
      ⟨fun h =>
        match a, b, h with
        | inlₗ (inlₗ a), inlₗ (inlₗ b), lex.inl h => lex.inl <| Lex.inl h
        | inlₗ (inlₗ a), inlₗ (inrₗ b), lex.sep _ _ => lex.inl <| Lex.sep _ _
        | inlₗ (inlₗ a), inrₗ b, lex.sep _ _ => Lex.sep _ _
        | inlₗ (inrₗ a), inlₗ (inrₗ b), lex.inr (lex.inl h) => lex.inl <| Lex.inr h
        | inlₗ (inrₗ a), inrₗ b, lex.inr (lex.sep _ _) => Lex.sep _ _
        | inrₗ a, inrₗ b, lex.inr (lex.inr h) => Lex.inr h,
        fun h =>
        match a, b, h with
        | inlₗ (inlₗ a), inlₗ (inlₗ b), lex.inl (lex.inl h) => Lex.inl h
        | inlₗ (inlₗ a), inlₗ (inrₗ b), lex.inl (lex.sep _ _) => Lex.sep _ _
        | inlₗ (inlₗ a), inrₗ b, lex.sep _ _ => Lex.sep _ _
        | inlₗ (inrₗ a), inlₗ (inrₗ b), lex.inl (lex.inr h) => lex.inr <| Lex.inl h
        | inlₗ (inrₗ a), inrₗ b, lex.sep _ _ => lex.inr <| Lex.sep _ _
        | inrₗ a, inrₗ b, lex.inr h => lex.inr <| Lex.inr h⟩ }
#align order_iso.sum_lex_assoc OrderIso.sumLexAssoc
-/

/- warning: order_iso.sum_lex_assoc_apply_inl_inl -> OrderIso.sumLexAssoc_apply_inl_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (a : α), Eq.{succ (max u1 u2 u3)} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (coeFn.{max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3)), max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3))} (OrderIso.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3))) (fun (_x : RelIso.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)))) => (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) -> (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (RelIso.hasCoeToFun.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)))) (OrderIso.sumLexAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3) (coeFn.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Equiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (fun (_x : Equiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) => (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) -> (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (Equiv.hasCoeToFun.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (toLex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.inl.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a))))) (coeFn.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (fun (_x : Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) => (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) -> (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (Equiv.hasCoeToFun.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (toLex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.inl.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) a))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (a : α), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (FunLike.coe.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ))) (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (fun (a_1 : Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) => Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ)) a_1) (EmbeddingLike.toFunLike.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ))) (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ)) (EquivLike.toEmbeddingLike.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ))) (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ)) (Equiv.instEquivLikeEquiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ))))) (toLex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ)) (Sum.inl.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ (FunLike.coe.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (fun (a : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) a) (EmbeddingLike.toFunLike.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))))) (toLex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a))))) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (fun (_x : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumLexAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3))) (FunLike.coe.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ))) (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (fun (_x : Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) => Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ))) (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ)) (EquivLike.toEmbeddingLike.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ))) (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ)) (Equiv.instEquivLikeEquiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ))))) (toLex.{max u1 u3 u2} (Sum.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ)) (Sum.inl.{max u3 u2, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a)) γ (FunLike.coe.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))))) (toLex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inl.{u3, u2} α β a))))) (FunLike.coe.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Equiv.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (fun (_x : Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) => Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) _x) (EmbeddingLike.toFunLike.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Equiv.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (EquivLike.toEmbeddingLike.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Equiv.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Equiv.instEquivLikeEquiv.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))))) (toLex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.inl.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) a))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_assoc_apply_inl_inl OrderIso.sumLexAssoc_apply_inl_inlₓ'. -/
@[simp]
theorem sumLexAssoc_apply_inl_inl :
    sumLexAssoc α β γ (toLex <| inl <| toLex <| inl a) = toLex (inl a) :=
  rfl
#align order_iso.sum_lex_assoc_apply_inl_inl OrderIso.sumLexAssoc_apply_inl_inl

/- warning: order_iso.sum_lex_assoc_apply_inl_inr -> OrderIso.sumLexAssoc_apply_inl_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (b : β), Eq.{succ (max u1 u2 u3)} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (coeFn.{max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3)), max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3))} (OrderIso.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3))) (fun (_x : RelIso.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)))) => (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) -> (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (RelIso.hasCoeToFun.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)))) (OrderIso.sumLexAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3) (coeFn.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Equiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (fun (_x : Equiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) => (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) -> (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (Equiv.hasCoeToFun.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (toLex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.inl.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (toLex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b))))) (coeFn.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (fun (_x : Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) => (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) -> (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (Equiv.hasCoeToFun.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (toLex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.inr.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u2, u3} β γ) (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (fun (_x : Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u2, u3} β γ) (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) => (Sum.{u2, u3} β γ) -> (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Equiv.hasCoeToFun.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u2, u3} β γ) (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (toLex.{max u2 u3} (Sum.{u2, u3} β γ)) (Sum.inl.{u2, u3} β γ b))))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (b : β), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (FunLike.coe.{succ (max u1 u2 u3), succ (max u1 u2 u3), succ (max u1 u2 u3)} (Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ))) (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (fun (a : Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) => Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ)) a) (EmbeddingLike.toFunLike.{succ (max u1 u2 u3), succ (max u1 u2 u3), succ (max u1 u2 u3)} (Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ))) (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ)) (EquivLike.toEmbeddingLike.{succ (max u1 u2 u3), succ (max u1 u2 u3), succ (max u1 u2 u3)} (Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ))) (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ))))) (toLex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ)) (Sum.inl.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ (FunLike.coe.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (fun (a : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) a) (EmbeddingLike.toFunLike.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))))) (toLex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b))))) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (fun (_x : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumLexAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3))) (FunLike.coe.{succ (max u1 u2 u3), succ (max u1 u2 u3), succ (max u1 u2 u3)} (Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ))) (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (fun (_x : Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) => Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2 u3), succ (max u1 u2 u3), succ (max u1 u2 u3)} (Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ))) (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ)) (EquivLike.toEmbeddingLike.{succ (max u1 u2 u3), succ (max u1 u2 u3), succ (max u1 u2 u3)} (Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ))) (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ))))) (toLex.{max u1 u2 u3} (Sum.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ)) (Sum.inl.{max u2 u3, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b)) γ (FunLike.coe.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, u2} α β) => Lex.{max u2 u3} (Sum.{u3, u2} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β)) (EquivLike.toEmbeddingLike.{succ (max u2 u3), succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))) (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β)) (Equiv.instEquivLikeEquiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u3, u2} α β) (Lex.{max u2 u3} (Sum.{u3, u2} α β))))) (toLex.{max u2 u3} (Sum.{u3, u2} α β)) (Sum.inr.{u3, u2} α β b))))) (FunLike.coe.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Equiv.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))))) (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) (fun (_x : Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) => Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b)))) _x) (EmbeddingLike.toFunLike.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Equiv.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))))) (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b)))) (EquivLike.toEmbeddingLike.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Equiv.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))))) (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b)))) (Equiv.instEquivLikeEquiv.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) (Lex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))))))) (toLex.{max (max u2 u1) u3} (Sum.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b)))) (Sum.inr.{u3, max u2 u1} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Sum.{u2, u1} β γ) (fun (_x : Sum.{u2, u1} β γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (toLex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_assoc_apply_inl_inr OrderIso.sumLexAssoc_apply_inl_inrₓ'. -/
@[simp]
theorem sumLexAssoc_apply_inl_inr :
    sumLexAssoc α β γ (toLex <| inl <| toLex <| inr b) = toLex (inr <| toLex <| inl b) :=
  rfl
#align order_iso.sum_lex_assoc_apply_inl_inr OrderIso.sumLexAssoc_apply_inl_inr

/- warning: order_iso.sum_lex_assoc_apply_inr -> OrderIso.sumLexAssoc_apply_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (c : γ), Eq.{succ (max u1 u2 u3)} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (coeFn.{max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3)), max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3))} (OrderIso.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3))) (fun (_x : RelIso.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)))) => (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) -> (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (RelIso.hasCoeToFun.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)))) (OrderIso.sumLexAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3) (coeFn.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Equiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (fun (_x : Equiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) => (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) -> (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (Equiv.hasCoeToFun.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (toLex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.inr.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ c))) (coeFn.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (fun (_x : Equiv.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) => (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) -> (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (Equiv.hasCoeToFun.{succ (max u1 u2 u3), succ (max u1 u2 u3)} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ))))) (toLex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.inr.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u2, u3} β γ) (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (fun (_x : Equiv.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u2, u3} β γ) (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) => (Sum.{u2, u3} β γ) -> (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (Equiv.hasCoeToFun.{succ (max u2 u3), succ (max u2 u3)} (Sum.{u2, u3} β γ) (Lex.{max u2 u3} (Sum.{u2, u3} β γ))) (toLex.{max u2 u3} (Sum.{u2, u3} β γ)) (Sum.inr.{u2, u3} β γ c))))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (c : γ), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (FunLike.coe.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (fun (a : Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) => Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) a) (EmbeddingLike.toFunLike.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (EquivLike.toEmbeddingLike.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Equiv.instEquivLikeEquiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))))) (toLex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.inr.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ c))) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (fun (_x : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumLexAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3))) (FunLike.coe.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (fun (_x : Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) => Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (EquivLike.toEmbeddingLike.{succ (max u1 u3 u2), succ (max u1 u3 u2), succ (max u1 u3 u2)} (Equiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Equiv.instEquivLikeEquiv.{succ (max u1 u3 u2), succ (max u1 u3 u2)} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ) (Lex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))))) (toLex.{max u1 u3 u2} (Sum.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.inr.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ c))) (FunLike.coe.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Equiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))))) (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) (fun (_x : Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) => Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c)))) _x) (EmbeddingLike.toFunLike.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Equiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))))) (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c)))) (EquivLike.toEmbeddingLike.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Equiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))))) (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c)))) (Equiv.instEquivLikeEquiv.{succ (max (max u1 u2) u3), succ (max (max u1 u2) u3)} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))))))) (toLex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c)))) (Sum.inr.{u3, max u1 u2} α ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Sum.{u2, u1} β γ) (fun (_x : Sum.{u2, u1} β γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} β γ) => Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ))) (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} β γ) (Lex.{max u1 u2} (Sum.{u2, u1} β γ))))) (toLex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_assoc_apply_inr OrderIso.sumLexAssoc_apply_inrₓ'. -/
@[simp]
theorem sumLexAssoc_apply_inr :
    sumLexAssoc α β γ (toLex <| inr c) = toLex (inr <| toLex <| inr c) :=
  rfl
#align order_iso.sum_lex_assoc_apply_inr OrderIso.sumLexAssoc_apply_inr

/- warning: order_iso.sum_lex_assoc_symm_apply_inl -> OrderIso.sumLexAssoc_symm_apply_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (a : α), Eq.{succ (max (max u1 u2) u3)} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (OrderIso.{max u1 u2 u3, max (max u1 u2) u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (fun (_x : RelIso.{max u1 u2 u3, max (max u1 u2) u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3))) => (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) -> (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (RelIso.hasCoeToFun.{max u1 u2 u3, max (max u1 u2) u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3))) (OrderIso.symm.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)) (OrderIso.sumLexAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3)) (Sum.inl.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) a)) (Sum.inl.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.inl.{u1, u2} α β a))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (a : α), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.inl.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) a)) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (fun (_x : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) (OrderIso.sumLexAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3)))) (Sum.inl.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) a)) (Sum.inl.{max u2 u3, u1} (Sum.{u3, u2} α β) γ (Sum.inl.{u3, u2} α β a))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_assoc_symm_apply_inl OrderIso.sumLexAssoc_symm_apply_inlₓ'. -/
@[simp]
theorem sumLexAssoc_symm_apply_inl : (sumLexAssoc α β γ).symm (inl a) = inl (inl a) :=
  rfl
#align order_iso.sum_lex_assoc_symm_apply_inl OrderIso.sumLexAssoc_symm_apply_inl

/- warning: order_iso.sum_lex_assoc_symm_apply_inr_inl -> OrderIso.sumLexAssoc_symm_apply_inr_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (b : β), Eq.{succ (max (max u1 u2) u3)} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (OrderIso.{max u1 u2 u3, max (max u1 u2) u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (fun (_x : RelIso.{max u1 u2 u3, max (max u1 u2) u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3))) => (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) -> (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (RelIso.hasCoeToFun.{max u1 u2 u3, max (max u1 u2) u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3))) (OrderIso.symm.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)) (OrderIso.sumLexAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3)) (Sum.inr.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) (Sum.inl.{u2, u3} β γ b))) (Sum.inl.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.inr.{u1, u2} α β b))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (b : β), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.inr.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (fun (_x : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) (OrderIso.sumLexAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3)))) (Sum.inr.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inl.{u2, u1} β γ b))) (Sum.inl.{max u2 u3, u1} (Sum.{u3, u2} α β) γ (Sum.inr.{u3, u2} α β b))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_assoc_symm_apply_inr_inl OrderIso.sumLexAssoc_symm_apply_inr_inlₓ'. -/
@[simp]
theorem sumLexAssoc_symm_apply_inr_inl : (sumLexAssoc α β γ).symm (inr (inl b)) = inl (inr b) :=
  rfl
#align order_iso.sum_lex_assoc_symm_apply_inr_inl OrderIso.sumLexAssoc_symm_apply_inr_inl

/- warning: order_iso.sum_lex_assoc_symm_apply_inr_inr -> OrderIso.sumLexAssoc_symm_apply_inr_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (c : γ), Eq.{succ (max (max u1 u2) u3)} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (OrderIso.{max u1 u2 u3, max (max u1 u2) u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (fun (_x : RelIso.{max u1 u2 u3, max (max u1 u2) u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3))) => (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) -> (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ))) (RelIso.hasCoeToFun.{max u1 u2 u3, max (max u1 u2) u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (LE.le.{max u1 u2 u3} (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3))) (LE.le.{max (max u1 u2) u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3))) (OrderIso.symm.{max (max u1 u2) u3, max u1 u2 u3} (Lex.{max (max u1 u2) u3} (Sum.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ)) (Lex.{max u1 u2 u3} (Sum.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)))) (Sum.Lex.LE.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Sum.Lex.LE.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) _inst_1 (Sum.Lex.LE.{u2, u3} β γ _inst_2 _inst_3)) (OrderIso.sumLexAssoc.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3)) (Sum.inr.{u1, max u2 u3} α (Lex.{max u2 u3} (Sum.{u2, u3} β γ)) (Sum.inr.{u2, u3} β γ c))) (Sum.inr.{max u1 u2, u3} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) γ c)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (c : γ), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.inr.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) (FunLike.coe.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (fun (_x : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) _x) (EmbeddingLike.toFunLike.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Function.Embedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ))) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Function.instEmbeddingLikeEmbedding.{succ (max (max u3 u2) u1), succ (max (max u3 u2) u1)} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)))) (RelEmbedding.toEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) => LE.le.{max (max u3 u2) u1} (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) => LE.le.{max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max (max u3 u2) u1, max (max u3 u2) u1} (Lex.{max u1 u2 u3} (Sum.{max u2 u3, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ)) (Lex.{max (max u1 u2) u3} (Sum.{u3, max u1 u2} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)))) (Sum.Lex.LE.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ (Sum.Lex.LE.{u3, u2} α β _inst_1 _inst_2) _inst_3) (Sum.Lex.LE.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) _inst_1 (Sum.Lex.LE.{u2, u1} β γ _inst_2 _inst_3)) (OrderIso.sumLexAssoc.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3)))) (Sum.inr.{u3, max u2 u1} α (Lex.{max u1 u2} (Sum.{u2, u1} β γ)) (Sum.inr.{u2, u1} β γ c))) (Sum.inr.{max u3 u2, u1} (Lex.{max u2 u3} (Sum.{u3, u2} α β)) γ c)
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_assoc_symm_apply_inr_inr OrderIso.sumLexAssoc_symm_apply_inr_inrₓ'. -/
@[simp]
theorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc α β γ).symm (inr (inr c)) = inr c :=
  rfl
#align order_iso.sum_lex_assoc_symm_apply_inr_inr OrderIso.sumLexAssoc_symm_apply_inr_inr

#print OrderIso.sumLexDualAntidistrib /-
/-- `order_dual` is antidistributive over `⊕ₗ` up to an order isomorphism. -/
def sumLexDualAntidistrib (α β : Type _) [LE α] [LE β] : (α ⊕ₗ β)ᵒᵈ ≃o βᵒᵈ ⊕ₗ αᵒᵈ :=
  { Equiv.sumComm α β with
    map_rel_iff' := by
      rintro (a | a) (b | b); simp
      · change
          toLex (inr <| to_dual a) ≤ toLex (inr <| to_dual b) ↔
            to_dual (toLex <| inl a) ≤ to_dual (toLex <| inl b)
        simp only [to_dual_le_to_dual, lex.inl_le_inl_iff, lex.inr_le_inr_iff]
      · exact iff_of_false lex.not_inr_le_inl lex.not_inr_le_inl
      · exact iff_of_true (lex.inl_le_inr _ _) (lex.inl_le_inr _ _)
      · change
          toLex (inl <| to_dual a) ≤ toLex (inl <| to_dual b) ↔
            to_dual (toLex <| inr a) ≤ to_dual (toLex <| inr b)
        simp only [to_dual_le_to_dual, lex.inl_le_inl_iff, lex.inr_le_inr_iff] }
#align order_iso.sum_lex_dual_antidistrib OrderIso.sumLexDualAntidistrib
-/

/- warning: order_iso.sum_lex_dual_antidistrib_inl -> OrderIso.sumLexDualAntidistrib_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (a : α), Eq.{succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (coeFn.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (OrderIso.{max u1 u2, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2)) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{max u1 u2, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2))) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1)))) => (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) -> (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α)))) (RelIso.hasCoeToFun.{max u1 u2, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2))) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1)))) (OrderIso.sumLexDualAntidistrib.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.toDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a))) (Sum.inr.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α) a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (a : α), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (a : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) a) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α)))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (fun (_x : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α)))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Function.instEmbeddingLikeEmbedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))))) (RelEmbedding.toEmbedding.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumLexDualAntidistrib.{u2, u1} α β _inst_1 _inst_2))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a))) (Sum.inr.{u1, u2} (OrderDual.{u1} β) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : α) => OrderDual.{u2} α) a) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : α) => OrderDual.{u2} α) _x) (EmbeddingLike.toFunLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (EquivLike.toEmbeddingLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (Equiv.instEquivLikeEquiv.{succ u2, succ u2} α (OrderDual.{u2} α)))) (OrderDual.toDual.{u2} α) a))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_dual_antidistrib_inl OrderIso.sumLexDualAntidistrib_inlₓ'. -/
@[simp]
theorem sumLexDualAntidistrib_inl : sumLexDualAntidistrib α β (toDual (inl a)) = inr (toDual a) :=
  rfl
#align order_iso.sum_lex_dual_antidistrib_inl OrderIso.sumLexDualAntidistrib_inl

/- warning: order_iso.sum_lex_dual_antidistrib_inr -> OrderIso.sumLexDualAntidistrib_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (b : β), Eq.{succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (coeFn.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (OrderIso.{max u1 u2, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2)) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{max u1 u2, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2))) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1)))) => (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) -> (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α)))) (RelIso.hasCoeToFun.{max u1 u2, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2))) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1)))) (OrderIso.sumLexDualAntidistrib.{u1, u2} α β _inst_1 _inst_2) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.toDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b))) (Sum.inl.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} β (OrderDual.{u2} β)) (fun (_x : Equiv.{succ u2, succ u2} β (OrderDual.{u2} β)) => β -> (OrderDual.{u2} β)) (Equiv.hasCoeToFun.{succ u2, succ u2} β (OrderDual.{u2} β)) (OrderDual.toDual.{u2} β) b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (b : β), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (a : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) a) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α)))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (fun (_x : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α)))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Function.instEmbeddingLikeEmbedding.{succ (max u2 u1), succ (max u2 u1)} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))))) (RelEmbedding.toEmbedding.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.sumLexDualAntidistrib.{u2, u1} α β _inst_1 _inst_2))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))) (Sum.inl.{u1, u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : β) => OrderDual.{u1} β) b) (OrderDual.{u2} α) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : β) => OrderDual.{u1} β) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} β (OrderDual.{u1} β)))) (OrderDual.toDual.{u1} β) b))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_dual_antidistrib_inr OrderIso.sumLexDualAntidistrib_inrₓ'. -/
@[simp]
theorem sumLexDualAntidistrib_inr : sumLexDualAntidistrib α β (toDual (inr b)) = inl (toDual b) :=
  rfl
#align order_iso.sum_lex_dual_antidistrib_inr OrderIso.sumLexDualAntidistrib_inr

/- warning: order_iso.sum_lex_dual_antidistrib_symm_inl -> OrderIso.sumLexDualAntidistrib_symm_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (b : β), Eq.{succ (max u1 u2)} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (coeFn.{max (succ (max u2 u1)) (succ (max u1 u2)), max (succ (max u2 u1)) (succ (max u1 u2))} (OrderIso.{max u2 u1, max u1 u2} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2))) (fun (_x : RelIso.{max u2 u1, max u1 u2} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2)))) => (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) -> (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)))) (RelIso.hasCoeToFun.{max u2 u1, max u1 u2} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2)))) (OrderIso.symm.{max u1 u2, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2)) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1)) (OrderIso.sumLexDualAntidistrib.{u1, u2} α β _inst_1 _inst_2)) (Sum.inl.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} β (OrderDual.{u2} β)) (fun (_x : Equiv.{succ u2, succ u2} β (OrderDual.{u2} β)) => β -> (OrderDual.{u2} β)) (Equiv.hasCoeToFun.{succ u2, succ u2} β (OrderDual.{u2} β)) (OrderDual.toDual.{u2} β) b))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.toDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inr.{u1, u2} α β b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (b : β), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.inl.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (fun (a : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : β) => OrderDual.{u1} β) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} β (OrderDual.{u1} β)))) (OrderDual.toDual.{u1} β) b))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β)))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (fun (_x : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β)))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Function.instEmbeddingLikeEmbedding.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (RelEmbedding.toEmbedding.{max u2 u1, max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => LE.le.{max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u2 u1, max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => LE.le.{max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) (OrderIso.sumLexDualAntidistrib.{u2, u1} α β _inst_1 _inst_2)))) (Sum.inl.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : β) => OrderDual.{u1} β) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} β (OrderDual.{u1} β)) β (OrderDual.{u1} β) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} β (OrderDual.{u1} β)))) (OrderDual.toDual.{u1} β) b))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inr.{u2, u1} α β b))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_dual_antidistrib_symm_inl OrderIso.sumLexDualAntidistrib_symm_inlₓ'. -/
@[simp]
theorem sumLexDualAntidistrib_symm_inl :
    (sumLexDualAntidistrib α β).symm (inl (toDual b)) = toDual (inr b) :=
  rfl
#align order_iso.sum_lex_dual_antidistrib_symm_inl OrderIso.sumLexDualAntidistrib_symm_inl

/- warning: order_iso.sum_lex_dual_antidistrib_symm_inr -> OrderIso.sumLexDualAntidistrib_symm_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (a : α), Eq.{succ (max u1 u2)} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (coeFn.{max (succ (max u2 u1)) (succ (max u1 u2)), max (succ (max u2 u1)) (succ (max u1 u2))} (OrderIso.{max u2 u1, max u1 u2} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2))) (fun (_x : RelIso.{max u2 u1, max u1 u2} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2)))) => (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) -> (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)))) (RelIso.hasCoeToFun.{max u2 u1, max u1 u2} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{max u1 u2} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2)))) (OrderIso.symm.{max u1 u2, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β))) (Lex.{max u2 u1} (Sum.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α))) (OrderDual.hasLe.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.Lex.LE.{u1, u2} α β _inst_1 _inst_2)) (Sum.Lex.LE.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (OrderDual.hasLe.{u2} β _inst_2) (OrderDual.hasLe.{u1} α _inst_1)) (OrderIso.sumLexDualAntidistrib.{u1, u2} α β _inst_1 _inst_2)) (Sum.inr.{u2, u1} (OrderDual.{u2} β) (OrderDual.{u1} α) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α) a))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) => (Sum.{u1, u2} α β) -> (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α β) (OrderDual.{max u1 u2} (Sum.{u1, u2} α β))) (OrderDual.toDual.{max u1 u2} (Sum.{u1, u2} α β)) (Sum.inl.{u1, u2} α β a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (a : α), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.inr.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (fun (a : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : α) => OrderDual.{u2} α) a) (EmbeddingLike.toFunLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (EquivLike.toEmbeddingLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (Equiv.instEquivLikeEquiv.{succ u2, succ u2} α (OrderDual.{u2} α)))) (OrderDual.toDual.{u2} α) a))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β)))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (fun (_x : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β)))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Function.instEmbeddingLikeEmbedding.{succ (max u2 u1), succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))))) (RelEmbedding.toEmbedding.{max u2 u1, max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => LE.le.{max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u2 u1, max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) => LE.le.{max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max u2 u1, max u2 u1} (OrderDual.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α β))) (Lex.{max u2 u1} (Sum.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α))) (OrderDual.instLEOrderDual.{max u2 u1} (Lex.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.Lex.LE.{u2, u1} α β _inst_1 _inst_2)) (Sum.Lex.LE.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (OrderDual.instLEOrderDual.{u1} β _inst_2) (OrderDual.instLEOrderDual.{u2} α _inst_1)) (OrderIso.sumLexDualAntidistrib.{u2, u1} α β _inst_1 _inst_2)))) (Sum.inr.{u1, u2} (OrderDual.{u1} β) (OrderDual.{u2} α) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : α) => OrderDual.{u2} α) _x) (EmbeddingLike.toFunLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (EquivLike.toEmbeddingLike.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (OrderDual.{u2} α) (Equiv.instEquivLikeEquiv.{succ u2, succ u2} α (OrderDual.{u2} α)))) (OrderDual.toDual.{u2} α) a))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (fun (_x : Sum.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α β) => OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))) (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α β) (OrderDual.{max u1 u2} (Sum.{u2, u1} α β))))) (OrderDual.toDual.{max u1 u2} (Sum.{u2, u1} α β)) (Sum.inl.{u2, u1} α β a))
Case conversion may be inaccurate. Consider using '#align order_iso.sum_lex_dual_antidistrib_symm_inr OrderIso.sumLexDualAntidistrib_symm_inrₓ'. -/
@[simp]
theorem sumLexDualAntidistrib_symm_inr :
    (sumLexDualAntidistrib α β).symm (inr (toDual a)) = toDual (inl a) :=
  rfl
#align order_iso.sum_lex_dual_antidistrib_symm_inr OrderIso.sumLexDualAntidistrib_symm_inr

end OrderIso

variable [LE α]

namespace WithBot

/- warning: with_bot.order_iso_punit_sum_lex -> WithBot.orderIsoPUnitSumLex is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], OrderIso.{u1, max u2 u1} (WithBot.{u1} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], OrderIso.{u1, max u1 u2} (WithBot.{u1} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.le.{u1} α _inst_1) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (DistribLattice.toLattice.{u2} PUnit.{succ u2} (instDistribLattice.{u2} PUnit.{succ u2} PUnit.instLinearOrderPUnit.{u2})))))) _inst_1)
Case conversion may be inaccurate. Consider using '#align with_bot.order_iso_punit_sum_lex WithBot.orderIsoPUnitSumLexₓ'. -/
/-- `with_bot α` is order-isomorphic to `punit ⊕ₗ α`, by sending `⊥` to `punit.star` and `↑a` to
`a`. -/
def orderIsoPUnitSumLex : WithBot α ≃o PUnit ⊕ₗ α :=
  ⟨(Equiv.optionEquivSumPUnit α).trans <| (Equiv.sumComm _ _).trans toLex, by
    rintro (a | _) (b | _) <;> simp <;> exact not_coe_le_bot _⟩
#align with_bot.order_iso_punit_sum_lex WithBot.orderIsoPUnitSumLex

/- warning: with_bot.order_iso_punit_sum_lex_bot -> WithBot.orderIsoPUnitSumLex_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (OrderIso.{u1, max u2 u1} (WithBot.{u1} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1)) (fun (_x : RelIso.{u1, max u2 u1} (WithBot.{u1} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (LE.le.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1))) => (WithBot.{u1} α) -> (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (RelIso.hasCoeToFun.{u1, max u2 u1} (WithBot.{u1} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (LE.le.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1))) (WithBot.orderIsoPUnitSumLex.{u1, u2} α _inst_1) (Bot.bot.{u1} (WithBot.{u1} α) (WithBot.hasBot.{u1} α))) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (fun (_x : Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) => (Sum.{u2, u1} PUnit.{succ u2} α) -> (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (toLex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.inl.{u2, u1} PUnit.{succ u2} α PUnit.unit.{succ u2}))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LE.{u2} α], Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : WithBot.{u2} α) => Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Bot.bot.{u2} (WithBot.{u2} α) (WithBot.bot.{u2} α))) (FunLike.coe.{max (succ u2) (succ (max u2 u1)), succ u2, succ (max u2 u1)} (Function.Embedding.{succ u2, succ (max u2 u1)} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (WithBot.{u2} α) (fun (_x : WithBot.{u2} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : WithBot.{u2} α) => Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ (max u2 u1)), succ u2, succ (max u2 u1)} (Function.Embedding.{succ u2, succ (max u2 u1)} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u2, succ (max u2 u1)} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)))) (RelEmbedding.toEmbedding.{u2, max u2 u1} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u2} α) => LE.le.{u2} (WithBot.{u2} α) (WithBot.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.Lex.LE.{u1, u2} PUnit.{succ u1} α (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1})))))) _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, max u2 u1} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u2} α) => LE.le.{u2} (WithBot.{u2} α) (WithBot.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.Lex.LE.{u1, u2} PUnit.{succ u1} α (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1})))))) _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithBot.orderIsoPUnitSumLex.{u2, u1} α _inst_1))) (Bot.bot.{u2} (WithBot.{u2} α) (WithBot.bot.{u2} α))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (fun (_x : Sum.{u1, u2} PUnit.{succ u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u1, u2} PUnit.{succ u1} α) => Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))))) (toLex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.inl.{u1, u2} PUnit.{succ u1} α PUnit.unit.{succ u1}))
Case conversion may be inaccurate. Consider using '#align with_bot.order_iso_punit_sum_lex_bot WithBot.orderIsoPUnitSumLex_botₓ'. -/
@[simp]
theorem orderIsoPUnitSumLex_bot : @orderIsoPUnitSumLex α _ ⊥ = toLex (inl PUnit.unit) :=
  rfl
#align with_bot.order_iso_punit_sum_lex_bot WithBot.orderIsoPUnitSumLex_bot

/- warning: with_bot.order_iso_punit_sum_lex_coe -> WithBot.orderIsoPUnitSumLex_toLex is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ (max u2 u1)} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (OrderIso.{u1, max u2 u1} (WithBot.{u1} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1)) (fun (_x : RelIso.{u1, max u2 u1} (WithBot.{u1} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (LE.le.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1))) => (WithBot.{u1} α) -> (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (RelIso.hasCoeToFun.{u1, max u2 u1} (WithBot.{u1} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (LE.le.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1))) (WithBot.orderIsoPUnitSumLex.{u1, u2} α _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (WithBot.{u1} α) (HasLiftT.mk.{succ u1, succ u1} α (WithBot.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} α (WithBot.{u1} α) (WithBot.hasCoeT.{u1} α))) a)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (fun (_x : Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) => (Sum.{u2, u1} PUnit.{succ u2} α) -> (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (toLex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.inr.{u2, u1} PUnit.{succ u2} α a))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LE.{u2} α] (a : α), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : WithBot.{u2} α) => Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (WithBot.some.{u2} α a)) (FunLike.coe.{max (succ u2) (succ (max u1 u2)), succ u2, succ (max u1 u2)} (Function.Embedding.{succ u2, succ (max u1 u2)} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (WithBot.{u2} α) (fun (_x : WithBot.{u2} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : WithBot.{u2} α) => Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ (max u1 u2)), succ u2, succ (max u1 u2)} (Function.Embedding.{succ u2, succ (max u1 u2)} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u2, succ (max u1 u2)} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)))) (RelEmbedding.toEmbedding.{u2, max u1 u2} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u2} α) => LE.le.{u2} (WithBot.{u2} α) (WithBot.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.Lex.LE.{u1, u2} PUnit.{succ u1} α (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1})))))) _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, max u1 u2} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u2} α) => LE.le.{u2} (WithBot.{u2} α) (WithBot.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) => LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.Lex.LE.{u1, u2} PUnit.{succ u1} α (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1})))))) _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithBot.orderIsoPUnitSumLex.{u2, u1} α _inst_1))) (WithBot.some.{u2} α a)) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (fun (_x : Sum.{u1, u2} PUnit.{succ u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u1, u2} PUnit.{succ u1} α) => Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))))) (toLex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.inr.{u1, u2} PUnit.{succ u1} α a))
Case conversion may be inaccurate. Consider using '#align with_bot.order_iso_punit_sum_lex_coe WithBot.orderIsoPUnitSumLex_toLexₓ'. -/
@[simp]
theorem orderIsoPUnitSumLex_toLex (a : α) : orderIsoPUnitSumLex ↑a = toLex (inr a) :=
  rfl
#align with_bot.order_iso_punit_sum_lex_coe WithBot.orderIsoPUnitSumLex_toLex

/- warning: with_bot.order_iso_punit_sum_lex_symm_inl -> WithBot.orderIsoPUnitSumLex_symm_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (x : PUnit.{succ u2}), Eq.{succ u1} (WithBot.{u1} α) (coeFn.{max (succ (max u2 u1)) (succ u1), max (succ (max u2 u1)) (succ u1)} (OrderIso.{max u2 u1, u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1) (WithBot.hasLe.{u1} α _inst_1)) (fun (_x : RelIso.{max u2 u1, u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1)) (LE.le.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) => (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) -> (WithBot.{u1} α)) (RelIso.hasCoeToFun.{max u2 u1, u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1)) (LE.le.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) (OrderIso.symm.{u1, max u2 u1} (WithBot.{u1} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1) (WithBot.orderIsoPUnitSumLex.{u1, u2} α _inst_1)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (fun (_x : Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) => (Sum.{u2, u1} PUnit.{succ u2} α) -> (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (toLex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.inl.{u2, u1} PUnit.{succ u2} α x))) (Bot.bot.{u1} (WithBot.{u1} α) (WithBot.hasBot.{u1} α))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (x : PUnit.{succ u2}), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) => WithBot.{u1} α) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))) (Sum.{u2, u1} PUnit.{succ u2} α) (fun (a : Sum.{u2, u1} PUnit.{succ u2} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} PUnit.{succ u2} α) => Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) a) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))) (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))) (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))))) (toLex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.inl.{u2, u1} PUnit.{succ u2} α x))) (FunLike.coe.{max (succ (max u1 u2)) (succ u1), succ (max u1 u2), succ u1} (Function.Embedding.{succ (max u1 u2), succ u1} (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α)) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (fun (_x : Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) => WithBot.{u1} α) _x) (EmbeddingLike.toFunLike.{max (succ (max u1 u2)) (succ u1), succ (max u1 u2), succ u1} (Function.Embedding.{succ (max u1 u2), succ u1} (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α)) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α) (Function.instEmbeddingLikeEmbedding.{succ (max u1 u2), succ u1} (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α))) (RelEmbedding.toEmbedding.{max u1 u2, u1} (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) => LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (DistribLattice.toLattice.{u2} PUnit.{succ u2} (instDistribLattice.{u2} PUnit.{succ u2} PUnit.instLinearOrderPUnit.{u2})))))) _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithBot.{u1} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithBot.{u1} α) => LE.le.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u1 u2, u1} (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) => LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (DistribLattice.toLattice.{u2} PUnit.{succ u2} (instDistribLattice.{u2} PUnit.{succ u2} PUnit.instLinearOrderPUnit.{u2})))))) _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithBot.{u1} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithBot.{u1} α) => LE.le.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u1, max u1 u2} (WithBot.{u1} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.le.{u1} α _inst_1) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (DistribLattice.toLattice.{u2} PUnit.{succ u2} (instDistribLattice.{u2} PUnit.{succ u2} PUnit.instLinearOrderPUnit.{u2})))))) _inst_1) (WithBot.orderIsoPUnitSumLex.{u1, u2} α _inst_1)))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))) (Sum.{u2, u1} PUnit.{succ u2} α) (fun (_x : Sum.{u2, u1} PUnit.{succ u2} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} PUnit.{succ u2} α) => Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))) (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))) (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))))) (toLex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.inl.{u2, u1} PUnit.{succ u2} α x))) (Bot.bot.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) => WithBot.{u1} α) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))) (Sum.{u2, u1} PUnit.{succ u2} α) (fun (a : Sum.{u2, u1} PUnit.{succ u2} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} PUnit.{succ u2} α) => Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) a) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))) (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))) (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α))))) (toLex.{max u1 u2} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.inl.{u2, u1} PUnit.{succ u2} α x))) (WithBot.bot.{u1} α))
Case conversion may be inaccurate. Consider using '#align with_bot.order_iso_punit_sum_lex_symm_inl WithBot.orderIsoPUnitSumLex_symm_inlₓ'. -/
@[simp]
theorem orderIsoPUnitSumLex_symm_inl (x : PUnit) :
    (@orderIsoPUnitSumLex α _).symm (toLex <| inl x) = ⊥ :=
  rfl
#align with_bot.order_iso_punit_sum_lex_symm_inl WithBot.orderIsoPUnitSumLex_symm_inl

/- warning: with_bot.order_iso_punit_sum_lex_symm_inr -> WithBot.orderIsoPUnitSumLex_symm_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} (WithBot.{u1} α) (coeFn.{max (succ (max u2 u1)) (succ u1), max (succ (max u2 u1)) (succ u1)} (OrderIso.{max u2 u1, u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1) (WithBot.hasLe.{u1} α _inst_1)) (fun (_x : RelIso.{max u2 u1, u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1)) (LE.le.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) => (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) -> (WithBot.{u1} α)) (RelIso.hasCoeToFun.{max u2 u1, u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.{u1} α) (LE.le.{max u2 u1} (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1)) (LE.le.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) (OrderIso.symm.{u1, max u2 u1} (WithBot.{u1} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (WithBot.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u2, u1} PUnit.{succ u2} α (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))) _inst_1) (WithBot.orderIsoPUnitSumLex.{u1, u2} α _inst_1)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (fun (_x : Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) => (Sum.{u2, u1} PUnit.{succ u2} α) -> (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u2, u1} PUnit.{succ u2} α) (Lex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α))) (toLex.{max u2 u1} (Sum.{u2, u1} PUnit.{succ u2} α)) (Sum.inr.{u2, u1} PUnit.{succ u2} α a))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (WithBot.{u1} α) (HasLiftT.mk.{succ u1, succ u1} α (WithBot.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} α (WithBot.{u1} α) (WithBot.hasCoeT.{u1} α))) a)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LE.{u2} α] (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) => WithBot.{u2} α) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (fun (a : Sum.{u1, u2} PUnit.{succ u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u1, u2} PUnit.{succ u1} α) => Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) a) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))))) (toLex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.inr.{u1, u2} PUnit.{succ u1} α a))) (FunLike.coe.{max (succ (max u1 u2)) (succ u2), succ (max u1 u2), succ u2} (Function.Embedding.{succ (max u1 u2), succ u2} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (WithBot.{u2} α)) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (fun (_x : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) => WithBot.{u2} α) _x) (EmbeddingLike.toFunLike.{max (succ (max u1 u2)) (succ u2), succ (max u1 u2), succ u2} (Function.Embedding.{succ (max u1 u2), succ u2} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (WithBot.{u2} α)) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (WithBot.{u2} α) (Function.instEmbeddingLikeEmbedding.{succ (max u1 u2), succ u2} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (WithBot.{u2} α))) (RelEmbedding.toEmbedding.{max u1 u2, u2} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (WithBot.{u2} α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) => LE.le.{max u1 u2} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.Lex.LE.{u1, u2} PUnit.{succ u1} α (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1})))))) _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithBot.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithBot.{u2} α) => LE.le.{u2} (WithBot.{u2} α) (WithBot.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u1 u2, u2} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (WithBot.{u2} α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) => LE.le.{max u1 u2} (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.Lex.LE.{u1, u2} PUnit.{succ u1} α (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1})))))) _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithBot.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithBot.{u2} α) => LE.le.{u2} (WithBot.{u2} α) (WithBot.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, max u1 u2} (WithBot.{u2} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (WithBot.le.{u2} α _inst_1) (Sum.Lex.LE.{u1, u2} PUnit.{succ u1} α (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1})))))) _inst_1) (WithBot.orderIsoPUnitSumLex.{u2, u1} α _inst_1)))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (fun (_x : Sum.{u1, u2} PUnit.{succ u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u1, u2} PUnit.{succ u1} α) => Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))) (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} PUnit.{succ u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α))))) (toLex.{max u2 u1} (Sum.{u1, u2} PUnit.{succ u1} α)) (Sum.inr.{u1, u2} PUnit.{succ u1} α a))) (WithBot.some.{u2} α a)
Case conversion may be inaccurate. Consider using '#align with_bot.order_iso_punit_sum_lex_symm_inr WithBot.orderIsoPUnitSumLex_symm_inrₓ'. -/
@[simp]
theorem orderIsoPUnitSumLex_symm_inr (a : α) : orderIsoPUnitSumLex.symm (toLex <| inr a) = a :=
  rfl
#align with_bot.order_iso_punit_sum_lex_symm_inr WithBot.orderIsoPUnitSumLex_symm_inr

end WithBot

namespace WithTop

/- warning: with_top.order_iso_sum_lex_punit -> WithTop.orderIsoSumLexPUnit is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], OrderIso.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], OrderIso.{u1, max u2 u1} (WithTop.{u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.le.{u1} α _inst_1) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (DistribLattice.toLattice.{u2} PUnit.{succ u2} (instDistribLattice.{u2} PUnit.{succ u2} PUnit.instLinearOrderPUnit.{u2})))))))
Case conversion may be inaccurate. Consider using '#align with_top.order_iso_sum_lex_punit WithTop.orderIsoSumLexPUnitₓ'. -/
/-- `with_top α` is order-isomorphic to `α ⊕ₗ punit`, by sending `⊤` to `punit.star` and `↑a` to
`a`. -/
def orderIsoSumLexPUnit : WithTop α ≃o α ⊕ₗ PUnit :=
  ⟨(Equiv.optionEquivSumPUnit α).trans toLex, by
    rintro (a | _) (b | _) <;> simp <;> exact not_top_le_coe _⟩
#align with_top.order_iso_sum_lex_punit WithTop.orderIsoSumLexPUnit

/- warning: with_top.order_iso_sum_lex_punit_top -> WithTop.orderIsoSumLexPUnit_top is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (coeFn.{max (succ u1) (succ (max u1 u2)), max (succ u1) (succ (max u1 u2))} (OrderIso.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))))) (fun (_x : RelIso.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (LE.le.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2})))))))) => (WithTop.{u1} α) -> (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (RelIso.hasCoeToFun.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (LE.le.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2})))))))) (WithTop.orderIsoSumLexPUnit.{u1, u2} α _inst_1) (Top.top.{u1} (WithTop.{u1} α) (WithTop.hasTop.{u1} α))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) => (Sum.{u1, u2} α PUnit.{succ u2}) -> (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (toLex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.inr.{u1, u2} α PUnit.{succ u2} PUnit.unit.{succ u2}))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LE.{u2} α], Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : WithTop.{u2} α) => Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Top.top.{u2} (WithTop.{u2} α) (WithTop.top.{u2} α))) (FunLike.coe.{max (succ u2) (succ (max u2 u1)), succ u2, succ (max u2 u1)} (Function.Embedding.{succ u2, succ (max u2 u1)} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (WithTop.{u2} α) (fun (_x : WithTop.{u2} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : WithTop.{u2} α) => Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ (max u2 u1)), succ u2, succ (max u2 u1)} (Function.Embedding.{succ u2, succ (max u2 u1)} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Function.instEmbeddingLikeEmbedding.{succ u2, succ (max u2 u1)} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})))) (RelEmbedding.toEmbedding.{u2, max u2 u1} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u2} α) => LE.le.{u2} (WithTop.{u2} α) (WithTop.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) => LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.Lex.LE.{u2, u1} α PUnit.{succ u1} _inst_1 (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1}))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, max u2 u1} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u2} α) => LE.le.{u2} (WithTop.{u2} α) (WithTop.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) => LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.Lex.LE.{u2, u1} α PUnit.{succ u1} _inst_1 (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1}))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithTop.orderIsoSumLexPUnit.{u2, u1} α _inst_1))) (Top.top.{u2} (WithTop.{u2} α) (WithTop.top.{u2} α))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (fun (_x : Sum.{u2, u1} α PUnit.{succ u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α PUnit.{succ u1}) => Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))))) (toLex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.inr.{u2, u1} α PUnit.{succ u1} PUnit.unit.{succ u1}))
Case conversion may be inaccurate. Consider using '#align with_top.order_iso_sum_lex_punit_top WithTop.orderIsoSumLexPUnit_topₓ'. -/
@[simp]
theorem orderIsoSumLexPUnit_top : @orderIsoSumLexPUnit α _ ⊤ = toLex (inr PUnit.unit) :=
  rfl
#align with_top.order_iso_sum_lex_punit_top WithTop.orderIsoSumLexPUnit_top

/- warning: with_top.order_iso_sum_lex_punit_coe -> WithTop.orderIsoSumLexPUnit_toLex is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ (max u1 u2)} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (coeFn.{max (succ u1) (succ (max u1 u2)), max (succ u1) (succ (max u1 u2))} (OrderIso.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))))) (fun (_x : RelIso.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (LE.le.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2})))))))) => (WithTop.{u1} α) -> (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (RelIso.hasCoeToFun.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (LE.le.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2})))))))) (WithTop.orderIsoSumLexPUnit.{u1, u2} α _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (WithTop.{u1} α) (HasLiftT.mk.{succ u1, succ u1} α (WithTop.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} α (WithTop.{u1} α) (WithTop.hasCoeT.{u1} α))) a)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) => (Sum.{u1, u2} α PUnit.{succ u2}) -> (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (toLex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.inl.{u1, u2} α PUnit.{succ u2} a))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LE.{u2} α] (a : α), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : WithTop.{u2} α) => Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (WithTop.some.{u2} α a)) (FunLike.coe.{max (succ u2) (succ (max u1 u2)), succ u2, succ (max u1 u2)} (Function.Embedding.{succ u2, succ (max u1 u2)} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (WithTop.{u2} α) (fun (_x : WithTop.{u2} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : WithTop.{u2} α) => Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ (max u1 u2)), succ u2, succ (max u1 u2)} (Function.Embedding.{succ u2, succ (max u1 u2)} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Function.instEmbeddingLikeEmbedding.{succ u2, succ (max u1 u2)} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})))) (RelEmbedding.toEmbedding.{u2, max u1 u2} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u2} α) => LE.le.{u2} (WithTop.{u2} α) (WithTop.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) => LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.Lex.LE.{u2, u1} α PUnit.{succ u1} _inst_1 (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1}))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, max u1 u2} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u2} α) => LE.le.{u2} (WithTop.{u2} α) (WithTop.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) => LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.Lex.LE.{u2, u1} α PUnit.{succ u1} _inst_1 (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1}))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithTop.orderIsoSumLexPUnit.{u2, u1} α _inst_1))) (WithTop.some.{u2} α a)) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (fun (_x : Sum.{u2, u1} α PUnit.{succ u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α PUnit.{succ u1}) => Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))))) (toLex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.inl.{u2, u1} α PUnit.{succ u1} a))
Case conversion may be inaccurate. Consider using '#align with_top.order_iso_sum_lex_punit_coe WithTop.orderIsoSumLexPUnit_toLexₓ'. -/
@[simp]
theorem orderIsoSumLexPUnit_toLex (a : α) : orderIsoSumLexPUnit ↑a = toLex (inl a) :=
  rfl
#align with_top.order_iso_sum_lex_punit_coe WithTop.orderIsoSumLexPUnit_toLex

/- warning: with_top.order_iso_sum_lex_punit_symm_inr -> WithTop.orderIsoSumLexPUnit_symm_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (x : PUnit.{succ u2}), Eq.{succ u1} (WithTop.{u1} α) (coeFn.{max (succ (max u1 u2)) (succ u1), max (succ (max u1 u2)) (succ u1)} (OrderIso.{max u1 u2, u1} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2})))))) (WithTop.hasLe.{u1} α _inst_1)) (fun (_x : RelIso.{max u1 u2, u1} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))))) (LE.le.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) => (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) -> (WithTop.{u1} α)) (RelIso.hasCoeToFun.{max u1 u2, u1} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))))) (LE.le.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) (OrderIso.symm.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2})))))) (WithTop.orderIsoSumLexPUnit.{u1, u2} α _inst_1)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) => (Sum.{u1, u2} α PUnit.{succ u2}) -> (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (toLex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.inr.{u1, u2} α PUnit.{succ u2} x))) (Top.top.{u1} (WithTop.{u1} α) (WithTop.hasTop.{u1} α))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (x : PUnit.{succ u2}), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) => WithTop.{u1} α) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))) (Sum.{u1, u2} α PUnit.{succ u2}) (fun (a : Sum.{u1, u2} α PUnit.{succ u2}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u1, u2} α PUnit.{succ u2}) => Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) a) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))) (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))) (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))))) (toLex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.inr.{u1, u2} α PUnit.{succ u2} x))) (FunLike.coe.{max (succ (max u1 u2)) (succ u1), succ (max u1 u2), succ u1} (Function.Embedding.{succ (max u1 u2), succ u1} (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α)) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (fun (_x : Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) => WithTop.{u1} α) _x) (EmbeddingLike.toFunLike.{max (succ (max u1 u2)) (succ u1), succ (max u1 u2), succ u1} (Function.Embedding.{succ (max u1 u2), succ u1} (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α)) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α) (Function.instEmbeddingLikeEmbedding.{succ (max u1 u2), succ u1} (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α))) (RelEmbedding.toEmbedding.{max u1 u2, u1} (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) => LE.le.{max u1 u2} (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (DistribLattice.toLattice.{u2} PUnit.{succ u2} (instDistribLattice.{u2} PUnit.{succ u2} PUnit.instLinearOrderPUnit.{u2}))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithTop.{u1} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithTop.{u1} α) => LE.le.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u1 u2, u1} (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) => LE.le.{max u1 u2} (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (DistribLattice.toLattice.{u2} PUnit.{succ u2} (instDistribLattice.{u2} PUnit.{succ u2} PUnit.instLinearOrderPUnit.{u2}))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithTop.{u1} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithTop.{u1} α) => LE.le.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.le.{u1} α _inst_1) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (DistribLattice.toLattice.{u2} PUnit.{succ u2} (instDistribLattice.{u2} PUnit.{succ u2} PUnit.instLinearOrderPUnit.{u2}))))))) (WithTop.orderIsoSumLexPUnit.{u1, u2} α _inst_1)))) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))) (Sum.{u1, u2} α PUnit.{succ u2}) (fun (_x : Sum.{u1, u2} α PUnit.{succ u2}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u1, u2} α PUnit.{succ u2}) => Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))) (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))) (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))))) (toLex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.inr.{u1, u2} α PUnit.{succ u2} x))) (Top.top.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) => WithTop.{u1} α) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))) (Sum.{u1, u2} α PUnit.{succ u2}) (fun (a : Sum.{u1, u2} α PUnit.{succ u2}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u1, u2} α PUnit.{succ u2}) => Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) a) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))) (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (EquivLike.toEmbeddingLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Equiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))) (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (Equiv.instEquivLikeEquiv.{succ (max u2 u1), succ (max u2 u1)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2}))))) (toLex.{max u2 u1} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.inr.{u1, u2} α PUnit.{succ u2} x))) (WithTop.top.{u1} α))
Case conversion may be inaccurate. Consider using '#align with_top.order_iso_sum_lex_punit_symm_inr WithTop.orderIsoSumLexPUnit_symm_inrₓ'. -/
@[simp]
theorem orderIsoSumLexPUnit_symm_inr (x : PUnit) :
    (@orderIsoSumLexPUnit α _).symm (toLex <| inr x) = ⊤ :=
  rfl
#align with_top.order_iso_sum_lex_punit_symm_inr WithTop.orderIsoSumLexPUnit_symm_inr

/- warning: with_top.order_iso_sum_lex_punit_symm_inl -> WithTop.orderIsoSumLexPUnit_symm_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} (WithTop.{u1} α) (coeFn.{max (succ (max u1 u2)) (succ u1), max (succ (max u1 u2)) (succ u1)} (OrderIso.{max u1 u2, u1} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2})))))) (WithTop.hasLe.{u1} α _inst_1)) (fun (_x : RelIso.{max u1 u2, u1} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))))) (LE.le.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) => (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) -> (WithTop.{u1} α)) (RelIso.hasCoeToFun.{max u1 u2, u1} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.{u1} α) (LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2}))))))) (LE.le.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) (OrderIso.symm.{u1, max u1 u2} (WithTop.{u1} α) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (WithTop.hasLe.{u1} α _inst_1) (Sum.Lex.LE.{u1, u2} α PUnit.{succ u2} _inst_1 (Preorder.toLE.{u2} PUnit.{succ u2} (PartialOrder.toPreorder.{u2} PUnit.{succ u2} (SemilatticeInf.toPartialOrder.{u2} PUnit.{succ u2} (Lattice.toSemilatticeInf.{u2} PUnit.{succ u2} (LinearOrder.toLattice.{u2} PUnit.{succ u2} PUnit.linearOrder.{u2})))))) (WithTop.orderIsoSumLexPUnit.{u1, u2} α _inst_1)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (fun (_x : Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) => (Sum.{u1, u2} α PUnit.{succ u2}) -> (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (Equiv.hasCoeToFun.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u1, u2} α PUnit.{succ u2}) (Lex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2}))) (toLex.{max u1 u2} (Sum.{u1, u2} α PUnit.{succ u2})) (Sum.inl.{u1, u2} α PUnit.{succ u2} a))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (WithTop.{u1} α) (HasLiftT.mk.{succ u1, succ u1} α (WithTop.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} α (WithTop.{u1} α) (WithTop.hasCoeT.{u1} α))) a)
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : LE.{u2} α] (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) => WithTop.{u2} α) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (fun (a : Sum.{u2, u1} α PUnit.{succ u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α PUnit.{succ u1}) => Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) a) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))))) (toLex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.inl.{u2, u1} α PUnit.{succ u1} a))) (FunLike.coe.{max (succ (max u1 u2)) (succ u2), succ (max u1 u2), succ u2} (Function.Embedding.{succ (max u1 u2), succ u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (WithTop.{u2} α)) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (fun (_x : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) => WithTop.{u2} α) _x) (EmbeddingLike.toFunLike.{max (succ (max u1 u2)) (succ u2), succ (max u1 u2), succ u2} (Function.Embedding.{succ (max u1 u2), succ u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (WithTop.{u2} α)) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (WithTop.{u2} α) (Function.instEmbeddingLikeEmbedding.{succ (max u1 u2), succ u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (WithTop.{u2} α))) (RelEmbedding.toEmbedding.{max u1 u2, u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (WithTop.{u2} α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) => LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.Lex.LE.{u2, u1} α PUnit.{succ u1} _inst_1 (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1}))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithTop.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithTop.{u2} α) => LE.le.{u2} (WithTop.{u2} α) (WithTop.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u1 u2, u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (WithTop.{u2} α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) => LE.le.{max u1 u2} (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.Lex.LE.{u2, u1} α PUnit.{succ u1} _inst_1 (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1}))))))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithTop.{u2} α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithTop.{u2} α) => LE.le.{u2} (WithTop.{u2} α) (WithTop.le.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, max u1 u2} (WithTop.{u2} α) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (WithTop.le.{u2} α _inst_1) (Sum.Lex.LE.{u2, u1} α PUnit.{succ u1} _inst_1 (Preorder.toLE.{u1} PUnit.{succ u1} (PartialOrder.toPreorder.{u1} PUnit.{succ u1} (SemilatticeInf.toPartialOrder.{u1} PUnit.{succ u1} (Lattice.toSemilatticeInf.{u1} PUnit.{succ u1} (DistribLattice.toLattice.{u1} PUnit.{succ u1} (instDistribLattice.{u1} PUnit.{succ u1} PUnit.instLinearOrderPUnit.{u1}))))))) (WithTop.orderIsoSumLexPUnit.{u2, u1} α _inst_1)))) (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (fun (_x : Sum.{u2, u1} α PUnit.{succ u1}) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.21 : Sum.{u2, u1} α PUnit.{succ u1}) => Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (EquivLike.toEmbeddingLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Equiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))) (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Equiv.instEquivLikeEquiv.{succ (max u1 u2), succ (max u1 u2)} (Sum.{u2, u1} α PUnit.{succ u1}) (Lex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1}))))) (toLex.{max u1 u2} (Sum.{u2, u1} α PUnit.{succ u1})) (Sum.inl.{u2, u1} α PUnit.{succ u1} a))) (WithTop.some.{u2} α a)
Case conversion may be inaccurate. Consider using '#align with_top.order_iso_sum_lex_punit_symm_inl WithTop.orderIsoSumLexPUnit_symm_inlₓ'. -/
@[simp]
theorem orderIsoSumLexPUnit_symm_inl (a : α) : orderIsoSumLexPUnit.symm (toLex <| inl a) = a :=
  rfl
#align with_top.order_iso_sum_lex_punit_symm_inl WithTop.orderIsoSumLexPUnit_symm_inl

end WithTop

