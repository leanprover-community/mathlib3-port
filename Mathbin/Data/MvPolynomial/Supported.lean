/-
Copyright (c) 2021 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes

! This file was ported from Lean 3 source module data.mv_polynomial.supported
! leanprover-community/mathlib commit 2f5b500a507264de86d666a5f87ddb976e2d8de4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.MvPolynomial.Variables

/-!
# Polynomials supported by a set of variables

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file contains the definition and lemmas about `mv_polynomial.supported`.

## Main definitions

* `mv_polynomial.supported` : Given a set `s : set σ`, `supported R s` is the subalgebra of
  `mv_polynomial σ R` consisting of polynomials whose set of variables is contained in `s`.
  This subalgebra is isomorphic to `mv_polynomial s R`

## Tags
variables, polynomial, vars
-/


universe u v w

namespace MvPolynomial

variable {σ τ : Type _} {R : Type u} {S : Type v} {r : R} {e : ℕ} {n m : σ}

section CommSemiring

variable [CommSemiring R] {p q : MvPolynomial σ R}

variable (R)

#print MvPolynomial.supported /-
/-- The set of polynomials whose variables are contained in `s` as a `subalgebra` over `R`. -/
noncomputable def supported (s : Set σ) : Subalgebra R (MvPolynomial σ R) :=
  Algebra.adjoin R (X '' s)
#align mv_polynomial.supported MvPolynomial.supported
-/

variable {σ R}

open Algebra

/- warning: mv_polynomial.supported_eq_range_rename -> MvPolynomial.supported_eq_range_rename is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (s : Set.{u2} σ), Eq.{succ (max u2 u1)} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s) (AlgHom.range.{u1, max u2 u1, max u2 u1} R (MvPolynomial.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) R _inst_1) (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.rename.{u2, u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) σ R _inst_1 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) σ (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) σ (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) σ (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) σ (coeSubtype.{succ u2} σ (fun (x : σ) => Membership.Mem.{u2, u2} σ (Set.{u2} σ) (Set.hasMem.{u2} σ) x s))))))))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (s : Set.{u1} σ), Eq.{max (succ u2) (succ u1)} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.supported.{u2, u1} σ R _inst_1 s) (AlgHom.range.{u2, max u1 u2, max u1 u2} R (MvPolynomial.{u1, u2} (Subtype.{succ u1} σ (fun (x : σ) => Membership.mem.{u1, u1} σ (Set.{u1} σ) (Set.instMembershipSet.{u1} σ) x s)) R _inst_1) (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} (Subtype.{succ u1} σ (fun (x : σ) => Membership.mem.{u1, u1} σ (Set.{u1} σ) (Set.instMembershipSet.{u1} σ) x s)) R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R (Subtype.{succ u1} σ (fun (x : σ) => Membership.mem.{u1, u1} σ (Set.{u1} σ) (Set.instMembershipSet.{u1} σ) x s)) _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R (Subtype.{succ u1} σ (fun (x : σ) => Membership.mem.{u1, u1} σ (Set.{u1} σ) (Set.instMembershipSet.{u1} σ) x s)) _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)) (MvPolynomial.rename.{u1, u1, u2} (Subtype.{succ u1} σ (fun (x : σ) => Membership.mem.{u1, u1} σ (Set.{u1} σ) (Set.instMembershipSet.{u1} σ) x s)) σ R _inst_1 (Subtype.val.{succ u1} σ (fun (x : σ) => Membership.mem.{u1, u1} σ (Set.{u1} σ) (Set.instMembershipSet.{u1} σ) x s))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_eq_range_rename MvPolynomial.supported_eq_range_renameₓ'. -/
theorem supported_eq_range_rename (s : Set σ) : supported R s = (rename (coe : s → σ)).range := by
  rw [supported, Set.image_eq_range, adjoin_range_eq_range_aeval, rename]
#align mv_polynomial.supported_eq_range_rename MvPolynomial.supported_eq_range_rename

/- warning: mv_polynomial.supported_equiv_mv_polynomial -> MvPolynomial.supportedEquivMvPolynomial is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (s : Set.{u2} σ), AlgEquiv.{u1, max u2 u1, max u2 u1} R (coeSort.{succ (max u2 u1), succ (succ (max u2 u1))} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) Type.{max u2 u1} (SetLike.hasCoeToSort.{max u2 u1, max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.setLike.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s)) (MvPolynomial.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) R _inst_1) _inst_1 (Subalgebra.toSemiring.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) _inst_1)) (Subalgebra.algebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s)) (MvPolynomial.algebra.{u1, u1, u2} R R (coeSort.{succ u2, succ (succ u2)} (Set.{u2} σ) Type.{u2} (Set.hasCoeToSort.{u2} σ) s) _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))
but is expected to have type
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (s : Set.{u2} σ), AlgEquiv.{u1, max u1 u2, max u1 u2} R (Subtype.{succ (max u1 u2)} (MvPolynomial.{u2, u1} σ R _inst_1) (fun (x : MvPolynomial.{u2, u1} σ R _inst_1) => Membership.mem.{max u1 u2, max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Subalgebra.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.instSetLikeSubalgebra.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) x (MvPolynomial.supported.{u1, u2} σ R _inst_1 s))) (MvPolynomial.{u2, u1} (Set.Elem.{u2} σ s) R _inst_1) _inst_1 (Subalgebra.toSemiring.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s)) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} (Set.Elem.{u2} σ s) R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R (Set.Elem.{u2} σ s) _inst_1)) (Subalgebra.algebra.{u1, max u1 u2} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s)) (MvPolynomial.algebra.{u1, u1, u2} R R (Set.Elem.{u2} σ s) _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_equiv_mv_polynomial MvPolynomial.supportedEquivMvPolynomialₓ'. -/
/-- The isomorphism between the subalgebra of polynomials supported by `s` and `mv_polynomial s R`-/
noncomputable def supportedEquivMvPolynomial (s : Set σ) : supported R s ≃ₐ[R] MvPolynomial s R :=
  (Subalgebra.equivOfEq _ _ (supported_eq_range_rename s)).trans
    (AlgEquiv.ofInjective (rename (coe : s → σ)) (rename_injective _ Subtype.val_injective)).symm
#align mv_polynomial.supported_equiv_mv_polynomial MvPolynomial.supportedEquivMvPolynomial

/- warning: mv_polynomial.supported_equiv_mv_polynomial_symm_C -> MvPolynomial.supportedEquivMvPolynomial_symm_C is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_equiv_mv_polynomial_symm_C MvPolynomial.supportedEquivMvPolynomial_symm_Cₓ'. -/
@[simp]
theorem supportedEquivMvPolynomial_symm_C (s : Set σ) (x : R) :
    (supportedEquivMvPolynomial s).symm (C x) = algebraMap R (supported R s) x :=
  by
  ext1
  simp [supported_equiv_mv_polynomial, MvPolynomial.algebraMap_eq]
#align mv_polynomial.supported_equiv_mv_polynomial_symm_C MvPolynomial.supportedEquivMvPolynomial_symm_C

/- warning: mv_polynomial.supported_equiv_mv_polynomial_symm_X -> MvPolynomial.supportedEquivMvPolynomial_symm_X is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_equiv_mv_polynomial_symm_X MvPolynomial.supportedEquivMvPolynomial_symm_Xₓ'. -/
@[simp]
theorem supportedEquivMvPolynomial_symm_X (s : Set σ) (i : s) :
    (↑((supportedEquivMvPolynomial s).symm (X i : MvPolynomial s R)) : MvPolynomial σ R) = X i := by
  simp [supported_equiv_mv_polynomial]
#align mv_polynomial.supported_equiv_mv_polynomial_symm_X MvPolynomial.supportedEquivMvPolynomial_symm_X

variable {s t : Set σ}

/- warning: mv_polynomial.mem_supported -> MvPolynomial.mem_supported is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : MvPolynomial.{u2, u1} σ R _inst_1} {s : Set.{u2} σ}, Iff (Membership.Mem.{max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (SetLike.hasMem.{max u2 u1, max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.setLike.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) p (MvPolynomial.supported.{u1, u2} σ R _inst_1 s)) (HasSubset.Subset.{u2} (Set.{u2} σ) (Set.hasSubset.{u2} σ) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} σ) (Set.{u2} σ) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} σ) (Set.{u2} σ) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} σ) (Set.{u2} σ) (Finset.Set.hasCoeT.{u2} σ))) (MvPolynomial.vars.{u1, u2} R σ _inst_1 p)) s)
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {p : MvPolynomial.{u1, u2} σ R _inst_1} {s : Set.{u1} σ}, Iff (Membership.mem.{max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.instSetLikeSubalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))) p (MvPolynomial.supported.{u2, u1} σ R _inst_1 s)) (HasSubset.Subset.{u1} (Set.{u1} σ) (Set.instHasSubsetSet.{u1} σ) (Finset.toSet.{u1} σ (MvPolynomial.vars.{u2, u1} R σ _inst_1 p)) s)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_supported MvPolynomial.mem_supportedₓ'. -/
theorem mem_supported : p ∈ supported R s ↔ ↑p.vars ⊆ s := by
  classical
    rw [supported_eq_range_rename, AlgHom.mem_range]
    constructor
    · rintro ⟨p, rfl⟩
      refine' trans (Finset.coe_subset.2 (vars_rename _ _)) _
      simp
    · intro hs
      exact exists_rename_eq_of_vars_subset_range p (coe : s → σ) Subtype.val_injective (by simpa)
#align mv_polynomial.mem_supported MvPolynomial.mem_supported

/- warning: mv_polynomial.supported_eq_vars_subset -> MvPolynomial.supported_eq_vars_subset is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {s : Set.{u2} σ}, Eq.{succ (max u2 u1)} (Set.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{max u2 u1}) [self : HasLiftT.{succ (max u2 u1), succ (max u2 u1)} a b] => self.0) (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (Set.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1)) (HasLiftT.mk.{succ (max u2 u1), succ (max u2 u1)} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (Set.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1)) (CoeTCₓ.coe.{succ (max u2 u1), succ (max u2 u1)} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (Set.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1)) (SetLike.Set.hasCoeT.{max u2 u1, max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.setLike.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))))) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s)) (setOf.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (fun (p : MvPolynomial.{u2, u1} σ R _inst_1) => HasSubset.Subset.{u2} (Set.{u2} σ) (Set.hasSubset.{u2} σ) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} σ) (Set.{u2} σ) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} σ) (Set.{u2} σ) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} σ) (Set.{u2} σ) (Finset.Set.hasCoeT.{u2} σ))) (MvPolynomial.vars.{u1, u2} R σ _inst_1 p)) s))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {s : Set.{u1} σ}, Eq.{max (succ u2) (succ u1)} (Set.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1)) (SetLike.coe.{max u2 u1, max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.instSetLikeSubalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.supported.{u2, u1} σ R _inst_1 s)) (setOf.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (fun (p : MvPolynomial.{u1, u2} σ R _inst_1) => HasSubset.Subset.{u1} (Set.{u1} σ) (Set.instHasSubsetSet.{u1} σ) (Finset.toSet.{u1} σ (MvPolynomial.vars.{u2, u1} R σ _inst_1 p)) s))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_eq_vars_subset MvPolynomial.supported_eq_vars_subsetₓ'. -/
theorem supported_eq_vars_subset : (supported R s : Set (MvPolynomial σ R)) = { p | ↑p.vars ⊆ s } :=
  Set.ext fun _ => mem_supported
#align mv_polynomial.supported_eq_vars_subset MvPolynomial.supported_eq_vars_subset

/- warning: mv_polynomial.mem_supported_vars -> MvPolynomial.mem_supported_vars is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (p : MvPolynomial.{u2, u1} σ R _inst_1), Membership.Mem.{max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (SetLike.hasMem.{max u2 u1, max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.setLike.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) p (MvPolynomial.supported.{u1, u2} σ R _inst_1 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} σ) (Set.{u2} σ) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} σ) (Set.{u2} σ) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} σ) (Set.{u2} σ) (Finset.Set.hasCoeT.{u2} σ))) (MvPolynomial.vars.{u1, u2} R σ _inst_1 p)))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (p : MvPolynomial.{u1, u2} σ R _inst_1), Membership.mem.{max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.instSetLikeSubalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))) p (MvPolynomial.supported.{u2, u1} σ R _inst_1 (Finset.toSet.{u1} σ (MvPolynomial.vars.{u2, u1} R σ _inst_1 p)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.mem_supported_vars MvPolynomial.mem_supported_varsₓ'. -/
@[simp]
theorem mem_supported_vars (p : MvPolynomial σ R) : p ∈ supported R (↑p.vars : Set σ) := by
  rw [mem_supported]
#align mv_polynomial.mem_supported_vars MvPolynomial.mem_supported_vars

variable (s)

/- warning: mv_polynomial.supported_eq_adjoin_X -> MvPolynomial.supported_eq_adjoin_X is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (s : Set.{u2} σ), Eq.{succ (max u2 u1)} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s) (Algebra.adjoin.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)) (Set.image.{u2, max u2 u1} σ (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.X.{u1, u2} R σ _inst_1) s))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (s : Set.{u1} σ), Eq.{max (succ u2) (succ u1)} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.supported.{u2, u1} σ R _inst_1 s) (Algebra.adjoin.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)) (Set.image.{u1, max u1 u2} σ (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.X.{u2, u1} R σ _inst_1) s))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_eq_adjoin_X MvPolynomial.supported_eq_adjoin_Xₓ'. -/
theorem supported_eq_adjoin_X : supported R s = Algebra.adjoin R (X '' s) :=
  rfl
#align mv_polynomial.supported_eq_adjoin_X MvPolynomial.supported_eq_adjoin_X

/- warning: mv_polynomial.supported_univ -> MvPolynomial.supported_univ is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R], Eq.{succ (max u2 u1)} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.supported.{u1, u2} σ R _inst_1 (Set.univ.{u2} σ)) (Top.top.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (CompleteLattice.toHasTop.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (Algebra.Subalgebra.completeLattice.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R], Eq.{max (succ u2) (succ u1)} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.supported.{u2, u1} σ R _inst_1 (Set.univ.{u1} σ)) (Top.top.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (CompleteLattice.toTop.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (Algebra.instCompleteLatticeSubalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_univ MvPolynomial.supported_univₓ'. -/
@[simp]
theorem supported_univ : supported R (Set.univ : Set σ) = ⊤ := by
  simp [Algebra.eq_top_iff, mem_supported]
#align mv_polynomial.supported_univ MvPolynomial.supported_univ

/- warning: mv_polynomial.supported_empty -> MvPolynomial.supported_empty is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R], Eq.{succ (max u2 u1)} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.supported.{u1, u2} σ R _inst_1 (EmptyCollection.emptyCollection.{u2} (Set.{u2} σ) (Set.hasEmptyc.{u2} σ))) (Bot.bot.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (CompleteLattice.toHasBot.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (Algebra.Subalgebra.completeLattice.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R], Eq.{max (succ u2) (succ u1)} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.supported.{u2, u1} σ R _inst_1 (EmptyCollection.emptyCollection.{u1} (Set.{u1} σ) (Set.instEmptyCollectionSet.{u1} σ))) (Bot.bot.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (CompleteLattice.toBot.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (Algebra.instCompleteLatticeSubalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_empty MvPolynomial.supported_emptyₓ'. -/
@[simp]
theorem supported_empty : supported R (∅ : Set σ) = ⊥ := by simp [supported_eq_adjoin_X]
#align mv_polynomial.supported_empty MvPolynomial.supported_empty

variable {s}

/- warning: mv_polynomial.supported_mono -> MvPolynomial.supported_mono is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {s : Set.{u2} σ} {t : Set.{u2} σ}, (HasSubset.Subset.{u2} (Set.{u2} σ) (Set.hasSubset.{u2} σ) s t) -> (LE.le.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (Preorder.toHasLe.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (PartialOrder.toPreorder.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (SetLike.partialOrder.{max u2 u1, max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.setLike.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))))) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s) (MvPolynomial.supported.{u1, u2} σ R _inst_1 t))
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {s : Set.{u1} σ} {t : Set.{u1} σ}, (HasSubset.Subset.{u1} (Set.{u1} σ) (Set.instHasSubsetSet.{u1} σ) s t) -> (LE.le.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (Preorder.toLE.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (PartialOrder.toPreorder.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (Algebra.instCompleteLatticeSubalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))))))) (MvPolynomial.supported.{u2, u1} σ R _inst_1 s) (MvPolynomial.supported.{u2, u1} σ R _inst_1 t))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_mono MvPolynomial.supported_monoₓ'. -/
theorem supported_mono (st : s ⊆ t) : supported R s ≤ supported R t :=
  Algebra.adjoin_mono (Set.image_subset _ st)
#align mv_polynomial.supported_mono MvPolynomial.supported_mono

/- warning: mv_polynomial.X_mem_supported -> MvPolynomial.X_mem_supported is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {s : Set.{u2} σ} [_inst_2 : Nontrivial.{u1} R] {i : σ}, Iff (Membership.Mem.{max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (SetLike.hasMem.{max u2 u1, max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.setLike.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))) (MvPolynomial.X.{u1, u2} R σ _inst_1 i) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s)) (Membership.Mem.{u2, u2} σ (Set.{u2} σ) (Set.hasMem.{u2} σ) i s)
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {s : Set.{u1} σ} [_inst_2 : Nontrivial.{u2} R] {i : σ}, Iff (Membership.mem.{max u1 u2, max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (SetLike.instMembership.{max u2 u1, max u1 u2} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (MvPolynomial.{u1, u2} σ R _inst_1) (Subalgebra.instSetLikeSubalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))) (MvPolynomial.X.{u2, u1} R σ _inst_1 i) (MvPolynomial.supported.{u2, u1} σ R _inst_1 s)) (Membership.mem.{u1, u1} σ (Set.{u1} σ) (Set.instMembershipSet.{u1} σ) i s)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.X_mem_supported MvPolynomial.X_mem_supportedₓ'. -/
@[simp]
theorem X_mem_supported [Nontrivial R] {i : σ} : X i ∈ supported R s ↔ i ∈ s := by
  simp [mem_supported]
#align mv_polynomial.X_mem_supported MvPolynomial.X_mem_supported

/- warning: mv_polynomial.supported_le_supported_iff -> MvPolynomial.supported_le_supported_iff is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {s : Set.{u2} σ} {t : Set.{u2} σ} [_inst_2 : Nontrivial.{u1} R], Iff (LE.le.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (Preorder.toHasLe.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (PartialOrder.toPreorder.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (SetLike.partialOrder.{max u2 u1, max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.setLike.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1)))))) (MvPolynomial.supported.{u1, u2} σ R _inst_1 s) (MvPolynomial.supported.{u1, u2} σ R _inst_1 t)) (HasSubset.Subset.{u2} (Set.{u2} σ) (Set.hasSubset.{u2} σ) s t)
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {s : Set.{u1} σ} {t : Set.{u1} σ} [_inst_2 : Nontrivial.{u2} R], Iff (LE.le.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (Preorder.toLE.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (PartialOrder.toPreorder.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (Algebra.instCompleteLatticeSubalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))))))) (MvPolynomial.supported.{u2, u1} σ R _inst_1 s) (MvPolynomial.supported.{u2, u1} σ R _inst_1 t)) (HasSubset.Subset.{u1} (Set.{u1} σ) (Set.instHasSubsetSet.{u1} σ) s t)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_le_supported_iff MvPolynomial.supported_le_supported_iffₓ'. -/
@[simp]
theorem supported_le_supported_iff [Nontrivial R] : supported R s ≤ supported R t ↔ s ⊆ t :=
  by
  constructor
  · intro h i
    simpa using @h (X i)
  · exact supported_mono
#align mv_polynomial.supported_le_supported_iff MvPolynomial.supported_le_supported_iff

/- warning: mv_polynomial.supported_strict_mono -> MvPolynomial.supported_strictMono is a dubious translation:
lean 3 declaration is
  forall {σ : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Nontrivial.{u1} R], StrictMono.{u2, max u2 u1} (Set.{u2} σ) (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (PartialOrder.toPreorder.{u2} (Set.{u2} σ) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} σ) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} σ) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} σ) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} σ) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} σ) (Set.completeBooleanAlgebra.{u2} σ))))))) (PartialOrder.toPreorder.{max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (SetLike.partialOrder.{max u2 u1, max u2 u1} (Subalgebra.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))) (MvPolynomial.{u2, u1} σ R _inst_1) (Subalgebra.setLike.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R _inst_1) (MvPolynomial.commSemiring.{u1, u2} R σ _inst_1)) (MvPolynomial.algebra.{u1, u1, u2} R R σ _inst_1 _inst_1 (Algebra.id.{u1} R _inst_1))))) (MvPolynomial.supported.{u1, u2} σ R _inst_1)
but is expected to have type
  forall {σ : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Nontrivial.{u2} R], StrictMono.{u1, max u2 u1} (Set.{u1} σ) (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (PartialOrder.toPreorder.{u1} (Set.{u1} σ) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} σ) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} σ) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} σ) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} σ) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} σ) (Set.instCompleteBooleanAlgebraSet.{u1} σ))))))) (PartialOrder.toPreorder.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u1} (Subalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1))) (Algebra.instCompleteLatticeSubalgebra.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) _inst_1 (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)) (MvPolynomial.algebra.{u2, u2, u1} R R σ _inst_1 _inst_1 (Algebra.id.{u2} R _inst_1)))))) (MvPolynomial.supported.{u2, u1} σ R _inst_1)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.supported_strict_mono MvPolynomial.supported_strictMonoₓ'. -/
theorem supported_strictMono [Nontrivial R] :
    StrictMono (supported R : Set σ → Subalgebra R (MvPolynomial σ R)) :=
  strictMono_of_le_iff_le fun _ _ => supported_le_supported_iff.symm
#align mv_polynomial.supported_strict_mono MvPolynomial.supported_strictMono

/- warning: mv_polynomial.exists_restrict_to_vars -> MvPolynomial.exists_restrict_to_vars is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align mv_polynomial.exists_restrict_to_vars MvPolynomial.exists_restrict_to_varsₓ'. -/
theorem exists_restrict_to_vars (R : Type _) [CommRing R] {F : MvPolynomial σ ℤ}
    (hF : ↑F.vars ⊆ s) : ∃ f : (s → R) → R, ∀ x : σ → R, f (x ∘ coe : s → R) = aeval x F := by
  classical
    rw [← mem_supported, supported_eq_range_rename, AlgHom.mem_range] at hF
    cases' hF with F' hF'
    use fun z => aeval z F'
    intro x
    simp only [← hF', aeval_rename]
#align mv_polynomial.exists_restrict_to_vars MvPolynomial.exists_restrict_to_vars

end CommSemiring

end MvPolynomial

