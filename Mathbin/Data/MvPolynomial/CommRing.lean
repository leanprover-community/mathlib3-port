/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Johan Commelin, Mario Carneiro

! This file was ported from Lean 3 source module data.mv_polynomial.comm_ring
! leanprover-community/mathlib commit 972aa4234fa56ce119d19506045158a9d76881fd
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.MvPolynomial.Variables

/-!
# Multivariate polynomials over a ring

Many results about polynomials hold when the coefficient ring is a commutative semiring.
Some stronger results can be derived when we assume this semiring is a ring.

This file does not define any new operations, but proves some of these stronger results.

## Notation

As in other polynomial files, we typically use the notation:

+ `σ : Type*` (indexing the variables)

+ `R : Type*` `[comm_ring R]` (the coefficients)

+ `s : σ →₀ ℕ`, a function from `σ` to `ℕ` which is zero away from a finite set.
This will give rise to a monomial in `mv_polynomial σ R` which mathematicians might call `X^s`

+ `a : R`

+ `i : σ`, with corresponding monomial `X i`, often denoted `X_i` by mathematicians

+ `p : mv_polynomial σ R`

-/


noncomputable section

open Classical BigOperators

open Set Function Finsupp AddMonoidAlgebra

open BigOperators

universe u v

variable {R : Type u} {S : Type v}

namespace MvPolynomial

variable {σ : Type _} {a a' a₁ a₂ : R} {e : ℕ} {n m : σ} {s : σ →₀ ℕ}

section CommRing

variable [CommRing R]

variable {p q : MvPolynomial σ R}

instance : CommRing (MvPolynomial σ R) :=
  AddMonoidAlgebra.commRing

variable (σ a a')

/- warning: mv_polynomial.C_sub -> MvPolynomial.C_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (σ : Type.{u2}) (a : R) (a' : R) [_inst_1 : CommRing.{u1} R], Eq.{max (succ u2) (succ u1)} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) => R -> (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1))) (RingHom.hasCoeToFun.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (MvPolynomial.C.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1)) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) a a')) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1)))))))) (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) => R -> (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1))) (RingHom.hasCoeToFun.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (MvPolynomial.C.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1)) a) (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) => R -> (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1))) (RingHom.hasCoeToFun.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (MvPolynomial.C.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1)) a'))
but is expected to have type
  forall {R : Type.{u2}} (σ : Type.{u1}) (a : R) (a' : R) [_inst_1 : CommRing.{u2} R], Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R (CommRing.toRing.{u2} R _inst_1))) a a')) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (MvPolynomial.C.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R (CommRing.toRing.{u2} R _inst_1))) a a')) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) a') ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R (CommRing.toRing.{u2} R _inst_1))) a a')) (instHSub.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) a) (Ring.toSub.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) a) (CommRing.toRing.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) a) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (MvPolynomial.C.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)) a) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (MvPolynomial.C.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)) a'))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.C_sub MvPolynomial.C_subₓ'. -/
@[simp]
theorem C_sub : (C (a - a') : MvPolynomial σ R) = C a - C a' :=
  RingHom.map_sub _ _ _
#align mv_polynomial.C_sub MvPolynomial.C_sub

/- warning: mv_polynomial.C_neg -> MvPolynomial.C_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (σ : Type.{u2}) (a : R) [_inst_1 : CommRing.{u1} R], Eq.{max (succ u2) (succ u1)} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) => R -> (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1))) (RingHom.hasCoeToFun.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (MvPolynomial.C.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1)) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) a)) (Neg.neg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasNeg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1))))))) (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) => R -> (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1))) (RingHom.hasCoeToFun.{u1, max u2 u1} R (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commSemiring.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1))))) (MvPolynomial.C.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1)) a))
but is expected to have type
  forall {R : Type.{u2}} (σ : Type.{u1}) (a : R) [_inst_1 : CommRing.{u2} R], Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Neg.neg.{u2} R (Ring.toNeg.{u2} R (CommRing.toRing.{u2} R _inst_1)) a)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (MvPolynomial.C.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)) (Neg.neg.{u2} R (Ring.toNeg.{u2} R (CommRing.toRing.{u2} R _inst_1)) a)) (Neg.neg.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) a) (Ring.toNeg.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) a) (CommRing.toRing.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) a) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1))))) R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.commSemiring.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)))))))) (MvPolynomial.C.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1)) a))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.C_neg MvPolynomial.C_negₓ'. -/
@[simp]
theorem C_neg : (C (-a) : MvPolynomial σ R) = -C a :=
  RingHom.map_neg _ _
#align mv_polynomial.C_neg MvPolynomial.C_neg

/- warning: mv_polynomial.coeff_neg -> MvPolynomial.coeff_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (σ : Type.{u2}) [_inst_1 : CommRing.{u1} R] (m : Finsupp.{u2, 0} σ Nat Nat.hasZero) (p : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)), Eq.{succ u1} R (MvPolynomial.coeff.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) m (Neg.neg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasNeg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1))))))) p)) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MvPolynomial.coeff.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) m p))
but is expected to have type
  forall {R : Type.{u2}} (σ : Type.{u1}) [_inst_1 : CommRing.{u2} R] (m : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)), Eq.{succ u2} R (MvPolynomial.coeff.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) m (Neg.neg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toNeg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1))) p)) (Neg.neg.{u2} R (Ring.toNeg.{u2} R (CommRing.toRing.{u2} R _inst_1)) (MvPolynomial.coeff.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) m p))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.coeff_neg MvPolynomial.coeff_negₓ'. -/
@[simp]
theorem coeff_neg (m : σ →₀ ℕ) (p : MvPolynomial σ R) : coeff m (-p) = -coeff m p :=
  Finsupp.neg_apply _ _
#align mv_polynomial.coeff_neg MvPolynomial.coeff_neg

/- warning: mv_polynomial.coeff_sub -> MvPolynomial.coeff_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (σ : Type.{u2}) [_inst_1 : CommRing.{u1} R] (m : Finsupp.{u2, 0} σ Nat Nat.hasZero) (p : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (q : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)), Eq.{succ u1} R (MvPolynomial.coeff.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) m (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1)))))))) p q)) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (MvPolynomial.coeff.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) m p) (MvPolynomial.coeff.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) m q))
but is expected to have type
  forall {R : Type.{u2}} (σ : Type.{u1}) [_inst_1 : CommRing.{u2} R] (m : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (q : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)), Eq.{succ u2} R (MvPolynomial.coeff.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) m (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1)))) p q)) (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (Ring.toSub.{u2} R (CommRing.toRing.{u2} R _inst_1))) (MvPolynomial.coeff.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) m p) (MvPolynomial.coeff.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) m q))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.coeff_sub MvPolynomial.coeff_subₓ'. -/
@[simp]
theorem coeff_sub (m : σ →₀ ℕ) (p q : MvPolynomial σ R) : coeff m (p - q) = coeff m p - coeff m q :=
  Finsupp.sub_apply _ _ _
#align mv_polynomial.coeff_sub MvPolynomial.coeff_sub

/- warning: mv_polynomial.support_neg -> MvPolynomial.support_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (σ : Type.{u2}) [_inst_1 : CommRing.{u1} R] {p : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)}, Eq.{succ u2} (Finset.{u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero)) (MvPolynomial.support.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) (Neg.neg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasNeg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1))))))) p)) (MvPolynomial.support.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) p)
but is expected to have type
  forall {R : Type.{u2}} (σ : Type.{u1}) [_inst_1 : CommRing.{u2} R] {p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)}, Eq.{succ u1} (Finset.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (MvPolynomial.support.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) (Neg.neg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toNeg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1))) p)) (MvPolynomial.support.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) p)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.support_neg MvPolynomial.support_negₓ'. -/
@[simp]
theorem support_neg : (-p).support = p.support :=
  Finsupp.support_neg p
#align mv_polynomial.support_neg MvPolynomial.support_neg

/- warning: mv_polynomial.support_sub -> MvPolynomial.support_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (σ : Type.{u2}) [_inst_1 : CommRing.{u1} R] (p : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (q : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)), HasSubset.Subset.{u2} (Finset.{u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero)) (Finset.hasSubset.{u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero)) (MvPolynomial.support.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1)))))))) p q)) (Union.union.{u2} (Finset.{u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero)) (Finset.hasUnion.{u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero) (fun (a : Finsupp.{u2, 0} σ Nat Nat.hasZero) (b : Finsupp.{u2, 0} σ Nat Nat.hasZero) => Finsupp.decidableEq.{u2, 0} σ Nat Nat.hasZero (fun (a : σ) (b : σ) => Classical.propDecidable (Eq.{succ u2} σ a b)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) a b)) (MvPolynomial.support.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) p) (MvPolynomial.support.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) q))
but is expected to have type
  forall {R : Type.{u2}} (σ : Type.{u1}) [_inst_1 : CommRing.{u2} R] (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (q : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)), HasSubset.Subset.{u1} (Finset.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instHasSubsetFinset.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (MvPolynomial.support.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1)))) p q)) (Union.union.{u1} (Finset.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instUnionFinset.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (fun (a : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (b : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) => Finsupp.decidableEq.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) (fun (a : σ) (b : σ) => Classical.propDecidable (Eq.{succ u1} σ a b)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) a b)) (MvPolynomial.support.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) p) (MvPolynomial.support.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) q))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.support_sub MvPolynomial.support_subₓ'. -/
theorem support_sub (p q : MvPolynomial σ R) : (p - q).support ⊆ p.support ∪ q.support :=
  Finsupp.support_sub
#align mv_polynomial.support_sub MvPolynomial.support_sub

variable {σ} (p)

section Degrees

/- warning: mv_polynomial.degrees_neg -> MvPolynomial.degrees_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {σ : Type.{u2}} [_inst_1 : CommRing.{u1} R] (p : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)), Eq.{succ u2} (Multiset.{u2} σ) (MvPolynomial.degrees.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) (Neg.neg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasNeg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1))))))) p)) (MvPolynomial.degrees.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) p)
but is expected to have type
  forall {R : Type.{u2}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)), Eq.{succ u1} (Multiset.{u1} σ) (MvPolynomial.degrees.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) (Neg.neg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toNeg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1))) p)) (MvPolynomial.degrees.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) p)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.degrees_neg MvPolynomial.degrees_negₓ'. -/
theorem degrees_neg (p : MvPolynomial σ R) : (-p).degrees = p.degrees := by
  rw [degrees, support_neg] <;> rfl
#align mv_polynomial.degrees_neg MvPolynomial.degrees_neg

/- warning: mv_polynomial.degrees_sub -> MvPolynomial.degrees_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {σ : Type.{u2}} [_inst_1 : CommRing.{u1} R] (p : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (q : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)), LE.le.{u2} (Multiset.{u2} σ) (Preorder.toLE.{u2} (Multiset.{u2} σ) (PartialOrder.toPreorder.{u2} (Multiset.{u2} σ) (Multiset.partialOrder.{u2} σ))) (MvPolynomial.degrees.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1)))))))) p q)) (Sup.sup.{u2} (Multiset.{u2} σ) (SemilatticeSup.toHasSup.{u2} (Multiset.{u2} σ) (Lattice.toSemilatticeSup.{u2} (Multiset.{u2} σ) (Multiset.lattice.{u2} σ (fun (a : σ) (b : σ) => Classical.propDecidable (Eq.{succ u2} σ a b))))) (MvPolynomial.degrees.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) p) (MvPolynomial.degrees.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) q))
but is expected to have type
  forall {R : Type.{u2}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (q : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)), LE.le.{u1} (Multiset.{u1} σ) (Preorder.toLE.{u1} (Multiset.{u1} σ) (PartialOrder.toPreorder.{u1} (Multiset.{u1} σ) (Multiset.instPartialOrderMultiset.{u1} σ))) (MvPolynomial.degrees.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1)))) p q)) (Sup.sup.{u1} (Multiset.{u1} σ) (SemilatticeSup.toSup.{u1} (Multiset.{u1} σ) (Lattice.toSemilatticeSup.{u1} (Multiset.{u1} σ) (Multiset.instLatticeMultiset.{u1} σ (fun (a : σ) (b : σ) => Classical.propDecidable (Eq.{succ u1} σ a b))))) (MvPolynomial.degrees.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) p) (MvPolynomial.degrees.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) q))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.degrees_sub MvPolynomial.degrees_subₓ'. -/
theorem degrees_sub (p q : MvPolynomial σ R) : (p - q).degrees ≤ p.degrees ⊔ q.degrees := by
  simpa only [sub_eq_add_neg] using le_trans (degrees_add p (-q)) (by rw [degrees_neg])
#align mv_polynomial.degrees_sub MvPolynomial.degrees_sub

end Degrees

section Vars

variable (p q)

/- warning: mv_polynomial.vars_neg -> MvPolynomial.vars_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {σ : Type.{u2}} [_inst_1 : CommRing.{u1} R] (p : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)), Eq.{succ u2} (Finset.{u2} σ) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) (Neg.neg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasNeg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1))))))) p)) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) p)
but is expected to have type
  forall {R : Type.{u2}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)), Eq.{succ u1} (Finset.{u1} σ) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) (Neg.neg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toNeg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1))) p)) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) p)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.vars_neg MvPolynomial.vars_negₓ'. -/
@[simp]
theorem vars_neg : (-p).vars = p.vars := by simp [vars, degrees_neg]
#align mv_polynomial.vars_neg MvPolynomial.vars_neg

/- warning: mv_polynomial.vars_sub_subset -> MvPolynomial.vars_sub_subset is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {σ : Type.{u2}} [_inst_1 : CommRing.{u1} R] (p : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (q : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)), HasSubset.Subset.{u2} (Finset.{u2} σ) (Finset.hasSubset.{u2} σ) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1)))))))) p q)) (Union.union.{u2} (Finset.{u2} σ) (Finset.hasUnion.{u2} σ (fun (a : σ) (b : σ) => Classical.propDecidable (Eq.{succ u2} σ a b))) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) p) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) q))
but is expected to have type
  forall {R : Type.{u2}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) {q : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)}, HasSubset.Subset.{u1} (Finset.{u1} σ) (Finset.instHasSubsetFinset.{u1} σ) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1)))) p q)) (Union.union.{u1} (Finset.{u1} σ) (Finset.instUnionFinset.{u1} σ (fun (a : σ) (b : σ) => Classical.propDecidable (Eq.{succ u1} σ a b))) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) p) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) q))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.vars_sub_subset MvPolynomial.vars_sub_subsetₓ'. -/
theorem vars_sub_subset : (p - q).vars ⊆ p.vars ∪ q.vars := by
  convert vars_add_subset p (-q) using 2 <;> simp [sub_eq_add_neg]
#align mv_polynomial.vars_sub_subset MvPolynomial.vars_sub_subset

variable {p q}

/- warning: mv_polynomial.vars_sub_of_disjoint -> MvPolynomial.vars_sub_of_disjoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {σ : Type.{u2}} [_inst_1 : CommRing.{u1} R] {p : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)} {q : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)}, (Disjoint.{u2} (Finset.{u2} σ) (Finset.partialOrder.{u2} σ) (Finset.orderBot.{u2} σ) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) p) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) q)) -> (Eq.{succ u2} (Finset.{u2} σ) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1)))))))) p q)) (Union.union.{u2} (Finset.{u2} σ) (Finset.hasUnion.{u2} σ (fun (a : σ) (b : σ) => Classical.propDecidable (Eq.{succ u2} σ a b))) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) p) (MvPolynomial.vars.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) q)))
but is expected to have type
  forall {R : Type.{u2}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) {q : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)}, (Disjoint.{u1} (Finset.{u1} σ) (Finset.partialOrder.{u1} σ) (Finset.instOrderBotFinsetToLEToPreorderPartialOrder.{u1} σ) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) p) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) q)) -> (Eq.{succ u1} (Finset.{u1} σ) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1)))) p q)) (Union.union.{u1} (Finset.{u1} σ) (Finset.instUnionFinset.{u1} σ (fun (a : σ) (b : σ) => Classical.propDecidable (Eq.{succ u1} σ a b))) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) p) (MvPolynomial.vars.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) q)))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.vars_sub_of_disjoint MvPolynomial.vars_sub_of_disjointₓ'. -/
@[simp]
theorem vars_sub_of_disjoint (hpq : Disjoint p.vars q.vars) : (p - q).vars = p.vars ∪ q.vars :=
  by
  rw [← vars_neg q] at hpq
  convert vars_add_of_disjoint hpq using 2 <;> simp [sub_eq_add_neg]
#align mv_polynomial.vars_sub_of_disjoint MvPolynomial.vars_sub_of_disjoint

end Vars

section Eval₂

variable [CommRing S]

variable (f : R →+* S) (g : σ → S)

/- warning: mv_polynomial.eval₂_sub -> MvPolynomial.eval₂_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {σ : Type.{u3}} [_inst_1 : CommRing.{u1} R] (p : MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) {q : MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)} [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (g : σ -> S), Eq.{succ u2} S (MvPolynomial.eval₂.{u1, u2, u3} R S σ (CommRing.toCommSemiring.{u1} R _inst_1) (CommRing.toCommSemiring.{u2} S _inst_2) f g (HSub.hSub.{max u3 u1, max u3 u1, max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasSub.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u3} R σ _inst_1)))))))) p q)) (HSub.hSub.{u2, u2, u2} S S S (instHSub.{u2} S (SubNegMonoid.toHasSub.{u2} S (AddGroup.toSubNegMonoid.{u2} S (AddGroupWithOne.toAddGroup.{u2} S (NonAssocRing.toAddGroupWithOne.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))))) (MvPolynomial.eval₂.{u1, u2, u3} R S σ (CommRing.toCommSemiring.{u1} R _inst_1) (CommRing.toCommSemiring.{u2} S _inst_2) f g p) (MvPolynomial.eval₂.{u1, u2, u3} R S σ (CommRing.toCommSemiring.{u1} R _inst_1) (CommRing.toCommSemiring.{u2} S _inst_2) f g q))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) {q : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)} [_inst_2 : CommRing.{u3} S] (f : RingHom.{u2, u3} R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))) (g : σ -> S), Eq.{succ u3} S (MvPolynomial.eval₂.{u2, u3, u1} R S σ (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u3} S _inst_2) f g (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1)))) p q)) (HSub.hSub.{u3, u3, u3} S S S (instHSub.{u3} S (Ring.toSub.{u3} S (CommRing.toRing.{u3} S _inst_2))) (MvPolynomial.eval₂.{u2, u3, u1} R S σ (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u3} S _inst_2) f g p) (MvPolynomial.eval₂.{u2, u3, u1} R S σ (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u3} S _inst_2) f g q))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.eval₂_sub MvPolynomial.eval₂_subₓ'. -/
@[simp]
theorem eval₂_sub : (p - q).eval₂ f g = p.eval₂ f g - q.eval₂ f g :=
  (eval₂Hom f g).map_sub _ _
#align mv_polynomial.eval₂_sub MvPolynomial.eval₂_sub

/- warning: mv_polynomial.eval₂_neg -> MvPolynomial.eval₂_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {σ : Type.{u3}} [_inst_1 : CommRing.{u1} R] (p : MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (g : σ -> S), Eq.{succ u2} S (MvPolynomial.eval₂.{u1, u2, u3} R S σ (CommRing.toCommSemiring.{u1} R _inst_1) (CommRing.toCommSemiring.{u2} S _inst_2) f g (Neg.neg.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasNeg.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u3 u1} (MvPolynomial.{u3, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u3} R σ _inst_1))))))) p)) (Neg.neg.{u2} S (SubNegMonoid.toHasNeg.{u2} S (AddGroup.toSubNegMonoid.{u2} S (AddGroupWithOne.toAddGroup.{u2} S (NonAssocRing.toAddGroupWithOne.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))))) (MvPolynomial.eval₂.{u1, u2, u3} R S σ (CommRing.toCommSemiring.{u1} R _inst_1) (CommRing.toCommSemiring.{u2} S _inst_2) f g p))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] (p : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) [_inst_2 : CommRing.{u3} S] (f : RingHom.{u2, u3} R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))) (g : σ -> S), Eq.{succ u3} S (MvPolynomial.eval₂.{u2, u3, u1} R S σ (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u3} S _inst_2) f g (Neg.neg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toNeg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1))) p)) (Neg.neg.{u3} S (Ring.toNeg.{u3} S (CommRing.toRing.{u3} S _inst_2)) (MvPolynomial.eval₂.{u2, u3, u1} R S σ (CommRing.toCommSemiring.{u2} R _inst_1) (CommRing.toCommSemiring.{u3} S _inst_2) f g p))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.eval₂_neg MvPolynomial.eval₂_negₓ'. -/
@[simp]
theorem eval₂_neg : (-p).eval₂ f g = -p.eval₂ f g :=
  (eval₂Hom f g).map_neg _
#align mv_polynomial.eval₂_neg MvPolynomial.eval₂_neg

/- warning: mv_polynomial.hom_C -> MvPolynomial.hom_C is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} {σ : Type.{u2}} [_inst_2 : CommRing.{u1} S] (f : RingHom.{u2, u1} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (Ring.toNonAssocRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (CommRing.toRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (MvPolynomial.commRing.{0, u2} Int σ Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (n : Int), Eq.{succ u1} S (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (Ring.toNonAssocRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (CommRing.toRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (MvPolynomial.commRing.{0, u2} Int σ Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (fun (_x : RingHom.{u2, u1} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (Ring.toNonAssocRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (CommRing.toRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (MvPolynomial.commRing.{0, u2} Int σ Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2)))) => (MvPolynomial.{u2, 0} σ Int Int.commSemiring) -> S) (RingHom.hasCoeToFun.{u2, u1} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (Ring.toNonAssocRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (CommRing.toRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (MvPolynomial.commRing.{0, u2} Int σ Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2)))) f (coeFn.{succ u2, succ u2} (RingHom.{0, u2} Int (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.commSemiring)) (Semiring.toNonAssocSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (CommSemiring.toSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (MvPolynomial.commSemiring.{0, u2} Int σ Int.commSemiring)))) (fun (_x : RingHom.{0, u2} Int (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.commSemiring)) (Semiring.toNonAssocSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (CommSemiring.toSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (MvPolynomial.commSemiring.{0, u2} Int σ Int.commSemiring)))) => Int -> (MvPolynomial.{u2, 0} σ Int Int.commSemiring)) (RingHom.hasCoeToFun.{0, u2} Int (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.commSemiring)) (Semiring.toNonAssocSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (CommSemiring.toSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (MvPolynomial.commSemiring.{0, u2} Int σ Int.commSemiring)))) (MvPolynomial.C.{0, u2} Int σ Int.commSemiring) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int S (HasLiftT.mk.{1, succ u1} Int S (CoeTCₓ.coe.{1, succ u1} Int S (Int.castCoe.{u1} S (AddGroupWithOne.toHasIntCast.{u1} S (NonAssocRing.toAddGroupWithOne.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))))) n)
but is expected to have type
  forall {S : Type.{u2}} {σ : Type.{u1}} [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int σ Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (n : Int), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) => S) (FunLike.coe.{succ u1, 1, succ u1} (RingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) Int (fun (a : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Int) => MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) a) (MulHomClass.toFunLike.{u1, 0, u1} (RingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (NonUnitalNonAssocSemiring.toMul.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)))) (NonUnitalNonAssocSemiring.toMul.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt))))) (NonUnitalRingHomClass.toMulHomClass.{u1, 0, u1} (RingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) (RingHomClass.toNonUnitalRingHomClass.{u1, 0, u1} (RingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt))) (RingHom.instRingHomClassRingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt))))))) (MvPolynomial.C.{0, u1} Int σ Int.instCommSemiringInt) n)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int σ Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (fun (_x : MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int σ Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) S (NonUnitalNonAssocSemiring.toMul.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int σ Int.instCommRingInt)))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int σ Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int σ Int.instCommRingInt))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int σ Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int σ Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int σ Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))))) f (FunLike.coe.{succ u1, 1, succ u1} (RingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) Int (fun (_x : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Int) => MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) _x) (MulHomClass.toFunLike.{u1, 0, u1} (RingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (NonUnitalNonAssocSemiring.toMul.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)))) (NonUnitalNonAssocSemiring.toMul.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt))))) (NonUnitalRingHomClass.toMulHomClass.{u1, 0, u1} (RingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) (RingHomClass.toNonUnitalRingHomClass.{u1, 0, u1} (RingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt)))) Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt))) (RingHom.instRingHomClassRingHom.{0, u1} Int (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (CommSemiring.toSemiring.{u1} (MvPolynomial.{u1, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.commSemiring.{0, u1} Int σ Int.instCommSemiringInt))))))) (MvPolynomial.C.{0, u1} Int σ Int.instCommSemiringInt) n)) (Int.cast.{u2} S (Ring.toIntCast.{u2} S (CommRing.toRing.{u2} S _inst_2)) n)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.hom_C MvPolynomial.hom_Cₓ'. -/
theorem hom_C (f : MvPolynomial σ ℤ →+* S) (n : ℤ) : f (C n) = (n : S) :=
  eq_intCast (f.comp C) n
#align mv_polynomial.hom_C MvPolynomial.hom_C

/- warning: mv_polynomial.eval₂_hom_X -> MvPolynomial.eval₂Hom_X is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u2}} [_inst_2 : CommRing.{u2} S] {R : Type.{u1}} (c : RingHom.{0, u2} Int S (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.ring)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (f : RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (MvPolynomial.commRing.{0, u1} Int R Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (x : MvPolynomial.{u1, 0} R Int Int.commSemiring), Eq.{succ u2} S (MvPolynomial.eval₂.{0, u2, u1} Int S R Int.commSemiring (CommRing.toCommSemiring.{u2} S _inst_2) c (Function.comp.{succ u1, succ u1, succ u2} R (MvPolynomial.{u1, 0} R Int Int.commSemiring) S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (MvPolynomial.commRing.{0, u1} Int R Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (MvPolynomial.commRing.{0, u1} Int R Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => (MvPolynomial.{u1, 0} R Int Int.commSemiring) -> S) (RingHom.hasCoeToFun.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (MvPolynomial.commRing.{0, u1} Int R Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f) (MvPolynomial.X.{0, u1} Int R Int.commSemiring)) x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (MvPolynomial.commRing.{0, u1} Int R Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (MvPolynomial.commRing.{0, u1} Int R Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => (MvPolynomial.{u1, 0} R Int Int.commSemiring) -> S) (RingHom.hasCoeToFun.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.commSemiring) (MvPolynomial.commRing.{0, u1} Int R Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f x)
but is expected to have type
  forall {S : Type.{u2}} [_inst_2 : CommRing.{u2} S] {R : Type.{u1}} (c : RingHom.{0, u2} Int S (NonAssocRing.toNonAssocSemiring.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (f : RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (x : MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt), Eq.{succ u2} S (MvPolynomial.eval₂.{0, u2, u1} Int S R Int.instCommSemiringInt (CommRing.toCommSemiring.{u2} S _inst_2) c (Function.comp.{succ u1, succ u1, succ u2} R (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (fun (_x : MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonUnitalNonAssocSemiring.toMul.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))))) f) (MvPolynomial.X.{0, u1} Int R Int.instCommSemiringInt)) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (fun (_x : MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonUnitalNonAssocSemiring.toMul.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (CommRing.toRing.{u1} (MvPolynomial.{u1, 0} R Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u1} Int R Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))))) f x)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.eval₂_hom_X MvPolynomial.eval₂Hom_Xₓ'. -/
/-- A ring homomorphism f : Z[X_1, X_2, ...] → R
is determined by the evaluations f(X_1), f(X_2), ... -/
@[simp]
theorem eval₂Hom_X {R : Type u} (c : ℤ →+* S) (f : MvPolynomial R ℤ →+* S) (x : MvPolynomial R ℤ) :
    eval₂ c (f ∘ X) x = f x :=
  MvPolynomial.induction_on x
    (fun n => by
      rw [hom_C f, eval₂_C]
      exact eq_intCast c n)
    (fun p q hp hq => by
      rw [eval₂_add, hp, hq]
      exact (f.map_add _ _).symm)
    fun p n hp => by
    rw [eval₂_mul, eval₂_X, hp]
    exact (f.map_mul _ _).symm
#align mv_polynomial.eval₂_hom_X MvPolynomial.eval₂Hom_X

/- warning: mv_polynomial.hom_equiv -> MvPolynomial.homEquiv is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} {σ : Type.{u2}} [_inst_2 : CommRing.{u1} S], Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) S (NonAssocRing.toNonAssocSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (Ring.toNonAssocRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (CommRing.toRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.commSemiring) (MvPolynomial.commRing.{0, u2} Int σ Int.commRing)))) (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (σ -> S)
but is expected to have type
  forall {S : Type.{u1}} {σ : Type.{u2}} [_inst_2 : CommRing.{u1} S], Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u2, u1} (MvPolynomial.{u2, 0} σ Int Int.instCommSemiringInt) S (NonAssocRing.toNonAssocSemiring.{u2} (MvPolynomial.{u2, 0} σ Int Int.instCommSemiringInt) (Ring.toNonAssocRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.instCommSemiringInt) (CommRing.toRing.{u2} (MvPolynomial.{u2, 0} σ Int Int.instCommSemiringInt) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{0, u2} Int σ Int.instCommRingInt)))) (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2)))) (σ -> S)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.hom_equiv MvPolynomial.homEquivₓ'. -/
/-- Ring homomorphisms out of integer polynomials on a type `σ` are the same as
functions out of the type `σ`, -/
def homEquiv : (MvPolynomial σ ℤ →+* S) ≃ (σ → S)
    where
  toFun f := ⇑f ∘ X
  invFun f := eval₂Hom (Int.castRingHom S) f
  left_inv f := RingHom.ext <| eval₂Hom_X _ _
  right_inv f := funext fun x => by simp only [coe_eval₂_hom, Function.comp_apply, eval₂_X]
#align mv_polynomial.hom_equiv MvPolynomial.homEquiv

end Eval₂

section DegreeOf

/- warning: mv_polynomial.degree_of_sub_lt -> MvPolynomial.degreeOf_sub_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {σ : Type.{u2}} [_inst_1 : CommRing.{u1} R] {x : σ} {f : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)} {g : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)} {k : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) k) -> (forall (m : Finsupp.{u2, 0} σ Nat Nat.hasZero), (Membership.Mem.{u2, u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero) (Finset.{u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero)) (Finset.hasMem.{u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero)) m (MvPolynomial.support.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) f)) -> (LE.le.{0} Nat Nat.hasLe k (coeFn.{succ u2, succ u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u2, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u2, 0} σ Nat Nat.hasZero) m x)) -> (Eq.{succ u1} R (MvPolynomial.coeff.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) m f) (MvPolynomial.coeff.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) m g))) -> (forall (m : Finsupp.{u2, 0} σ Nat Nat.hasZero), (Membership.Mem.{u2, u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero) (Finset.{u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero)) (Finset.hasMem.{u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero)) m (MvPolynomial.support.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) g)) -> (LE.le.{0} Nat Nat.hasLe k (coeFn.{succ u2, succ u2} (Finsupp.{u2, 0} σ Nat Nat.hasZero) (fun (_x : Finsupp.{u2, 0} σ Nat Nat.hasZero) => σ -> Nat) (Finsupp.coeFun.{u2, 0} σ Nat Nat.hasZero) m x)) -> (Eq.{succ u1} R (MvPolynomial.coeff.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) m f) (MvPolynomial.coeff.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) m g))) -> (LT.lt.{0} Nat Nat.hasLt (MvPolynomial.degreeOf.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) x (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1)))))))) f g)) k)
but is expected to have type
  forall {R : Type.{u2}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] {x : σ} {f : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)} {g : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)} {k : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) k) -> (forall (m : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Membership.mem.{u1, u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instMembershipFinset.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) m (MvPolynomial.support.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) f)) -> (LE.le.{0} Nat instLENat k (FunLike.coe.{succ u1, succ u1, 1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (_x : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) _x) (Finsupp.funLike.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) m x)) -> (Eq.{succ u2} R (MvPolynomial.coeff.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) m f) (MvPolynomial.coeff.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) m g))) -> (forall (m : Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)), (Membership.mem.{u1, u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finset.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) (Finset.instMembershipFinset.{u1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))) m (MvPolynomial.support.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) g)) -> (LE.le.{0} Nat instLENat k (FunLike.coe.{succ u1, succ u1, 1} (Finsupp.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) σ (fun (_x : σ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : σ) => Nat) _x) (Finsupp.funLike.{u1, 0} σ Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) m x)) -> (Eq.{succ u2} R (MvPolynomial.coeff.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) m f) (MvPolynomial.coeff.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) m g))) -> (LT.lt.{0} Nat instLTNat (MvPolynomial.degreeOf.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) x (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1)))) f g)) k)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.degree_of_sub_lt MvPolynomial.degreeOf_sub_ltₓ'. -/
theorem degreeOf_sub_lt {x : σ} {f g : MvPolynomial σ R} {k : ℕ} (h : 0 < k)
    (hf : ∀ m : σ →₀ ℕ, m ∈ f.support → k ≤ m x → coeff m f = coeff m g)
    (hg : ∀ m : σ →₀ ℕ, m ∈ g.support → k ≤ m x → coeff m f = coeff m g) : degreeOf x (f - g) < k :=
  by
  rw [degree_of_lt_iff h]
  intro m hm
  by_contra hc
  simp only [not_lt] at hc
  have h := support_sub σ f g hm
  simp only [mem_support_iff, Ne.def, coeff_sub, sub_eq_zero] at hm
  cases' Finset.mem_union.1 h with cf cg
  · exact hm (hf m cf hc)
  · exact hm (hg m cg hc)
#align mv_polynomial.degree_of_sub_lt MvPolynomial.degreeOf_sub_lt

end DegreeOf

section TotalDegree

/- warning: mv_polynomial.total_degree_neg -> MvPolynomial.totalDegree_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {σ : Type.{u2}} [_inst_1 : CommRing.{u1} R] (a : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)), Eq.{1} Nat (MvPolynomial.totalDegree.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) (Neg.neg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasNeg.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1))))))) a)) (MvPolynomial.totalDegree.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) a)
but is expected to have type
  forall {R : Type.{u2}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] (a : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)), Eq.{1} Nat (MvPolynomial.totalDegree.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) (Neg.neg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toNeg.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1))) a)) (MvPolynomial.totalDegree.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) a)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.total_degree_neg MvPolynomial.totalDegree_negₓ'. -/
@[simp]
theorem totalDegree_neg (a : MvPolynomial σ R) : (-a).totalDegree = a.totalDegree := by
  simp only [total_degree, support_neg]
#align mv_polynomial.total_degree_neg MvPolynomial.totalDegree_neg

/- warning: mv_polynomial.total_degree_sub -> MvPolynomial.totalDegree_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {σ : Type.{u2}} [_inst_1 : CommRing.{u1} R] (a : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (b : MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)), LE.le.{0} Nat Nat.hasLe (MvPolynomial.totalDegree.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (SubNegMonoid.toHasSub.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroup.toSubNegMonoid.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (AddGroupWithOne.toAddGroup.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonAssocRing.toAddGroupWithOne.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ring.toNonAssocRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u2, u1} σ R (CommRing.toCommSemiring.{u1} R _inst_1)) (MvPolynomial.commRing.{u1, u2} R σ _inst_1)))))))) a b)) (LinearOrder.max.{0} Nat Nat.linearOrder (MvPolynomial.totalDegree.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) a) (MvPolynomial.totalDegree.{u1, u2} R σ (CommRing.toCommSemiring.{u1} R _inst_1) b))
but is expected to have type
  forall {R : Type.{u2}} {σ : Type.{u1}} [_inst_1 : CommRing.{u2} R] (a : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (b : MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)), LE.le.{0} Nat instLENat (MvPolynomial.totalDegree.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (instHSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ring.toSub.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommRing.toRing.{max u2 u1} (MvPolynomial.{u1, u2} σ R (CommRing.toCommSemiring.{u2} R _inst_1)) (MvPolynomial.instCommRingMvPolynomialToCommSemiring.{u2, u1} R σ _inst_1)))) a b)) (Max.max.{0} Nat Nat.instMaxNat (MvPolynomial.totalDegree.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) a) (MvPolynomial.totalDegree.{u2, u1} R σ (CommRing.toCommSemiring.{u2} R _inst_1) b))
Case conversion may be inaccurate. Consider using '#align mv_polynomial.total_degree_sub MvPolynomial.totalDegree_subₓ'. -/
theorem totalDegree_sub (a b : MvPolynomial σ R) :
    (a - b).totalDegree ≤ max a.totalDegree b.totalDegree :=
  calc
    (a - b).totalDegree = (a + -b).totalDegree := by rw [sub_eq_add_neg]
    _ ≤ max a.totalDegree (-b).totalDegree := (totalDegree_add a (-b))
    _ = max a.totalDegree b.totalDegree := by rw [total_degree_neg]
    
#align mv_polynomial.total_degree_sub MvPolynomial.totalDegree_sub

end TotalDegree

end CommRing

end MvPolynomial

