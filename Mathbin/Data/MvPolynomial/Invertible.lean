/-
Copyright (c) 2020 Johan Commelin, Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Robert Y. Lewis

! This file was ported from Lean 3 source module data.mv_polynomial.invertible
! leanprover-community/mathlib commit f6c030fea3c2809bb489bc8901f307bf6b4bf0c0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.MvPolynomial.Basic
import Mathbin.RingTheory.AlgebraTower

/-!
# Invertible polynomials

This file is a stub containing some basic facts about
invertible elements in the ring of polynomials.
-/


open MvPolynomial

/- warning: mv_polynomial.invertible_C -> MvPolynomial.invertibleC is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (r : R) [_inst_2 : Invertible.{u2} R (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) r], Invertible.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulOneClass.toHasMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroOneClass.toMulOneClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (MulOneClass.toHasOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MulZeroOneClass.toMulOneClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (fun (_x : RingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) => R -> (MvPolynomial.{u1, u2} σ R _inst_1)) (RingHom.hasCoeToFun.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r)
but is expected to have type
  forall (σ : Type.{u1}) {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (r : R) [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toOne.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) r], Invertible.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (Semiring.toNonAssocSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toOne.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (CommSemiring.toSemiring.{max u1 u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R _inst_1) r) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MvPolynomial.{u1, u2} σ R _inst_1) _x) (MulHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, max u1 u2} (RingHom.{u2, max u2 u1} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))) R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (RingHom.instRingHomClassRingHom.{u2, max u1 u2} R (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u2 u1} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))) (MvPolynomial.C.{u2, u1} R σ _inst_1) r)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.invertible_C MvPolynomial.invertibleCₓ'. -/
noncomputable instance MvPolynomial.invertibleC (σ : Type _) {R : Type _} [CommSemiring R] (r : R)
    [Invertible r] : Invertible (C r : MvPolynomial σ R) :=
  Invertible.map (C : R →+* MvPolynomial σ R) _
#align mv_polynomial.invertible_C MvPolynomial.invertibleC

/- warning: mv_polynomial.invertible_coe_nat -> MvPolynomial.invertibleCoeNat is a dubious translation:
lean 3 declaration is
  forall (σ : Type.{u1}) (R : Type.{u2}) (p : Nat) [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Invertible.{u2} R (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u2} Nat R (CoeTCₓ.coe.{1, succ u2} Nat R (Nat.castCoe.{u2} R (AddMonoidWithOne.toNatCast.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))))) p)], Invertible.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Distrib.toHasMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toDistrib.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) (AddMonoidWithOne.toOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1)))))) ((fun (a : Type) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{1, max (succ u1) (succ u2)} a b] => self.0) Nat (MvPolynomial.{u1, u2} σ R _inst_1) (HasLiftT.mk.{1, max (succ u1) (succ u2)} Nat (MvPolynomial.{u1, u2} σ R _inst_1) (CoeTCₓ.coe.{1, max (succ u1) (succ u2)} Nat (MvPolynomial.{u1, u2} σ R _inst_1) (Nat.castCoe.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (AddMonoidWithOne.toNatCast.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))))))) p)
but is expected to have type
  forall (σ : Type.{u1}) (R : Type.{u2}) (p : Nat) [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (Semiring.toOne.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Nat.cast.{u2} R (Semiring.toNatCast.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) p)], Invertible.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonUnitalNonAssocSemiring.toMul.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNonAssocSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))))) (Semiring.toOne.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) (Nat.cast.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (Semiring.toNatCast.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (CommSemiring.toSemiring.{max u1 u2} (MvPolynomial.{u1, u2} σ R _inst_1) (MvPolynomial.commSemiring.{u2, u1} R σ _inst_1))) p)
Case conversion may be inaccurate. Consider using '#align mv_polynomial.invertible_coe_nat MvPolynomial.invertibleCoeNatₓ'. -/
/-- A natural number that is invertible when coerced to a commutative semiring `R`
is also invertible when coerced to any polynomial ring with rational coefficients.

Short-cut for typeclass resolution. -/
noncomputable instance MvPolynomial.invertibleCoeNat (σ R : Type _) (p : ℕ) [CommSemiring R]
    [Invertible (p : R)] : Invertible (p : MvPolynomial σ R) :=
  IsScalarTower.invertibleAlgebraCoeNat R _ _
#align mv_polynomial.invertible_coe_nat MvPolynomial.invertibleCoeNat

