import Mathbin.Control.Functor.Multivariate 
import Mathbin.Data.Pfunctor.Multivariate.Basic 
import Mathbin.Data.Pfunctor.Multivariate.M 
import Mathbin.Data.Qpf.Multivariate.Basic

/-!
# The final co-algebra of a multivariate qpf is again a qpf.

For a `(n+1)`-ary QPF `F (α₀,..,αₙ)`, we take the least fixed point of `F` with
regards to its last argument `αₙ`. The result is a `n`-ary functor: `fix F (α₀,..,αₙ₋₁)`.
Making `fix F` into a functor allows us to take the fixed point, compose with other functors
and take a fixed point again.

## Main definitions

 * `cofix.mk`     - constructor
 * `cofix.dest    - destructor
 * `cofix.corec`  - corecursor: useful for formulating infinite, productive computations
 * `cofix.bisim`  - bisimulation: proof technique to show the equality of possibly infinite values
                    of `cofix F α`

## Implementation notes

For `F` a QPF`, we define `cofix F α` in terms of the M-type of the polynomial functor `P` of `F`.
We define the relation `Mcongr` and take its quotient as the definition of `cofix F α`.

`Mcongr` is taken as the weakest bisimulation on M-type.  See
[avigad-carneiro-hudon2019] for more details.

## Reference

 * [Jeremy Avigad, Mario M. Carneiro and Simon Hudon, *Data Types as Quotients of Polynomial Functors*][avigad-carneiro-hudon2019]
-/


universe u

open_locale Mvfunctor

namespace Mvqpf

open Typevec Mvpfunctor

open mvfunctor(Liftp Liftr)

variable{n : ℕ}{F : Typevec.{u} (n+1) → Type u}[Mvfunctor F][q : Mvqpf F]

include q

/-- `corecF` is used as a basis for defining the corecursor of `cofix F α`. `corecF`
uses corecursion to construct the M-type generated by `q.P` and uses function on `F`
as a corecursive step -/
def corecF {α : Typevec n} {β : Type _} (g : β → F (α.append1 β)) : β → q.P.M α :=
  M.corec _ fun x => reprₓ (g x)

theorem corecF_eq {α : Typevec n} {β : Type _} (g : β → F (α.append1 β)) (x : β) :
  M.dest q.P (corecF g x) = append_fun id (corecF g) <$$> reprₓ (g x) :=
  by 
    rw [corecF, M.dest_corec]

/-- Characterization of desirable equivalence relations on M-types -/
def is_precongr {α : Typevec n} (r : q.P.M α → q.P.M α → Prop) : Prop :=
  ∀ ⦃x y⦄, r x y → abs (append_fun id (Quot.mk r) <$$> M.dest q.P x) = abs (append_fun id (Quot.mk r) <$$> M.dest q.P y)

/-- Equivalence relation on M-types representing a value of type `cofix F` -/
def Mcongr {α : Typevec n} (x y : q.P.M α) : Prop :=
  ∃ r, is_precongr r ∧ r x y

/-- Greatest fixed point of functor F. The result is a functor with one fewer parameters
than the input. For `F a b c` a ternary functor, fix F is a binary functor such that

```lean
cofix F a b = F a b (cofix F a b)
```
-/
def cofix (F : Typevec (n+1) → Type u) [Mvfunctor F] [q : Mvqpf F] (α : Typevec n) :=
  Quot (@Mcongr _ F _ q α)

instance  {α : Typevec n} [Inhabited q.P.A] [∀ (i : Fin2 n), Inhabited (α i)] : Inhabited (cofix F α) :=
  ⟨Quot.mk _ (default _)⟩

/-- maps every element of the W type to a canonical representative -/
def Mrepr {α : Typevec n} : q.P.M α → q.P.M α :=
  corecF (abs ∘ M.dest q.P)

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- the map function for the functor `cofix F` -/
def cofix.map {α β : typevec n} (g : «expr ⟹ »(α, β)) : cofix F α → cofix F β :=
quot.lift (λ
 x : q.P.M α, quot.mk Mcongr «expr <$$> »(g, x)) (begin
   rintros [ident aa₁, ident aa₂, "⟨", ident r, ",", ident pr, ",", ident ra₁a₂, "⟩"],
   apply [expr quot.sound],
   let [ident r'] [] [":=", expr λ
    b₁
    b₂, «expr∃ , »((a₁
      a₂ : q.P.M α), «expr ∧ »(r a₁ a₂, «expr ∧ »(«expr = »(b₁, «expr <$$> »(g, a₁)), «expr = »(b₂, «expr <$$> »(g, a₂)))))],
   use [expr r'],
   split,
   { show [expr is_precongr r'],
     rintros [ident b₁, ident b₂, "⟨", ident a₁, ",", ident a₂, ",", ident ra₁a₂, ",", ident b₁eq, ",", ident b₂eq, "⟩"],
     let [ident u] [":", expr quot r → quot r'] [":=", expr quot.lift (λ
       x : q.P.M α, quot.mk r' «expr <$$> »(g, x)) (by { intros [ident a₁, ident a₂, ident ra₁a₂],
         apply [expr quot.sound],
         exact [expr ⟨a₁, a₂, ra₁a₂, rfl, rfl⟩] })],
     have [ident hu] [":", expr «expr = »(«expr ∘ »(quot.mk r', λ
        x : q.P.M α, «expr <$$> »(g, x)), «expr ∘ »(u, quot.mk r))] [],
     { ext [] [ident x] [],
       refl },
     rw ["[", expr b₁eq, ",", expr b₂eq, ",", expr M.dest_map, ",", expr M.dest_map, ",", "<-", expr q.P.comp_map, ",", "<-", expr q.P.comp_map, "]"] [],
     rw ["[", "<-", expr append_fun_comp, ",", expr id_comp, ",", expr hu, ",", expr hu, ",", "<-", expr comp_id g, ",", expr append_fun_comp, "]"] [],
     rw ["[", expr q.P.comp_map, ",", expr q.P.comp_map, ",", expr abs_map, ",", expr pr ra₁a₂, ",", "<-", expr abs_map, "]"] [] },
   show [expr r' «expr <$$> »(g, aa₁) «expr <$$> »(g, aa₂)],
   from [expr ⟨aa₁, aa₂, ra₁a₂, rfl, rfl⟩]
 end)

instance cofix.mvfunctor : Mvfunctor (cofix F) :=
  { map := @cofix.map _ _ _ _ }

/-- Corecursor for `cofix F` -/
def cofix.corec {α : Typevec n} {β : Type u} (g : β → F (α.append1 β)) : β → cofix F α :=
  fun x => Quot.mk _ (corecF g x)

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Destructor for `cofix F` -/ def cofix.dest {α : typevec n} : cofix F α → F (α.append1 (cofix F α)) :=
quot.lift (λ
 x, «expr <$$> »(append_fun id (quot.mk Mcongr), abs (M.dest q.P x))) (begin
   rintros [ident x, ident y, "⟨", ident r, ",", ident pr, ",", ident rxy, "⟩"],
   dsimp [] [] [] [],
   have [] [":", expr ∀ x y, r x y → Mcongr x y] [],
   { intros [ident x, ident y, ident h],
     exact [expr ⟨r, pr, h⟩] },
   rw ["[", "<-", expr quot.factor_mk_eq _ _ this, "]"] [],
   dsimp [] [] [] [],
   conv [] [] { to_lhs,
     rw ["[", expr append_fun_comp_id, ",", expr comp_map, ",", "<-", expr abs_map, ",", expr pr rxy, ",", expr abs_map, ",", "<-", expr comp_map, ",", "<-", expr append_fun_comp_id, "]"] }
 end)

/-- Abstraction function for `cofix F α` -/
def cofix.abs {α} : q.P.M α → cofix F α :=
  Quot.mk _

/-- Representation function for `cofix F α` -/
def cofix.repr {α} : cofix F α → q.P.M α :=
  M.corec _$ reprₓ ∘ cofix.dest

/-- Corecursor for `cofix F` -/
def cofix.corec'₁ {α : Typevec n} {β : Type u} (g : ∀ {X}, (β → X) → F (α.append1 X)) (x : β) : cofix F α :=
  cofix.corec (fun x => g id) x

/-- More flexible corecursor for `cofix F`. Allows the return of a fully formed
value instead of making a recursive call -/
def cofix.corec' {α : Typevec n} {β : Type u} (g : β → F (α.append1 (Sum (cofix F α) β))) (x : β) : cofix F α :=
  let f : (α ::: cofix F α) ⟹ (α ::: Sum (cofix F α) β) := id ::: Sum.inl 
  cofix.corec (Sum.elim (Mvfunctor.map f ∘ cofix.dest) g) (Sum.inr x : Sum (cofix F α) β)

/-- Corecursor for `cofix F`. The shape allows recursive calls to
look like recursive calls. -/
def cofix.corec₁ {α : Typevec n} {β : Type u} (g : ∀ {X}, (cofix F α → X) → (β → X) → β → F (α ::: X)) (x : β) :
  cofix F α :=
  cofix.corec' (fun x => g Sum.inl Sum.inr x) x

theorem cofix.dest_corec {α : Typevec n} {β : Type u} (g : β → F (α.append1 β)) (x : β) :
  cofix.dest (cofix.corec g x) = append_fun id (cofix.corec g) <$$> g x :=
  by 
    conv  => toLHS rw [cofix.dest, cofix.corec]
    dsimp 
    rw [corecF_eq, abs_map, abs_repr, ←comp_map, ←append_fun_comp]
    rfl

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- constructor for `cofix F` -/ def cofix.mk {α : typevec n} : F «expr $ »(α.append1, cofix F α) → cofix F α :=
cofix.corec (λ x, «expr <$$> »(append_fun id (λ i : cofix F α, cofix.dest.{u} i), x))

/-!
## Bisimulation principles for `cofix F`

The following theorems are bisimulation principles. The general idea
is to use a bisimulation relation to prove the equality between
specific values of type `cofix F α`.

A bisimulation relation `R` for values `x y : cofix F α`:

 * holds for `x y`: `R x y`
 * for any values `x y` that satisfy `R`, their root has the same shape
   and their children can be paired in such a way that they satisfy `R`.

-/


-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
private
theorem cofix.bisim_aux
{α : typevec n}
(r : cofix F α → cofix F α → exprProp())
(h' : ∀ x, r x x)
(h : ∀
 x
 y, r x y → «expr = »(«expr <$$> »(append_fun id (quot.mk r), cofix.dest x), «expr <$$> »(append_fun id (quot.mk r), cofix.dest y))) : ∀
x y, r x y → «expr = »(x, y) :=
begin
  intro [ident x],
  apply [expr quot.induction_on x],
  clear [ident x],
  intros [ident x, ident y],
  apply [expr quot.induction_on y],
  clear [ident y],
  intros [ident y, ident rxy],
  apply [expr quot.sound],
  let [ident r'] [] [":=", expr λ x y, r (quot.mk _ x) (quot.mk _ y)],
  have [] [":", expr is_precongr r'] [],
  { intros [ident a, ident b, ident r'ab],
    have [ident h₀] [":", expr «expr = »(«expr <$$> »(append_fun id «expr ∘ »(quot.mk r, quot.mk Mcongr), abs (M.dest q.P a)), «expr <$$> »(append_fun id «expr ∘ »(quot.mk r, quot.mk Mcongr), abs (M.dest q.P b)))] [":=", expr by rw ["[", expr append_fun_comp_id, ",", expr comp_map, ",", expr comp_map, "]"] []; exact [expr h _ _ r'ab]],
    have [ident h₁] [":", expr ∀ u v : q.P.M α, Mcongr u v → «expr = »(quot.mk r' u, quot.mk r' v)] [],
    { intros [ident u, ident v, ident cuv],
      apply [expr quot.sound],
      dsimp [] ["[", expr r', "]"] [] [],
      rw [expr quot.sound cuv] [],
      apply [expr h'] },
    let [ident f] [":", expr quot r → quot r'] [":=", expr quot.lift (quot.lift (quot.mk r') h₁) (begin
        intro [ident c],
        apply [expr quot.induction_on c],
        clear [ident c],
        intros [ident c, ident d],
        apply [expr quot.induction_on d],
        clear [ident d],
        intros [ident d, ident rcd],
        apply [expr quot.sound],
        apply [expr rcd]
      end)],
    have [] [":", expr «expr = »(«expr ∘ »(f, «expr ∘ »(quot.mk r, quot.mk Mcongr)), quot.mk r')] [":=", expr rfl],
    rw ["[", "<-", expr this, ",", expr append_fun_comp_id, ",", expr q.P.comp_map, ",", expr q.P.comp_map, ",", expr abs_map, ",", expr abs_map, ",", expr abs_map, ",", expr abs_map, ",", expr h₀, "]"] [] },
  refine [expr ⟨r', this, rxy⟩]
end

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Bisimulation principle using `map` and `quot.mk` to match and relate children of two trees. -/
theorem cofix.bisim_rel
{α : typevec n}
(r : cofix F α → cofix F α → exprProp())
(h : ∀
 x
 y, r x y → «expr = »(«expr <$$> »(append_fun id (quot.mk r), cofix.dest x), «expr <$$> »(append_fun id (quot.mk r), cofix.dest y))) : ∀
x y, r x y → «expr = »(x, y) :=
let r' (x y) := «expr ∨ »(«expr = »(x, y), r x y) in
begin
  intros [ident x, ident y, ident rxy],
  apply [expr cofix.bisim_aux r'],
  { intro [ident x],
    left,
    reflexivity },
  { intros [ident x, ident y, ident r'xy],
    cases [expr r'xy] [],
    { rw [expr r'xy] [] },
    have [] [":", expr ∀ x y, r x y → r' x y] [":=", expr λ x y h, or.inr h],
    rw ["<-", expr quot.factor_mk_eq _ _ this] [],
    dsimp [] [] [] [],
    rw ["[", expr append_fun_comp_id, ",", expr append_fun_comp_id, "]"] [],
    rw ["[", expr @comp_map _ _ _ q _ _ _ (append_fun id (quot.mk r)), ",", expr @comp_map _ _ _ q _ _ _ (append_fun id (quot.mk r)), "]"] [],
    rw [expr h _ _ r'xy] [] },
  right,
  exact [expr rxy]
end

/-- Bisimulation principle using `liftr` to match and relate children of two trees. -/
theorem cofix.bisim {α : Typevec n} (r : cofix F α → cofix F α → Prop)
  (h : ∀ x y, r x y → liftr (rel_last α r) (cofix.dest x) (cofix.dest y)) : ∀ x y, r x y → x = y :=
  by 
    apply cofix.bisim_rel 
    intro x y rxy 
    rcases(liftr_iff (rel_last α r) _ _).mp (h x y rxy) with ⟨a, f₀, f₁, dxeq, dyeq, h'⟩
    rw [dxeq, dyeq, ←abs_map, ←abs_map, Mvpfunctor.map_eq, Mvpfunctor.map_eq]
    rw [←split_drop_fun_last_fun f₀, ←split_drop_fun_last_fun f₁]
    rw [append_fun_comp_split_fun, append_fun_comp_split_fun]
    rw [id_comp, id_comp]
    congr 2 with i j 
    cases' i with _ i <;> dsimp
    ·
      apply Quot.sound 
      apply h' _ j
    ·
      change f₀ _ j = f₁ _ j 
      apply h' _ j

open Mvfunctor

/-- Bisimulation principle using `liftr'` to match and relate children of two trees. -/
theorem cofix.bisim₂ {α : Typevec n} (r : cofix F α → cofix F α → Prop)
  (h : ∀ x y, r x y → liftr' (rel_last' α r) (cofix.dest x) (cofix.dest y)) : ∀ x y, r x y → x = y :=
  cofix.bisim _$
    by 
      intros  <;> rw [←liftr_last_rel_iff] <;> apply h <;> assumption

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- Bisimulation principle the values `⟨a,f⟩` of the polynomial functor representing
`cofix F α` as well as an invariant `Q : β → Prop` and a state `β` generating the
left-hand side and right-hand side of the equality through functions `u v : β → cofix F α` -/
theorem cofix.bisim'
{α : typevec n}
{β : Type*}
(Q : β → exprProp())
(u v : β → cofix F α)
(h : ∀
 x, Q x → «expr∃ , »((a
   f'
   f₀
   f₁), «expr ∧ »(«expr = »(cofix.dest (u x), abs ⟨a, q.P.append_contents f' f₀⟩), «expr ∧ »(«expr = »(cofix.dest (v x), abs ⟨a, q.P.append_contents f' f₁⟩), ∀
    i, «expr∃ , »((x'), «expr ∧ »(Q x', «expr ∧ »(«expr = »(f₀ i, u x'), «expr = »(f₁ i, v x')))))))) : ∀
x, Q x → «expr = »(u x, v x) :=
λ
x
Qx, let R := λ w z : cofix F α, «expr∃ , »((x'), «expr ∧ »(Q x', «expr ∧ »(«expr = »(w, u x'), «expr = »(z, v x')))) in
cofix.bisim R (λ (x y) ⟨x', Qx', xeq, yeq⟩, begin
   rcases [expr h x' Qx', "with", "⟨", ident a, ",", ident f', ",", ident f₀, ",", ident f₁, ",", ident ux'eq, ",", ident vx'eq, ",", ident h', "⟩"],
   rw [expr liftr_iff] [],
   refine [expr ⟨a, q.P.append_contents f' f₀, q.P.append_contents f' f₁, «expr ▸ »(xeq.symm, ux'eq), «expr ▸ »(yeq.symm, vx'eq), _⟩],
   intro [ident i],
   cases [expr i] [],
   { apply [expr h'] },
   { intro [ident j],
     apply [expr eq.refl] }
 end) _ _ ⟨x, Qx, rfl, rfl⟩

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem cofix.mk_dest {α : typevec n} (x : cofix F α) : «expr = »(cofix.mk (cofix.dest x), x) :=
begin
  apply [expr cofix.bisim_rel (λ x y : cofix F α, «expr = »(x, cofix.mk (cofix.dest y))) _ _ _ rfl],
  dsimp [] [] [] [],
  intros [ident x, ident y, ident h],
  rw [expr h] [],
  conv [] [] { to_lhs,
    congr,
    skip,
    rw ["[", expr cofix.mk, "]"],
    rw [expr cofix.dest_corec] },
  rw ["[", "<-", expr comp_map, ",", "<-", expr append_fun_comp, ",", expr id_comp, "]"] [],
  rw ["[", "<-", expr comp_map, ",", "<-", expr append_fun_comp, ",", expr id_comp, ",", "<-", expr cofix.mk, "]"] [],
  congr' [2] ["with", ident u],
  apply [expr quot.sound],
  refl
end

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem cofix.dest_mk {α : typevec n} (x : F «expr $ »(α.append1, cofix F α)) : «expr = »(cofix.dest (cofix.mk x), x) :=
begin
  have [] [":", expr «expr = »(«expr ∘ »(cofix.mk, cofix.dest), @_root_.id (cofix F α))] [":=", expr funext cofix.mk_dest],
  rw ["[", expr cofix.mk, ",", expr cofix.dest_corec, ",", "<-", expr comp_map, ",", "<-", expr cofix.mk, ",", "<-", expr append_fun_comp, ",", expr this, ",", expr id_comp, ",", expr append_fun_id_id, ",", expr mvfunctor.id_map, "]"] []
end

theorem cofix.ext {α : Typevec n} (x y : cofix F α) (h : x.dest = y.dest) : x = y :=
  by 
    rw [←cofix.mk_dest x, h, cofix.mk_dest]

theorem cofix.ext_mk {α : Typevec n} (x y : F (α ::: cofix F α)) (h : cofix.mk x = cofix.mk y) : x = y :=
  by 
    rw [←cofix.dest_mk x, h, cofix.dest_mk]

/-!
`liftr_map`, `liftr_map_last` and `liftr_map_last'` are useful for reasoning about
the induction step in bisimulation proofs.
-/


section LiftrMap

omit q

theorem liftr_map {α β : Typevec n} {F' : Typevec n → Type u} [Mvfunctor F'] [IsLawfulMvfunctor F']
  (R : β ⊗ β ⟹ repeat n Prop) (x : F' α) (f g : α ⟹ β) (h : α ⟹ subtype_ R)
  (hh : subtype_val _ ⊚ h = (f ⊗' g) ⊚ prod.diag) : liftr' R (f <$$> x) (g <$$> x) :=
  by 
    rw [liftr_def]
    exists h <$$> x 
    rw [Mvfunctor.map_map, comp_assoc, hh, ←comp_assoc, fst_prod_mk, comp_assoc, fst_diag]
    rw [Mvfunctor.map_map, comp_assoc, hh, ←comp_assoc, snd_prod_mk, comp_assoc, snd_diag]
    dsimp [liftr']
    split  <;> rfl

open Function

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem liftr_map_last
[is_lawful_mvfunctor F]
{α : typevec n}
{ι ι'}
(R : ι' → ι' → exprProp())
(x : F [«expr ::: »/«expr ::: »](α, ι))
(f g : ι → ι')
(hh : ∀
 x : ι, R (f x) (g x)) : liftr' (rel_last' _ R) «expr <$$> »([«expr ::: »/«expr ::: »](id, f), x) «expr <$$> »([«expr ::: »/«expr ::: »](id, g), x) :=
let h : ι → {x : «expr × »(ι', ι') // uncurry R x} := λ x, ⟨(f x, g x), hh x⟩ in
let b : «expr ⟹ »([«expr ::: »/«expr ::: »](α, ι), _) := [«expr ::: »/«expr ::: »](@diag_sub n α, h),
    c : «expr ⟹ »([«expr ::: »/«expr ::: »](subtype_ α.repeat_eq, {x // uncurry R x}), [«expr ::: »/«expr ::: »](λ
      i : fin2 n, {x // of_repeat (α.rel_last' R i.fs x)}, subtype (uncurry R))) := [«expr ::: »/«expr ::: »](of_subtype _, id) in
have hh : «expr = »(«expr ⊚ »(subtype_val _, «expr ⊚ »(to_subtype _, «expr ⊚ »(from_append1_drop_last, «expr ⊚ »(c, b)))), «expr ⊚ »(«expr ⊗' »([«expr ::: »/«expr ::: »](id, f), [«expr ::: »/«expr ::: »](id, g)), prod.diag)), by { dsimp [] ["[", expr c, ",", expr b, "]"] [] [],
  apply [expr eq_of_drop_last_eq],
  { dsimp [] [] [] [],
    simp [] [] ["only"] ["[", expr prod_map_id, ",", expr drop_fun_prod, ",", expr drop_fun_append_fun, ",", expr drop_fun_diag, ",", expr id_comp, ",", expr drop_fun_to_subtype, "]"] [] [],
    erw ["[", expr to_subtype_of_subtype_assoc, ",", expr id_comp, "]"] [],
    clear_except [],
    ext [] [ident i, ident x] [":", 2],
    induction [expr i] [] [] [],
    refl,
    apply [expr i_ih] },
  simp [] [] ["only"] ["[", expr h, ",", expr last_fun_from_append1_drop_last, ",", expr last_fun_to_subtype, ",", expr last_fun_append_fun, ",", expr last_fun_subtype_val, ",", expr comp.left_id, ",", expr last_fun_comp, ",", expr last_fun_prod, "]"] [] [],
  dsimp [] [] [] [],
  ext1 [] [],
  refl },
liftr_map _ _ _ _ «expr ⊚ »(to_subtype _, «expr ⊚ »(from_append1_drop_last, «expr ⊚ »(c, b))) hh

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem liftr_map_last'
[is_lawful_mvfunctor F]
{α : typevec n}
{ι}
(R : ι → ι → exprProp())
(x : F [«expr ::: »/«expr ::: »](α, ι))
(f : ι → ι)
(hh : ∀ x : ι, R (f x) x) : liftr' (rel_last' _ R) «expr <$$> »([«expr ::: »/«expr ::: »](id, f), x) x :=
begin
  have [] [] [":=", expr liftr_map_last R x f id hh],
  rwa ["[", expr append_fun_id_id, ",", expr mvfunctor.id_map, "]"] ["at", ident this]
end

end LiftrMap

-- error in Data.Qpf.Multivariate.Constructions.Cofix: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem cofix.abs_repr {α} (x : cofix F α) : «expr = »(quot.mk _ (cofix.repr x), x) :=
begin
  let [ident R] [] [":=", expr λ x y : cofix F α, «expr = »(cofix.abs (cofix.repr y), x)],
  refine [expr cofix.bisim₂ R _ _ _ rfl],
  clear [ident x],
  rintros [ident x, ident y, ident h],
  dsimp [] ["[", expr R, "]"] [] ["at", ident h],
  subst [expr h],
  dsimp [] ["[", expr cofix.dest, ",", expr cofix.abs, "]"] [] [],
  induction [expr y] ["using", ident quot.ind] [] [],
  simp [] [] ["only"] ["[", expr cofix.repr, ",", expr M.dest_corec, ",", expr abs_map, ",", expr abs_repr, "]"] [] [],
  conv [] [] { congr,
    skip,
    rw [expr cofix.dest] },
  dsimp [] [] [] [],
  rw ["[", expr mvfunctor.map_map, ",", expr mvfunctor.map_map, ",", "<-", expr append_fun_comp_id, ",", "<-", expr append_fun_comp_id, "]"] [],
  let [ident f] [":", expr «expr ⟹ »([«expr ::: »/«expr ::: »](α, (P F).M α), subtype_ (α.rel_last' R))] [":=", expr split_fun diag_sub (λ
    x, ⟨(cofix.abs (cofix.abs x).repr, cofix.abs x), _⟩)],
  refine [expr liftr_map _ _ _ _ f _],
  { simp [] [] ["only"] ["[", "<-", expr append_prod_append_fun, ",", expr prod_map_id, "]"] [] [],
    apply [expr eq_of_drop_last_eq],
    { dsimp [] [] [] [],
      simp [] [] ["only"] ["[", expr drop_fun_diag, "]"] [] [],
      erw [expr subtype_val_diag_sub] [] },
    ext1 [] [],
    simp [] [] ["only"] ["[", expr cofix.abs, ",", expr prod.mk.inj_iff, ",", expr prod_map, ",", expr function.comp_app, ",", expr last_fun_append_fun, ",", expr last_fun_subtype_val, ",", expr last_fun_comp, ",", expr last_fun_split_fun, "]"] [] [],
    dsimp [] ["[", expr drop_fun_rel_last, ",", expr last_fun, ",", expr prod.diag, "]"] [] [],
    split; refl },
  dsimp [] ["[", expr rel_last', ",", expr split_fun, ",", expr function.uncurry, ",", expr R, "]"] [] [],
  refl
end

section Tactic

setup_tactic_parser

open Tactic

omit q

/-- tactic for proof by bisimulation -/
unsafe def mv_bisim (e : parse texpr) (ids : parse with_ident_list) : tactic Unit :=
  do 
    let e ← to_expr e 
    let expr.pi n bi d b ←
      retrieve$
          do 
            generalize e 
            target 
    let quote.1 (@Eq (%%ₓt) (%%ₓl) (%%ₓr)) ← pure b 
    let x ← mk_local_def `n d 
    let v₀ ← mk_local_def `a t 
    let v₁ ← mk_local_def `b t 
    let x₀ ← mk_app `` Eq [v₀, l.instantiate_var x]
    let x₁ ← mk_app `` Eq [v₁, r.instantiate_var x]
    let xx ← mk_app `` And [x₀, x₁]
    let ex ← lambdas [x] xx 
    let ex ← mk_app `` Exists [ex] >>= lambdas [v₀, v₁]
    let R ← pose `R none ex 
    refine (pquote.1 (cofix.bisim₂ (%%ₓR) _ _ _ ⟨_, rfl, rfl⟩))
    let f (a b : Name) : Name := if a = `_ then b else a 
    let ids := (ids ++ List.repeat `_ 5).zipWith f [`a, `b, `x, `Ha, `Hb]
    let (ids₀, w :: ids₁) ← pure$ List.splitAt 2 ids 
    intro_lst ids₀ 
    let h ← intro1 
    let [(_, [w, h], _)] ← cases_core h [w]
    cases h ids₁ 
    pure ()

run_cmd 
  add_interactive [`` mv_bisim]

end Tactic

theorem corec_roll {α : Typevec n} {X Y} {x₀ : X} (f : X → Y) (g : Y → F (α ::: X)) :
  cofix.corec (g ∘ f) x₀ = cofix.corec (Mvfunctor.map (id ::: f) ∘ g) (f x₀) :=
  by 
    mvBisim x₀ 
    rw [Ha, Hb, cofix.dest_corec, cofix.dest_corec]
    rw [Mvfunctor.map_map, ←append_fun_comp_id]
    refine' liftr_map_last _ _ _ _ _ 
    intro a 
    refine' ⟨a, rfl, rfl⟩

theorem cofix.dest_corec' {α : Typevec n} {β : Type u} (g : β → F (α.append1 (Sum (cofix F α) β))) (x : β) :
  cofix.dest (cofix.corec' g x) = append_fun id (Sum.elim id (cofix.corec' g)) <$$> g x :=
  by 
    rw [cofix.corec', cofix.dest_corec]
    dsimp 
    congr with (i | i) <;> rw [corec_roll] <;> dsimp [cofix.corec']
    ·
      mvBisim i 
      rw [Ha, Hb, cofix.dest_corec]
      dsimp [· ∘ ·]
      repeat' 
        rw [Mvfunctor.map_map, ←append_fun_comp_id]
      apply liftr_map_last' 
      dsimp [· ∘ ·, R]
      intros 
      exact ⟨_, rfl, rfl⟩
    ·
      congr with y 
      erw [append_fun_id_id]
      simp [Mvfunctor.id_map]

theorem cofix.dest_corec₁ {α : Typevec n} {β : Type u} (g : ∀ {X}, (cofix F α → X) → (β → X) → β → F (α.append1 X))
  (x : β) (h : ∀ X Y (f : cofix F α → X) (f' : β → X) (k : X → Y), g (k ∘ f) (k ∘ f') x = (id ::: k) <$$> g f f' x) :
  cofix.dest (cofix.corec₁ (@g) x) = g id (cofix.corec₁ @g) x :=
  by 
    rw [cofix.corec₁, cofix.dest_corec', ←h] <;> rfl

instance mvqpf_cofix : Mvqpf (cofix F) :=
  { p := q.P.Mp, abs := fun α => Quot.mk Mcongr, repr := fun α => cofix.repr, abs_repr := fun α => cofix.abs_repr,
    abs_map := fun α β g x => rfl }

end Mvqpf

