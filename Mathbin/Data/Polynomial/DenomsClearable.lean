/-
Copyright (c) 2020 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa

! This file was ported from Lean 3 source module data.polynomial.denoms_clearable
! leanprover-community/mathlib commit 97eab48559068f3d6313da387714ef25768fb730
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Polynomial.EraseLead
import Mathbin.Data.Polynomial.Eval

/-!
# Denominators of evaluation of polynomials at ratios

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Let `i : R → K` be a homomorphism of semirings.  Assume that `K` is commutative.  If `a` and
`b` are elements of `R` such that `i b ∈ K` is invertible, then for any polynomial
`f ∈ R[X]` the "mathematical" expression `b ^ f.nat_degree * f (a / b) ∈ K` is in
the image of the homomorphism `i`.
-/


open Polynomial Finset

open Polynomial

section DenomsClearable

variable {R K : Type _} [Semiring R] [CommSemiring K] {i : R →+* K}

variable {a b : R} {bi : K}

#print DenomsClearable /-
-- TODO: use hypothesis (ub : is_unit (i b)) to work with localizations.
/-- `denoms_clearable` formalizes the property that `b ^ N * f (a / b)`
does not have denominators, if the inequality `f.nat_degree ≤ N` holds.

The definition asserts the existence of an element `D` of `R` and an
element `bi = 1 / i b` of `K` such that clearing the denominators of
the fraction equals `i D`.
-/
def DenomsClearable (a b : R) (N : ℕ) (f : R[X]) (i : R →+* K) : Prop :=
  ∃ (D : R)(bi : K), bi * i b = 1 ∧ i D = i b ^ N * eval (i a * bi) (f.map i)
#align denoms_clearable DenomsClearable
-/

/- warning: denoms_clearable_zero -> denomsClearable_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {K : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommSemiring.{u2} K] {i : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))} {b : R} {bi : K} (N : Nat) (a : R), (Eq.{succ u2} K (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (NonUnitalNonAssocSemiring.toDistrib.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))))) bi (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) (fun (_x : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) => R -> K) (RingHom.hasCoeToFun.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) i b)) (OfNat.ofNat.{u2} K 1 (OfNat.mk.{u2} K 1 (One.one.{u2} K (AddMonoidWithOne.toOne.{u2} K (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} K (NonAssocSemiring.toAddCommMonoidWithOne.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))))))) -> (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b N (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) i)
but is expected to have type
  forall {R : Type.{u1}} {K : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommSemiring.{u2} K] {i : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))} {b : R} {bi : K} (N : Nat) (a : R), (Eq.{succ u2} K (HMul.hMul.{u2, u2, u2} K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => K) b) K (instHMul.{u2} K (NonUnitalNonAssocSemiring.toMul.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))) bi (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => K) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R K (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))))) i b)) (OfNat.ofNat.{u2} K 1 (One.toOfNat1.{u2} K (Semiring.toOne.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))) -> (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b N (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))) i)
Case conversion may be inaccurate. Consider using '#align denoms_clearable_zero denomsClearable_zeroₓ'. -/
theorem denomsClearable_zero (N : ℕ) (a : R) (bu : bi * i b = 1) : DenomsClearable a b N 0 i :=
  ⟨0, bi, bu, by
    simp only [eval_zero, RingHom.map_zero, MulZeroClass.mul_zero, Polynomial.map_zero]⟩
#align denoms_clearable_zero denomsClearable_zero

/- warning: denoms_clearable_C_mul_X_pow -> denomsClearable_C_mul_X_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {K : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommSemiring.{u2} K] {i : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))} {b : R} {bi : K} {N : Nat} (a : R), (Eq.{succ u2} K (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (NonUnitalNonAssocSemiring.toDistrib.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))))) bi (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) (fun (_x : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) => R -> K) (RingHom.hasCoeToFun.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) i b)) (OfNat.ofNat.{u2} K 1 (OfNat.mk.{u2} K 1 (One.one.{u2} K (AddMonoidWithOne.toOne.{u2} K (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} K (NonAssocSemiring.toAddCommMonoidWithOne.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))))))) -> (forall {n : Nat} (r : R), (LE.le.{0} Nat Nat.hasLe n N) -> (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b N (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) r) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) n)) i))
but is expected to have type
  forall {R : Type.{u1}} {K : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommSemiring.{u2} K] {i : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))} {b : R} {bi : K} {N : Nat} (a : R), (Eq.{succ u2} K (HMul.hMul.{u2, u2, u2} K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => K) b) K (instHMul.{u2} K (NonUnitalNonAssocSemiring.toMul.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))) bi (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => K) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R K (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))))) i b)) (OfNat.ofNat.{u2} K 1 (One.toOfNat1.{u2} K (Semiring.toOne.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))) -> (forall {n : Nat} (r : R), (LE.le.{0} Nat instLENat n N) -> (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b N (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) r) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) r) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) r) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) n)) i))
Case conversion may be inaccurate. Consider using '#align denoms_clearable_C_mul_X_pow denomsClearable_C_mul_X_powₓ'. -/
/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([2]) } -/
theorem denomsClearable_C_mul_X_pow {N : ℕ} (a : R) (bu : bi * i b = 1) {n : ℕ} (r : R)
    (nN : n ≤ N) : DenomsClearable a b N (C r * X ^ n) i :=
  by
  refine' ⟨r * a ^ n * b ^ (N - n), bi, bu, _⟩
  rw [C_mul_X_pow_eq_monomial, map_monomial, ← C_mul_X_pow_eq_monomial, eval_mul, eval_pow, eval_C]
  rw [RingHom.map_mul, RingHom.map_mul, RingHom.map_pow, RingHom.map_pow, eval_X, mul_comm]
  rw [← tsub_add_cancel_of_le nN]
  rw [pow_add, mul_assoc, mul_comm (i b ^ n), mul_pow, mul_assoc, mul_assoc (i a ^ n), ← mul_pow]
  rw [bu, one_pow, mul_one]
#align denoms_clearable_C_mul_X_pow denomsClearable_C_mul_X_pow

/- warning: denoms_clearable.add -> DenomsClearable.add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {K : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommSemiring.{u2} K] {i : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))} {a : R} {b : R} {N : Nat} {f : Polynomial.{u1} R _inst_1} {g : Polynomial.{u1} R _inst_1}, (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b N f i) -> (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b N g i) -> (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b N (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) f g) i)
but is expected to have type
  forall {R : Type.{u2}} {K : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : CommSemiring.{u1} K] {i : RingHom.{u2, u1} R K (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2))} {a : R} {b : R} {N : Nat} {f : Polynomial.{u2} R _inst_1} {g : Polynomial.{u2} R _inst_1}, (DenomsClearable.{u2, u1} R K _inst_1 _inst_2 a b N f i) -> (DenomsClearable.{u2, u1} R K _inst_1 _inst_2 a b N g i) -> (DenomsClearable.{u2, u1} R K _inst_1 _inst_2 a b N (HAdd.hAdd.{u2, u2, u2} (Polynomial.{u2} R _inst_1) (Polynomial.{u2} R _inst_1) (Polynomial.{u2} R _inst_1) (instHAdd.{u2} (Polynomial.{u2} R _inst_1) (Polynomial.add'.{u2} R _inst_1)) f g) i)
Case conversion may be inaccurate. Consider using '#align denoms_clearable.add DenomsClearable.addₓ'. -/
theorem DenomsClearable.add {N : ℕ} {f g : R[X]} :
    DenomsClearable a b N f i → DenomsClearable a b N g i → DenomsClearable a b N (f + g) i :=
  fun ⟨Df, bf, bfu, Hf⟩ ⟨Dg, bg, bgu, Hg⟩ =>
  ⟨Df + Dg, bf, bfu,
    by
    rw [RingHom.map_add, Polynomial.map_add, eval_add, mul_add, Hf, Hg]
    congr
    refine' @inv_unique K _ (i b) bg bf _ _ <;> rwa [mul_comm]⟩
#align denoms_clearable.add DenomsClearable.add

/- warning: denoms_clearable_of_nat_degree_le -> denomsClearable_of_natDegree_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {K : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommSemiring.{u2} K] {i : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))} {b : R} {bi : K} (N : Nat) (a : R), (Eq.{succ u2} K (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (NonUnitalNonAssocSemiring.toDistrib.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))))) bi (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) (fun (_x : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) => R -> K) (RingHom.hasCoeToFun.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) i b)) (OfNat.ofNat.{u2} K 1 (OfNat.mk.{u2} K 1 (One.one.{u2} K (AddMonoidWithOne.toOne.{u2} K (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} K (NonAssocSemiring.toAddCommMonoidWithOne.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))))))) -> (forall (f : Polynomial.{u1} R _inst_1), (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_1 f) N) -> (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b N f i))
but is expected to have type
  forall {R : Type.{u1}} {K : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommSemiring.{u2} K] {i : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))} {b : R} {bi : K} (N : Nat) (a : R), (Eq.{succ u2} K (HMul.hMul.{u2, u2, u2} K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => K) b) K (instHMul.{u2} K (NonUnitalNonAssocSemiring.toMul.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))) bi (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => K) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R K (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))))) i b)) (OfNat.ofNat.{u2} K 1 (One.toOfNat1.{u2} K (Semiring.toOne.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))) -> (forall (f : Polynomial.{u1} R _inst_1), (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R _inst_1 f) N) -> (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b N f i))
Case conversion may be inaccurate. Consider using '#align denoms_clearable_of_nat_degree_le denomsClearable_of_natDegree_leₓ'. -/
theorem denomsClearable_of_natDegree_le (N : ℕ) (a : R) (bu : bi * i b = 1) :
    ∀ f : R[X], f.natDegree ≤ N → DenomsClearable a b N f i :=
  induction_with_natDegree_le _ N (denomsClearable_zero N a bu)
    (fun N_1 r r0 => denomsClearable_C_mul_X_pow a bu r) fun f g fg gN df dg => df.add dg
#align denoms_clearable_of_nat_degree_le denomsClearable_of_natDegree_le

/- warning: denoms_clearable_nat_degree -> denomsClearable_natDegree is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {K : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommSemiring.{u2} K] {b : R} {bi : K} (i : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) (f : Polynomial.{u1} R _inst_1) (a : R), (Eq.{succ u2} K (HMul.hMul.{u2, u2, u2} K K K (instHMul.{u2} K (Distrib.toHasMul.{u2} K (NonUnitalNonAssocSemiring.toDistrib.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2)))))) bi (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) (fun (_x : RingHom.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) => R -> K) (RingHom.hasCoeToFun.{u1, u2} R K (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))) i b)) (OfNat.ofNat.{u2} K 1 (OfNat.mk.{u2} K 1 (One.one.{u2} K (AddMonoidWithOne.toOne.{u2} K (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} K (NonAssocSemiring.toAddCommMonoidWithOne.{u2} K (Semiring.toNonAssocSemiring.{u2} K (CommSemiring.toSemiring.{u2} K _inst_2))))))))) -> (DenomsClearable.{u1, u2} R K _inst_1 _inst_2 a b (Polynomial.natDegree.{u1} R _inst_1 f) f i)
but is expected to have type
  forall {R : Type.{u2}} {K : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : CommSemiring.{u1} K] {b : R} {bi : K} (i : RingHom.{u2, u1} R K (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2))) (f : Polynomial.{u2} R _inst_1) (a : R), (Eq.{succ u1} K (HMul.hMul.{u1, u1, u1} K ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => K) b) K (instHMul.{u1} K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2))))) bi (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R K (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => K) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R K (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2))) R K (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R K (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2))) R K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R K (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2))) R K (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R K (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2)))))) i b)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (Semiring.toOne.{u1} K (CommSemiring.toSemiring.{u1} K _inst_2))))) -> (DenomsClearable.{u2, u1} R K _inst_1 _inst_2 a b (Polynomial.natDegree.{u2} R _inst_1 f) f i)
Case conversion may be inaccurate. Consider using '#align denoms_clearable_nat_degree denomsClearable_natDegreeₓ'. -/
/-- If `i : R → K` is a ring homomorphism, `f` is a polynomial with coefficients in `R`,
`a, b` are elements of `R`, with `i b` invertible, then there is a `D ∈ R` such that
`b ^ f.nat_degree * f (a / b)` equals `i D`. -/
theorem denomsClearable_natDegree (i : R →+* K) (f : R[X]) (a : R) (bu : bi * i b = 1) :
    DenomsClearable a b f.natDegree f i :=
  denomsClearable_of_natDegree_le f.natDegree a bu f le_rfl
#align denoms_clearable_nat_degree denomsClearable_natDegree

end DenomsClearable

open RingHom

/- warning: one_le_pow_mul_abs_eval_div -> one_le_pow_mul_abs_eval_div is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} K] {f : Polynomial.{0} Int Int.semiring} {a : Int} {b : Int}, (LT.lt.{0} Int Int.hasLt (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) b) -> (Ne.{succ u1} K (Polynomial.eval.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int K (HasLiftT.mk.{1, succ u1} Int K (CoeTCₓ.coe.{1, succ u1} Int K (Int.castCoe.{u1} K (AddGroupWithOne.toHasIntCast.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))))))) a) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int K (HasLiftT.mk.{1, succ u1} Int K (CoeTCₓ.coe.{1, succ u1} Int K (Int.castCoe.{u1} K (AddGroupWithOne.toHasIntCast.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))))))) b)) (Polynomial.map.{0, u1} Int K Int.semiring (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) (algebraMap.{0, u1} Int K Int.commSemiring (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) (algebraInt.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))) f)) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))))))))))) -> (LE.le.{u1} K (Preorder.toHasLe.{u1} K (PartialOrder.toPreorder.{u1} K (OrderedAddCommGroup.toPartialOrder.{u1} K (StrictOrderedRing.toOrderedAddCommGroup.{u1} K (LinearOrderedRing.toStrictOrderedRing.{u1} K (LinearOrderedCommRing.toLinearOrderedRing.{u1} K (LinearOrderedField.toLinearOrderedCommRing.{u1} K _inst_1))))))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))))) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (Ring.toMonoid.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int K (HasLiftT.mk.{1, succ u1} Int K (CoeTCₓ.coe.{1, succ u1} Int K (Int.castCoe.{u1} K (AddGroupWithOne.toHasIntCast.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))))))) b) (Polynomial.natDegree.{0} Int Int.semiring f)) (Abs.abs.{u1} K (Neg.toHasAbs.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} K (Lattice.toSemilatticeSup.{u1} K (LinearOrder.toLattice.{u1} K (LinearOrderedRing.toLinearOrder.{u1} K (LinearOrderedCommRing.toLinearOrderedRing.{u1} K (LinearOrderedField.toLinearOrderedCommRing.{u1} K _inst_1))))))) (Polynomial.eval.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int K (HasLiftT.mk.{1, succ u1} Int K (CoeTCₓ.coe.{1, succ u1} Int K (Int.castCoe.{u1} K (AddGroupWithOne.toHasIntCast.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))))))) a) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int K (HasLiftT.mk.{1, succ u1} Int K (CoeTCₓ.coe.{1, succ u1} Int K (Int.castCoe.{u1} K (AddGroupWithOne.toHasIntCast.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))))))) b)) (Polynomial.map.{0, u1} Int K Int.semiring (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) (algebraMap.{0, u1} Int K Int.commSemiring (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) (algebraInt.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))) f)))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : LinearOrderedField.{u1} K] {f : Polynomial.{0} Int Int.instSemiringInt} {a : Int} {b : Int}, (LT.lt.{0} Int Int.instLTInt (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) b) -> (Ne.{succ u1} K (Polynomial.eval.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (LinearOrderedSemifield.toSemifield.{u1} K (LinearOrderedField.toLinearOrderedSemifield.{u1} K _inst_1)))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (LinearOrderedField.toDiv.{u1} K _inst_1)) (Int.cast.{u1} K (Ring.toIntCast.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) a) (Int.cast.{u1} K (Ring.toIntCast.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) b)) (Polynomial.map.{0, u1} Int K (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (LinearOrderedSemifield.toSemifield.{u1} K (LinearOrderedField.toLinearOrderedSemifield.{u1} K _inst_1)))) (algebraMap.{0, u1} Int K Int.instCommSemiringInt (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (LinearOrderedSemifield.toSemifield.{u1} K (LinearOrderedField.toLinearOrderedSemifield.{u1} K _inst_1)))) (algebraInt.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))) f)) (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommGroupWithZero.toCommMonoidWithZero.{u1} K (Semifield.toCommGroupWithZero.{u1} K (LinearOrderedSemifield.toSemifield.{u1} K (LinearOrderedField.toLinearOrderedSemifield.{u1} K _inst_1)))))))) -> (LE.le.{u1} K (Preorder.toLE.{u1} K (PartialOrder.toPreorder.{u1} K (StrictOrderedRing.toPartialOrder.{u1} K (LinearOrderedRing.toStrictOrderedRing.{u1} K (LinearOrderedCommRing.toLinearOrderedRing.{u1} K (LinearOrderedField.toLinearOrderedCommRing.{u1} K _inst_1)))))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (Semiring.toOne.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (LinearOrderedSemifield.toSemifield.{u1} K (LinearOrderedField.toLinearOrderedSemifield.{u1} K _inst_1))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))))) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (LinearOrderedSemifield.toSemifield.{u1} K (LinearOrderedField.toLinearOrderedSemifield.{u1} K _inst_1)))))))) (Int.cast.{u1} K (Ring.toIntCast.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) b) (Polynomial.natDegree.{0} Int Int.instSemiringInt f)) (Abs.abs.{u1} K (Neg.toHasAbs.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) (SemilatticeSup.toSup.{u1} K (Lattice.toSemilatticeSup.{u1} K (DistribLattice.toLattice.{u1} K (instDistribLattice.{u1} K (LinearOrderedRing.toLinearOrder.{u1} K (LinearOrderedCommRing.toLinearOrderedRing.{u1} K (LinearOrderedField.toLinearOrderedCommRing.{u1} K _inst_1)))))))) (Polynomial.eval.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (LinearOrderedSemifield.toSemifield.{u1} K (LinearOrderedField.toLinearOrderedSemifield.{u1} K _inst_1)))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (LinearOrderedField.toDiv.{u1} K _inst_1)) (Int.cast.{u1} K (Ring.toIntCast.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) a) (Int.cast.{u1} K (Ring.toIntCast.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1)))) b)) (Polynomial.map.{0, u1} Int K (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (LinearOrderedSemifield.toSemifield.{u1} K (LinearOrderedField.toLinearOrderedSemifield.{u1} K _inst_1)))) (algebraMap.{0, u1} Int K Int.instCommSemiringInt (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (LinearOrderedSemifield.toSemifield.{u1} K (LinearOrderedField.toLinearOrderedSemifield.{u1} K _inst_1)))) (algebraInt.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K (LinearOrderedField.toField.{u1} K _inst_1))))) f)))))
Case conversion may be inaccurate. Consider using '#align one_le_pow_mul_abs_eval_div one_le_pow_mul_abs_eval_divₓ'. -/
/-- Evaluating a polynomial with integer coefficients at a rational number and clearing
denominators, yields a number greater than or equal to one.  The target can be any
`linear_ordered_field K`.
The assumption on `K` could be weakened to `linear_ordered_comm_ring` assuming that the
image of the denominator is invertible in `K`. -/
theorem one_le_pow_mul_abs_eval_div {K : Type _} [LinearOrderedField K] {f : ℤ[X]} {a b : ℤ}
    (b0 : 0 < b) (fab : eval ((a : K) / b) (f.map (algebraMap ℤ K)) ≠ 0) :
    (1 : K) ≤ b ^ f.natDegree * |eval ((a : K) / b) (f.map (algebraMap ℤ K))| :=
  by
  obtain ⟨ev, bi, bu, hF⟩ :=
    @denomsClearable_natDegree _ _ _ _ b _ (algebraMap ℤ K) f a
      (by
        rw [eq_intCast, one_div_mul_cancel]
        rw [Int.cast_ne_zero]
        exact b0.ne.symm)
  obtain Fa := congr_arg abs hF
  rw [eq_one_div_of_mul_eq_one_left bu, eq_intCast, eq_intCast, abs_mul] at Fa
  rw [abs_of_pos (pow_pos (int.cast_pos.mpr b0) _ : 0 < (b : K) ^ _), one_div, eq_intCast] at Fa
  rw [div_eq_mul_inv, ← Fa, ← Int.cast_abs, ← Int.cast_one, Int.cast_le]
  refine' Int.le_of_lt_add_one ((lt_add_iff_pos_left 1).mpr (abs_pos.mpr fun F0 => fab _))
  rw [eq_one_div_of_mul_eq_one_left bu, F0, one_div, eq_intCast, Int.cast_zero, zero_eq_mul] at hF
  cases' hF with hF hF
  · exact (not_le.mpr b0 (le_of_eq (int.cast_eq_zero.mp (pow_eq_zero hF)))).elim
  · rwa [div_eq_mul_inv]
#align one_le_pow_mul_abs_eval_div one_le_pow_mul_abs_eval_div

