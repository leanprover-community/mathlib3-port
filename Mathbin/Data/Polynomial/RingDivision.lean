/-
Copyright (c) 2018 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes, Johannes Hölzl, Scott Morrison, Jens Wagemaker, Johan Commelin

! This file was ported from Lean 3 source module data.polynomial.ring_division
! leanprover-community/mathlib commit 97eab48559068f3d6313da387714ef25768fb730
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.CharZero.Infinite
import Mathbin.Data.Polynomial.AlgebraMap
import Mathbin.Data.Polynomial.Degree.Lemmas
import Mathbin.Data.Polynomial.Div
import Mathbin.RingTheory.Localization.FractionRing
import Mathbin.Algebra.Polynomial.BigOperators

/-!
# Theory of univariate polynomials

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file starts looking like the ring theory of $ R[X] $

## Main definitions

* `polynomial.roots p`: The multiset containing all the roots of `p`, including their
  multiplicities.
* `polynomial.root_set p E`: The set of distinct roots of `p` in an algebra `E`.

## Main statements

* `polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C`: If a polynomial has as many roots as its
  degree, it can be written as the product of its leading coefficient with `∏ (X - a)` where `a`
  ranges through its roots.

-/


noncomputable section

open Classical Polynomial

open Finset

namespace Polynomial

universe u v w z

variable {R : Type u} {S : Type v} {T : Type w} {a b : R} {n : ℕ}

section CommRing

variable [CommRing R] {p q : R[X]}

section

variable [Semiring S]

#print Polynomial.natDegree_pos_of_aeval_root /-
theorem natDegree_pos_of_aeval_root [Algebra R S] {p : R[X]} (hp : p ≠ 0) {z : S}
    (hz : aeval z p = 0) (inj : ∀ x : R, algebraMap R S x = 0 → x = 0) : 0 < p.natDegree :=
  natDegree_pos_of_eval₂_root hp (algebraMap R S) hz inj
#align polynomial.nat_degree_pos_of_aeval_root Polynomial.natDegree_pos_of_aeval_root
-/

#print Polynomial.degree_pos_of_aeval_root /-
theorem degree_pos_of_aeval_root [Algebra R S] {p : R[X]} (hp : p ≠ 0) {z : S} (hz : aeval z p = 0)
    (inj : ∀ x : R, algebraMap R S x = 0 → x = 0) : 0 < p.degree :=
  natDegree_pos_iff_degree_pos.mp (natDegree_pos_of_aeval_root hp hz inj)
#align polynomial.degree_pos_of_aeval_root Polynomial.degree_pos_of_aeval_root
-/

#print Polynomial.modByMonic_eq_of_dvd_sub /-
theorem modByMonic_eq_of_dvd_sub (hq : q.Monic) {p₁ p₂ : R[X]} (h : q ∣ p₁ - p₂) :
    p₁ %ₘ q = p₂ %ₘ q := by
  nontriviality R
  obtain ⟨f, sub_eq⟩ := h
  refine' (div_mod_by_monic_unique (p₂ /ₘ q + f) _ hq ⟨_, degree_mod_by_monic_lt _ hq⟩).2
  rw [sub_eq_iff_eq_add.mp sub_eq, mul_add, ← add_assoc, mod_by_monic_add_div _ hq, add_comm]
#align polynomial.mod_by_monic_eq_of_dvd_sub Polynomial.modByMonic_eq_of_dvd_sub
-/

#print Polynomial.add_modByMonic /-
theorem add_modByMonic (p₁ p₂ : R[X]) : (p₁ + p₂) %ₘ q = p₁ %ₘ q + p₂ %ₘ q :=
  by
  by_cases hq : q.monic
  · nontriviality R
    exact
      (div_mod_by_monic_unique (p₁ /ₘ q + p₂ /ₘ q) _ hq
          ⟨by
            rw [mul_add, add_left_comm, add_assoc, mod_by_monic_add_div _ hq, ← add_assoc,
              add_comm (q * _), mod_by_monic_add_div _ hq],
            (degree_add_le _ _).trans_lt
              (max_lt (degree_mod_by_monic_lt _ hq) (degree_mod_by_monic_lt _ hq))⟩).2
  · simp_rw [mod_by_monic_eq_of_not_monic _ hq]
#align polynomial.add_mod_by_monic Polynomial.add_modByMonic
-/

#print Polynomial.smul_modByMonic /-
theorem smul_modByMonic (c : R) (p : R[X]) : c • p %ₘ q = c • (p %ₘ q) :=
  by
  by_cases hq : q.monic
  · nontriviality R
    exact
      (div_mod_by_monic_unique (c • (p /ₘ q)) (c • (p %ₘ q)) hq
          ⟨by rw [mul_smul_comm, ← smul_add, mod_by_monic_add_div p hq],
            (degree_smul_le _ _).trans_lt (degree_mod_by_monic_lt _ hq)⟩).2
  · simp_rw [mod_by_monic_eq_of_not_monic _ hq]
#align polynomial.smul_mod_by_monic Polynomial.smul_modByMonic
-/

#print Polynomial.modByMonicHom /-
/-- `_ %ₘ q` as an `R`-linear map. -/
@[simps]
def modByMonicHom (q : R[X]) : R[X] →ₗ[R] R[X]
    where
  toFun p := p %ₘ q
  map_add' := add_modByMonic
  map_smul' := smul_modByMonic
#align polynomial.mod_by_monic_hom Polynomial.modByMonicHom
-/

end

section

variable [Ring S]

#print Polynomial.aeval_modByMonic_eq_self_of_root /-
theorem aeval_modByMonic_eq_self_of_root [Algebra R S] {p q : R[X]} (hq : q.Monic) {x : S}
    (hx : aeval x q = 0) : aeval x (p %ₘ q) = aeval x p :=
  by-- `eval₂_mod_by_monic_eq_self_of_root` doesn't work here as it needs commutativity
  rw [mod_by_monic_eq_sub_mul_div p hq, _root_.map_sub, _root_.map_mul, hx, MulZeroClass.zero_mul,
    sub_zero]
#align polynomial.aeval_mod_by_monic_eq_self_of_root Polynomial.aeval_modByMonic_eq_self_of_root
-/

end

end CommRing

section NoZeroDivisors

variable [Semiring R] [NoZeroDivisors R] {p q : R[X]}

instance : NoZeroDivisors R[X]
    where eq_zero_or_eq_zero_of_mul_eq_zero a b h :=
    by
    rw [← leading_coeff_eq_zero, ← leading_coeff_eq_zero]
    refine' eq_zero_or_eq_zero_of_mul_eq_zero _
    rw [← leading_coeff_zero, ← leading_coeff_mul, h]

/- warning: polynomial.nat_degree_mul -> Polynomial.natDegree_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Ne.{succ u1} (Polynomial.{u1} R _inst_1) p (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p q)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (Polynomial.natDegree.{u1} R _inst_1 p) (Polynomial.natDegree.{u1} R _inst_1 q)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Ne.{succ u1} (Polynomial.{u1} R _inst_1) p (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p q)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (Polynomial.natDegree.{u1} R _inst_1 p) (Polynomial.natDegree.{u1} R _inst_1 q)))
Case conversion may be inaccurate. Consider using '#align polynomial.nat_degree_mul Polynomial.natDegree_mulₓ'. -/
theorem natDegree_mul (hp : p ≠ 0) (hq : q ≠ 0) : natDegree (p * q) = natDegree p + natDegree q :=
  by
  rw [← WithBot.coe_eq_coe, ← degree_eq_nat_degree (mul_ne_zero hp hq), WithBot.coe_add, ←
    degree_eq_nat_degree hp, ← degree_eq_nat_degree hq, degree_mul]
#align polynomial.nat_degree_mul Polynomial.natDegree_mul

/- warning: polynomial.trailing_degree_mul -> Polynomial.trailingDegree_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, Eq.{1} ENat (Polynomial.trailingDegree.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p q)) (HAdd.hAdd.{0, 0, 0} ENat ENat ENat (instHAdd.{0} ENat (Distrib.toHasAdd.{0} ENat (NonUnitalNonAssocSemiring.toDistrib.{0} ENat (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENat (Semiring.toNonAssocSemiring.{0} ENat (OrderedSemiring.toSemiring.{0} ENat (OrderedCommSemiring.toOrderedSemiring.{0} ENat (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENat ENat.canonicallyOrderedCommSemiring)))))))) (Polynomial.trailingDegree.{u1} R _inst_1 p) (Polynomial.trailingDegree.{u1} R _inst_1 q))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, Eq.{1} ENat (Polynomial.trailingDegree.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p q)) (HAdd.hAdd.{0, 0, 0} ENat ENat ENat (instHAdd.{0} ENat (Distrib.toAdd.{0} ENat (NonUnitalNonAssocSemiring.toDistrib.{0} ENat (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} ENat (Semiring.toNonAssocSemiring.{0} ENat (OrderedSemiring.toSemiring.{0} ENat (OrderedCommSemiring.toOrderedSemiring.{0} ENat (CanonicallyOrderedCommSemiring.toOrderedCommSemiring.{0} ENat instENatCanonicallyOrderedCommSemiring)))))))) (Polynomial.trailingDegree.{u1} R _inst_1 p) (Polynomial.trailingDegree.{u1} R _inst_1 q))
Case conversion may be inaccurate. Consider using '#align polynomial.trailing_degree_mul Polynomial.trailingDegree_mulₓ'. -/
theorem trailingDegree_mul : (p * q).trailingDegree = p.trailingDegree + q.trailingDegree :=
  by
  by_cases hp : p = 0
  · rw [hp, MulZeroClass.zero_mul, trailing_degree_zero, top_add]
  by_cases hq : q = 0
  · rw [hq, MulZeroClass.mul_zero, trailing_degree_zero, add_top]
  rw [trailing_degree_eq_nat_trailing_degree hp, trailing_degree_eq_nat_trailing_degree hq,
    trailing_degree_eq_nat_trailing_degree (mul_ne_zero hp hq), nat_trailing_degree_mul hp hq,
    WithTop.coe_add]
#align polynomial.trailing_degree_mul Polynomial.trailingDegree_mul

/- warning: polynomial.nat_degree_pow -> Polynomial.natDegree_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] (p : Polynomial.{u1} R _inst_1) (n : Nat), Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p n)) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) n (Polynomial.natDegree.{u1} R _inst_1 p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] (p : Polynomial.{u1} R _inst_1) (n : Nat), Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p n)) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) n (Polynomial.natDegree.{u1} R _inst_1 p))
Case conversion may be inaccurate. Consider using '#align polynomial.nat_degree_pow Polynomial.natDegree_powₓ'. -/
@[simp]
theorem natDegree_pow (p : R[X]) (n : ℕ) : natDegree (p ^ n) = n * natDegree p :=
  if hp0 : p = 0 then
    if hn0 : n = 0 then by simp [hp0, hn0]
    else by rw [hp0, zero_pow (Nat.pos_of_ne_zero hn0)] <;> simp
  else
    natDegree_pow'
      (by rw [← leading_coeff_pow, Ne.def, leading_coeff_eq_zero] <;> exact pow_ne_zero _ hp0)
#align polynomial.nat_degree_pow Polynomial.natDegree_pow

/- warning: polynomial.degree_le_mul_left -> Polynomial.degree_le_mul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {q : Polynomial.{u1} R _inst_1} (p : Polynomial.{u1} R _inst_1), (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 p) (Polynomial.degree.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p q)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {q : Polynomial.{u1} R _inst_1} (p : Polynomial.{u1} R _inst_1), (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 p) (Polynomial.degree.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p q)))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_le_mul_left Polynomial.degree_le_mul_leftₓ'. -/
theorem degree_le_mul_left (p : R[X]) (hq : q ≠ 0) : degree p ≤ degree (p * q) :=
  if hp : p = 0 then by simp only [hp, MulZeroClass.zero_mul, le_refl]
  else by
    rw [degree_mul, degree_eq_nat_degree hp, degree_eq_nat_degree hq] <;>
      exact WithBot.coe_le_coe.2 (Nat.le_add_right _ _)
#align polynomial.degree_le_mul_left Polynomial.degree_le_mul_left

/- warning: polynomial.nat_degree_le_of_dvd -> Polynomial.natDegree_le_of_dvd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Dvd.Dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_1 p) (Polynomial.natDegree.{u1} R _inst_1 q))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Dvd.dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R _inst_1 p) (Polynomial.natDegree.{u1} R _inst_1 q))
Case conversion may be inaccurate. Consider using '#align polynomial.nat_degree_le_of_dvd Polynomial.natDegree_le_of_dvdₓ'. -/
theorem natDegree_le_of_dvd {p q : R[X]} (h1 : p ∣ q) (h2 : q ≠ 0) : p.natDegree ≤ q.natDegree :=
  by
  rcases h1 with ⟨q, rfl⟩; rw [mul_ne_zero_iff] at h2
  rw [nat_degree_mul h2.1 h2.2]; exact Nat.le_add_right _ _
#align polynomial.nat_degree_le_of_dvd Polynomial.natDegree_le_of_dvd

/- warning: polynomial.degree_le_of_dvd -> Polynomial.degree_le_of_dvd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Dvd.Dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 p) (Polynomial.degree.{u1} R _inst_1 q))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Dvd.dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 p) (Polynomial.degree.{u1} R _inst_1 q))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_le_of_dvd Polynomial.degree_le_of_dvdₓ'. -/
theorem degree_le_of_dvd {p q : R[X]} (h1 : p ∣ q) (h2 : q ≠ 0) : degree p ≤ degree q :=
  by
  rcases h1 with ⟨q, rfl⟩; rw [mul_ne_zero_iff] at h2
  exact degree_le_mul_left p h2.2
#align polynomial.degree_le_of_dvd Polynomial.degree_le_of_dvd

/- warning: polynomial.eq_zero_of_dvd_of_degree_lt -> Polynomial.eq_zero_of_dvd_of_degree_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Dvd.Dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q) -> (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 q) (Polynomial.degree.{u1} R _inst_1 p)) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Dvd.dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q) -> (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 q) (Polynomial.degree.{u1} R _inst_1 p)) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align polynomial.eq_zero_of_dvd_of_degree_lt Polynomial.eq_zero_of_dvd_of_degree_ltₓ'. -/
theorem eq_zero_of_dvd_of_degree_lt {p q : R[X]} (h₁ : p ∣ q) (h₂ : degree q < degree p) : q = 0 :=
  by
  by_contra hc
  exact (lt_iff_not_ge _ _).mp h₂ (degree_le_of_dvd h₁ hc)
#align polynomial.eq_zero_of_dvd_of_degree_lt Polynomial.eq_zero_of_dvd_of_degree_lt

/- warning: polynomial.eq_zero_of_dvd_of_nat_degree_lt -> Polynomial.eq_zero_of_dvd_of_natDegree_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Dvd.Dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q) -> (LT.lt.{0} Nat Nat.hasLt (Polynomial.natDegree.{u1} R _inst_1 q) (Polynomial.natDegree.{u1} R _inst_1 p)) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Dvd.dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q) -> (LT.lt.{0} Nat instLTNat (Polynomial.natDegree.{u1} R _inst_1 q) (Polynomial.natDegree.{u1} R _inst_1 p)) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align polynomial.eq_zero_of_dvd_of_nat_degree_lt Polynomial.eq_zero_of_dvd_of_natDegree_ltₓ'. -/
theorem eq_zero_of_dvd_of_natDegree_lt {p q : R[X]} (h₁ : p ∣ q) (h₂ : natDegree q < natDegree p) :
    q = 0 := by
  by_contra hc
  exact (lt_iff_not_ge _ _).mp h₂ (nat_degree_le_of_dvd h₁ hc)
#align polynomial.eq_zero_of_dvd_of_nat_degree_lt Polynomial.eq_zero_of_dvd_of_natDegree_lt

/- warning: polynomial.not_dvd_of_degree_lt -> Polynomial.not_dvd_of_degree_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 q) (Polynomial.degree.{u1} R _inst_1 p)) -> (Not (Dvd.Dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 q) (Polynomial.degree.{u1} R _inst_1 p)) -> (Not (Dvd.dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q))
Case conversion may be inaccurate. Consider using '#align polynomial.not_dvd_of_degree_lt Polynomial.not_dvd_of_degree_ltₓ'. -/
theorem not_dvd_of_degree_lt {p q : R[X]} (h0 : q ≠ 0) (hl : q.degree < p.degree) : ¬p ∣ q :=
  by
  by_contra hcontra
  exact h0 (eq_zero_of_dvd_of_degree_lt hcontra hl)
#align polynomial.not_dvd_of_degree_lt Polynomial.not_dvd_of_degree_lt

/- warning: polynomial.not_dvd_of_nat_degree_lt -> Polynomial.not_dvd_of_natDegree_lt is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (LT.lt.{0} Nat Nat.hasLt (Polynomial.natDegree.{u1} R _inst_1 q) (Polynomial.natDegree.{u1} R _inst_1 p)) -> (Not (Dvd.Dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1} {q : Polynomial.{u1} R _inst_1}, (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (LT.lt.{0} Nat instLTNat (Polynomial.natDegree.{u1} R _inst_1 q) (Polynomial.natDegree.{u1} R _inst_1 p)) -> (Not (Dvd.dvd.{u1} (Polynomial.{u1} R _inst_1) (semigroupDvd.{u1} (Polynomial.{u1} R _inst_1) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R _inst_1) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonUnitalSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) p q))
Case conversion may be inaccurate. Consider using '#align polynomial.not_dvd_of_nat_degree_lt Polynomial.not_dvd_of_natDegree_ltₓ'. -/
theorem not_dvd_of_natDegree_lt {p q : R[X]} (h0 : q ≠ 0) (hl : q.natDegree < p.natDegree) :
    ¬p ∣ q := by
  by_contra hcontra
  exact h0 (eq_zero_of_dvd_of_nat_degree_lt hcontra hl)
#align polynomial.not_dvd_of_nat_degree_lt Polynomial.not_dvd_of_natDegree_lt

/- warning: polynomial.nat_degree_sub_eq_of_prod_eq -> Polynomial.natDegree_sub_eq_of_prod_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p₁ : Polynomial.{u1} R _inst_1} {p₂ : Polynomial.{u1} R _inst_1} {q₁ : Polynomial.{u1} R _inst_1} {q₂ : Polynomial.{u1} R _inst_1}, (Ne.{succ u1} (Polynomial.{u1} R _inst_1) p₁ (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q₁ (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) p₂ (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q₂ (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p₁ q₂) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p₂ q₁)) -> (Eq.{1} Int (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (Polynomial.natDegree.{u1} R _inst_1 p₁)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (Polynomial.natDegree.{u1} R _inst_1 q₁))) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (Polynomial.natDegree.{u1} R _inst_1 p₂)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (Polynomial.natDegree.{u1} R _inst_1 q₂))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p₁ : Polynomial.{u1} R _inst_1} {p₂ : Polynomial.{u1} R _inst_1} {q₁ : Polynomial.{u1} R _inst_1} {q₂ : Polynomial.{u1} R _inst_1}, (Ne.{succ u1} (Polynomial.{u1} R _inst_1) p₁ (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q₁ (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) p₂ (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (Ne.{succ u1} (Polynomial.{u1} R _inst_1) q₂ (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p₁ q₂) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) p₂ q₁)) -> (Eq.{1} Int (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (Nat.cast.{0} Int instNatCastInt (Polynomial.natDegree.{u1} R _inst_1 p₁)) (Nat.cast.{0} Int instNatCastInt (Polynomial.natDegree.{u1} R _inst_1 q₁))) (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) (Nat.cast.{0} Int instNatCastInt (Polynomial.natDegree.{u1} R _inst_1 p₂)) (Nat.cast.{0} Int instNatCastInt (Polynomial.natDegree.{u1} R _inst_1 q₂))))
Case conversion may be inaccurate. Consider using '#align polynomial.nat_degree_sub_eq_of_prod_eq Polynomial.natDegree_sub_eq_of_prod_eqₓ'. -/
/-- This lemma is useful for working with the `int_degree` of a rational function. -/
theorem natDegree_sub_eq_of_prod_eq {p₁ p₂ q₁ q₂ : R[X]} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0)
    (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) :
    (p₁.natDegree : ℤ) - q₁.natDegree = (p₂.natDegree : ℤ) - q₂.natDegree :=
  by
  rw [sub_eq_sub_iff_add_eq_add]
  norm_cast
  rw [← nat_degree_mul hp₁ hq₂, ← nat_degree_mul hp₂ hq₁, h_eq]
#align polynomial.nat_degree_sub_eq_of_prod_eq Polynomial.natDegree_sub_eq_of_prod_eq

/- warning: polynomial.nat_degree_eq_zero_of_is_unit -> Polynomial.natDegree_eq_zero_of_isUnit is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1}, (IsUnit.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) p) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 p) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1}, (IsUnit.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) p) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R _inst_1 p) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))
Case conversion may be inaccurate. Consider using '#align polynomial.nat_degree_eq_zero_of_is_unit Polynomial.natDegree_eq_zero_of_isUnitₓ'. -/
theorem natDegree_eq_zero_of_isUnit (h : IsUnit p) : natDegree p = 0 :=
  by
  nontriviality R
  obtain ⟨q, hq⟩ := h.exists_right_inv
  have := nat_degree_mul (left_ne_zero_of_mul_eq_one hq) (right_ne_zero_of_mul_eq_one hq)
  rw [hq, nat_degree_one, eq_comm, add_eq_zero_iff] at this
  exact this.1
#align polynomial.nat_degree_eq_zero_of_is_unit Polynomial.natDegree_eq_zero_of_isUnit

/- warning: polynomial.degree_eq_zero_of_is_unit -> Polynomial.degree_eq_zero_of_isUnit is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1} [_inst_3 : Nontrivial.{u1} R], (IsUnit.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) p) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1} [_inst_3 : Nontrivial.{u1} R], (IsUnit.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) p) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_eq_zero_of_is_unit Polynomial.degree_eq_zero_of_isUnitₓ'. -/
theorem degree_eq_zero_of_isUnit [Nontrivial R] (h : IsUnit p) : degree p = 0 :=
  (natDegree_eq_zero_iff_degree_le_zero.mp <| natDegree_eq_zero_of_isUnit h).antisymm
    (zero_le_degree_iff.mpr h.NeZero)
#align polynomial.degree_eq_zero_of_is_unit Polynomial.degree_eq_zero_of_isUnit

/- warning: polynomial.degree_coe_units -> Polynomial.degree_coe_units is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] [_inst_3 : Nontrivial.{u1} R] (u : Units.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))), Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Polynomial.{u1} R _inst_1) (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Polynomial.{u1} R _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Polynomial.{u1} R _inst_1) (coeBase.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Polynomial.{u1} R _inst_1) (Units.hasCoe.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) u)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] [_inst_3 : Nontrivial.{u1} R] (u : Units.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))), Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R _inst_1 (Units.val.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) u)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_coe_units Polynomial.degree_coe_unitsₓ'. -/
@[simp]
theorem degree_coe_units [Nontrivial R] (u : R[X]ˣ) : degree (u : R[X]) = 0 :=
  degree_eq_zero_of_isUnit ⟨u, rfl⟩
#align polynomial.degree_coe_units Polynomial.degree_coe_units

/- warning: polynomial.is_unit_iff -> Polynomial.isUnit_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] {p : Polynomial.{u1} R _inst_1}, Iff (IsUnit.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) p) (Exists.{succ u1} R (fun (r : R) => And (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) r) (Eq.{succ u1} (Polynomial.{u1} R _inst_1) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) r) p)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R _inst_1}, Iff (IsUnit.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) p) (Exists.{succ u1} R (fun (r : R) => And (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) r) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) r) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) r) p)))
Case conversion may be inaccurate. Consider using '#align polynomial.is_unit_iff Polynomial.isUnit_iffₓ'. -/
theorem isUnit_iff : IsUnit p ↔ ∃ r : R, IsUnit r ∧ C r = p :=
  ⟨fun hp =>
    ⟨p.coeff 0,
      let h := eq_C_of_natDegree_eq_zero (natDegree_eq_zero_of_isUnit hp)
      ⟨isUnit_C.1 (h ▸ hp), h.symm⟩⟩,
    fun ⟨r, hr, hrp⟩ => hrp ▸ isUnit_C.2 hr⟩
#align polynomial.is_unit_iff Polynomial.isUnit_iff

variable [CharZero R]

@[simp]
theorem degree_bit0_eq (p : R[X]) : degree (bit0 p) = degree p := by
  rw [bit0_eq_two_mul, degree_mul, (by simp : (2 : R[X]) = C 2),
    @Polynomial.degree_C R _ _ two_ne_zero, zero_add]
#align polynomial.degree_bit0_eq Polynomial.degree_bit0_eq

@[simp]
theorem natDegree_bit0_eq (p : R[X]) : natDegree (bit0 p) = natDegree p :=
  natDegree_eq_of_degree_eq <| degree_bit0_eq p
#align polynomial.nat_degree_bit0_eq Polynomial.natDegree_bit0_eq

@[simp]
theorem natDegree_bit1_eq (p : R[X]) : natDegree (bit1 p) = natDegree p :=
  by
  rw [bit1]
  apply le_antisymm
  convert nat_degree_add_le _ _
  · simp
  by_cases h : p.nat_degree = 0
  · simp [h]
  apply le_nat_degree_of_ne_zero
  intro hh
  apply h
  simp_all [coeff_one, if_neg (Ne.symm h)]
#align polynomial.nat_degree_bit1_eq Polynomial.natDegree_bit1_eq

theorem degree_bit1_eq {p : R[X]} (hp : 0 < degree p) : degree (bit1 p) = degree p :=
  by
  rw [bit1, degree_add_eq_left_of_degree_lt, degree_bit0_eq]
  rwa [degree_one, degree_bit0_eq]
#align polynomial.degree_bit1_eq Polynomial.degree_bit1_eq

end NoZeroDivisors

section NoZeroDivisors

variable [CommSemiring R] [NoZeroDivisors R] {p q : R[X]}

/- warning: polynomial.irreducible_of_monic -> Polynomial.irreducible_of_monic is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) -> (Ne.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (OfNat.mk.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.one.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.hasOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) -> (Iff (Irreducible.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p) (forall (f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (g : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) -> (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) f g) p) -> (Or (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) f (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (OfNat.mk.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.one.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.hasOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) g (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (OfNat.mk.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.one.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.hasOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) -> (Ne.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.toOfNat1.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.one.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) -> (Iff (Irreducible.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p) (forall (f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (g : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) -> (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) f g) p) -> (Or (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) f (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.toOfNat1.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.one.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) g (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.toOfNat1.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.one.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.irreducible_of_monic Polynomial.irreducible_of_monicₓ'. -/
theorem irreducible_of_monic (hp : p.Monic) (hp1 : p ≠ 1) :
    Irreducible p ↔ ∀ f g : R[X], f.Monic → g.Monic → f * g = p → f = 1 ∨ g = 1 :=
  by
  refine'
    ⟨fun h f g hf hg hp => (h.2 f g hp.symm).imp hf.eq_one_of_isUnit hg.eq_one_of_isUnit, fun h =>
      ⟨hp1 ∘ hp.eq_one_of_is_unit, fun f g hfg =>
        (h (g * C f.leadingCoeff) (f * C g.leadingCoeff) _ _ _).symm.imp (isUnit_of_mul_eq_one f _)
          (isUnit_of_mul_eq_one g _)⟩⟩
  · rwa [monic, leading_coeff_mul, leading_coeff_C, ← leading_coeff_mul, mul_comm, ← hfg, ← monic]
  · rwa [monic, leading_coeff_mul, leading_coeff_C, ← leading_coeff_mul, ← hfg, ← monic]
  ·
    rw [mul_mul_mul_comm, ← C_mul, ← leading_coeff_mul, ← hfg, hp.leading_coeff, C_1, mul_one,
      mul_comm, ← hfg]
#align polynomial.irreducible_of_monic Polynomial.irreducible_of_monic

/- warning: polynomial.monic.irreducible_iff_nat_degree -> Polynomial.Monic.irreducible_iff_natDegree is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) -> (Iff (Irreducible.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p) (And (Ne.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (OfNat.mk.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.one.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.hasOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (forall (f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (g : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) -> (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) f g) p) -> (Or (Eq.{1} Nat (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (Eq.{1} Nat (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) -> (Iff (Irreducible.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p) (And (Ne.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.toOfNat1.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.one.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (forall (f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (g : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) -> (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) f g) p) -> (Or (Eq.{1} Nat (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Eq.{1} Nat (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.monic.irreducible_iff_nat_degree Polynomial.Monic.irreducible_iff_natDegreeₓ'. -/
theorem Monic.irreducible_iff_natDegree (hp : p.Monic) :
    Irreducible p ↔
      p ≠ 1 ∧ ∀ f g : R[X], f.Monic → g.Monic → f * g = p → f.natDegree = 0 ∨ g.natDegree = 0 :=
  by
  by_cases hp1 : p = 1; · simp [hp1]
  rw [irreducible_of_monic hp hp1, and_iff_right hp1]
  refine' forall₄_congr fun a b ha hb => _
  rw [ha.nat_degree_eq_zero_iff_eq_one, hb.nat_degree_eq_zero_iff_eq_one]
#align polynomial.monic.irreducible_iff_nat_degree Polynomial.Monic.irreducible_iff_natDegree

/- warning: polynomial.monic.irreducible_iff_nat_degree' -> Polynomial.Monic.irreducible_iff_natDegree' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) -> (Iff (Irreducible.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p) (And (Ne.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (OfNat.mk.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.one.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.hasOne.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (forall (f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (g : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) -> (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) f g) p) -> (Not (Membership.Mem.{0, 0} Nat (Finset.{0} Nat) (Finset.hasMem.{0} Nat) (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) (Finset.Ioc.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) Nat.locallyFiniteOrder (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (HDiv.hDiv.{0, 0, 0} Nat Nat Nat (instHDiv.{0} Nat Nat.hasDiv) (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) -> (Iff (Irreducible.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p) (And (Ne.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) 1 (One.toOfNat1.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.one.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (forall (f : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (g : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) f) -> (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) -> (Eq.{succ u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) f g) p) -> (Not (Membership.mem.{0, 0} Nat (Finset.{0} Nat) (Finset.instMembershipFinset.{0} Nat) (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) g) (Finset.Ioc.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) instLocallyFiniteOrderNatToPreorderToPartialOrderStrictOrderedSemiring (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (HDiv.hDiv.{0, 0, 0} Nat Nat Nat (instHDiv.{0} Nat Nat.instDivNat) (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.monic.irreducible_iff_nat_degree' Polynomial.Monic.irreducible_iff_natDegree'ₓ'. -/
theorem Monic.irreducible_iff_natDegree' (hp : p.Monic) :
    Irreducible p ↔
      p ≠ 1 ∧ ∀ f g : R[X], f.Monic → g.Monic → f * g = p → g.natDegree ∉ Ioc 0 (p.natDegree / 2) :=
  by
  simp_rw [hp.irreducible_iff_nat_degree, mem_Ioc, Nat.le_div_iff_mul_le zero_lt_two, mul_two]
  apply and_congr_right'
  constructor <;> intro h f g hf hg he <;> subst he
  · rw [hf.nat_degree_mul hg, add_le_add_iff_right]
    exact fun ha => (h f g hf hg rfl).elim (ha.1.trans_le ha.2).ne' ha.1.ne'
  · simp_rw [hf.nat_degree_mul hg, pos_iff_ne_zero] at h
    contrapose! h
    obtain hl | hl := le_total f.nat_degree g.nat_degree
    · exact ⟨g, f, hg, hf, mul_comm g f, h.1, add_le_add_left hl _⟩
    · exact ⟨f, g, hf, hg, rfl, h.2, add_le_add_right hl _⟩
#align polynomial.monic.irreducible_iff_nat_degree' Polynomial.Monic.irreducible_iff_natDegree'

/- warning: polynomial.monic.not_irreducible_iff_exists_add_mul_eq_coeff -> Polynomial.Monic.not_irreducible_iff_exists_add_mul_eq_coeff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (Iff (Not (Irreducible.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p)) (Exists.{succ u1} R (fun (c₁ : R) => Exists.{succ u1} R (fun (c₂ : R) => And (Eq.{succ u1} R (Polynomial.coeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) c₁ c₂)) (Eq.{succ u1} R (Polynomial.coeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) c₁ c₂))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.Monic.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Iff (Not (Irreducible.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p)) (Exists.{succ u1} R (fun (c₁ : R) => Exists.{succ u1} R (fun (c₂ : R) => And (Eq.{succ u1} R (Polynomial.coeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) c₁ c₂)) (Eq.{succ u1} R (Polynomial.coeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) c₁ c₂))))))
Case conversion may be inaccurate. Consider using '#align polynomial.monic.not_irreducible_iff_exists_add_mul_eq_coeff Polynomial.Monic.not_irreducible_iff_exists_add_mul_eq_coeffₓ'. -/
theorem Monic.not_irreducible_iff_exists_add_mul_eq_coeff (hm : p.Monic) (hnd : p.natDegree = 2) :
    ¬Irreducible p ↔ ∃ c₁ c₂, p.coeff 0 = c₁ * c₂ ∧ p.coeff 1 = c₁ + c₂ :=
  by
  cases subsingleton_or_nontrivial R
  · simpa only [nat_degree_of_subsingleton] using hnd
  rw [hm.irreducible_iff_nat_degree', and_iff_right, hnd]
  push_neg; constructor
  · rintro ⟨a, b, ha, hb, rfl, hdb | ⟨⟨⟩⟩⟩
    have hda := hnd
    rw [ha.nat_degree_mul hb, hdb] at hda
    use a.coeff 0, b.coeff 0, mul_coeff_zero a b
    simpa only [next_coeff, hnd, add_right_cancel hda, hdb] using ha.next_coeff_mul hb
  · rintro ⟨c₁, c₂, hmul, hadd⟩
    refine'
      ⟨X + C c₁, X + C c₂, monic_X_add_C _, monic_X_add_C _, _, Or.inl <| nat_degree_X_add_C _⟩
    rw [p.as_sum_range_C_mul_X_pow, hnd, Finset.sum_range_succ, Finset.sum_range_succ,
      Finset.sum_range_one, ← hnd, hm.coeff_nat_degree, hnd, hmul, hadd, C_mul, C_add, C_1]
    ring
  · rintro rfl
    simpa only [nat_degree_one] using hnd
#align polynomial.monic.not_irreducible_iff_exists_add_mul_eq_coeff Polynomial.Monic.not_irreducible_iff_exists_add_mul_eq_coeff

/- warning: polynomial.root_mul -> Polynomial.root_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {q : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) p q) a) (Or (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p a) (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) q a))
but is expected to have type
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {q : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) p q) a) (Or (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p a) (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) q a))
Case conversion may be inaccurate. Consider using '#align polynomial.root_mul Polynomial.root_mulₓ'. -/
theorem root_mul : IsRoot (p * q) a ↔ IsRoot p a ∨ IsRoot q a := by
  simp_rw [is_root, eval_mul, mul_eq_zero]
#align polynomial.root_mul Polynomial.root_mul

/- warning: polynomial.root_or_root_of_root_mul -> Polynomial.root_or_root_of_root_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {q : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) p q) a) -> (Or (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p a) (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) q a))
but is expected to have type
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1))] {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)} {q : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (instHMul.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.mul'.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) p q) a) -> (Or (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p a) (Polynomial.IsRoot.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) q a))
Case conversion may be inaccurate. Consider using '#align polynomial.root_or_root_of_root_mul Polynomial.root_or_root_of_root_mulₓ'. -/
theorem root_or_root_of_root_mul (h : IsRoot (p * q) a) : IsRoot p a ∨ IsRoot q a :=
  root_mul.1 h
#align polynomial.root_or_root_of_root_mul Polynomial.root_or_root_of_root_mul

end NoZeroDivisors

section Ring

variable [Ring R] [IsDomain R] {p q : R[X]}

instance : IsDomain R[X] :=
  NoZeroDivisors.to_isDomain _

end Ring

section CommRing

variable [CommRing R]

/- warning: polynomial.le_root_multiplicity_iff -> Polynomial.le_rootMultiplicity_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (forall {a : R} {n : Nat}, Iff (LE.le.{0} Nat Nat.hasLe n (Polynomial.rootMultiplicity.{u1} R _inst_1 a p)) (Dvd.Dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) n) p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) -> (forall {a : R} {n : Nat}, Iff (LE.le.{0} Nat instLENat n (Polynomial.rootMultiplicity.{u1} R _inst_1 a p)) (Dvd.dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) n) p))
Case conversion may be inaccurate. Consider using '#align polynomial.le_root_multiplicity_iff Polynomial.le_rootMultiplicity_iffₓ'. -/
/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff
  `(X - a) ^ n` divides `p`. -/
theorem le_rootMultiplicity_iff {p : R[X]} (p0 : p ≠ 0) {a : R} {n : ℕ} :
    n ≤ rootMultiplicity a p ↔ (X - C a) ^ n ∣ p :=
  by
  simp_rw [root_multiplicity, dif_neg p0, Nat.le_find_iff, Classical.not_not]
  refine' ⟨fun h => _, fun h m hm => (pow_dvd_pow _ hm).trans h⟩
  cases n;
  · rw [pow_zero]
    apply one_dvd; · exact h n n.lt_succ_self
#align polynomial.le_root_multiplicity_iff Polynomial.le_rootMultiplicity_iff

/- warning: polynomial.root_multiplicity_le_iff -> Polynomial.rootMultiplicity_le_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (forall (a : R) (n : Nat), Iff (LE.le.{0} Nat Nat.hasLe (Polynomial.rootMultiplicity.{u1} R _inst_1 a p) n) (Not (Dvd.Dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) p)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) -> (forall (a : R) (n : Nat), Iff (LE.le.{0} Nat instLENat (Polynomial.rootMultiplicity.{u1} R _inst_1 a p) n) (Not (Dvd.dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) p)))
Case conversion may be inaccurate. Consider using '#align polynomial.root_multiplicity_le_iff Polynomial.rootMultiplicity_le_iffₓ'. -/
theorem rootMultiplicity_le_iff {p : R[X]} (p0 : p ≠ 0) (a : R) (n : ℕ) :
    rootMultiplicity a p ≤ n ↔ ¬(X - C a) ^ (n + 1) ∣ p := by
  rw [← (le_root_multiplicity_iff p0).Not, not_le, Nat.lt_add_one_iff]
#align polynomial.root_multiplicity_le_iff Polynomial.rootMultiplicity_le_iff

/- warning: polynomial.pow_root_multiplicity_not_dvd -> Polynomial.pow_rootMultiplicity_not_dvd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (forall (a : R), Not (Dvd.Dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (Polynomial.rootMultiplicity.{u1} R _inst_1 a p) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) -> (forall (a : R), Not (Dvd.dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (Polynomial.rootMultiplicity.{u1} R _inst_1 a p) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) p))
Case conversion may be inaccurate. Consider using '#align polynomial.pow_root_multiplicity_not_dvd Polynomial.pow_rootMultiplicity_not_dvdₓ'. -/
theorem pow_rootMultiplicity_not_dvd {p : R[X]} (p0 : p ≠ 0) (a : R) :
    ¬(X - C a) ^ (rootMultiplicity a p + 1) ∣ p := by rw [← root_multiplicity_le_iff p0]
#align polynomial.pow_root_multiplicity_not_dvd Polynomial.pow_rootMultiplicity_not_dvd

/- warning: polynomial.root_multiplicity_add -> Polynomial.rootMultiplicity_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} (a : R), (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHAdd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.add'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) p q) (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (LE.le.{0} Nat Nat.hasLe (LinearOrder.min.{0} Nat Nat.linearOrder (Polynomial.rootMultiplicity.{u1} R _inst_1 a p) (Polynomial.rootMultiplicity.{u1} R _inst_1 a q)) (Polynomial.rootMultiplicity.{u1} R _inst_1 a (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHAdd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.add'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) p q)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} (a : R), (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHAdd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.add'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) p q) (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) -> (LE.le.{0} Nat instLENat (Min.min.{0} Nat instMinNat (Polynomial.rootMultiplicity.{u1} R _inst_1 a p) (Polynomial.rootMultiplicity.{u1} R _inst_1 a q)) (Polynomial.rootMultiplicity.{u1} R _inst_1 a (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHAdd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.add'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) p q)))
Case conversion may be inaccurate. Consider using '#align polynomial.root_multiplicity_add Polynomial.rootMultiplicity_addₓ'. -/
/-- The multiplicity of `p + q` is at least the minimum of the multiplicities. -/
theorem rootMultiplicity_add {p q : R[X]} (a : R) (hzero : p + q ≠ 0) :
    min (rootMultiplicity a p) (rootMultiplicity a q) ≤ rootMultiplicity a (p + q) :=
  by
  rw [le_root_multiplicity_iff hzero]
  have hdivp : (X - C a) ^ root_multiplicity a p ∣ p := pow_root_multiplicity_dvd p a
  have hdivq : (X - C a) ^ root_multiplicity a q ∣ q := pow_root_multiplicity_dvd q a
  exact min_pow_dvd_add hdivp hdivq
#align polynomial.root_multiplicity_add Polynomial.rootMultiplicity_add

variable [IsDomain R] {p q : R[X]}

section Roots

open Multiset

/- warning: polynomial.prime_X_sub_C -> Polynomial.prime_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (r : R), Prime.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommSemiring.toCommMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (r : R), Prime.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (IsDomain.toCancelCommMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Polynomial.instIsDomainPolynomialToSemiringSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1) _inst_2))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))
Case conversion may be inaccurate. Consider using '#align polynomial.prime_X_sub_C Polynomial.prime_X_sub_Cₓ'. -/
theorem prime_X_sub_C (r : R) : Prime (X - C r) :=
  ⟨X_sub_C_ne_zero r, not_isUnit_X_sub_C r, fun _ _ =>
    by
    simp_rw [dvd_iff_is_root, is_root.def, eval_mul, mul_eq_zero]
    exact id⟩
#align polynomial.prime_X_sub_C Polynomial.prime_X_sub_C

#print Polynomial.prime_X /-
theorem prime_X : Prime (X : R[X]) :=
  by
  convert prime_X_sub_C (0 : R)
  simp
#align polynomial.prime_X Polynomial.prime_X
-/

#print Polynomial.Monic.prime_of_degree_eq_one /-
theorem Monic.prime_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Prime p :=
  have : p = X - C (-p.coeff 0) := by simpa [hm.leading_coeff] using eq_X_add_C_of_degree_eq_one hp1
  this.symm ▸ prime_X_sub_C _
#align polynomial.monic.prime_of_degree_eq_one Polynomial.Monic.prime_of_degree_eq_one
-/

/- warning: polynomial.irreducible_X_sub_C -> Polynomial.irreducible_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (r : R), Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (r : R), Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))
Case conversion may be inaccurate. Consider using '#align polynomial.irreducible_X_sub_C Polynomial.irreducible_X_sub_Cₓ'. -/
theorem irreducible_X_sub_C (r : R) : Irreducible (X - C r) :=
  (prime_X_sub_C r).Irreducible
#align polynomial.irreducible_X_sub_C Polynomial.irreducible_X_sub_C

/- warning: polynomial.irreducible_X -> Polynomial.irreducible_X is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align polynomial.irreducible_X Polynomial.irreducible_Xₓ'. -/
theorem irreducible_X : Irreducible (X : R[X]) :=
  Prime.irreducible prime_X
#align polynomial.irreducible_X Polynomial.irreducible_X

/- warning: polynomial.monic.irreducible_of_degree_eq_one -> Polynomial.Monic.irreducible_of_degree_eq_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne))))) -> (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))))) -> (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) p)
Case conversion may be inaccurate. Consider using '#align polynomial.monic.irreducible_of_degree_eq_one Polynomial.Monic.irreducible_of_degree_eq_oneₓ'. -/
theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=
  (hm.prime_of_degree_eq_one hp1).Irreducible
#align polynomial.monic.irreducible_of_degree_eq_one Polynomial.Monic.irreducible_of_degree_eq_one

/- warning: polynomial.eq_of_monic_of_associated -> Polynomial.eq_of_monic_of_associated is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q) -> (Associated.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p q) -> (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p q)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q) -> (Associated.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) p q) -> (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p q)
Case conversion may be inaccurate. Consider using '#align polynomial.eq_of_monic_of_associated Polynomial.eq_of_monic_of_associatedₓ'. -/
theorem eq_of_monic_of_associated (hp : p.Monic) (hq : q.Monic) (hpq : Associated p q) : p = q :=
  by
  obtain ⟨u, hu⟩ := hpq
  unfold monic at hp hq
  rw [eq_C_of_degree_le_zero (degree_coe_units _).le] at hu
  rw [← hu, leading_coeff_mul, hp, one_mul, leading_coeff_C] at hq
  rwa [hq, C_1, mul_one] at hu
  all_goals infer_instance
#align polynomial.eq_of_monic_of_associated Polynomial.eq_of_monic_of_associated

#print Polynomial.rootMultiplicity_mul /-
theorem rootMultiplicity_mul {p q : R[X]} {x : R} (hpq : p * q ≠ 0) :
    rootMultiplicity x (p * q) = rootMultiplicity x p + rootMultiplicity x q :=
  by
  have hp : p ≠ 0 := left_ne_zero_of_mul hpq
  have hq : q ≠ 0 := right_ne_zero_of_mul hpq
  rw [root_multiplicity_eq_multiplicity (p * q), dif_neg hpq, root_multiplicity_eq_multiplicity p,
    dif_neg hp, root_multiplicity_eq_multiplicity q, dif_neg hq,
    multiplicity.mul' (prime_X_sub_C x)]
#align polynomial.root_multiplicity_mul Polynomial.rootMultiplicity_mul
-/

/- warning: polynomial.root_multiplicity_X_sub_C_self -> Polynomial.rootMultiplicity_X_sub_C_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {x : R}, Eq.{1} Nat (Polynomial.rootMultiplicity.{u1} R _inst_1 x (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) x))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {x : R}, Eq.{1} Nat (Polynomial.rootMultiplicity.{u1} R _inst_1 x (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) x) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) x))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))
Case conversion may be inaccurate. Consider using '#align polynomial.root_multiplicity_X_sub_C_self Polynomial.rootMultiplicity_X_sub_C_selfₓ'. -/
theorem rootMultiplicity_X_sub_C_self {x : R} : rootMultiplicity x (X - C x) = 1 := by
  rw [root_multiplicity_eq_multiplicity, dif_neg (X_sub_C_ne_zero x),
    multiplicity.get_multiplicity_self]
#align polynomial.root_multiplicity_X_sub_C_self Polynomial.rootMultiplicity_X_sub_C_self

/- warning: polynomial.root_multiplicity_X_sub_C -> Polynomial.rootMultiplicity_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {x : R} {y : R}, Eq.{1} Nat (Polynomial.rootMultiplicity.{u1} R _inst_1 x (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) y))) (ite.{1} Nat (Eq.{succ u1} R x y) (Classical.propDecidable (Eq.{succ u1} R x y)) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {x : R} {y : R}, Eq.{1} Nat (Polynomial.rootMultiplicity.{u1} R _inst_1 x (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) y) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) y))) (ite.{1} Nat (Eq.{succ u1} R x y) (Classical.propDecidable (Eq.{succ u1} R x y)) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))
Case conversion may be inaccurate. Consider using '#align polynomial.root_multiplicity_X_sub_C Polynomial.rootMultiplicity_X_sub_Cₓ'. -/
theorem rootMultiplicity_X_sub_C {x y : R} :
    rootMultiplicity x (X - C y) = if x = y then 1 else 0 :=
  by
  split_ifs with hxy
  · rw [hxy]
    exact root_multiplicity_X_sub_C_self
  exact root_multiplicity_eq_zero (mt root_X_sub_C.mp (Ne.symm hxy))
#align polynomial.root_multiplicity_X_sub_C Polynomial.rootMultiplicity_X_sub_C

/- warning: polynomial.root_multiplicity_X_sub_C_pow -> Polynomial.rootMultiplicity_X_sub_C_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (a : R) (n : Nat), Eq.{1} Nat (Polynomial.rootMultiplicity.{u1} R _inst_1 a (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) n)) n
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (a : R) (n : Nat), Eq.{1} Nat (Polynomial.rootMultiplicity.{u1} R _inst_1 a (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) n)) n
Case conversion may be inaccurate. Consider using '#align polynomial.root_multiplicity_X_sub_C_pow Polynomial.rootMultiplicity_X_sub_C_powₓ'. -/
/-- The multiplicity of `a` as root of `(X - a) ^ n` is `n`. -/
theorem rootMultiplicity_X_sub_C_pow (a : R) (n : ℕ) : rootMultiplicity a ((X - C a) ^ n) = n :=
  by
  induction' n with n hn
  · refine' root_multiplicity_eq_zero _
    simp only [eval_one, is_root.def, not_false_iff, one_ne_zero, pow_zero]
  have hzero := pow_ne_zero n.succ (X_sub_C_ne_zero a)
  rw [pow_succ (X - C a) n] at hzero⊢
  simp only [root_multiplicity_mul hzero, root_multiplicity_X_sub_C_self, hn, Nat.one_add]
#align polynomial.root_multiplicity_X_sub_C_pow Polynomial.rootMultiplicity_X_sub_C_pow

/- warning: polynomial.exists_multiset_roots -> Polynomial.exists_multiset_roots is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (Exists.{succ u1} (Multiset.{u1} R) (fun (s : Multiset.{u1} R) => And (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (WithBot.{0} Nat) (HasLiftT.mk.{1, 1} Nat (WithBot.{0} Nat) (CoeTCₓ.coe.{1, 1} Nat (WithBot.{0} Nat) (WithBot.hasCoeT.{0} Nat))) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) s)) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (forall (a : R), Eq.{1} Nat (Multiset.count.{u1} R (fun (a : R) (b : R) => Classical.propDecidable (Eq.{succ u1} R a b)) a s) (Polynomial.rootMultiplicity.{u1} R _inst_1 a p))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) -> (Exists.{succ u1} (Multiset.{u1} R) (fun (s : Multiset.{u1} R) => And (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Nat.cast.{0} (WithBot.{0} Nat) (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) s)) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (forall (a : R), Eq.{1} Nat (Multiset.count.{u1} R (fun (a : R) (b : R) => Classical.propDecidable (Eq.{succ u1} R a b)) a s) (Polynomial.rootMultiplicity.{u1} R _inst_1 a p))))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_multiset_roots Polynomial.exists_multiset_rootsₓ'. -/
theorem exists_multiset_roots :
    ∀ {p : R[X]} (hp : p ≠ 0),
      ∃ s : Multiset R, (s.card : WithBot ℕ) ≤ degree p ∧ ∀ a, s.count a = rootMultiplicity a p
  | p => fun hp =>
    haveI := Classical.propDecidable (∃ x, is_root p x)
    if h : ∃ x, is_root p x then
      let ⟨x, hx⟩ := h
      have hpd : 0 < degree p := degree_pos_of_root hp hx
      have hd0 : p /ₘ (X - C x) ≠ 0 := fun h => by
        rw [← mul_div_by_monic_eq_iff_is_root.2 hx, h, MulZeroClass.mul_zero] at hp <;> exact hp rfl
      have wf : degree (p /ₘ _) < degree p :=
        degree_div_by_monic_lt _ (monic_X_sub_C x) hp ((degree_X_sub_C x).symm ▸ by decide)
      let ⟨t, htd, htr⟩ := @exists_multiset_roots (p /ₘ (X - C x)) hd0
      have hdeg : degree (X - C x) ≤ degree p :=
        by
        rw [degree_X_sub_C, degree_eq_nat_degree hp]
        rw [degree_eq_nat_degree hp] at hpd
        exact WithBot.coe_le_coe.2 (WithBot.coe_lt_coe.1 hpd)
      have hdiv0 : p /ₘ (X - C x) ≠ 0 :=
        mt (div_by_monic_eq_zero_iff (monic_X_sub_C x)).1 <| not_lt.2 hdeg
      ⟨x ::ₘ t,
        calc
          (card (x ::ₘ t) : WithBot ℕ) = t.card + 1 := by exact_mod_cast card_cons _ _
          _ ≤ degree p := by
            rw [← degree_add_div_by_monic (monic_X_sub_C x) hdeg, degree_X_sub_C, add_comm] <;>
              exact add_le_add (le_refl (1 : WithBot ℕ)) htd
          ,
        by
        intro a
        conv_rhs => rw [← mul_div_by_monic_eq_iff_is_root.mpr hx]
        rw [root_multiplicity_mul (mul_ne_zero (X_sub_C_ne_zero x) hdiv0),
          root_multiplicity_X_sub_C, ← htr a]
        split_ifs with ha
        · rw [ha, count_cons_self, Nat.succ_eq_add_one, add_comm]
        · rw [count_cons_of_ne ha, zero_add]⟩
    else
      ⟨0, (degree_eq_nat_degree hp).symm ▸ WithBot.coe_le_coe.2 (Nat.zero_le _),
        by
        intro a
        rw [count_zero, root_multiplicity_eq_zero (not_exists.mp h a)]⟩
#align polynomial.exists_multiset_roots Polynomial.exists_multiset_roots

#print Polynomial.roots /-
/-- `roots p` noncomputably gives a multiset containing all the roots of `p`,
including their multiplicities. -/
noncomputable def roots (p : R[X]) : Multiset R :=
  if h : p = 0 then ∅ else Classical.choose (exists_multiset_roots h)
#align polynomial.roots Polynomial.roots
-/

#print Polynomial.roots_zero /-
@[simp]
theorem roots_zero : (0 : R[X]).roots = 0 :=
  dif_pos rfl
#align polynomial.roots_zero Polynomial.roots_zero
-/

/- warning: polynomial.card_roots -> Polynomial.card_roots is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (WithBot.{0} Nat) (HasLiftT.mk.{1, 1} Nat (WithBot.{0} Nat) (CoeTCₓ.coe.{1, 1} Nat (WithBot.{0} Nat) (WithBot.hasCoeT.{0} Nat))) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Nat.cast.{0} (WithBot.{0} Nat) (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p))
Case conversion may be inaccurate. Consider using '#align polynomial.card_roots Polynomial.card_rootsₓ'. -/
theorem card_roots (hp0 : p ≠ 0) : ((roots p).card : WithBot ℕ) ≤ degree p :=
  by
  unfold roots
  rw [dif_neg hp0]
  exact (Classical.choose_spec (exists_multiset_roots hp0)).1
#align polynomial.card_roots Polynomial.card_roots

/- warning: polynomial.card_roots' -> Polynomial.card_roots' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), LE.le.{0} Nat Nat.hasLe (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), LE.le.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) instLENat (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)
Case conversion may be inaccurate. Consider using '#align polynomial.card_roots' Polynomial.card_roots'ₓ'. -/
theorem card_roots' (p : R[X]) : p.roots.card ≤ natDegree p :=
  by
  by_cases hp0 : p = 0
  · simp [hp0]
  exact WithBot.coe_le_coe.1 (le_trans (card_roots hp0) (le_of_eq <| degree_eq_nat_degree hp0))
#align polynomial.card_roots' Polynomial.card_roots'

/- warning: polynomial.card_roots_sub_C -> Polynomial.card_roots_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {a : R}, (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (WithBot.{0} Nat) (HasLiftT.mk.{1, 1} Nat (WithBot.{0} Nat) (CoeTCₓ.coe.{1, 1} Nat (WithBot.{0} Nat) (WithBot.hasCoeT.{0} Nat))) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a))))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {a : R}, (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Nat.cast.{0} (WithBot.{0} Nat) (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a))))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p))
Case conversion may be inaccurate. Consider using '#align polynomial.card_roots_sub_C Polynomial.card_roots_sub_Cₓ'. -/
theorem card_roots_sub_C {p : R[X]} {a : R} (hp0 : 0 < degree p) :
    ((p - C a).roots.card : WithBot ℕ) ≤ degree p :=
  calc
    ((p - C a).roots.card : WithBot ℕ) ≤ degree (p - C a) :=
      card_roots <| mt sub_eq_zero.1 fun h => not_le_of_gt hp0 <| h.symm ▸ degree_C_le
    _ = degree p := by rw [sub_eq_add_neg, ← C_neg] <;> exact degree_add_C hp0
    
#align polynomial.card_roots_sub_C Polynomial.card_roots_sub_C

/- warning: polynomial.card_roots_sub_C' -> Polynomial.card_roots_sub_C' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {a : R}, (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (LE.le.{0} Nat Nat.hasLe (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {a : R}, (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (LE.le.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) instLENat (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p))
Case conversion may be inaccurate. Consider using '#align polynomial.card_roots_sub_C' Polynomial.card_roots_sub_C'ₓ'. -/
theorem card_roots_sub_C' {p : R[X]} {a : R} (hp0 : 0 < degree p) :
    (p - C a).roots.card ≤ natDegree p :=
  WithBot.coe_le_coe.1
    (le_trans (card_roots_sub_C hp0)
      (le_of_eq <| degree_eq_natDegree fun h => by simp_all [lt_irrefl]))
#align polynomial.card_roots_sub_C' Polynomial.card_roots_sub_C'

#print Polynomial.count_roots /-
@[simp]
theorem count_roots (p : R[X]) : p.roots.count a = rootMultiplicity a p :=
  by
  by_cases hp : p = 0
  · simp [hp]
  rw [roots, dif_neg hp]
  exact (Classical.choose_spec (exists_multiset_roots hp)).2 a
#align polynomial.count_roots Polynomial.count_roots
-/

#print Polynomial.mem_roots' /-
@[simp]
theorem mem_roots' : a ∈ p.roots ↔ p ≠ 0 ∧ IsRoot p a := by
  rw [← count_pos, count_roots p, root_multiplicity_pos']
#align polynomial.mem_roots' Polynomial.mem_roots'
-/

#print Polynomial.mem_roots /-
theorem mem_roots (hp : p ≠ 0) : a ∈ p.roots ↔ IsRoot p a :=
  mem_roots'.trans <| and_iff_right hp
#align polynomial.mem_roots Polynomial.mem_roots
-/

#print Polynomial.ne_zero_of_mem_roots /-
theorem ne_zero_of_mem_roots (h : a ∈ p.roots) : p ≠ 0 :=
  (mem_roots'.1 h).1
#align polynomial.ne_zero_of_mem_roots Polynomial.ne_zero_of_mem_roots
-/

#print Polynomial.isRoot_of_mem_roots /-
theorem isRoot_of_mem_roots (h : a ∈ p.roots) : IsRoot p a :=
  (mem_roots'.1 h).2
#align polynomial.is_root_of_mem_roots Polynomial.isRoot_of_mem_roots
-/

#print Polynomial.card_le_degree_of_subset_roots /-
theorem card_le_degree_of_subset_roots {p : R[X]} {Z : Finset R} (h : Z.val ⊆ p.roots) :
    Z.card ≤ p.natDegree :=
  (Multiset.card_le_of_le (Finset.val_le_iff_val_subset.2 h)).trans (Polynomial.card_roots' p)
#align polynomial.card_le_degree_of_subset_roots Polynomial.card_le_degree_of_subset_roots
-/

#print Polynomial.finite_setOf_isRoot /-
theorem finite_setOf_isRoot {p : R[X]} (hp : p ≠ 0) : Set.Finite { x | IsRoot p x } := by
  simpa only [← Finset.setOf_mem, mem_to_finset, mem_roots hp] using p.roots.to_finset.finite_to_set
#align polynomial.finite_set_of_is_root Polynomial.finite_setOf_isRoot
-/

#print Polynomial.eq_zero_of_infinite_isRoot /-
theorem eq_zero_of_infinite_isRoot (p : R[X]) (h : Set.Infinite { x | IsRoot p x }) : p = 0 :=
  not_imp_comm.mp finite_setOf_isRoot h
#align polynomial.eq_zero_of_infinite_is_root Polynomial.eq_zero_of_infinite_isRoot
-/

#print Polynomial.exists_max_root /-
theorem exists_max_root [LinearOrder R] (p : R[X]) (hp : p ≠ 0) : ∃ x₀, ∀ x, p.IsRoot x → x ≤ x₀ :=
  Set.exists_upper_bound_image _ _ <| finite_setOf_isRoot hp
#align polynomial.exists_max_root Polynomial.exists_max_root
-/

#print Polynomial.exists_min_root /-
theorem exists_min_root [LinearOrder R] (p : R[X]) (hp : p ≠ 0) : ∃ x₀, ∀ x, p.IsRoot x → x₀ ≤ x :=
  Set.exists_lower_bound_image _ _ <| finite_setOf_isRoot hp
#align polynomial.exists_min_root Polynomial.exists_min_root
-/

#print Polynomial.eq_of_infinite_eval_eq /-
theorem eq_of_infinite_eval_eq (p q : R[X]) (h : Set.Infinite { x | eval x p = eval x q }) :
    p = q := by
  rw [← sub_eq_zero]
  apply eq_zero_of_infinite_is_root
  simpa only [is_root, eval_sub, sub_eq_zero]
#align polynomial.eq_of_infinite_eval_eq Polynomial.eq_of_infinite_eval_eq
-/

#print Polynomial.roots_mul /-
theorem roots_mul {p q : R[X]} (hpq : p * q ≠ 0) : (p * q).roots = p.roots + q.roots :=
  Multiset.ext.mpr fun r => by
    rw [count_add, count_roots, count_roots, count_roots, root_multiplicity_mul hpq]
#align polynomial.roots_mul Polynomial.roots_mul
-/

/- warning: polynomial.roots.le_of_dvd -> Polynomial.roots.le_of_dvd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) q (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (Dvd.Dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) p q) -> (LE.le.{u1} (Multiset.{u1} R) (Preorder.toLE.{u1} (Multiset.{u1} R) (PartialOrder.toPreorder.{u1} (Multiset.{u1} R) (Multiset.partialOrder.{u1} R))) (Polynomial.roots.{u1} R _inst_1 _inst_2 p) (Polynomial.roots.{u1} R _inst_1 _inst_2 q))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) q (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) -> (Dvd.dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) p q) -> (LE.le.{u1} (Multiset.{u1} R) (Preorder.toLE.{u1} (Multiset.{u1} R) (PartialOrder.toPreorder.{u1} (Multiset.{u1} R) (Multiset.instPartialOrderMultiset.{u1} R))) (Polynomial.roots.{u1} R _inst_1 _inst_2 p) (Polynomial.roots.{u1} R _inst_1 _inst_2 q))
Case conversion may be inaccurate. Consider using '#align polynomial.roots.le_of_dvd Polynomial.roots.le_of_dvdₓ'. -/
theorem roots.le_of_dvd (h : q ≠ 0) : p ∣ q → roots p ≤ roots q :=
  by
  rintro ⟨k, rfl⟩
  exact multiset.le_iff_exists_add.mpr ⟨k.roots, roots_mul h⟩
#align polynomial.roots.le_of_dvd Polynomial.roots.le_of_dvd

/- warning: polynomial.mem_roots_sub_C' -> Polynomial.mem_roots_sub_C' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {a : R} {x : R}, Iff (Membership.Mem.{u1, u1} R (Multiset.{u1} R) (Multiset.hasMem.{u1} R) x (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (And (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Eq.{succ u1} R (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) x p) a))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {a : R} {x : R}, Iff (Membership.mem.{u1, u1} R (Multiset.{u1} R) (Multiset.instMembershipMultiset.{u1} R) x (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (And (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Eq.{succ u1} R (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) x p) a))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_roots_sub_C' Polynomial.mem_roots_sub_C'ₓ'. -/
theorem mem_roots_sub_C' {p : R[X]} {a x : R} : x ∈ (p - C a).roots ↔ p ≠ C a ∧ p.eval x = a := by
  rw [mem_roots', is_root.def, sub_ne_zero, eval_sub, sub_eq_zero, eval_C]
#align polynomial.mem_roots_sub_C' Polynomial.mem_roots_sub_C'

/- warning: polynomial.mem_roots_sub_C -> Polynomial.mem_roots_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {a : R} {x : R}, (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (Iff (Membership.Mem.{u1, u1} R (Multiset.{u1} R) (Multiset.hasMem.{u1} R) x (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (Eq.{succ u1} R (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) x p) a))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {a : R} {x : R}, (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (Iff (Membership.mem.{u1, u1} R (Multiset.{u1} R) (Multiset.instMembershipMultiset.{u1} R) x (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (Eq.{succ u1} R (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) x p) a))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_roots_sub_C Polynomial.mem_roots_sub_Cₓ'. -/
theorem mem_roots_sub_C {p : R[X]} {a x : R} (hp0 : 0 < degree p) :
    x ∈ (p - C a).roots ↔ p.eval x = a :=
  mem_roots_sub_C'.trans <| and_iff_right fun hp => hp0.not_le <| hp.symm ▸ degree_C_le
#align polynomial.mem_roots_sub_C Polynomial.mem_roots_sub_C

/- warning: polynomial.roots_X_sub_C -> Polynomial.roots_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (r : R), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))) (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.hasSingleton.{u1} R) r)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (r : R), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))) (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.instSingletonMultiset.{u1} R) r)
Case conversion may be inaccurate. Consider using '#align polynomial.roots_X_sub_C Polynomial.roots_X_sub_Cₓ'. -/
@[simp]
theorem roots_X_sub_C (r : R) : roots (X - C r) = {r} :=
  by
  ext s
  rw [count_roots, root_multiplicity_X_sub_C, count_singleton]
#align polynomial.roots_X_sub_C Polynomial.roots_X_sub_C

/- warning: polynomial.roots_X -> Polynomial.roots_X is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.hasSingleton.{u1} R) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.instSingletonMultiset.{u1} R) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2))))))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_X Polynomial.roots_Xₓ'. -/
@[simp]
theorem roots_X : roots (X : R[X]) = {0} := by rw [← roots_X_sub_C, C_0, sub_zero]
#align polynomial.roots_X Polynomial.roots_X

/- warning: polynomial.roots_C -> Polynomial.roots_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (x : R), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) x)) (OfNat.ofNat.{u1} (Multiset.{u1} R) 0 (OfNat.mk.{u1} (Multiset.{u1} R) 0 (Zero.zero.{u1} (Multiset.{u1} R) (Multiset.hasZero.{u1} R))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (x : R), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) x)) (OfNat.ofNat.{u1} (Multiset.{u1} R) 0 (Zero.toOfNat0.{u1} (Multiset.{u1} R) (Multiset.instZeroMultiset.{u1} R)))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_C Polynomial.roots_Cₓ'. -/
@[simp]
theorem roots_C (x : R) : (C x).roots = 0 :=
  if H : x = 0 then by rw [H, C_0, roots_zero]
  else
    Multiset.ext.mpr fun r => by
      rw [count_roots, count_zero, root_multiplicity_eq_zero (not_is_root_C _ _ H)]
#align polynomial.roots_C Polynomial.roots_C

#print Polynomial.roots_one /-
@[simp]
theorem roots_one : (1 : R[X]).roots = ∅ :=
  roots_C 1
#align polynomial.roots_one Polynomial.roots_one
-/

/- warning: polynomial.roots_C_mul -> Polynomial.roots_C_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) -> (Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) p)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))
but is expected to have type
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2)))))) -> (Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) p)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_C_mul Polynomial.roots_C_mulₓ'. -/
@[simp]
theorem roots_C_mul (p : R[X]) (ha : a ≠ 0) : (C a * p).roots = p.roots := by
  by_cases hp : p = 0 <;>
    simp only [roots_mul, *, Ne.def, mul_eq_zero, C_eq_zero, or_self_iff, not_false_iff, roots_C,
      zero_add, MulZeroClass.mul_zero]
#align polynomial.roots_C_mul Polynomial.roots_C_mul

/- warning: polynomial.roots_smul_nonzero -> Polynomial.roots_smul_nonzero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) -> (Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (SMul.smul.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SMulZeroClass.toHasSmul.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.smulZeroClass.{u1, u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) R (SMulWithZero.toSmulZeroClass.{u1, u1} R R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toSMulWithZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))) a p)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))
but is expected to have type
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2)))))) -> (Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSMul.hSMul.{u1, u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSMul.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Algebra.toSMul.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommSemiring.{u1} R _inst_1) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.algebraOfAlgebra.{u1, u1} R R (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) a p)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_smul_nonzero Polynomial.roots_smul_nonzeroₓ'. -/
@[simp]
theorem roots_smul_nonzero (p : R[X]) (ha : a ≠ 0) : (a • p).roots = p.roots := by
  rw [smul_eq_C_mul, roots_C_mul _ ha]
#align polynomial.roots_smul_nonzero Polynomial.roots_smul_nonzero

#print Polynomial.roots_list_prod /-
theorem roots_list_prod (L : List R[X]) :
    (0 : R[X]) ∉ L → L.Prod.roots = (L : Multiset R[X]).bind roots :=
  List.recOn L (fun _ => roots_one) fun hd tl ih H =>
    by
    rw [List.mem_cons, not_or] at H
    rw [List.prod_cons, roots_mul (mul_ne_zero (Ne.symm H.1) <| List.prod_ne_zero H.2), ←
      Multiset.cons_coe, Multiset.cons_bind, ih H.2]
#align polynomial.roots_list_prod Polynomial.roots_list_prod
-/

#print Polynomial.roots_multiset_prod /-
theorem roots_multiset_prod (m : Multiset R[X]) : (0 : R[X]) ∉ m → m.Prod.roots = m.bind roots :=
  by
  rcases m with ⟨L⟩
  simpa only [Multiset.coe_prod, quot_mk_to_coe''] using roots_list_prod L
#align polynomial.roots_multiset_prod Polynomial.roots_multiset_prod
-/

/- warning: polynomial.roots_prod -> Polynomial.roots_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {ι : Type.{u2}} (f : ι -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (s : Finset.{u2} ι), (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Finset.prod.{u1, u2} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ι (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) s f) (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (Finset.prod.{u1, u2} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ι (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) s f)) (Multiset.bind.{u2, u1} ι R (Finset.val.{u2} ι s) (fun (i : ι) => Polynomial.roots.{u1} R _inst_1 _inst_2 (f i))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] [_inst_2 : IsDomain.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))] {ι : Type.{u1}} (f : ι -> (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (s : Finset.{u1} ι), (Ne.{succ u2} (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Finset.prod.{u2, u1} (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) ι (CommRing.toCommMonoid.{u2} (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Polynomial.commRing.{u2} R _inst_1)) s f) (OfNat.ofNat.{u2} (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) 0 (Zero.toOfNat0.{u2} (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Polynomial.zero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)))))) -> (Eq.{succ u2} (Multiset.{u2} R) (Polynomial.roots.{u2} R _inst_1 _inst_2 (Finset.prod.{u2, u1} (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) ι (CommRing.toCommMonoid.{u2} (Polynomial.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Polynomial.commRing.{u2} R _inst_1)) s f)) (Multiset.bind.{u1, u2} ι R (Finset.val.{u1} ι s) (fun (i : ι) => Polynomial.roots.{u2} R _inst_1 _inst_2 (f i))))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_prod Polynomial.roots_prodₓ'. -/
theorem roots_prod {ι : Type _} (f : ι → R[X]) (s : Finset ι) :
    s.Prod f ≠ 0 → (s.Prod f).roots = s.val.bind fun i => roots (f i) :=
  by
  rcases s with ⟨m, hm⟩
  simpa [Multiset.prod_eq_zero_iff, bind_map] using roots_multiset_prod (m.map f)
#align polynomial.roots_prod Polynomial.roots_prod

/- warning: polynomial.roots_pow -> Polynomial.roots_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (n : Nat), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) p n)) (SMul.smul.{0, u1} Nat (Multiset.{u1} R) (AddMonoid.SMul.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) n (Polynomial.roots.{u1} R _inst_1 _inst_2 p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (n : Nat), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) p n)) (HSMul.hSMul.{0, u1, u1} Nat (Multiset.{u1} R) (Multiset.{u1} R) (instHSMul.{0, u1} Nat (Multiset.{u1} R) (AddMonoid.SMul.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) n (Polynomial.roots.{u1} R _inst_1 _inst_2 p))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_pow Polynomial.roots_powₓ'. -/
@[simp]
theorem roots_pow (p : R[X]) (n : ℕ) : (p ^ n).roots = n • p.roots :=
  by
  induction' n with n ihn
  · rw [pow_zero, roots_one, zero_smul, empty_eq_zero]
  · rcases eq_or_ne p 0 with (rfl | hp)
    · rw [zero_pow n.succ_pos, roots_zero, smul_zero]
    ·
      rw [pow_succ', roots_mul (mul_ne_zero (pow_ne_zero _ hp) hp), ihn, Nat.succ_eq_add_one,
        add_smul, one_smul]
#align polynomial.roots_pow Polynomial.roots_pow

/- warning: polynomial.roots_X_pow -> Polynomial.roots_X_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (n : Nat), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) n)) (SMul.smul.{0, u1} Nat (Multiset.{u1} R) (AddMonoid.SMul.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) n (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.hasSingleton.{u1} R) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (n : Nat), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) n)) (HSMul.hSMul.{0, u1, u1} Nat (Multiset.{u1} R) (Multiset.{u1} R) (instHSMul.{0, u1} Nat (Multiset.{u1} R) (AddMonoid.SMul.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) n (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.instSingletonMultiset.{u1} R) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_X_pow Polynomial.roots_X_powₓ'. -/
theorem roots_X_pow (n : ℕ) : (X ^ n : R[X]).roots = n • {0} := by rw [roots_pow, roots_X]
#align polynomial.roots_X_pow Polynomial.roots_X_pow

/- warning: polynomial.roots_C_mul_X_pow -> Polynomial.roots_C_mul_X_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) -> (forall (n : Nat), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) n))) (SMul.smul.{0, u1} Nat (Multiset.{u1} R) (AddMonoid.SMul.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) n (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.hasSingleton.{u1} R) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))))
but is expected to have type
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2)))))) -> (forall (n : Nat), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) n))) (HSMul.hSMul.{0, u1, u1} Nat (Multiset.{u1} R) (Multiset.{u1} R) (instHSMul.{0, u1} Nat (Multiset.{u1} R) (AddMonoid.SMul.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) n (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.instSingletonMultiset.{u1} R) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_C_mul_X_pow Polynomial.roots_C_mul_X_powₓ'. -/
theorem roots_C_mul_X_pow (ha : a ≠ 0) (n : ℕ) : (C a * X ^ n).roots = n • {0} := by
  rw [roots_C_mul _ ha, roots_X_pow]
#align polynomial.roots_C_mul_X_pow Polynomial.roots_C_mul_X_pow

/- warning: polynomial.roots_monomial -> Polynomial.roots_monomial is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) -> (forall (n : Nat), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : LinearMap.{u1, u1, u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} R R R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.monomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) n) a)) (SMul.smul.{0, u1} Nat (Multiset.{u1} R) (AddMonoid.SMul.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) n (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.hasSingleton.{u1} R) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))))
but is expected to have type
  forall {R : Type.{u1}} {a : R} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2)))))) -> (forall (n : Nat), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} R R R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.monomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) n) a)) (HSMul.hSMul.{0, u1, u1} Nat (Multiset.{u1} R) (Multiset.{u1} R) (instHSMul.{0, u1} Nat (Multiset.{u1} R) (AddMonoid.SMul.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) n (Singleton.singleton.{u1, u1} R (Multiset.{u1} R) (Multiset.instSingletonMultiset.{u1} R) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_monomial Polynomial.roots_monomialₓ'. -/
@[simp]
theorem roots_monomial (ha : a ≠ 0) (n : ℕ) : (monomial n a).roots = n • {0} := by
  rw [← C_mul_X_pow_eq_monomial, roots_C_mul_X_pow ha]
#align polynomial.roots_monomial Polynomial.roots_monomial

/- warning: polynomial.roots_prod_X_sub_C -> Polynomial.roots_prod_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (s : Finset.{u1} R), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (Finset.prod.{u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) s (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (Finset.val.{u1} R s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (s : Finset.{u1} R), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (Finset.prod.{u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) s (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (Finset.val.{u1} R s)
Case conversion may be inaccurate. Consider using '#align polynomial.roots_prod_X_sub_C Polynomial.roots_prod_X_sub_Cₓ'. -/
theorem roots_prod_X_sub_C (s : Finset R) : (s.Prod fun a => X - C a).roots = s.val :=
  (roots_prod (fun a => X - C a) s (prod_ne_zero_iff.mpr fun a _ => X_sub_C_ne_zero a)).trans
    (by simp_rw [roots_X_sub_C, Multiset.bind_singleton, Multiset.map_id'])
#align polynomial.roots_prod_X_sub_C Polynomial.roots_prod_X_sub_C

/- warning: polynomial.roots_multiset_prod_X_sub_C -> Polynomial.roots_multiset_prod_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (s : Multiset.{u1} R), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) s))) s
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (s : Multiset.{u1} R), Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) s))) s
Case conversion may be inaccurate. Consider using '#align polynomial.roots_multiset_prod_X_sub_C Polynomial.roots_multiset_prod_X_sub_Cₓ'. -/
@[simp]
theorem roots_multiset_prod_X_sub_C (s : Multiset R) : (s.map fun a => X - C a).Prod.roots = s :=
  by
  rw [roots_multiset_prod, Multiset.bind_map]
  · simp_rw [roots_X_sub_C, Multiset.bind_singleton, Multiset.map_id']
  · rw [Multiset.mem_map]
    rintro ⟨a, -, h⟩
    exact X_sub_C_ne_zero a h
#align polynomial.roots_multiset_prod_X_sub_C Polynomial.roots_multiset_prod_X_sub_C

/- warning: polynomial.nat_degree_multiset_prod_X_sub_C_eq_card -> Polynomial.natDegree_multiset_prod_X_sub_C_eq_card is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (s : Multiset.{u1} R), Eq.{1} Nat (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) s))) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (s : Multiset.{u1} R), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) s) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) s))) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) s)
Case conversion may be inaccurate. Consider using '#align polynomial.nat_degree_multiset_prod_X_sub_C_eq_card Polynomial.natDegree_multiset_prod_X_sub_C_eq_cardₓ'. -/
@[simp]
theorem natDegree_multiset_prod_X_sub_C_eq_card (s : Multiset R) :
    (s.map fun a => X - C a).Prod.natDegree = s.card :=
  by
  rw [nat_degree_multiset_prod_of_monic, Multiset.map_map]
  ·
    simp only [(· ∘ ·), nat_degree_X_sub_C, Multiset.map_const, Multiset.sum_replicate, smul_eq_mul,
      mul_one]
  · exact Multiset.forall_mem_map_iff.2 fun a _ => monic_X_sub_C a
#align polynomial.nat_degree_multiset_prod_X_sub_C_eq_card Polynomial.natDegree_multiset_prod_X_sub_C_eq_card

/- warning: polynomial.card_roots_X_pow_sub_C -> Polynomial.card_roots_X_pow_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (forall (a : R), LE.le.{0} Nat Nat.hasLe (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) n) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) n)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (forall (a : R), LE.le.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) n) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) instLENat (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) n) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) n)
Case conversion may be inaccurate. Consider using '#align polynomial.card_roots_X_pow_sub_C Polynomial.card_roots_X_pow_sub_Cₓ'. -/
theorem card_roots_X_pow_sub_C {n : ℕ} (hn : 0 < n) (a : R) :
    (roots ((X : R[X]) ^ n - C a)).card ≤ n :=
  WithBot.coe_le_coe.1 <|
    calc
      ((roots ((X : R[X]) ^ n - C a)).card : WithBot ℕ) ≤ degree ((X : R[X]) ^ n - C a) :=
        card_roots (X_pow_sub_C_ne_zero hn a)
      _ = n := degree_X_pow_sub_C hn a
      
#align polynomial.card_roots_X_pow_sub_C Polynomial.card_roots_X_pow_sub_C

section NthRoots

#print Polynomial.nthRoots /-
/-- `nth_roots n a` noncomputably returns the solutions to `x ^ n = a`-/
def nthRoots (n : ℕ) (a : R) : Multiset R :=
  roots ((X : R[X]) ^ n - C a)
#align polynomial.nth_roots Polynomial.nthRoots
-/

/- warning: polynomial.mem_nth_roots -> Polynomial.mem_nthRoots is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (forall {a : R} {x : R}, Iff (Membership.Mem.{u1, u1} R (Multiset.{u1} R) (Multiset.hasMem.{u1} R) x (Polynomial.nthRoots.{u1} R _inst_1 _inst_2 n a)) (Eq.{succ u1} R (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) x n) a))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (forall {a : R} {x : R}, Iff (Membership.mem.{u1, u1} R (Multiset.{u1} R) (Multiset.instMembershipMultiset.{u1} R) x (Polynomial.nthRoots.{u1} R _inst_1 _inst_2 n a)) (Eq.{succ u1} R (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) x n) a))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_nth_roots Polynomial.mem_nthRootsₓ'. -/
@[simp]
theorem mem_nthRoots {n : ℕ} (hn : 0 < n) {a x : R} : x ∈ nthRoots n a ↔ x ^ n = a := by
  rw [nth_roots, mem_roots (X_pow_sub_C_ne_zero hn a), is_root.def, eval_sub, eval_C, eval_pow,
    eval_X, sub_eq_zero]
#align polynomial.mem_nth_roots Polynomial.mem_nthRoots

#print Polynomial.nthRoots_zero /-
@[simp]
theorem nthRoots_zero (r : R) : nthRoots 0 r = 0 := by
  simp only [empty_eq_zero, pow_zero, nth_roots, ← C_1, ← C_sub, roots_C]
#align polynomial.nth_roots_zero Polynomial.nthRoots_zero
-/

/- warning: polynomial.card_nth_roots -> Polynomial.card_nthRoots is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (n : Nat) (a : R), LE.le.{0} Nat Nat.hasLe (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.nthRoots.{u1} R _inst_1 _inst_2 n a)) n
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (n : Nat) (a : R), LE.le.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.nthRoots.{u1} R _inst_1 _inst_2 n a)) instLENat (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) (Polynomial.nthRoots.{u1} R _inst_1 _inst_2 n a)) n
Case conversion may be inaccurate. Consider using '#align polynomial.card_nth_roots Polynomial.card_nthRootsₓ'. -/
theorem card_nthRoots (n : ℕ) (a : R) : (nthRoots n a).card ≤ n :=
  if hn : n = 0 then
    if h : (X : R[X]) ^ n - C a = 0 then by
      simp only [Nat.zero_le, nth_roots, roots, h, dif_pos rfl, empty_eq_zero, card_zero]
    else
      WithBot.coe_le_coe.1
        (le_trans (card_roots h)
          (by
            rw [hn, pow_zero, ← C_1, ← RingHom.map_sub]
            exact degree_C_le))
  else by
    rw [← WithBot.coe_le_coe, ← degree_X_pow_sub_C (Nat.pos_of_ne_zero hn) a] <;>
      exact card_roots (X_pow_sub_C_ne_zero (Nat.pos_of_ne_zero hn) a)
#align polynomial.card_nth_roots Polynomial.card_nthRoots

/- warning: polynomial.nth_roots_two_eq_zero_iff -> Polynomial.nthRoots_two_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {r : R}, Iff (Eq.{succ u1} (Multiset.{u1} R) (Polynomial.nthRoots.{u1} R _inst_1 _inst_2 (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) r) (OfNat.ofNat.{u1} (Multiset.{u1} R) 0 (OfNat.mk.{u1} (Multiset.{u1} R) 0 (Zero.zero.{u1} (Multiset.{u1} R) (Multiset.hasZero.{u1} R))))) (Not (IsSquare.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {r : R}, Iff (Eq.{succ u1} (Multiset.{u1} R) (Polynomial.nthRoots.{u1} R _inst_1 _inst_2 (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) r) (OfNat.ofNat.{u1} (Multiset.{u1} R) 0 (Zero.toOfNat0.{u1} (Multiset.{u1} R) (Multiset.instZeroMultiset.{u1} R)))) (Not (IsSquare.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))) r))
Case conversion may be inaccurate. Consider using '#align polynomial.nth_roots_two_eq_zero_iff Polynomial.nthRoots_two_eq_zero_iffₓ'. -/
@[simp]
theorem nthRoots_two_eq_zero_iff {r : R} : nthRoots 2 r = 0 ↔ ¬IsSquare r := by
  simp_rw [isSquare_iff_exists_sq, eq_zero_iff_forall_not_mem, mem_nth_roots (by norm_num : 0 < 2),
    ← not_exists, eq_comm]
#align polynomial.nth_roots_two_eq_zero_iff Polynomial.nthRoots_two_eq_zero_iff

#print Polynomial.nthRootsFinset /-
/-- The multiset `nth_roots ↑n (1 : R)` as a finset. -/
def nthRootsFinset (n : ℕ) (R : Type _) [CommRing R] [IsDomain R] : Finset R :=
  Multiset.toFinset (nthRoots n (1 : R))
#align polynomial.nth_roots_finset Polynomial.nthRootsFinset
-/

/- warning: polynomial.mem_nth_roots_finset -> Polynomial.mem_nthRootsFinset is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {n : Nat}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (forall {x : R}, Iff (Membership.Mem.{u1, u1} R (Finset.{u1} R) (Finset.hasMem.{u1} R) x (Polynomial.nthRootsFinset.{u1} n R _inst_1 _inst_2)) (Eq.{succ u1} R (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) x n) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {n : Nat}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (forall {x : R}, Iff (Membership.mem.{u1, u1} R (Finset.{u1} R) (Finset.instMembershipFinset.{u1} R) x (Polynomial.nthRootsFinset.{u1} n R _inst_1 _inst_2)) (Eq.{succ u1} R (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) x n) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_nth_roots_finset Polynomial.mem_nthRootsFinsetₓ'. -/
@[simp]
theorem mem_nthRootsFinset {n : ℕ} (h : 0 < n) {x : R} : x ∈ nthRootsFinset n R ↔ x ^ (n : ℕ) = 1 :=
  by rw [nth_roots_finset, mem_to_finset, mem_nth_roots h]
#align polynomial.mem_nth_roots_finset Polynomial.mem_nthRootsFinset

#print Polynomial.nthRootsFinset_zero /-
@[simp]
theorem nthRootsFinset_zero : nthRootsFinset 0 R = ∅ := by simp [nth_roots_finset]
#align polynomial.nth_roots_finset_zero Polynomial.nthRootsFinset_zero
-/

end NthRoots

#print Polynomial.Monic.comp /-
theorem Monic.comp (hp : p.Monic) (hq : q.Monic) (h : q.natDegree ≠ 0) : (p.comp q).Monic := by
  rw [monic.def, leading_coeff_comp h, monic.def.1 hp, monic.def.1 hq, one_pow, one_mul]
#align polynomial.monic.comp Polynomial.Monic.comp
-/

/- warning: polynomial.monic.comp_X_add_C -> Polynomial.Monic.comp_X_add_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (forall (r : R), Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Polynomial.comp.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHAdd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.add'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (forall (r : R), Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Polynomial.comp.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHAdd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.add'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))))
Case conversion may be inaccurate. Consider using '#align polynomial.monic.comp_X_add_C Polynomial.Monic.comp_X_add_Cₓ'. -/
theorem Monic.comp_X_add_C (hp : p.Monic) (r : R) : (p.comp (X + C r)).Monic :=
  by
  refine' hp.comp (monic_X_add_C _) fun ha => _
  rw [nat_degree_X_add_C] at ha
  exact one_ne_zero ha
#align polynomial.monic.comp_X_add_C Polynomial.Monic.comp_X_add_C

/- warning: polynomial.monic.comp_X_sub_C -> Polynomial.Monic.comp_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (forall (r : R), Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Polynomial.comp.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (forall (r : R), Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Polynomial.comp.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) r))))
Case conversion may be inaccurate. Consider using '#align polynomial.monic.comp_X_sub_C Polynomial.Monic.comp_X_sub_Cₓ'. -/
theorem Monic.comp_X_sub_C (hp : p.Monic) (r : R) : (p.comp (X - C r)).Monic := by
  simpa using hp.comp_X_add_C (-r)
#align polynomial.monic.comp_X_sub_C Polynomial.Monic.comp_X_sub_C

/- warning: polynomial.units_coeff_zero_smul -> Polynomial.units_coeff_zero_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (c : Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SMul.smul.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SMulZeroClass.toHasSmul.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.smulZeroClass.{u1, u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) R (SMulWithZero.toSmulZeroClass.{u1, u1} R R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toSMulWithZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))) (Polynomial.coeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeBase.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.hasCoe.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) c) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) p) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeBase.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.hasCoe.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) c) p)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (c : Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HSMul.hSMul.{u1, u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSMul.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Algebra.toSMul.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommSemiring.{u1} R _inst_1) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.algebraOfAlgebra.{u1, u1} R R (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Polynomial.coeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Units.val.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) c) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) p) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Units.val.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) c) p)
Case conversion may be inaccurate. Consider using '#align polynomial.units_coeff_zero_smul Polynomial.units_coeff_zero_smulₓ'. -/
theorem units_coeff_zero_smul (c : R[X]ˣ) (p : R[X]) : (c : R[X]).coeff 0 • p = c * p := by
  rw [← Polynomial.C_mul', ← Polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)]
#align polynomial.units_coeff_zero_smul Polynomial.units_coeff_zero_smul

/- warning: polynomial.nat_degree_coe_units -> Polynomial.natDegree_coe_units is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (u : Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))), Eq.{1} Nat (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeBase.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.hasCoe.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) u)) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (u : Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))), Eq.{1} Nat (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Units.val.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) u)) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))
Case conversion may be inaccurate. Consider using '#align polynomial.nat_degree_coe_units Polynomial.natDegree_coe_unitsₓ'. -/
@[simp]
theorem natDegree_coe_units (u : R[X]ˣ) : natDegree (u : R[X]) = 0 :=
  natDegree_eq_of_degree_eq_some (degree_coe_units u)
#align polynomial.nat_degree_coe_units Polynomial.natDegree_coe_units

/- warning: polynomial.comp_eq_zero_iff -> Polynomial.comp_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Iff (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.comp.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p q) (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Or (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (And (Eq.{succ u1} R (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Polynomial.coeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) p) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) q (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.coeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Iff (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.comp.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p q) (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Or (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (And (Eq.{succ u1} R (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Polynomial.coeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) p) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2)))))) (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) q (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.coeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.comp_eq_zero_iff Polynomial.comp_eq_zero_iffₓ'. -/
theorem comp_eq_zero_iff : p.comp q = 0 ↔ p = 0 ∨ p.eval (q.coeff 0) = 0 ∧ q = C (q.coeff 0) :=
  by
  constructor
  · intro h
    have key : p.nat_degree = 0 ∨ q.nat_degree = 0 := by
      rw [← mul_eq_zero, ← nat_degree_comp, h, nat_degree_zero]
    replace key := Or.imp eq_C_of_nat_degree_eq_zero eq_C_of_nat_degree_eq_zero key
    cases key
    · rw [key, C_comp] at h
      exact Or.inl (key.trans h)
    · rw [key, comp_C, C_eq_zero] at h
      exact Or.inr ⟨h, key⟩
  ·
    exact fun h =>
      Or.ndrec (fun h => by rw [h, zero_comp]) (fun h => by rw [h.2, comp_C, h.1, C_0]) h
#align polynomial.comp_eq_zero_iff Polynomial.comp_eq_zero_iff

/- warning: polynomial.zero_of_eval_zero -> Polynomial.zero_of_eval_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : Infinite.{succ u1} R] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (forall (x : R), Eq.{succ u1} R (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) x p) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) -> (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : Infinite.{succ u1} R] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (forall (x : R), Eq.{succ u1} R (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) x p) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2)))))) -> (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align polynomial.zero_of_eval_zero Polynomial.zero_of_eval_zeroₓ'. -/
theorem zero_of_eval_zero [Infinite R] (p : R[X]) (h : ∀ x, p.eval x = 0) : p = 0 := by
  classical by_contra hp <;>
      exact
        Fintype.false
          ⟨p.roots.to_finset, fun x => multiset.mem_to_finset.mpr ((mem_roots hp).mpr (h _))⟩
#align polynomial.zero_of_eval_zero Polynomial.zero_of_eval_zero

#print Polynomial.funext /-
theorem funext [Infinite R] {p q : R[X]} (ext : ∀ r : R, p.eval r = q.eval r) : p = q :=
  by
  rw [← sub_eq_zero]
  apply zero_of_eval_zero
  intro x
  rw [eval_sub, sub_eq_zero, ext]
#align polynomial.funext Polynomial.funext
-/

variable [CommRing T]

#print Polynomial.rootSet /-
/-- The set of distinct roots of `p` in `E`.

If you have a non-separable polynomial, use `polynomial.roots` for the multiset
where multiple roots have the appropriate multiplicity. -/
def rootSet (p : T[X]) (S) [CommRing S] [IsDomain S] [Algebra T S] : Set S :=
  (p.map (algebraMap T S)).roots.toFinset
#align polynomial.root_set Polynomial.rootSet
-/

/- warning: polynomial.root_set_def -> Polynomial.rootSet_def is a dubious translation:
lean 3 declaration is
  forall {T : Type.{u1}} [_inst_3 : CommRing.{u1} T] (p : Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) (S : Type.{u2}) [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))], Eq.{succ u2} (Set.{u2} S) (Polynomial.rootSet.{u1, u2} T _inst_3 p S _inst_4 _inst_5 _inst_6) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} S) (Set.{u2} S) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} S) (Set.{u2} S) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} S) (Set.{u2} S) (Finset.Set.hasCoeT.{u2} S))) (Multiset.toFinset.{u2} S (fun (a : S) (b : S) => Classical.propDecidable (Eq.{succ u2} S a b)) (Polynomial.roots.{u2} S _inst_4 _inst_5 (Polynomial.map.{u1, u2} T S (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (algebraMap.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6) p))))
but is expected to have type
  forall {T : Type.{u2}} [_inst_3 : CommRing.{u2} T] (p : Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (S : Type.{u1}) [_inst_4 : CommRing.{u1} S] [_inst_5 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_6 : Algebra.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))], Eq.{succ u1} (Set.{u1} S) (Polynomial.rootSet.{u2, u1} T _inst_3 p S _inst_4 _inst_5 _inst_6) (Finset.toSet.{u1} S (Multiset.toFinset.{u1} S (fun (a : S) (b : S) => Classical.propDecidable (Eq.{succ u1} S a b)) (Polynomial.roots.{u1} S _inst_4 _inst_5 (Polynomial.map.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (algebraMap.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6) p))))
Case conversion may be inaccurate. Consider using '#align polynomial.root_set_def Polynomial.rootSet_defₓ'. -/
theorem rootSet_def (p : T[X]) (S) [CommRing S] [IsDomain S] [Algebra T S] :
    p.rootSet S = (p.map (algebraMap T S)).roots.toFinset :=
  rfl
#align polynomial.root_set_def Polynomial.rootSet_def

/- warning: polynomial.root_set_C -> Polynomial.rootSet_C is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} {T : Type.{u2}} [_inst_3 : CommRing.{u2} T] [_inst_4 : CommRing.{u1} S] [_inst_5 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_6 : Algebra.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] (a : T), Eq.{succ u1} (Set.{u1} S) (Polynomial.rootSet.{u2, u1} T _inst_3 (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) (fun (_x : RingHom.{u2, u2} T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) => T -> (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3)))) (RingHom.hasCoeToFun.{u2, u2} T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) (Polynomial.C.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) a) S _inst_4 _inst_5 _inst_6) (EmptyCollection.emptyCollection.{u1} (Set.{u1} S) (Set.hasEmptyc.{u1} S))
but is expected to have type
  forall {S : Type.{u1}} {T : Type.{u2}} [_inst_3 : CommRing.{u2} T] [_inst_4 : CommRing.{u1} S] [_inst_5 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_6 : Algebra.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] (a : T), Eq.{succ u1} (Set.{u1} S) (Polynomial.rootSet.{u2, u1} T _inst_3 (FunLike.coe.{succ u2, succ u2, succ u2} (RingHom.{u2, u2} T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) T (fun (_x : T) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : T) => Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) _x) (MulHomClass.toFunLike.{u2, u2, u2} (RingHom.{u2, u2} T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toMul.{u2} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) (NonUnitalNonAssocSemiring.toMul.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3)))))) (NonUnitalRingHomClass.toMulHomClass.{u2, u2, u2} (RingHom.{u2, u2} T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} T (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) (RingHomClass.toNonUnitalRingHomClass.{u2, u2, u2} (RingHom.{u2, u2} T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3)))) (RingHom.instRingHomClassRingHom.{u2, u2} T (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3)))))))) (Polynomial.C.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) a) S _inst_4 _inst_5 _inst_6) (EmptyCollection.emptyCollection.{u1} (Set.{u1} S) (Set.instEmptyCollectionSet.{u1} S))
Case conversion may be inaccurate. Consider using '#align polynomial.root_set_C Polynomial.rootSet_Cₓ'. -/
@[simp]
theorem rootSet_C [CommRing S] [IsDomain S] [Algebra T S] (a : T) : (C a).rootSet S = ∅ := by
  rw [root_set_def, map_C, roots_C, Multiset.toFinset_zero, Finset.coe_empty]
#align polynomial.root_set_C Polynomial.rootSet_C

/- warning: polynomial.root_set_zero -> Polynomial.rootSet_zero is a dubious translation:
lean 3 declaration is
  forall {T : Type.{u1}} [_inst_3 : CommRing.{u1} T] (S : Type.{u2}) [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))], Eq.{succ u2} (Set.{u2} S) (Polynomial.rootSet.{u1, u2} T _inst_3 (OfNat.ofNat.{u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) 0 (OfNat.mk.{u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) 0 (Zero.zero.{u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) (Polynomial.zero.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3)))))) S _inst_4 _inst_5 _inst_6) (EmptyCollection.emptyCollection.{u2} (Set.{u2} S) (Set.hasEmptyc.{u2} S))
but is expected to have type
  forall {T : Type.{u2}} [_inst_3 : CommRing.{u2} T] (S : Type.{u1}) [_inst_4 : CommRing.{u1} S] [_inst_5 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_6 : Algebra.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))], Eq.{succ u1} (Set.{u1} S) (Polynomial.rootSet.{u2, u1} T _inst_3 (OfNat.ofNat.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) 0 (Zero.toOfNat0.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.zero.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))))) S _inst_4 _inst_5 _inst_6) (EmptyCollection.emptyCollection.{u1} (Set.{u1} S) (Set.instEmptyCollectionSet.{u1} S))
Case conversion may be inaccurate. Consider using '#align polynomial.root_set_zero Polynomial.rootSet_zeroₓ'. -/
@[simp]
theorem rootSet_zero (S) [CommRing S] [IsDomain S] [Algebra T S] : (0 : T[X]).rootSet S = ∅ := by
  rw [← C_0, root_set_C]
#align polynomial.root_set_zero Polynomial.rootSet_zero

#print Polynomial.rootSetFintype /-
instance rootSetFintype (p : T[X]) (S : Type _) [CommRing S] [IsDomain S] [Algebra T S] :
    Fintype (p.rootSet S) :=
  FinsetCoe.fintype _
#align polynomial.root_set_fintype Polynomial.rootSetFintype
-/

/- warning: polynomial.root_set_finite -> Polynomial.rootSet_finite is a dubious translation:
lean 3 declaration is
  forall {T : Type.{u1}} [_inst_3 : CommRing.{u1} T] (p : Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) (S : Type.{u2}) [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))], Set.Finite.{u2} S (Polynomial.rootSet.{u1, u2} T _inst_3 p S _inst_4 _inst_5 _inst_6)
but is expected to have type
  forall {T : Type.{u2}} [_inst_3 : CommRing.{u2} T] (p : Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (S : Type.{u1}) [_inst_4 : CommRing.{u1} S] [_inst_5 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_6 : Algebra.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))], Set.Finite.{u1} S (Polynomial.rootSet.{u2, u1} T _inst_3 p S _inst_4 _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align polynomial.root_set_finite Polynomial.rootSet_finiteₓ'. -/
theorem rootSet_finite (p : T[X]) (S : Type _) [CommRing S] [IsDomain S] [Algebra T S] :
    (p.rootSet S).Finite :=
  Set.toFinite _
#align polynomial.root_set_finite Polynomial.rootSet_finite

/- warning: polynomial.bUnion_roots_finite -> Polynomial.bUnion_roots_finite is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_4 : Semiring.{u1} R] [_inst_5 : CommRing.{u2} S] [_inst_6 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_5))] (m : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_4) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_5)))) (d : Nat) {U : Set.{u1} R}, (Set.Finite.{u1} R U) -> (Set.Finite.{u2} S (Set.unionᵢ.{u2, succ u1} S (Polynomial.{u1} R _inst_4) (fun (f : Polynomial.{u1} R _inst_4) => Set.unionᵢ.{u2, 0} S (And (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_4 f) d) (forall (i : Nat), Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) (Polynomial.coeff.{u1} R _inst_4 f i) U)) (fun (hf : And (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_4 f) d) (forall (i : Nat), Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) (Polynomial.coeff.{u1} R _inst_4 f i) U)) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} S) (Set.{u2} S) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} S) (Set.{u2} S) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} S) (Set.{u2} S) (Finset.Set.hasCoeT.{u2} S))) (Multiset.toFinset.{u2} S (fun (a : S) (b : S) => Classical.propDecidable (Eq.{succ u2} S a b)) (Polynomial.roots.{u2} S _inst_5 _inst_6 (Polynomial.map.{u1, u2} R S _inst_4 (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_5)) m f)))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_4 : Semiring.{u2} R] [_inst_5 : CommRing.{u1} S] [_inst_6 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_5))] (m : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_4) (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_5)))) (d : Nat) {U : Set.{u2} R}, (Set.Finite.{u2} R U) -> (Set.Finite.{u1} S (Set.unionᵢ.{u1, succ u2} S (Polynomial.{u2} R _inst_4) (fun (f : Polynomial.{u2} R _inst_4) => Set.unionᵢ.{u1, 0} S (And (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u2} R _inst_4 f) d) (forall (i : Nat), Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) (Polynomial.coeff.{u2} R _inst_4 f i) U)) (fun (hf : And (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u2} R _inst_4 f) d) (forall (i : Nat), Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) (Polynomial.coeff.{u2} R _inst_4 f i) U)) => Finset.toSet.{u1} S (Multiset.toFinset.{u1} S (fun (a : S) (b : S) => Classical.propDecidable (Eq.{succ u1} S a b)) (Polynomial.roots.{u1} S _inst_5 _inst_6 (Polynomial.map.{u2, u1} R S _inst_4 (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_5)) m f)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.bUnion_roots_finite Polynomial.bUnion_roots_finiteₓ'. -/
/-- The set of roots of all polynomials of bounded degree and having coefficients in a finite set
is finite. -/
theorem bUnion_roots_finite {R S : Type _} [Semiring R] [CommRing S] [IsDomain S] (m : R →+* S)
    (d : ℕ) {U : Set R} (h : U.Finite) :
    (⋃ (f : R[X]) (hf : f.natDegree ≤ d ∧ ∀ i, f.coeff i ∈ U),
        ((f.map m).roots.toFinset : Set S)).Finite :=
  Set.Finite.bunionᵢ
    (by
      -- We prove that the set of polynomials under consideration is finite because its
      -- image by the injective map `π` is finite
      let π : R[X] → Fin (d + 1) → R := fun f i => f.coeff i
      refine' ((Set.Finite.pi fun e => h).Subset <| _).of_finite_image (_ : Set.InjOn π _)
      · exact Set.image_subset_iff.2 fun f hf i _ => hf.2 i
      · refine' fun x hx y hy hxy => (ext_iff_nat_degree_le hx.1 hy.1).2 fun i hi => _
        exact id congr_fun hxy ⟨i, Nat.lt_succ_of_le hi⟩)
    fun i hi => Finset.finite_toSet _
#align polynomial.bUnion_roots_finite Polynomial.bUnion_roots_finite

/- warning: polynomial.mem_root_set' -> Polynomial.mem_rootSet' is a dubious translation:
lean 3 declaration is
  forall {T : Type.{u1}} [_inst_3 : CommRing.{u1} T] {p : Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))} {S : Type.{u2}} [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] {a : S}, Iff (Membership.Mem.{u2, u2} S (Set.{u2} S) (Set.hasMem.{u2} S) a (Polynomial.rootSet.{u1, u2} T _inst_3 p S _inst_4 _inst_5 _inst_6)) (And (Ne.{succ u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) (Polynomial.map.{u1, u2} T S (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (algebraMap.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6) p) (OfNat.ofNat.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) 0 (OfNat.mk.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) 0 (Zero.zero.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) (Polynomial.zero.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))))) (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AlgHom.{u1, u1, u2} T (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) S (CommRing.toCommSemiring.{u1} T _inst_3) (Polynomial.semiring.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Polynomial.algebraOfAlgebra.{u1, u1} T T (CommRing.toCommSemiring.{u1} T _inst_3) (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Algebra.id.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) _inst_6) (fun (_x : AlgHom.{u1, u1, u2} T (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) S (CommRing.toCommSemiring.{u1} T _inst_3) (Polynomial.semiring.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Polynomial.algebraOfAlgebra.{u1, u1} T T (CommRing.toCommSemiring.{u1} T _inst_3) (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Algebra.id.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) _inst_6) => (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) -> S) ([anonymous].{u1, u1, u2} T (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) S (CommRing.toCommSemiring.{u1} T _inst_3) (Polynomial.semiring.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Polynomial.algebraOfAlgebra.{u1, u1} T T (CommRing.toCommSemiring.{u1} T _inst_3) (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Algebra.id.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) _inst_6) (Polynomial.aeval.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6 a) p) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))))))
but is expected to have type
  forall {T : Type.{u2}} [_inst_3 : CommRing.{u2} T] {p : Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))} {S : Type.{u1}} [_inst_4 : CommRing.{u1} S] [_inst_5 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_6 : Algebra.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] {a : S}, Iff (Membership.mem.{u1, u1} S (Set.{u1} S) (Set.instMembershipSet.{u1} S) a (Polynomial.rootSet.{u2, u1} T _inst_3 p S _inst_4 _inst_5 _inst_6)) (And (Ne.{succ u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))) (Polynomial.map.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (algebraMap.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6) p) (OfNat.ofNat.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))) (Polynomial.zero.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))))) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (fun (_x : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) _x) (SMulHomClass.toFunLike.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (SMulZeroClass.toSMul.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddMonoid.toZero.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))))) (DistribSMul.toSMulZeroClass.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))))) (DistribMulAction.toDistribSMul.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))))) (Module.toDistribMulAction.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))) (Algebra.toModule.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))))) (SMulZeroClass.toSMul.{u2, u1} T S (AddMonoid.toZero.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))))) (DistribSMul.toSMulZeroClass.{u2, u1} T S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))))) (DistribMulAction.toDistribSMul.{u2, u1} T S (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))))) (Module.toDistribMulAction.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))) (Algebra.toModule.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6))))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))))) (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))))) (Module.toDistribMulAction.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))) (Algebra.toModule.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))) (Module.toDistribMulAction.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))) (Algebra.toModule.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))) (Module.toDistribMulAction.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))) (Algebra.toModule.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))) (Module.toDistribMulAction.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))) (Algebra.toModule.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, u2, u1, max u1 u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6 (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) (AlgHom.algHomClass.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6))))) (Polynomial.aeval.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6 a) p) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (CommMonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (IsDomain.toCancelCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (CommRing.toCommSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) _inst_4) _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_root_set' Polynomial.mem_rootSet'ₓ'. -/
theorem mem_rootSet' {p : T[X]} {S : Type _} [CommRing S] [IsDomain S] [Algebra T S] {a : S} :
    a ∈ p.rootSet S ↔ p.map (algebraMap T S) ≠ 0 ∧ aeval a p = 0 := by
  rw [root_set, Finset.mem_coe, mem_to_finset, mem_roots', is_root.def, ← eval₂_eq_eval_map,
    aeval_def]
#align polynomial.mem_root_set' Polynomial.mem_rootSet'

/- warning: polynomial.mem_root_set -> Polynomial.mem_rootSet is a dubious translation:
lean 3 declaration is
  forall {T : Type.{u1}} [_inst_3 : CommRing.{u1} T] {p : Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))} {S : Type.{u2}} [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_7 : NoZeroSMulDivisors.{u1, u2} T S (MulZeroClass.toHasZero.{u1} T (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} T (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} T (NonAssocRing.toNonUnitalNonAssocRing.{u1} T (Ring.toNonAssocRing.{u1} T (CommRing.toRing.{u1} T _inst_3)))))) (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_4)))))) (SMulZeroClass.toHasSmul.{u1, u2} T S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} T S (MulZeroClass.toHasZero.{u1} T (MulZeroOneClass.toMulZeroClass.{u1} T (MonoidWithZero.toMulZeroOneClass.{u1} T (Semiring.toMonoidWithZero.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)))))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} T S (Semiring.toMonoidWithZero.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))) (Module.toMulActionWithZero.{u1, u2} T S (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))) (Algebra.toModule.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6)))))] {a : S}, Iff (Membership.Mem.{u2, u2} S (Set.{u2} S) (Set.hasMem.{u2} S) a (Polynomial.rootSet.{u1, u2} T _inst_3 p S _inst_4 _inst_5 _inst_6)) (And (Ne.{succ u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) p (OfNat.ofNat.{u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) 0 (OfNat.mk.{u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) 0 (Zero.zero.{u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) (Polynomial.zero.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))))))) (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AlgHom.{u1, u1, u2} T (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) S (CommRing.toCommSemiring.{u1} T _inst_3) (Polynomial.semiring.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Polynomial.algebraOfAlgebra.{u1, u1} T T (CommRing.toCommSemiring.{u1} T _inst_3) (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Algebra.id.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) _inst_6) (fun (_x : AlgHom.{u1, u1, u2} T (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) S (CommRing.toCommSemiring.{u1} T _inst_3) (Polynomial.semiring.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Polynomial.algebraOfAlgebra.{u1, u1} T T (CommRing.toCommSemiring.{u1} T _inst_3) (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Algebra.id.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) _inst_6) => (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) -> S) ([anonymous].{u1, u1, u2} T (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) S (CommRing.toCommSemiring.{u1} T _inst_3) (Polynomial.semiring.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Polynomial.algebraOfAlgebra.{u1, u1} T T (CommRing.toCommSemiring.{u1} T _inst_3) (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Algebra.id.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) _inst_6) (Polynomial.aeval.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6 a) p) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))))))
but is expected to have type
  forall {T : Type.{u2}} [_inst_3 : CommRing.{u2} T] {p : Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))} {S : Type.{u1}} [_inst_4 : CommRing.{u1} S] [_inst_5 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_6 : Algebra.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_7 : NoZeroSMulDivisors.{u2, u1} T S (CommMonoidWithZero.toZero.{u2} T (CommSemiring.toCommMonoidWithZero.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommMonoidWithZero.toZero.{u1} S (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} S (IsDomain.toCancelCommMonoidWithZero.{u1} S (CommRing.toCommSemiring.{u1} S _inst_4) _inst_5))) (Algebra.toSMul.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6)] {a : S}, Iff (Membership.mem.{u1, u1} S (Set.{u1} S) (Set.instMembershipSet.{u1} S) a (Polynomial.rootSet.{u2, u1} T _inst_3 p S _inst_4 _inst_5 _inst_6)) (And (Ne.{succ u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) p (OfNat.ofNat.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) 0 (Zero.toOfNat0.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.zero.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3)))))) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (fun (_x : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) _x) (SMulHomClass.toFunLike.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (SMulZeroClass.toSMul.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddMonoid.toZero.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))))) (DistribSMul.toSMulZeroClass.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))))) (DistribMulAction.toDistribSMul.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))))) (Module.toDistribMulAction.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))) (Algebra.toModule.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))))) (SMulZeroClass.toSMul.{u2, u1} T S (AddMonoid.toZero.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))))) (DistribSMul.toSMulZeroClass.{u2, u1} T S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))))) (DistribMulAction.toDistribSMul.{u2, u1} T S (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))))) (Module.toDistribMulAction.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))) (Algebra.toModule.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6))))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))))) (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))))) (Module.toDistribMulAction.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))) (Algebra.toModule.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))) (Module.toDistribMulAction.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))) (Algebra.toModule.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))) (Module.toDistribMulAction.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))) (Algebra.toModule.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))) (Module.toDistribMulAction.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))) (Algebra.toModule.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, u2, u1, max u1 u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6 (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) (AlgHom.algHomClass.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6))))) (Polynomial.aeval.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6 a) p) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (CommMonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (IsDomain.toCancelCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (CommRing.toCommSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) _inst_4) _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_root_set Polynomial.mem_rootSetₓ'. -/
theorem mem_rootSet {p : T[X]} {S : Type _} [CommRing S] [IsDomain S] [Algebra T S]
    [NoZeroSMulDivisors T S] {a : S} : a ∈ p.rootSet S ↔ p ≠ 0 ∧ aeval a p = 0 := by
  rw [mem_root_set',
    (map_injective _ (NoZeroSMulDivisors.algebraMap_injective T S)).ne_iff' (Polynomial.map_zero _)]
#align polynomial.mem_root_set Polynomial.mem_rootSet

/- warning: polynomial.mem_root_set_of_ne -> Polynomial.mem_rootSet_of_ne is a dubious translation:
lean 3 declaration is
  forall {T : Type.{u1}} [_inst_3 : CommRing.{u1} T] {p : Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))} {S : Type.{u2}} [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_7 : NoZeroSMulDivisors.{u1, u2} T S (MulZeroClass.toHasZero.{u1} T (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} T (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} T (NonAssocRing.toNonUnitalNonAssocRing.{u1} T (Ring.toNonAssocRing.{u1} T (CommRing.toRing.{u1} T _inst_3)))))) (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_4)))))) (SMulZeroClass.toHasSmul.{u1, u2} T S (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} T S (MulZeroClass.toHasZero.{u1} T (MulZeroOneClass.toMulZeroClass.{u1} T (MonoidWithZero.toMulZeroOneClass.{u1} T (Semiring.toMonoidWithZero.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)))))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} T S (Semiring.toMonoidWithZero.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (AddZeroClass.toHasZero.{u2} S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))) (Module.toMulActionWithZero.{u1, u2} T S (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))) (Algebra.toModule.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6)))))], (Ne.{succ u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) p (OfNat.ofNat.{u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) 0 (OfNat.mk.{u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) 0 (Zero.zero.{u1} (Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))) (Polynomial.zero.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))))))) -> (forall {a : S}, Iff (Membership.Mem.{u2, u2} S (Set.{u2} S) (Set.hasMem.{u2} S) a (Polynomial.rootSet.{u1, u2} T _inst_3 p S _inst_4 _inst_5 _inst_6)) (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AlgHom.{u1, u1, u2} T (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) S (CommRing.toCommSemiring.{u1} T _inst_3) (Polynomial.semiring.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Polynomial.algebraOfAlgebra.{u1, u1} T T (CommRing.toCommSemiring.{u1} T _inst_3) (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Algebra.id.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) _inst_6) (fun (_x : AlgHom.{u1, u1, u2} T (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) S (CommRing.toCommSemiring.{u1} T _inst_3) (Polynomial.semiring.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Polynomial.algebraOfAlgebra.{u1, u1} T T (CommRing.toCommSemiring.{u1} T _inst_3) (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Algebra.id.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) _inst_6) => (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) -> S) ([anonymous].{u1, u1, u2} T (Polynomial.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) S (CommRing.toCommSemiring.{u1} T _inst_3) (Polynomial.semiring.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Polynomial.algebraOfAlgebra.{u1, u1} T T (CommRing.toCommSemiring.{u1} T _inst_3) (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (Algebra.id.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) _inst_6) (Polynomial.aeval.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6 a) p) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))))))
but is expected to have type
  forall {T : Type.{u2}} [_inst_3 : CommRing.{u2} T] {p : Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))} {S : Type.{u1}} [_inst_4 : CommRing.{u1} S] [_inst_5 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_6 : Algebra.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))] [_inst_7 : NoZeroSMulDivisors.{u2, u1} T S (CommMonoidWithZero.toZero.{u2} T (CommSemiring.toCommMonoidWithZero.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommMonoidWithZero.toZero.{u1} S (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} S (IsDomain.toCancelCommMonoidWithZero.{u1} S (CommRing.toCommSemiring.{u1} S _inst_4) _inst_5))) (Algebra.toSMul.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6)], (Ne.{succ u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) p (OfNat.ofNat.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) 0 (Zero.toOfNat0.{u2} (Polynomial.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3))) (Polynomial.zero.{u2} T (Ring.toSemiring.{u2} T (CommRing.toRing.{u2} T _inst_3)))))) -> (forall {a : S}, Iff (Membership.mem.{u1, u1} S (Set.{u1} S) (Set.instMembershipSet.{u1} S) a (Polynomial.rootSet.{u2, u1} T _inst_3 p S _inst_4 _inst_5 _inst_6)) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (fun (_x : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) _x) (SMulHomClass.toFunLike.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (SMulZeroClass.toSMul.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddMonoid.toZero.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))))) (DistribSMul.toSMulZeroClass.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))))) (DistribMulAction.toDistribSMul.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))))) (Module.toDistribMulAction.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))) (Algebra.toModule.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))))) (SMulZeroClass.toSMul.{u2, u1} T S (AddMonoid.toZero.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))))) (DistribSMul.toSMulZeroClass.{u2, u1} T S (AddMonoid.toAddZeroClass.{u1} S (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))))) (DistribMulAction.toDistribSMul.{u2, u1} T S (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))))) (Module.toDistribMulAction.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))) (Algebra.toModule.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6))))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))))) (AddCommMonoid.toAddMonoid.{u1} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))))) (Module.toDistribMulAction.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))) (Algebra.toModule.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))) (Module.toDistribMulAction.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))) (Algebra.toModule.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (MonoidWithZero.toMonoid.{u2} T (Semiring.toMonoidWithZero.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)))) (Module.toDistribMulAction.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)))))) (Algebra.toModule.{u2, u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))))) (Module.toDistribMulAction.{u2, u1} T S (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4))))) (Algebra.toModule.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, u2, u1, max u1 u2} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6 (AlgHom.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6) (AlgHom.algHomClass.{u2, u2, u1} T (Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) S (CommRing.toCommSemiring.{u2} T _inst_3) (Polynomial.semiring.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) (Polynomial.algebraOfAlgebra.{u2, u2} T T (CommRing.toCommSemiring.{u2} T _inst_3) (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3)) (Algebra.id.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) _inst_6))))) (Polynomial.aeval.{u2, u1} T S (CommRing.toCommSemiring.{u2} T _inst_3) (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_4)) _inst_6 a) p) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (CommMonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (IsDomain.toCancelCommMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) (CommRing.toCommSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u2} T (CommSemiring.toSemiring.{u2} T (CommRing.toCommSemiring.{u2} T _inst_3))) => S) p) _inst_4) _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_root_set_of_ne Polynomial.mem_rootSet_of_neₓ'. -/
theorem mem_rootSet_of_ne {p : T[X]} {S : Type _} [CommRing S] [IsDomain S] [Algebra T S]
    [NoZeroSMulDivisors T S] (hp : p ≠ 0) {a : S} : a ∈ p.rootSet S ↔ aeval a p = 0 :=
  mem_rootSet.trans <| and_iff_right hp
#align polynomial.mem_root_set_of_ne Polynomial.mem_rootSet_of_ne

/- warning: polynomial.root_set_maps_to' -> Polynomial.rootSet_maps_to' is a dubious translation:
lean 3 declaration is
  forall {T : Type.{u1}} [_inst_3 : CommRing.{u1} T] {p : Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))} {S : Type.{u2}} {S' : Type.{u3}} [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_7 : CommRing.{u3} S'] [_inst_8 : IsDomain.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))] [_inst_9 : Algebra.{u1, u3} T S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))], ((Eq.{succ u3} (Polynomial.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))) (Polynomial.map.{u1, u3} T S' (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3)) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) (algebraMap.{u1, u3} T S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_9) p) (OfNat.ofNat.{u3} (Polynomial.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))) 0 (OfNat.mk.{u3} (Polynomial.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))) 0 (Zero.zero.{u3} (Polynomial.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))) (Polynomial.zero.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))))))) -> (Eq.{succ u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) (Polynomial.map.{u1, u2} T S (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (algebraMap.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6) p) (OfNat.ofNat.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) 0 (OfNat.mk.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) 0 (Zero.zero.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) (Polynomial.zero.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))))) -> (forall (f : AlgHom.{u1, u2, u3} T S S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_6 _inst_9), Set.MapsTo.{u2, u3} S S' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AlgHom.{u1, u2, u3} T S S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_6 _inst_9) (fun (_x : AlgHom.{u1, u2, u3} T S S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_6 _inst_9) => S -> S') ([anonymous].{u1, u2, u3} T S S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_6 _inst_9) f) (Polynomial.rootSet.{u1, u2} T _inst_3 p S _inst_4 _inst_5 _inst_6) (Polynomial.rootSet.{u1, u3} T _inst_3 p S' _inst_7 _inst_8 _inst_9))
but is expected to have type
  forall {T : Type.{u3}} [_inst_3 : CommRing.{u3} T] {p : Polynomial.{u3} T (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_3))} {S : Type.{u2}} {S' : Type.{u1}} [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u3, u2} T S (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_7 : CommRing.{u1} S'] [_inst_8 : IsDomain.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))] [_inst_9 : Algebra.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))], ((Eq.{succ u1} (Polynomial.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))) (Polynomial.map.{u3, u1} T S' (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) (algebraMap.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_9) p) (OfNat.ofNat.{u1} (Polynomial.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))) (Polynomial.zero.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)))))) -> (Eq.{succ u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) (Polynomial.map.{u3, u2} T S (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (algebraMap.{u3, u2} T S (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6) p) (OfNat.ofNat.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) 0 (Zero.toOfNat0.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))) (Polynomial.zero.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))))) -> (forall (f : AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9), Set.MapsTo.{u2, u1} S S' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : S) => S') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) T S S' (SMulZeroClass.toSMul.{u3, u2} T S (AddMonoid.toZero.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))))) (DistribSMul.toSMulZeroClass.{u3, u2} T S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))))) (DistribMulAction.toDistribSMul.{u3, u2} T S (MonoidWithZero.toMonoid.{u3} T (Semiring.toMonoidWithZero.{u3} T (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))) (Module.toDistribMulAction.{u3, u2} T S (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))) (Algebra.toModule.{u3, u2} T S (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6))))) (SMulZeroClass.toSMul.{u3, u1} T S' (AddMonoid.toZero.{u1} S' (AddCommMonoid.toAddMonoid.{u1} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))))) (DistribSMul.toSMulZeroClass.{u3, u1} T S' (AddMonoid.toAddZeroClass.{u1} S' (AddCommMonoid.toAddMonoid.{u1} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))))) (DistribMulAction.toDistribSMul.{u3, u1} T S' (MonoidWithZero.toMonoid.{u3} T (Semiring.toMonoidWithZero.{u3} T (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u1} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)))))) (Module.toDistribMulAction.{u3, u1} T S' (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))) (Algebra.toModule.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_9))))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) T S S' (MonoidWithZero.toMonoid.{u3} T (Semiring.toMonoidWithZero.{u3} T (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))) (AddCommMonoid.toAddMonoid.{u1} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)))))) (Module.toDistribMulAction.{u3, u2} T S (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))) (Algebra.toModule.{u3, u2} T S (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6)) (Module.toDistribMulAction.{u3, u1} T S' (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))) (Algebra.toModule.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_9)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) T S S' (MonoidWithZero.toMonoid.{u3} T (Semiring.toMonoidWithZero.{u3} T (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)))) (Module.toDistribMulAction.{u3, u2} T S (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))) (Algebra.toModule.{u3, u2} T S (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6)) (Module.toDistribMulAction.{u3, u1} T S' (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))) (Algebra.toModule.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_9)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u3, u2, u1, max u2 u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9 (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) (AlgHom.algHomClass.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9))))) f) (Polynomial.rootSet.{u3, u2} T _inst_3 p S _inst_4 _inst_5 _inst_6) (Polynomial.rootSet.{u3, u1} T _inst_3 p S' _inst_7 _inst_8 _inst_9))
Case conversion may be inaccurate. Consider using '#align polynomial.root_set_maps_to' Polynomial.rootSet_maps_to'ₓ'. -/
theorem rootSet_maps_to' {p : T[X]} {S S'} [CommRing S] [IsDomain S] [Algebra T S] [CommRing S']
    [IsDomain S'] [Algebra T S'] (hp : p.map (algebraMap T S') = 0 → p.map (algebraMap T S) = 0)
    (f : S →ₐ[T] S') : (p.rootSet S).MapsTo f (p.rootSet S') := fun x hx =>
  by
  rw [mem_root_set'] at hx⊢
  rw [aeval_alg_hom, AlgHom.comp_apply, hx.2, _root_.map_zero]
  exact ⟨mt hp hx.1, rfl⟩
#align polynomial.root_set_maps_to' Polynomial.rootSet_maps_to'

#print Polynomial.ne_zero_of_mem_rootSet /-
theorem ne_zero_of_mem_rootSet {p : T[X]} [CommRing S] [IsDomain S] [Algebra T S] {a : S}
    (h : a ∈ p.rootSet S) : p ≠ 0 := fun hf => by rwa [hf, root_set_zero] at h
#align polynomial.ne_zero_of_mem_root_set Polynomial.ne_zero_of_mem_rootSet
-/

#print Polynomial.aeval_eq_zero_of_mem_rootSet /-
theorem aeval_eq_zero_of_mem_rootSet {p : T[X]} [CommRing S] [IsDomain S] [Algebra T S] {a : S}
    (hx : a ∈ p.rootSet S) : aeval a p = 0 :=
  (mem_rootSet'.1 hx).2
#align polynomial.aeval_eq_zero_of_mem_root_set Polynomial.aeval_eq_zero_of_mem_rootSet
-/

/- warning: polynomial.root_set_maps_to -> Polynomial.rootSet_mapsTo is a dubious translation:
lean 3 declaration is
  forall {T : Type.{u1}} [_inst_3 : CommRing.{u1} T] {p : Polynomial.{u1} T (Ring.toSemiring.{u1} T (CommRing.toRing.{u1} T _inst_3))} {S : Type.{u2}} {S' : Type.{u3}} [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u1, u2} T S (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_7 : CommRing.{u3} S'] [_inst_8 : IsDomain.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))] [_inst_9 : Algebra.{u1, u3} T S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))] [_inst_10 : NoZeroSMulDivisors.{u1, u3} T S' (MulZeroClass.toHasZero.{u1} T (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} T (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} T (NonAssocRing.toNonUnitalNonAssocRing.{u1} T (Ring.toNonAssocRing.{u1} T (CommRing.toRing.{u1} T _inst_3)))))) (MulZeroClass.toHasZero.{u3} S' (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} S' (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S' (NonAssocRing.toNonUnitalNonAssocRing.{u3} S' (Ring.toNonAssocRing.{u3} S' (CommRing.toRing.{u3} S' _inst_7)))))) (SMulZeroClass.toHasSmul.{u1, u3} T S' (AddZeroClass.toHasZero.{u3} S' (AddMonoid.toAddZeroClass.{u3} S' (AddCommMonoid.toAddMonoid.{u3} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' (Semiring.toNonAssocSemiring.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)))))))) (SMulWithZero.toSmulZeroClass.{u1, u3} T S' (MulZeroClass.toHasZero.{u1} T (MulZeroOneClass.toMulZeroClass.{u1} T (MonoidWithZero.toMulZeroOneClass.{u1} T (Semiring.toMonoidWithZero.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)))))) (AddZeroClass.toHasZero.{u3} S' (AddMonoid.toAddZeroClass.{u3} S' (AddCommMonoid.toAddMonoid.{u3} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' (Semiring.toNonAssocSemiring.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)))))))) (MulActionWithZero.toSMulWithZero.{u1, u3} T S' (Semiring.toMonoidWithZero.{u1} T (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3))) (AddZeroClass.toHasZero.{u3} S' (AddMonoid.toAddZeroClass.{u3} S' (AddCommMonoid.toAddMonoid.{u3} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' (Semiring.toNonAssocSemiring.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)))))))) (Module.toMulActionWithZero.{u1, u3} T S' (CommSemiring.toSemiring.{u1} T (CommRing.toCommSemiring.{u1} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S' (Semiring.toNonAssocSemiring.{u3} S' (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7))))) (Algebra.toModule.{u1, u3} T S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_9)))))] (f : AlgHom.{u1, u2, u3} T S S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_6 _inst_9), Set.MapsTo.{u2, u3} S S' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AlgHom.{u1, u2, u3} T S S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_6 _inst_9) (fun (_x : AlgHom.{u1, u2, u3} T S S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_6 _inst_9) => S -> S') ([anonymous].{u1, u2, u3} T S S' (CommRing.toCommSemiring.{u1} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u3} S' (CommRing.toRing.{u3} S' _inst_7)) _inst_6 _inst_9) f) (Polynomial.rootSet.{u1, u2} T _inst_3 p S _inst_4 _inst_5 _inst_6) (Polynomial.rootSet.{u1, u3} T _inst_3 p S' _inst_7 _inst_8 _inst_9)
but is expected to have type
  forall {T : Type.{u3}} [_inst_3 : CommRing.{u3} T] {p : Polynomial.{u3} T (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_3))} {S : Type.{u2}} {S' : Type.{u1}} [_inst_4 : CommRing.{u2} S] [_inst_5 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_6 : Algebra.{u3, u2} T S (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] [_inst_7 : CommRing.{u1} S'] [_inst_8 : IsDomain.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))] [_inst_9 : Algebra.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))] [_inst_10 : NoZeroSMulDivisors.{u3, u1} T S' (CommMonoidWithZero.toZero.{u3} T (CommSemiring.toCommMonoidWithZero.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3))) (CommMonoidWithZero.toZero.{u1} S' (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} S' (IsDomain.toCancelCommMonoidWithZero.{u1} S' (CommRing.toCommSemiring.{u1} S' _inst_7) _inst_8))) (Algebra.toSMul.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_9)] (f : AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9), Set.MapsTo.{u2, u1} S S' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : S) => S') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) T S S' (SMulZeroClass.toSMul.{u3, u2} T S (AddMonoid.toZero.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))))) (DistribSMul.toSMulZeroClass.{u3, u2} T S (AddMonoid.toAddZeroClass.{u2} S (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))))) (DistribMulAction.toDistribSMul.{u3, u2} T S (MonoidWithZero.toMonoid.{u3} T (Semiring.toMonoidWithZero.{u3} T (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))) (Module.toDistribMulAction.{u3, u2} T S (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))) (Algebra.toModule.{u3, u2} T S (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6))))) (SMulZeroClass.toSMul.{u3, u1} T S' (AddMonoid.toZero.{u1} S' (AddCommMonoid.toAddMonoid.{u1} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))))) (DistribSMul.toSMulZeroClass.{u3, u1} T S' (AddMonoid.toAddZeroClass.{u1} S' (AddCommMonoid.toAddMonoid.{u1} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))))) (DistribMulAction.toDistribSMul.{u3, u1} T S' (MonoidWithZero.toMonoid.{u3} T (Semiring.toMonoidWithZero.{u3} T (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u1} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)))))) (Module.toDistribMulAction.{u3, u1} T S' (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))) (Algebra.toModule.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_9))))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) T S S' (MonoidWithZero.toMonoid.{u3} T (Semiring.toMonoidWithZero.{u3} T (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)))) (AddCommMonoid.toAddMonoid.{u2} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))))) (AddCommMonoid.toAddMonoid.{u1} S' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)))))) (Module.toDistribMulAction.{u3, u2} T S (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))) (Algebra.toModule.{u3, u2} T S (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6)) (Module.toDistribMulAction.{u3, u1} T S' (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))) (Algebra.toModule.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_9)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) T S S' (MonoidWithZero.toMonoid.{u3} T (Semiring.toMonoidWithZero.{u3} T (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)))) (Module.toDistribMulAction.{u3, u2} T S (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))))) (Algebra.toModule.{u3, u2} T S (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) _inst_6)) (Module.toDistribMulAction.{u3, u1} T S' (CommSemiring.toSemiring.{u3} T (CommRing.toCommSemiring.{u3} T _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7))))) (Algebra.toModule.{u3, u1} T S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_9)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u3, u2, u1, max u2 u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9 (AlgHom.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9) (AlgHom.algHomClass.{u3, u2, u1} T S S' (CommRing.toCommSemiring.{u3} T _inst_3) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) (Ring.toSemiring.{u1} S' (CommRing.toRing.{u1} S' _inst_7)) _inst_6 _inst_9))))) f) (Polynomial.rootSet.{u3, u2} T _inst_3 p S _inst_4 _inst_5 _inst_6) (Polynomial.rootSet.{u3, u1} T _inst_3 p S' _inst_7 _inst_8 _inst_9)
Case conversion may be inaccurate. Consider using '#align polynomial.root_set_maps_to Polynomial.rootSet_mapsToₓ'. -/
theorem rootSet_mapsTo {p : T[X]} {S S'} [CommRing S] [IsDomain S] [Algebra T S] [CommRing S']
    [IsDomain S'] [Algebra T S'] [NoZeroSMulDivisors T S'] (f : S →ₐ[T] S') :
    (p.rootSet S).MapsTo f (p.rootSet S') :=
  by
  refine' root_set_maps_to' (fun h₀ => _) f
  obtain rfl : p = 0 :=
    map_injective _ (NoZeroSMulDivisors.algebraMap_injective T S') (by rwa [Polynomial.map_zero])
  exact Polynomial.map_zero _
#align polynomial.root_set_maps_to Polynomial.rootSet_mapsTo

end Roots

/- warning: polynomial.coeff_coe_units_zero_ne_zero -> Polynomial.coeff_coe_units_zero_ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (u : Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))), Ne.{succ u1} R (Polynomial.coeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeBase.{succ u1, succ u1} (Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Units.hasCoe.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) u) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (u : Units.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))), Ne.{succ u1} R (Polynomial.coeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Units.val.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) u) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} R (IsDomain.toCancelCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) _inst_2)))))
Case conversion may be inaccurate. Consider using '#align polynomial.coeff_coe_units_zero_ne_zero Polynomial.coeff_coe_units_zero_ne_zeroₓ'. -/
theorem coeff_coe_units_zero_ne_zero (u : R[X]ˣ) : coeff (u : R[X]) 0 ≠ 0 :=
  by
  conv in 0 => rw [← nat_degree_coe_units u]
  rw [← leading_coeff, Ne.def, leading_coeff_eq_zero]
  exact Units.ne_zero _
#align polynomial.coeff_coe_units_zero_ne_zero Polynomial.coeff_coe_units_zero_ne_zero

/- warning: polynomial.degree_eq_degree_of_associated -> Polynomial.degree_eq_degree_of_associated is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Associated.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p q) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Associated.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) p q) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_eq_degree_of_associated Polynomial.degree_eq_degree_of_associatedₓ'. -/
theorem degree_eq_degree_of_associated (h : Associated p q) : degree p = degree q :=
  by
  let ⟨u, hu⟩ := h
  simp [hu.symm]
#align polynomial.degree_eq_degree_of_associated Polynomial.degree_eq_degree_of_associated

/- warning: polynomial.degree_eq_one_of_irreducible_of_root -> Polynomial.degree_eq_one_of_irreducible_of_root is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p) -> (forall {x : R}, (Polynomial.IsRoot.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p x) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) p) -> (forall {x : R}, (Polynomial.IsRoot.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p x) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))))))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_eq_one_of_irreducible_of_root Polynomial.degree_eq_one_of_irreducible_of_rootₓ'. -/
theorem degree_eq_one_of_irreducible_of_root (hi : Irreducible p) {x : R} (hx : IsRoot p x) :
    degree p = 1 :=
  let ⟨g, hg⟩ := dvd_iff_isRoot.2 hx
  have : IsUnit (X - C x) ∨ IsUnit g := hi.isUnit_or_isUnit hg
  this.elim
    (fun h => by
      have h₁ : degree (X - C x) = 1 := degree_X_sub_C x
      have h₂ : degree (X - C x) = 0 := degree_eq_zero_of_isUnit h
      rw [h₁] at h₂ <;> exact absurd h₂ (by decide))
    fun hgu => by rw [hg, degree_mul, degree_X_sub_C, degree_eq_zero_of_is_unit hgu, add_zero]
#align polynomial.degree_eq_one_of_irreducible_of_root Polynomial.degree_eq_one_of_irreducible_of_root

#print Polynomial.leadingCoeff_divByMonic_of_monic /-
/-- Division by a monic polynomial doesn't change the leading coefficient. -/
theorem leadingCoeff_divByMonic_of_monic {R : Type u} [CommRing R] {p q : R[X]} (hmonic : q.Monic)
    (hdegree : q.degree ≤ p.degree) : (p /ₘ q).leadingCoeff = p.leadingCoeff :=
  by
  nontriviality
  have h : q.leading_coeff * (p /ₘ q).leadingCoeff ≠ 0 := by
    simpa [div_by_monic_eq_zero_iff hmonic, hmonic.leading_coeff,
      Nat.WithBot.one_le_iff_zero_lt] using hdegree
  nth_rw_rhs 1 [← mod_by_monic_add_div p hmonic]
  rw [leading_coeff_add_of_degree_lt, leading_coeff_monic_mul hmonic]
  rw [degree_mul' h, degree_add_div_by_monic hmonic hdegree]
  exact (degree_mod_by_monic_lt p hmonic).trans_le hdegree
#align polynomial.leading_coeff_div_by_monic_of_monic Polynomial.leadingCoeff_divByMonic_of_monic
-/

/- warning: polynomial.leading_coeff_div_by_monic_X_sub_C -> Polynomial.leadingCoeff_divByMonic_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero))))) -> (forall (a : R), Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Polynomial.divByMonic.{u1} R (CommRing.toRing.{u1} R _inst_1) p (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))))) -> (forall (a : R), Eq.{succ u1} R (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Polynomial.divByMonic.{u1} R (CommRing.toRing.{u1} R _inst_1) p (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p))
Case conversion may be inaccurate. Consider using '#align polynomial.leading_coeff_div_by_monic_X_sub_C Polynomial.leadingCoeff_divByMonic_X_sub_Cₓ'. -/
theorem leadingCoeff_divByMonic_X_sub_C (p : R[X]) (hp : degree p ≠ 0) (a : R) :
    leadingCoeff (p /ₘ (X - C a)) = leadingCoeff p :=
  by
  nontriviality
  cases' hp.lt_or_lt with hd hd
  · rw [degree_eq_bot.mp <| (Nat.WithBot.lt_zero_iff _).mp hd, zero_div_by_monic]
  refine' leading_coeff_div_by_monic_of_monic (monic_X_sub_C a) _
  rwa [degree_X_sub_C, Nat.WithBot.one_le_iff_zero_lt]
#align polynomial.leading_coeff_div_by_monic_X_sub_C Polynomial.leadingCoeff_divByMonic_X_sub_C

/- warning: polynomial.eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le -> Polynomial.eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) p) -> (Dvd.Dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.commRing.{u1} R _inst_3))))))) p q) -> (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) q) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) p)) -> (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) q (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instHMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) q)) p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : CommRing.{u1} R] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))} {q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) p) -> (Dvd.dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.commRing.{u1} R _inst_3))))))) p q) -> (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) q) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) p)) -> (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) q (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) q)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) q)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) q)) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) q)) p))
Case conversion may be inaccurate. Consider using '#align polynomial.eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le Polynomial.eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_leₓ'. -/
theorem eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le {R} [CommRing R] {p q : R[X]}
    (hp : p.Monic) (hdiv : p ∣ q) (hdeg : q.natDegree ≤ p.natDegree) : q = C q.leadingCoeff * p :=
  by
  obtain ⟨r, hr⟩ := hdiv
  obtain rfl | hq := eq_or_ne q 0; · simp
  have rzero : r ≠ 0 := fun h => by simpa [h, hq] using hr
  rw [hr, nat_degree_mul'] at hdeg; swap
  · rw [hp.leading_coeff, one_mul, leading_coeff_ne_zero]
    exact rzero
  rw [mul_comm, @eq_C_of_nat_degree_eq_zero _ _ r] at hr
  · convert hr
    convert leading_coeff_C _ using 1
    rw [hr, leading_coeff_mul_monic hp]
  · exact (add_right_inj _).1 (le_antisymm hdeg <| Nat.le.intro rfl)
#align polynomial.eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le Polynomial.eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le

#print Polynomial.eq_of_monic_of_dvd_of_natDegree_le /-
theorem eq_of_monic_of_dvd_of_natDegree_le {R} [CommRing R] {p q : R[X]} (hp : p.Monic)
    (hq : q.Monic) (hdiv : p ∣ q) (hdeg : q.natDegree ≤ p.natDegree) : q = p :=
  by
  convert eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le hp hdiv hdeg
  rw [hq.leading_coeff, C_1, one_mul]
#align polynomial.eq_of_monic_of_dvd_of_nat_degree_le Polynomial.eq_of_monic_of_dvd_of_natDegree_le
-/

/- warning: polynomial.is_coprime_X_sub_C_of_is_unit_sub -> Polynomial.isCoprime_X_sub_C_of_isUnit_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : CommRing.{u1} R] {a : R} {b : R}, (IsUnit.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_3)) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))))) a b)) -> (IsCoprime.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) a)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) b)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : CommRing.{u1} R] {a : R} {b : R}, (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R (CommRing.toRing.{u1} R _inst_3))) a b)) -> (IsCoprime.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.commSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) a)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) b) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) b)))
Case conversion may be inaccurate. Consider using '#align polynomial.is_coprime_X_sub_C_of_is_unit_sub Polynomial.isCoprime_X_sub_C_of_isUnit_subₓ'. -/
theorem isCoprime_X_sub_C_of_isUnit_sub {R} [CommRing R] {a b : R} (h : IsUnit (a - b)) :
    IsCoprime (X - C a) (X - C b) :=
  ⟨-C h.Unit⁻¹.val, C h.Unit⁻¹.val,
    by
    rw [neg_mul_comm, ← left_distrib, neg_add_eq_sub, sub_sub_sub_cancel_left, ← C_sub, ← C_mul]
    convert C_1
    exact h.coe_inv_mul⟩
#align polynomial.is_coprime_X_sub_C_of_is_unit_sub Polynomial.isCoprime_X_sub_C_of_isUnit_sub

/- warning: polynomial.pairwise_coprime_X_sub_C -> Polynomial.pairwise_coprime_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} [_inst_3 : Field.{u2} K] {I : Type.{u1}} {s : I -> K}, (Function.Injective.{succ u1, succ u2} I K s) -> (Pairwise.{u1} I (Function.onFun.{succ u1, succ u2, 1} I (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) Prop (IsCoprime.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Polynomial.commSemiring.{u2} K (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_3)))) (fun (i : I) => HSub.hSub.{u2, u2, u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (instHSub.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Polynomial.sub.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Polynomial.X.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))))) (fun (_x : RingHom.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))))) => K -> (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3))))) (RingHom.hasCoeToFun.{u2, u2} K (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Semiring.toNonAssocSemiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (Polynomial.semiring.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))))) (Polynomial.C.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_3)))) (s i)))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_3 : Field.{u1} K] {I : Type.{u2}} {s : I -> K}, (Function.Injective.{succ u2, succ u1} I K s) -> (Pairwise.{u2} I (Function.onFun.{succ u2, succ u1, 1} I (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) Prop (IsCoprime.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.commSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (fun (i : I) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (s i)) (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (instHSub.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.sub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_3)))) (Polynomial.X.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3))))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))))) K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3))))) (RingHom.instRingHomClassRingHom.{u1, u1} K (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3))))))))) (Polynomial.C.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_3)))) (s i)))))
Case conversion may be inaccurate. Consider using '#align polynomial.pairwise_coprime_X_sub_C Polynomial.pairwise_coprime_X_sub_Cₓ'. -/
theorem pairwise_coprime_X_sub_C {K} [Field K] {I : Type v} {s : I → K} (H : Function.Injective s) :
    Pairwise (IsCoprime on fun i : I => X - C (s i)) := fun i j hij =>
  isCoprime_X_sub_C_of_isUnit_sub (sub_ne_zero_of_ne <| H.Ne hij).IsUnit
#align polynomial.pairwise_coprime_X_sub_C Polynomial.pairwise_coprime_X_sub_C

/- warning: polynomial.monic_prod_multiset_X_sub_C -> Polynomial.monic_prod_multiset_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)))
Case conversion may be inaccurate. Consider using '#align polynomial.monic_prod_multiset_X_sub_C Polynomial.monic_prod_multiset_X_sub_Cₓ'. -/
theorem monic_prod_multiset_X_sub_C : Monic (p.roots.map fun a => X - C a).Prod :=
  monic_multiset_prod_of_monic _ _ fun a _ => monic_X_sub_C a
#align polynomial.monic_prod_multiset_X_sub_C Polynomial.monic_prod_multiset_X_sub_C

/- warning: polynomial.prod_multiset_root_eq_finset_root -> Polynomial.prod_multiset_root_eq_finset_root is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) (Finset.prod.{u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.toFinset.{u1} R (fun (a : R) (b : R) => Classical.propDecidable (Eq.{succ u1} R a b)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (fun (a : R) => HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.rootMultiplicity.{u1} R _inst_1 a p)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) (Finset.prod.{u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.toFinset.{u1} R (fun (a : R) (b : R) => Classical.propDecidable (Eq.{succ u1} R a b)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (fun (a : R) => HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.rootMultiplicity.{u1} R _inst_1 a p)))
Case conversion may be inaccurate. Consider using '#align polynomial.prod_multiset_root_eq_finset_root Polynomial.prod_multiset_root_eq_finset_rootₓ'. -/
theorem prod_multiset_root_eq_finset_root :
    (p.roots.map fun a => X - C a).Prod =
      p.roots.toFinset.Prod fun a => (X - C a) ^ rootMultiplicity a p :=
  by simp only [count_roots, Finset.prod_multiset_map_count]
#align polynomial.prod_multiset_root_eq_finset_root Polynomial.prod_multiset_root_eq_finset_root

/- warning: polynomial.prod_multiset_X_sub_C_dvd -> Polynomial.prod_multiset_X_sub_C_dvd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Dvd.Dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) p
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Dvd.dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) p
Case conversion may be inaccurate. Consider using '#align polynomial.prod_multiset_X_sub_C_dvd Polynomial.prod_multiset_X_sub_C_dvdₓ'. -/
/-- The product `∏ (X - a)` for `a` inside the multiset `p.roots` divides `p`. -/
theorem prod_multiset_X_sub_C_dvd (p : R[X]) : (p.roots.map fun a => X - C a).Prod ∣ p :=
  by
  rw [← map_dvd_map _ (IsFractionRing.injective R <| FractionRing R) monic_prod_multiset_X_sub_C]
  rw [prod_multiset_root_eq_finset_root, Polynomial.map_prod]
  refine' Finset.prod_dvd_of_coprime (fun a _ b _ h => _) fun a _ => _
  · simp_rw [Polynomial.map_pow, Polynomial.map_sub, map_C, map_X]
    exact (pairwise_coprime_X_sub_C (IsFractionRing.injective R <| FractionRing R) h).pow
  · exact Polynomial.map_dvd _ (pow_root_multiplicity_dvd p a)
#align polynomial.prod_multiset_X_sub_C_dvd Polynomial.prod_multiset_X_sub_C_dvd

/- warning: multiset.prod_X_sub_C_dvd_iff_le_roots -> Multiset.prod_X_sub_C_dvd_iff_le_roots is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (OfNat.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.zero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) -> (forall (s : Multiset.{u1} R), Iff (Dvd.Dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) s)) p) (LE.le.{u1} (Multiset.{u1} R) (Preorder.toLE.{u1} (Multiset.{u1} R) (PartialOrder.toPreorder.{u1} (Multiset.{u1} R) (Multiset.partialOrder.{u1} R))) s (Polynomial.roots.{u1} R _inst_1 _inst_2 p)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Ne.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) p (OfNat.ofNat.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.zero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) -> (forall (s : Multiset.{u1} R), Iff (Dvd.dvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (semigroupDvd.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1))))))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) s)) p) (LE.le.{u1} (Multiset.{u1} R) (Preorder.toLE.{u1} (Multiset.{u1} R) (PartialOrder.toPreorder.{u1} (Multiset.{u1} R) (Multiset.instPartialOrderMultiset.{u1} R))) s (Polynomial.roots.{u1} R _inst_1 _inst_2 p)))
Case conversion may be inaccurate. Consider using '#align multiset.prod_X_sub_C_dvd_iff_le_roots Multiset.prod_X_sub_C_dvd_iff_le_rootsₓ'. -/
/-- A Galois connection. -/
theorem Multiset.prod_X_sub_C_dvd_iff_le_roots {p : R[X]} (hp : p ≠ 0) (s : Multiset R) :
    (s.map fun a => X - C a).Prod ∣ p ↔ s ≤ p.roots :=
  ⟨fun h =>
    Multiset.le_iff_count.2 fun r =>
      by
      rw [count_roots, le_root_multiplicity_iff hp, ← Multiset.prod_replicate, ←
        Multiset.map_replicate fun a => X - C a, ← Multiset.filter_eq]
      exact (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map <| s.filter_le _).trans h,
    fun h =>
    (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map h).trans p.prod_multiset_X_sub_C_dvd⟩
#align multiset.prod_X_sub_C_dvd_iff_le_roots Multiset.prod_X_sub_C_dvd_iff_le_roots

/- warning: polynomial.exists_prod_multiset_X_sub_C_mul -> Polynomial.exists_prod_multiset_X_sub_C_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Exists.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) => And (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) q) p) (And (Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 q) (OfNat.ofNat.{u1} (Multiset.{u1} R) 0 (OfNat.mk.{u1} (Multiset.{u1} R) 0 (Zero.zero.{u1} (Multiset.{u1} R) (Multiset.hasZero.{u1} R)))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Exists.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (q : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) => And (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) q) p) (And (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (HAdd.hAdd.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (instHAdd.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) instAddNat) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) q)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (Eq.{succ u1} (Multiset.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 q) (OfNat.ofNat.{u1} (Multiset.{u1} R) 0 (Zero.toOfNat0.{u1} (Multiset.{u1} R) (Multiset.instZeroMultiset.{u1} R))))))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_prod_multiset_X_sub_C_mul Polynomial.exists_prod_multiset_X_sub_C_mulₓ'. -/
theorem exists_prod_multiset_X_sub_C_mul (p : R[X]) :
    ∃ q,
      (p.roots.map fun a => X - C a).Prod * q = p ∧
        p.roots.card + q.natDegree = p.natDegree ∧ q.roots = 0 :=
  by
  obtain ⟨q, he⟩ := p.prod_multiset_X_sub_C_dvd
  use q, he.symm
  obtain rfl | hq := eq_or_ne q 0
  · rw [MulZeroClass.mul_zero] at he
    subst he
    simp
  constructor
  · conv_rhs => rw [he]
    rw [monic_prod_multiset_X_sub_C.nat_degree_mul' hq, nat_degree_multiset_prod_X_sub_C_eq_card]
  · replace he := congr_arg roots he.symm
    rw [roots_mul, roots_multiset_prod_X_sub_C] at he
    exacts[add_right_eq_self.1 he, mul_ne_zero monic_prod_multiset_X_sub_C.ne_zero hq]
#align polynomial.exists_prod_multiset_X_sub_C_mul Polynomial.exists_prod_multiset_X_sub_C_mul

/- warning: polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C -> Polynomial.c_leadingCoeff_mul_prod_multiset_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Eq.{1} Nat (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)))) p)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (Multiset.prod.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (CommRing.toCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)))) p)
Case conversion may be inaccurate. Consider using '#align polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C Polynomial.c_leadingCoeff_mul_prod_multiset_X_sub_Cₓ'. -/
/-- A polynomial `p` that has as many roots as its degree
can be written `p = p.leading_coeff * ∏(X - a)`, for `a` in `p.roots`. -/
theorem c_leadingCoeff_mul_prod_multiset_X_sub_C (hroots : p.roots.card = p.natDegree) :
    C p.leadingCoeff * (p.roots.map fun a => X - C a).Prod = p :=
  (eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le monic_prod_multiset_X_sub_C
      p.prod_multiset_X_sub_C_dvd
      ((natDegree_multiset_prod_X_sub_C_eq_card _).trans hroots).ge).symm
#align polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C Polynomial.c_leadingCoeff_mul_prod_multiset_X_sub_C

/- warning: polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq -> Polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (Eq.{1} Nat (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} R) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.orderedCancelAddCommMonoid.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) p)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p) -> (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) (fun (_x : Multiset.{u1} R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} R) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} R) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} R) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} R) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} R) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} R) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} R) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} R) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} R)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} R) (Polynomial.roots.{u1} R _inst_1 _inst_2 p)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) p)) -> (Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Multiset.prod.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CommRing.toCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.commRing.{u1} R _inst_1)) (Multiset.map.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (fun (a : R) => HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a) (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.sub.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) a)) (Polynomial.roots.{u1} R _inst_1 _inst_2 p))) p)
Case conversion may be inaccurate. Consider using '#align polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq Polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eqₓ'. -/
/-- A monic polynomial `p` that has as many roots as its degree
can be written `p = ∏(X - a)`, for `a` in `p.roots`. -/
theorem prod_multiset_X_sub_C_of_monic_of_roots_card_eq (hp : p.Monic)
    (hroots : p.roots.card = p.natDegree) : (p.roots.map fun a => X - C a).Prod = p :=
  by
  convert C_leading_coeff_mul_prod_multiset_X_sub_C hroots
  rw [hp.leading_coeff, C_1, one_mul]
#align polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq Polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq

end CommRing

section

variable {A B : Type _} [CommRing A] [CommRing B]

/- warning: polynomial.le_root_multiplicity_map -> Polynomial.le_rootMultiplicity_map is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommRing.{u1} A] [_inst_2 : CommRing.{u2} B] {p : Polynomial.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))} {f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))}, (Ne.{succ u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p) (OfNat.ofNat.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) 0 (OfNat.mk.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) 0 (Zero.zero.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) (Polynomial.zero.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))))))) -> (forall (a : A), LE.le.{0} Nat Nat.hasLe (Polynomial.rootMultiplicity.{u1} A _inst_1 a p) (Polynomial.rootMultiplicity.{u2} B _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f a) (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p)))
but is expected to have type
  forall {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommRing.{u2} A] [_inst_2 : CommRing.{u1} B] {p : Polynomial.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))} {f : RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p) (OfNat.ofNat.{u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) (Polynomial.zero.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)))))) -> (forall (a : A), LE.le.{0} Nat instLENat (Polynomial.rootMultiplicity.{u2} A _inst_1 a p) (Polynomial.rootMultiplicity.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f a) (Polynomial.map.{u2, u1} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) (CommRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) _inst_2)) f p)))
Case conversion may be inaccurate. Consider using '#align polynomial.le_root_multiplicity_map Polynomial.le_rootMultiplicity_mapₓ'. -/
theorem le_rootMultiplicity_map {p : A[X]} {f : A →+* B} (hmap : map f p ≠ 0) (a : A) :
    rootMultiplicity a p ≤ rootMultiplicity (f a) (p.map f) :=
  by
  rw [le_root_multiplicity_iff hmap]
  refine' trans _ ((map_ring_hom f).map_dvd (pow_root_multiplicity_dvd p a))
  rw [map_pow, map_sub, coe_map_ring_hom, map_X, map_C]
#align polynomial.le_root_multiplicity_map Polynomial.le_rootMultiplicity_map

/- warning: polynomial.eq_root_multiplicity_map -> Polynomial.eq_rootMultiplicity_map is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommRing.{u1} A] [_inst_2 : CommRing.{u2} B] {p : Polynomial.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))} {f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))}, (Function.Injective.{succ u1, succ u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f)) -> (forall (a : A), Eq.{1} Nat (Polynomial.rootMultiplicity.{u1} A _inst_1 a p) (Polynomial.rootMultiplicity.{u2} B _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f a) (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p)))
but is expected to have type
  forall {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommRing.{u2} A] [_inst_2 : CommRing.{u1} B] {p : Polynomial.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))} {f : RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))}, (Function.Injective.{succ u2, succ u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f)) -> (forall (a : A), Eq.{1} Nat (Polynomial.rootMultiplicity.{u2} A _inst_1 a p) (Polynomial.rootMultiplicity.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f a) (Polynomial.map.{u2, u1} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) (CommRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) a) _inst_2)) f p)))
Case conversion may be inaccurate. Consider using '#align polynomial.eq_root_multiplicity_map Polynomial.eq_rootMultiplicity_mapₓ'. -/
theorem eq_rootMultiplicity_map {p : A[X]} {f : A →+* B} (hf : Function.Injective f) (a : A) :
    rootMultiplicity a p = rootMultiplicity (f a) (p.map f) :=
  by
  by_cases hp0 : p = 0; · simp only [hp0, root_multiplicity_zero, Polynomial.map_zero]
  apply le_antisymm (le_root_multiplicity_map ((Polynomial.map_ne_zero_iff hf).mpr hp0) a)
  rw [le_root_multiplicity_iff hp0, ← map_dvd_map f hf ((monic_X_sub_C a).pow _),
    Polynomial.map_pow, Polynomial.map_sub, map_X, map_C]
  apply pow_root_multiplicity_dvd
#align polynomial.eq_root_multiplicity_map Polynomial.eq_rootMultiplicity_map

/- warning: polynomial.count_map_roots -> Polynomial.count_map_roots is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommRing.{u1} A] [_inst_2 : CommRing.{u2} B] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))] {p : Polynomial.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))} {f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))}, (Ne.{succ u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p) (OfNat.ofNat.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) 0 (OfNat.mk.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) 0 (Zero.zero.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) (Polynomial.zero.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))))))) -> (forall (b : B), LE.le.{0} Nat Nat.hasLe (Multiset.count.{u2} B (fun (a : B) (b : B) => Classical.propDecidable (Eq.{succ u2} B a b)) b (Multiset.map.{u1, u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f) (Polynomial.roots.{u1} A _inst_1 _inst_3 p))) (Polynomial.rootMultiplicity.{u2} B _inst_2 b (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p)))
but is expected to have type
  forall {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommRing.{u2} A] [_inst_2 : CommRing.{u1} B] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))] {p : Polynomial.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))} {f : RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p) (OfNat.ofNat.{u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) (Polynomial.zero.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)))))) -> (forall (b : B), LE.le.{0} Nat instLENat (Multiset.count.{u1} B (fun (a : B) (b : B) => Classical.propDecidable (Eq.{succ u1} B a b)) b (Multiset.map.{u2, u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f) (Polynomial.roots.{u2} A _inst_1 _inst_3 p))) (Polynomial.rootMultiplicity.{u1} B _inst_2 b (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p)))
Case conversion may be inaccurate. Consider using '#align polynomial.count_map_roots Polynomial.count_map_rootsₓ'. -/
theorem count_map_roots [IsDomain A] {p : A[X]} {f : A →+* B} (hmap : map f p ≠ 0) (b : B) :
    (p.roots.map f).count b ≤ rootMultiplicity b (p.map f) :=
  by
  rw [le_root_multiplicity_iff hmap, ← Multiset.prod_replicate, ←
    Multiset.map_replicate fun a => X - C a]
  rw [← Multiset.filter_eq]
  refine' (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map <| Multiset.filter_le _ _).trans _
  convert Polynomial.map_dvd _ p.prod_multiset_X_sub_C_dvd
  simp only [Polynomial.map_multiset_prod, Multiset.map_map]
  congr ; ext1
  simp only [Function.comp_apply, Polynomial.map_sub, map_X, map_C]
#align polynomial.count_map_roots Polynomial.count_map_roots

/- warning: polynomial.count_map_roots_of_injective -> Polynomial.count_map_roots_of_injective is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommRing.{u1} A] [_inst_2 : CommRing.{u2} B] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))] (p : Polynomial.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))) {f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))}, (Function.Injective.{succ u1, succ u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f)) -> (forall (b : B), LE.le.{0} Nat Nat.hasLe (Multiset.count.{u2} B (fun (a : B) (b : B) => Classical.propDecidable (Eq.{succ u2} B a b)) b (Multiset.map.{u1, u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f) (Polynomial.roots.{u1} A _inst_1 _inst_3 p))) (Polynomial.rootMultiplicity.{u2} B _inst_2 b (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p)))
but is expected to have type
  forall {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommRing.{u2} A] [_inst_2 : CommRing.{u1} B] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))] (p : Polynomial.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))) {f : RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))}, (Function.Injective.{succ u2, succ u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f)) -> (forall (b : B), LE.le.{0} Nat instLENat (Multiset.count.{u1} B (fun (a : B) (b : B) => Classical.propDecidable (Eq.{succ u1} B a b)) b (Multiset.map.{u2, u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f) (Polynomial.roots.{u2} A _inst_1 _inst_3 p))) (Polynomial.rootMultiplicity.{u1} B _inst_2 b (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p)))
Case conversion may be inaccurate. Consider using '#align polynomial.count_map_roots_of_injective Polynomial.count_map_roots_of_injectiveₓ'. -/
theorem count_map_roots_of_injective [IsDomain A] (p : A[X]) {f : A →+* B}
    (hf : Function.Injective f) (b : B) : (p.roots.map f).count b ≤ rootMultiplicity b (p.map f) :=
  by
  by_cases hp0 : p = 0
  ·
    simp only [hp0, roots_zero, Multiset.map_zero, Multiset.count_zero, Polynomial.map_zero,
      root_multiplicity_zero]
  · exact count_map_roots ((Polynomial.map_ne_zero_iff hf).mpr hp0) b
#align polynomial.count_map_roots_of_injective Polynomial.count_map_roots_of_injective

/- warning: polynomial.map_roots_le -> Polynomial.map_roots_le is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommRing.{u1} A] [_inst_2 : CommRing.{u2} B] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))] [_inst_4 : IsDomain.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] {p : Polynomial.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))} {f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))}, (Ne.{succ u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p) (OfNat.ofNat.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) 0 (OfNat.mk.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) 0 (Zero.zero.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) (Polynomial.zero.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))))))) -> (LE.le.{u2} (Multiset.{u2} B) (Preorder.toLE.{u2} (Multiset.{u2} B) (PartialOrder.toPreorder.{u2} (Multiset.{u2} B) (Multiset.partialOrder.{u2} B))) (Multiset.map.{u1, u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f) (Polynomial.roots.{u1} A _inst_1 _inst_3 p)) (Polynomial.roots.{u2} B _inst_2 _inst_4 (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p)))
but is expected to have type
  forall {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommRing.{u2} A] [_inst_2 : CommRing.{u1} B] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))] [_inst_4 : IsDomain.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))] {p : Polynomial.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))} {f : RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p) (OfNat.ofNat.{u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) (Polynomial.zero.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)))))) -> (LE.le.{u1} (Multiset.{u1} B) (Preorder.toLE.{u1} (Multiset.{u1} B) (PartialOrder.toPreorder.{u1} (Multiset.{u1} B) (Multiset.instPartialOrderMultiset.{u1} B))) (Multiset.map.{u2, u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f) (Polynomial.roots.{u2} A _inst_1 _inst_3 p)) (Polynomial.roots.{u1} B _inst_2 _inst_4 (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p)))
Case conversion may be inaccurate. Consider using '#align polynomial.map_roots_le Polynomial.map_roots_leₓ'. -/
theorem map_roots_le [IsDomain A] [IsDomain B] {p : A[X]} {f : A →+* B} (h : p.map f ≠ 0) :
    p.roots.map f ≤ (p.map f).roots :=
  Multiset.le_iff_count.2 fun b => by
    rw [count_roots]
    apply count_map_roots h
#align polynomial.map_roots_le Polynomial.map_roots_le

/- warning: polynomial.map_roots_le_of_injective -> Polynomial.map_roots_le_of_injective is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommRing.{u1} A] [_inst_2 : CommRing.{u2} B] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))] [_inst_4 : IsDomain.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] (p : Polynomial.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))) {f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))}, (Function.Injective.{succ u1, succ u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f)) -> (LE.le.{u2} (Multiset.{u2} B) (Preorder.toLE.{u2} (Multiset.{u2} B) (PartialOrder.toPreorder.{u2} (Multiset.{u2} B) (Multiset.partialOrder.{u2} B))) (Multiset.map.{u1, u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f) (Polynomial.roots.{u1} A _inst_1 _inst_3 p)) (Polynomial.roots.{u2} B _inst_2 _inst_4 (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p)))
but is expected to have type
  forall {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommRing.{u2} A] [_inst_2 : CommRing.{u1} B] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))] [_inst_4 : IsDomain.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))] (p : Polynomial.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))) {f : RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))}, (Function.Injective.{succ u2, succ u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f)) -> (LE.le.{u1} (Multiset.{u1} B) (Preorder.toLE.{u1} (Multiset.{u1} B) (PartialOrder.toPreorder.{u1} (Multiset.{u1} B) (Multiset.instPartialOrderMultiset.{u1} B))) (Multiset.map.{u2, u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f) (Polynomial.roots.{u2} A _inst_1 _inst_3 p)) (Polynomial.roots.{u1} B _inst_2 _inst_4 (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p)))
Case conversion may be inaccurate. Consider using '#align polynomial.map_roots_le_of_injective Polynomial.map_roots_le_of_injectiveₓ'. -/
theorem map_roots_le_of_injective [IsDomain A] [IsDomain B] (p : A[X]) {f : A →+* B}
    (hf : Function.Injective f) : p.roots.map f ≤ (p.map f).roots :=
  by
  by_cases hp0 : p = 0; · simp only [hp0, roots_zero, Multiset.map_zero, Polynomial.map_zero]
  exact map_roots_le ((Polynomial.map_ne_zero_iff hf).mpr hp0)
#align polynomial.map_roots_le_of_injective Polynomial.map_roots_le_of_injective

/- warning: polynomial.card_roots_le_map -> Polynomial.card_roots_le_map is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommRing.{u1} A] [_inst_2 : CommRing.{u2} B] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))] [_inst_4 : IsDomain.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] {p : Polynomial.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))} {f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))}, (Ne.{succ u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p) (OfNat.ofNat.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) 0 (OfNat.mk.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) 0 (Zero.zero.{u2} (Polynomial.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))) (Polynomial.zero.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))))))) -> (LE.le.{0} Nat Nat.hasLe (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} A) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} A) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} A) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} A) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} A) (Multiset.orderedCancelAddCommMonoid.{u1} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} A) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} A) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} A) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} A) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} A) (Multiset.orderedCancelAddCommMonoid.{u1} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} A) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} A) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} A) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} A) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} A) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} A) (Multiset.orderedCancelAddCommMonoid.{u1} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} A) (Polynomial.roots.{u1} A _inst_1 _inst_3 p)) (coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, 0} (Multiset.{u2} B) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} B) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} B) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} B) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} B) (Multiset.orderedCancelAddCommMonoid.{u2} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u2, 0} (Multiset.{u2} B) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} B) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} B) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} B) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} B) (Multiset.orderedCancelAddCommMonoid.{u2} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u2} B) -> Nat) (AddMonoidHom.hasCoeToFun.{u2, 0} (Multiset.{u2} B) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} B) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} B) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} B) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} B) (Multiset.orderedCancelAddCommMonoid.{u2} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u2} B) (Polynomial.roots.{u2} B _inst_2 _inst_4 (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p))))
but is expected to have type
  forall {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommRing.{u2} A] [_inst_2 : CommRing.{u1} B] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))] [_inst_4 : IsDomain.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))] {p : Polynomial.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))} {f : RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))}, (Ne.{succ u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p) (OfNat.ofNat.{u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))) (Polynomial.zero.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)))))) -> (LE.le.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} A) => Nat) (Polynomial.roots.{u2} A _inst_1 _inst_3 p)) instLENat (FunLike.coe.{succ u2, succ u2, 1} (AddMonoidHom.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} A) (fun (_x : Multiset.{u2} A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} A) => Nat) _x) (AddHomClass.toFunLike.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} A) Nat (AddZeroClass.toAdd.{u2} (Multiset.{u2} A) (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u2} A) (Polynomial.roots.{u2} A _inst_1 _inst_3 p)) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} B) (fun (_x : Multiset.{u1} B) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} B) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} B) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} B) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} B) (Polynomial.roots.{u1} B _inst_2 _inst_4 (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p))))
Case conversion may be inaccurate. Consider using '#align polynomial.card_roots_le_map Polynomial.card_roots_le_mapₓ'. -/
theorem card_roots_le_map [IsDomain A] [IsDomain B] {p : A[X]} {f : A →+* B} (h : p.map f ≠ 0) :
    p.roots.card ≤ (p.map f).roots.card :=
  by
  rw [← p.roots.card_map f]
  exact Multiset.card_le_of_le (map_roots_le h)
#align polynomial.card_roots_le_map Polynomial.card_roots_le_map

/- warning: polynomial.card_roots_le_map_of_injective -> Polynomial.card_roots_le_map_of_injective is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommRing.{u1} A] [_inst_2 : CommRing.{u2} B] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))] [_inst_4 : IsDomain.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] {p : Polynomial.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))} {f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))}, (Function.Injective.{succ u1, succ u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f)) -> (LE.le.{0} Nat Nat.hasLe (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} A) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} A) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} A) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} A) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} A) (Multiset.orderedCancelAddCommMonoid.{u1} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} A) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} A) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} A) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} A) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} A) (Multiset.orderedCancelAddCommMonoid.{u1} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} A) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} A) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} A) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} A) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} A) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} A) (Multiset.orderedCancelAddCommMonoid.{u1} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} A) (Polynomial.roots.{u1} A _inst_1 _inst_3 p)) (coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, 0} (Multiset.{u2} B) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} B) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} B) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} B) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} B) (Multiset.orderedCancelAddCommMonoid.{u2} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u2, 0} (Multiset.{u2} B) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} B) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} B) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} B) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} B) (Multiset.orderedCancelAddCommMonoid.{u2} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u2} B) -> Nat) (AddMonoidHom.hasCoeToFun.{u2, 0} (Multiset.{u2} B) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} B) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} B) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} B) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} B) (Multiset.orderedCancelAddCommMonoid.{u2} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u2} B) (Polynomial.roots.{u2} B _inst_2 _inst_4 (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p))))
but is expected to have type
  forall {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommRing.{u2} A] [_inst_2 : CommRing.{u1} B] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))] [_inst_4 : IsDomain.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))] {p : Polynomial.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))} {f : RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))}, (Function.Injective.{succ u2, succ u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f)) -> (LE.le.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} A) => Nat) (Polynomial.roots.{u2} A _inst_1 _inst_3 p)) instLENat (FunLike.coe.{succ u2, succ u2, 1} (AddMonoidHom.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} A) (fun (_x : Multiset.{u2} A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} A) => Nat) _x) (AddHomClass.toFunLike.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} A) Nat (AddZeroClass.toAdd.{u2} (Multiset.{u2} A) (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u2} A) (Polynomial.roots.{u2} A _inst_1 _inst_3 p)) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} B) (fun (_x : Multiset.{u1} B) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} B) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} B) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} B) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} B) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} B) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} B) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} B) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} B) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} B) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} B)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} B) (Polynomial.roots.{u1} B _inst_2 _inst_4 (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p))))
Case conversion may be inaccurate. Consider using '#align polynomial.card_roots_le_map_of_injective Polynomial.card_roots_le_map_of_injectiveₓ'. -/
theorem card_roots_le_map_of_injective [IsDomain A] [IsDomain B] {p : A[X]} {f : A →+* B}
    (hf : Function.Injective f) : p.roots.card ≤ (p.map f).roots.card :=
  by
  by_cases hp0 : p = 0; · simp only [hp0, roots_zero, Polynomial.map_zero, Multiset.card_zero]
  exact card_roots_le_map ((Polynomial.map_ne_zero_iff hf).mpr hp0)
#align polynomial.card_roots_le_map_of_injective Polynomial.card_roots_le_map_of_injective

/- warning: polynomial.roots_map_of_injective_of_card_eq_nat_degree -> Polynomial.roots_map_of_injective_of_card_eq_natDegree is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommRing.{u1} A] [_inst_2 : CommRing.{u2} B] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))] [_inst_4 : IsDomain.{u2} B (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2))] {p : Polynomial.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1))} {f : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))}, (Function.Injective.{succ u1, succ u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f)) -> (Eq.{1} Nat (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} A) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} A) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} A) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} A) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} A) (Multiset.orderedCancelAddCommMonoid.{u1} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} A) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} A) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} A) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} A) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} A) (Multiset.orderedCancelAddCommMonoid.{u1} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} A) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} A) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} A) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} A) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} A) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} A) (Multiset.orderedCancelAddCommMonoid.{u1} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} A) (Polynomial.roots.{u1} A _inst_1 _inst_3 p)) (Polynomial.natDegree.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) p)) -> (Eq.{succ u2} (Multiset.{u2} B) (Multiset.map.{u1, u2} A B (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) (fun (_x : RingHom.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) => A -> B) (RingHom.hasCoeToFun.{u1, u2} A B (NonAssocRing.toNonAssocSemiring.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} B (Ring.toNonAssocRing.{u2} B (CommRing.toRing.{u2} B _inst_2)))) f) (Polynomial.roots.{u1} A _inst_1 _inst_3 p)) (Polynomial.roots.{u2} B _inst_2 _inst_4 (Polynomial.map.{u1, u2} A B (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_1)) (Ring.toSemiring.{u2} B (CommRing.toRing.{u2} B _inst_2)) f p)))
but is expected to have type
  forall {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommRing.{u2} A] [_inst_2 : CommRing.{u1} B] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))] [_inst_4 : IsDomain.{u1} B (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2))] {p : Polynomial.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1))} {f : RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))}, (Function.Injective.{succ u2, succ u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f)) -> (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} A) => Nat) (Polynomial.roots.{u2} A _inst_1 _inst_3 p)) (FunLike.coe.{succ u2, succ u2, 1} (AddMonoidHom.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} A) (fun (_x : Multiset.{u2} A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} A) => Nat) _x) (AddHomClass.toFunLike.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} A) Nat (AddZeroClass.toAdd.{u2} (Multiset.{u2} A) (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u2, 0} (Multiset.{u2} A) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} A) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} A) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} A) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} A) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} A) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} A)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u2} A) (Polynomial.roots.{u2} A _inst_1 _inst_3 p)) (Polynomial.natDegree.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) p)) -> (Eq.{succ u1} (Multiset.{u1} B) (Multiset.map.{u2, u1} A B (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : A) => B) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2)))) A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))) (RingHom.instRingHomClassRingHom.{u2, u1} A B (NonAssocRing.toNonAssocSemiring.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} B (Ring.toNonAssocRing.{u1} B (CommRing.toRing.{u1} B _inst_2))))))) f) (Polynomial.roots.{u2} A _inst_1 _inst_3 p)) (Polynomial.roots.{u1} B _inst_2 _inst_4 (Polynomial.map.{u2, u1} A B (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_1)) (Ring.toSemiring.{u1} B (CommRing.toRing.{u1} B _inst_2)) f p)))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_map_of_injective_of_card_eq_nat_degree Polynomial.roots_map_of_injective_of_card_eq_natDegreeₓ'. -/
theorem roots_map_of_injective_of_card_eq_natDegree [IsDomain A] [IsDomain B] {p : A[X]}
    {f : A →+* B} (hf : Function.Injective f) (hroots : p.roots.card = p.natDegree) :
    p.roots.map f = (p.map f).roots :=
  by
  apply Multiset.eq_of_le_of_card_le (map_roots_le_of_injective p hf)
  simpa only [Multiset.card_map, hroots] using (card_roots' _).trans (nat_degree_map_le f p)
#align polynomial.roots_map_of_injective_of_card_eq_nat_degree Polynomial.roots_map_of_injective_of_card_eq_natDegree

end

section

variable [Semiring R] [CommRing S] [IsDomain S] (φ : R →+* S)

/- warning: polynomial.is_unit_of_is_unit_leading_coeff_of_is_unit_map -> Polynomial.isUnit_of_isUnit_leadingCoeff_of_isUnit_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_3 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (φ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) {f : Polynomial.{u1} R _inst_1}, (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (Polynomial.leadingCoeff.{u1} R _inst_1 f)) -> (IsUnit.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ring.toMonoid.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Polynomial.ring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Polynomial.map.{u1, u2} R S _inst_1 (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) φ f)) -> (IsUnit.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) f)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_3 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (φ : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) {f : Polynomial.{u1} R _inst_1}, (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (Polynomial.leadingCoeff.{u1} R _inst_1 f)) -> (IsUnit.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (MonoidWithZero.toMonoid.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Semiring.toMonoidWithZero.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Polynomial.semiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Polynomial.map.{u1, u2} R S _inst_1 (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) φ f)) -> (IsUnit.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) f)
Case conversion may be inaccurate. Consider using '#align polynomial.is_unit_of_is_unit_leading_coeff_of_is_unit_map Polynomial.isUnit_of_isUnit_leadingCoeff_of_isUnit_mapₓ'. -/
theorem isUnit_of_isUnit_leadingCoeff_of_isUnit_map {f : R[X]} (hf : IsUnit f.leadingCoeff)
    (H : IsUnit (map φ f)) : IsUnit f :=
  by
  have dz := degree_eq_zero_of_is_unit H
  rw [degree_map_eq_of_leading_coeff_ne_zero] at dz
  · rw [eq_C_of_degree_eq_zero dz]
    refine' IsUnit.map C _
    convert hf
    rw [(degree_eq_iff_nat_degree_eq _).1 dz]
    rintro rfl
    simpa using H
  · intro h
    have u : IsUnit (φ f.leading_coeff) := IsUnit.map φ hf
    rw [h] at u
    simpa using u
#align polynomial.is_unit_of_is_unit_leading_coeff_of_is_unit_map Polynomial.isUnit_of_isUnit_leadingCoeff_of_isUnit_map

end

section

variable [CommRing R] [IsDomain R] [CommRing S] [IsDomain S] (φ : R →+* S)

/- warning: polynomial.monic.irreducible_of_irreducible_map -> Polynomial.Monic.irreducible_of_irreducible_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : CommRing.{u2} S] [_inst_4 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))] (φ : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_3)))) (f : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f) -> (Irreducible.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))) (Ring.toMonoid.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))) (Polynomial.ring.{u2} S (CommRing.toRing.{u2} S _inst_3))) (Polynomial.map.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3)) φ f)) -> (Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.ring.{u1} R (CommRing.toRing.{u1} R _inst_1))) f)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : CommRing.{u2} S] [_inst_4 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))] (φ : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_3)))) (f : Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), (Polynomial.Monic.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) f) -> (Irreducible.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))) (MonoidWithZero.toMonoid.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))) (Semiring.toMonoidWithZero.{u2} (Polynomial.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))) (Polynomial.semiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))))) (Polynomial.map.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3)) φ f)) -> (Irreducible.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) f)
Case conversion may be inaccurate. Consider using '#align polynomial.monic.irreducible_of_irreducible_map Polynomial.Monic.irreducible_of_irreducible_mapₓ'. -/
/-- A polynomial over an integral domain `R` is irreducible if it is monic and
  irreducible after mapping into an integral domain `S`.

A special case of this lemma is that a polynomial over `ℤ` is irreducible if
  it is monic and irreducible over `ℤ/pℤ` for some prime `p`.
-/
theorem Monic.irreducible_of_irreducible_map (f : R[X]) (h_mon : Monic f)
    (h_irr : Irreducible (map φ f)) : Irreducible f :=
  by
  refine' ⟨h_irr.not_unit ∘ IsUnit.map (map_ring_hom φ), fun a b h => _⟩
  dsimp [monic] at h_mon
  have q := (leading_coeff_mul a b).symm
  rw [← h, h_mon] at q
  refine'
        (h_irr.is_unit_or_is_unit <| (congr_arg (map φ) h).trans (Polynomial.map_mul φ)).imp _ _ <;>
      apply is_unit_of_is_unit_leading_coeff_of_is_unit_map <;>
    apply isUnit_of_mul_eq_one
  · exact q;
  · rw [mul_comm]
    exact q
#align polynomial.monic.irreducible_of_irreducible_map Polynomial.Monic.irreducible_of_irreducible_map

end

end Polynomial

