/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen

! This file was ported from Lean 3 source module data.polynomial.degree.card_pow_degree
! leanprover-community/mathlib commit 31ca6f9cf5f90a6206092cd7f84b359dcb6d52e0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.EuclideanAbsoluteValue
import Mathbin.Data.Polynomial.FieldDivision

/-!
# Absolute value on polynomials over a finite field.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Let `Fq` be a finite field of cardinality `q`, then the map sending a polynomial `p`
to `q ^ degree p` (where `q ^ degree 0 = 0`) is an absolute value.

## Main definitions

 * `polynomial.card_pow_degree` is an absolute value on `ùîΩ_q[t]`, the ring of
   polynomials over a finite field of cardinality `q`, mapping a polynomial `p`
   to `q ^ degree p` (where `q ^ degree 0 = 0`)

## Main results
 * `polynomial.card_pow_degree_is_euclidean`: `card_pow_degree` respects the
   Euclidean domain structure on the ring of polynomials

-/


namespace Polynomial

variable {Fq : Type _} [Field Fq] [Fintype Fq]

open AbsoluteValue

open Classical Polynomial

#print Polynomial.cardPowDegree /-
/-- `card_pow_degree` is the absolute value on `ùîΩ_q[t]` sending `f` to `q ^ degree f`.

`card_pow_degree 0` is defined to be `0`. -/
noncomputable def cardPowDegree : AbsoluteValue Fq[X] ‚Ñ§ :=
  have card_pos : 0 < Fintype.card Fq := Fintype.card_pos_iff.mpr inferInstance
  have pow_pos : ‚àÄ n, 0 < (Fintype.card Fq : ‚Ñ§) ^ n := fun n =>
    pow_pos (Int.coe_nat_pos.mpr card_pos) n
  { toFun := fun p => if p = 0 then 0 else Fintype.card Fq ^ p.natDegree
    nonneg' := fun p => by
      dsimp
      split_ifs
      ¬∑ rfl
      exact pow_nonneg (Int.ofNat_zero_le _) _
    eq_zero' := fun p =>
      ite_eq_left_iff.trans <|
        ‚ü®fun h => by
          contrapose! h
          exact ‚ü®h, (pow_pos _).ne'‚ü©, absurd‚ü©
    add_le' := fun p q => by
      by_cases hp : p = 0; ¬∑ simp [hp]
      by_cases hq : q = 0; ¬∑ simp [hq]
      by_cases hpq : p + q = 0
      ¬∑ simp only [hpq, hp, hq, eq_self_iff_true, if_true, if_false]
        exact add_nonneg (pow_pos _).le (pow_pos _).le
      simp only [hpq, hp, hq, if_false]
      refine' le_trans (pow_le_pow (by linarith) (Polynomial.natDegree_add_le _ _)) _
      refine'
        le_trans (le_max_iff.mpr _)
          (max_le_add_of_nonneg (pow_nonneg (by linarith) _) (pow_nonneg (by linarith) _))
      exact (max_choice p.nat_degree q.nat_degree).imp (fun h => by rw [h]) fun h => by rw [h]
    map_mul' := fun p q => by
      by_cases hp : p = 0; ¬∑ simp [hp]
      by_cases hq : q = 0; ¬∑ simp [hq]
      have hpq : p * q ‚â† 0 := mul_ne_zero hp hq
      simp only [hpq, hp, hq, eq_self_iff_true, if_true, if_false, Polynomial.natDegree_mul hp hq,
        pow_add] }
#align polynomial.card_pow_degree Polynomial.cardPowDegree
-/

/- warning: polynomial.card_pow_degree_apply -> Polynomial.cardPowDegree_apply is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Field.{u1} Fq] [_inst_2 : Fintype.{u1} Fq] (p : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))), Eq.{1} Int (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_1 _inst_2) p) (ite.{1} Int (Eq.{succ u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) p (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))))))) (Classical.propDecidable (Eq.{succ u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) p (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1))))))))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTC‚Çì.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (Fintype.card.{u1} Fq _inst_2)) (Polynomial.natDegree.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1))) p)))
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Field.{u1} Fq] [_inst_2 : Fintype.{u1} Fq] (p : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))), Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => Int) p) (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_1 _inst_2) p) (ite.{1} Int (Eq.{succ u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) p (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1))))))) (Classical.propDecidable (Eq.{succ u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) p (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))))))) (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) (HPow.hPow.{0, 0, 0} Int Nat Int Int.instHPowIntNat (Nat.cast.{0} Int instNatCastInt (Fintype.card.{u1} Fq _inst_2)) (Polynomial.natDegree.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1))) p)))
Case conversion may be inaccurate. Consider using '#align polynomial.card_pow_degree_apply Polynomial.cardPowDegree_apply‚Çì'. -/
theorem cardPowDegree_apply (p : Fq[X]) :
    cardPowDegree p = if p = 0 then 0 else Fintype.card Fq ^ natDegree p :=
  rfl
#align polynomial.card_pow_degree_apply Polynomial.cardPowDegree_apply

/- warning: polynomial.card_pow_degree_zero -> Polynomial.cardPowDegree_zero is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Field.{u1} Fq] [_inst_2 : Fintype.{u1} Fq], Eq.{1} Int (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_1 _inst_2) (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))))))) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero)))
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Field.{u1} Fq] [_inst_2 : Fintype.{u1} Fq], Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => Int) (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1))))))) (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_1 _inst_2) (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1))))))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => Int) (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1))))))) 0 (instOfNatInt 0))
Case conversion may be inaccurate. Consider using '#align polynomial.card_pow_degree_zero Polynomial.cardPowDegree_zero‚Çì'. -/
@[simp]
theorem cardPowDegree_zero : cardPowDegree (0 : Fq[X]) = 0 :=
  if_pos rfl
#align polynomial.card_pow_degree_zero Polynomial.cardPowDegree_zero

/- warning: polynomial.card_pow_degree_nonzero -> Polynomial.cardPowDegree_nonzero is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Field.{u1} Fq] [_inst_2 : Fintype.{u1} Fq] (p : Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))), (Ne.{succ u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) p (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))))))) -> (Eq.{1} Int (coeFn.{succ u1, succ u1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (fun (f : AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) => (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) -> Int) (AbsoluteValue.hasCoeToFun.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (Polynomial.cardPowDegree.{u1} Fq _inst_1 _inst_2) p) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTC‚Çì.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (Fintype.card.{u1} Fq _inst_2)) (Polynomial.natDegree.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1))) p)))
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Field.{u1} Fq] [_inst_2 : Fintype.{u1} Fq] (p : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))), (Ne.{succ u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) p (OfNat.ofNat.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Polynomial.zero.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1))))))) -> (Eq.{1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => Int) p) (FunLike.coe.{succ u1, succ u1, 1} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (fun (f : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.99 : Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) => Int) f) (SubadditiveHomClass.toFunLike.{u1, u1, 0} (AbsoluteValue.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))) (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Distrib.toAdd.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))))))) (Distrib.toAdd.{0} Int (NonUnitalNonAssocSemiring.toDistrib.{0} Int (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Int (Semiring.toNonAssocSemiring.{0} Int (OrderedSemiring.toSemiring.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))))) (Preorder.toLE.{0} Int (PartialOrder.toPreorder.{0} Int (OrderedSemiring.toPartialOrder.{0} Int (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing))))))) (AbsoluteValue.subadditiveHomClass.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.semiring.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))))) (Polynomial.cardPowDegree.{u1} Fq _inst_1 _inst_2) p) (HPow.hPow.{0, 0, 0} Int Nat Int Int.instHPowIntNat (Nat.cast.{0} Int instNatCastInt (Fintype.card.{u1} Fq _inst_2)) (Polynomial.natDegree.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1))) p)))
Case conversion may be inaccurate. Consider using '#align polynomial.card_pow_degree_nonzero Polynomial.cardPowDegree_nonzero‚Çì'. -/
@[simp]
theorem cardPowDegree_nonzero (p : Fq[X]) (hp : p ‚â† 0) :
    cardPowDegree p = Fintype.card Fq ^ p.natDegree :=
  if_neg hp
#align polynomial.card_pow_degree_nonzero Polynomial.cardPowDegree_nonzero

/- warning: polynomial.card_pow_degree_is_euclidean -> Polynomial.cardPowDegree_isEuclidean is a dubious translation:
lean 3 declaration is
  forall {Fq : Type.{u1}} [_inst_1 : Field.{u1} Fq] [_inst_2 : Fintype.{u1} Fq], AbsoluteValue.IsEuclidean.{u1, 0} (Polynomial.{u1} Fq (Ring.toSemiring.{u1} Fq (DivisionRing.toRing.{u1} Fq (Field.toDivisionRing.{u1} Fq _inst_1)))) Int (Polynomial.euclideanDomain.{u1} Fq _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{0} Int (StrictOrderedRing.toStrictOrderedSemiring.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) (Polynomial.cardPowDegree.{u1} Fq _inst_1 _inst_2)
but is expected to have type
  forall {Fq : Type.{u1}} [_inst_1 : Field.{u1} Fq] [_inst_2 : Fintype.{u1} Fq], AbsoluteValue.IsEuclidean.{u1, 0} (Polynomial.{u1} Fq (DivisionSemiring.toSemiring.{u1} Fq (Semifield.toDivisionSemiring.{u1} Fq (Field.toSemifield.{u1} Fq _inst_1)))) Int (Polynomial.instEuclideanDomainPolynomialToSemiringToDivisionSemiringToSemifield.{u1} Fq _inst_1) (OrderedCommSemiring.toOrderedSemiring.{0} Int (StrictOrderedCommSemiring.toOrderedCommSemiring.{0} Int (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{0} Int (LinearOrderedCommRing.toLinearOrderedCommSemiring.{0} Int Int.linearOrderedCommRing)))) (Polynomial.cardPowDegree.{u1} Fq _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align polynomial.card_pow_degree_is_euclidean Polynomial.cardPowDegree_isEuclidean‚Çì'. -/
theorem cardPowDegree_isEuclidean : IsEuclidean (cardPowDegree : AbsoluteValue Fq[X] ‚Ñ§) :=
  have card_pos : 0 < Fintype.card Fq := Fintype.card_pos_iff.mpr inferInstance
  have pow_pos : ‚àÄ n, 0 < (Fintype.card Fq : ‚Ñ§) ^ n := fun n =>
    pow_pos (Int.coe_nat_pos.mpr card_pos) n
  {
    map_lt_map_iff' := fun p q =>
      by
      simp only [EuclideanDomain.r, card_pow_degree_apply]
      split_ifs with hp hq hq
      ¬∑ simp only [hp, hq, lt_self_iff_false]
      ¬∑
        simp only [hp, hq, degree_zero, Ne.def, bot_lt_iff_ne_bot, degree_eq_bot, pow_pos,
          not_false_iff]
      ¬∑ simp only [hp, hq, degree_zero, not_lt_bot, (pow_pos _).not_lt]
      ¬∑ rw [degree_eq_nat_degree hp, degree_eq_nat_degree hq, WithBot.coe_lt_coe, pow_lt_pow_iff]
        exact_mod_cast @Fintype.one_lt_card Fq _ _ }
#align polynomial.card_pow_degree_is_euclidean Polynomial.cardPowDegree_isEuclidean

end Polynomial

