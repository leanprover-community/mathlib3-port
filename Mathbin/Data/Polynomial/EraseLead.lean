/-
Copyright (c) 2020 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa

! This file was ported from Lean 3 source module data.polynomial.erase_lead
! leanprover-community/mathlib commit 69c6a5a12d8a2b159f20933e60115a4f2de62b58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.BigOperators.Fin
import Mathbin.Data.Polynomial.Degree.Definitions

/-!
# Erase the leading term of a univariate polynomial

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Definition

* `erase_lead f`: the polynomial `f - leading term of f`

`erase_lead` serves as reduction step in an induction, shaving off one monomial from a polynomial.
The definition is set up so that it does not mention subtraction in the definition,
and thus works for polynomials over semirings as well as rings.
-/


noncomputable section

open Classical Polynomial

open Polynomial Finset

namespace Polynomial

variable {R : Type _} [Semiring R] {f : R[X]}

#print Polynomial.eraseLead /-
/-- `erase_lead f` for a polynomial `f` is the polynomial obtained by
subtracting from `f` the leading term of `f`. -/
def eraseLead (f : R[X]) : R[X] :=
  Polynomial.erase f.natDegree f
#align polynomial.erase_lead Polynomial.eraseLead
-/

section EraseLead

/- warning: polynomial.erase_lead_support -> Polynomial.eraseLead_support is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (f : Polynomial.{u1} R _inst_1), Eq.{1} (Finset.{0} Nat) (Polynomial.support.{u1} R _inst_1 (Polynomial.eraseLead.{u1} R _inst_1 f)) (Finset.erase.{0} Nat (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) (Polynomial.support.{u1} R _inst_1 f) (Polynomial.natDegree.{u1} R _inst_1 f))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (f : Polynomial.{u1} R _inst_1), Eq.{1} (Finset.{0} Nat) (Polynomial.support.{u1} R _inst_1 (Polynomial.eraseLead.{u1} R _inst_1 f)) (Finset.erase.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) (Polynomial.support.{u1} R _inst_1 f) (Polynomial.natDegree.{u1} R _inst_1 f))
Case conversion may be inaccurate. Consider using '#align polynomial.erase_lead_support Polynomial.eraseLead_supportₓ'. -/
theorem eraseLead_support (f : R[X]) : f.eraseLead.support = f.support.eraseₓ f.natDegree := by
  simp only [erase_lead, support_erase]
#align polynomial.erase_lead_support Polynomial.eraseLead_support

/- warning: polynomial.erase_lead_coeff -> Polynomial.eraseLead_coeff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1} (i : Nat), Eq.{succ u1} R (Polynomial.coeff.{u1} R _inst_1 (Polynomial.eraseLead.{u1} R _inst_1 f) i) (ite.{succ u1} R (Eq.{1} Nat i (Polynomial.natDegree.{u1} R _inst_1 f)) (Nat.decidableEq i (Polynomial.natDegree.{u1} R _inst_1 f)) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (Polynomial.coeff.{u1} R _inst_1 f i))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1} (i : Nat), Eq.{succ u1} R (Polynomial.coeff.{u1} R _inst_1 (Polynomial.eraseLead.{u1} R _inst_1 f) i) (ite.{succ u1} R (Eq.{1} Nat i (Polynomial.natDegree.{u1} R _inst_1 f)) (instDecidableEqNat i (Polynomial.natDegree.{u1} R _inst_1 f)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (Polynomial.coeff.{u1} R _inst_1 f i))
Case conversion may be inaccurate. Consider using '#align polynomial.erase_lead_coeff Polynomial.eraseLead_coeffₓ'. -/
theorem eraseLead_coeff (i : ℕ) : f.eraseLead.coeff i = if i = f.natDegree then 0 else f.coeff i :=
  by simp only [erase_lead, coeff_erase]
#align polynomial.erase_lead_coeff Polynomial.eraseLead_coeff

/- warning: polynomial.erase_lead_coeff_nat_degree -> Polynomial.eraseLead_coeff_natDegree is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, Eq.{succ u1} R (Polynomial.coeff.{u1} R _inst_1 (Polynomial.eraseLead.{u1} R _inst_1 f) (Polynomial.natDegree.{u1} R _inst_1 f)) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, Eq.{succ u1} R (Polynomial.coeff.{u1} R _inst_1 (Polynomial.eraseLead.{u1} R _inst_1 f) (Polynomial.natDegree.{u1} R _inst_1 f)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align polynomial.erase_lead_coeff_nat_degree Polynomial.eraseLead_coeff_natDegreeₓ'. -/
@[simp]
theorem eraseLead_coeff_natDegree : f.eraseLead.coeff f.natDegree = 0 := by simp [erase_lead_coeff]
#align polynomial.erase_lead_coeff_nat_degree Polynomial.eraseLead_coeff_natDegree

#print Polynomial.eraseLead_coeff_of_ne /-
theorem eraseLead_coeff_of_ne (i : ℕ) (hi : i ≠ f.natDegree) : f.eraseLead.coeff i = f.coeff i := by
  simp [erase_lead_coeff, hi]
#align polynomial.erase_lead_coeff_of_ne Polynomial.eraseLead_coeff_of_ne
-/

#print Polynomial.eraseLead_zero /-
@[simp]
theorem eraseLead_zero : eraseLead (0 : R[X]) = 0 := by simp only [erase_lead, erase_zero]
#align polynomial.erase_lead_zero Polynomial.eraseLead_zero
-/

/- warning: polynomial.erase_lead_add_monomial_nat_degree_leading_coeff -> Polynomial.eraseLead_add_monomial_natDegree_leadingCoeff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (f : Polynomial.{u1} R _inst_1), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (Polynomial.eraseLead.{u1} R _inst_1 f) (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 (Polynomial.natDegree.{u1} R _inst_1 f)) (Polynomial.leadingCoeff.{u1} R _inst_1 f))) f
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (f : Polynomial.{u1} R _inst_1), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => Polynomial.{u1} R _inst_1) (Polynomial.leadingCoeff.{u1} R _inst_1 f)) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (Polynomial.eraseLead.{u1} R _inst_1 f) (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => Polynomial.{u1} R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 (Polynomial.natDegree.{u1} R _inst_1 f)) (Polynomial.leadingCoeff.{u1} R _inst_1 f))) f
Case conversion may be inaccurate. Consider using '#align polynomial.erase_lead_add_monomial_nat_degree_leading_coeff Polynomial.eraseLead_add_monomial_natDegree_leadingCoeffₓ'. -/
@[simp]
theorem eraseLead_add_monomial_natDegree_leadingCoeff (f : R[X]) :
    f.eraseLead + monomial f.natDegree f.leadingCoeff = f :=
  (add_comm _ _).trans (f.monomial_add_erase _)
#align polynomial.erase_lead_add_monomial_nat_degree_leading_coeff Polynomial.eraseLead_add_monomial_natDegree_leadingCoeff

/- warning: polynomial.erase_lead_add_C_mul_X_pow -> Polynomial.eraseLead_add_C_mul_X_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (f : Polynomial.{u1} R _inst_1), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (Polynomial.eraseLead.{u1} R _inst_1 f) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) (Polynomial.leadingCoeff.{u1} R _inst_1 f)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (Polynomial.natDegree.{u1} R _inst_1 f)))) f
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (f : Polynomial.{u1} R _inst_1), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Polynomial.leadingCoeff.{u1} R _inst_1 f)) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (Polynomial.eraseLead.{u1} R _inst_1 f) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Polynomial.leadingCoeff.{u1} R _inst_1 f)) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Polynomial.leadingCoeff.{u1} R _inst_1 f)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (Polynomial.leadingCoeff.{u1} R _inst_1 f)) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) (Polynomial.leadingCoeff.{u1} R _inst_1 f)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (Polynomial.natDegree.{u1} R _inst_1 f)))) f
Case conversion may be inaccurate. Consider using '#align polynomial.erase_lead_add_C_mul_X_pow Polynomial.eraseLead_add_C_mul_X_powₓ'. -/
@[simp]
theorem eraseLead_add_C_mul_X_pow (f : R[X]) :
    f.eraseLead + C f.leadingCoeff * X ^ f.natDegree = f := by
  rw [C_mul_X_pow_eq_monomial, erase_lead_add_monomial_nat_degree_leading_coeff]
#align polynomial.erase_lead_add_C_mul_X_pow Polynomial.eraseLead_add_C_mul_X_pow

/- warning: polynomial.self_sub_monomial_nat_degree_leading_coeff -> Polynomial.self_sub_monomial_natDegree_leadingCoeff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_2 : Ring.{u1} R] (f : Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)), Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.sub.{u1} R _inst_2)) f (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (Ring.toSemiring.{u1} R _inst_2) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R _inst_2) R (Ring.toSemiring.{u1} R _inst_2) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (fun (_x : LinearMap.{u1, u1, u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (Ring.toSemiring.{u1} R _inst_2) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R _inst_2) R (Ring.toSemiring.{u1} R _inst_2) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} R R R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Ring.toSemiring.{u1} R _inst_2) (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R _inst_2) R (Ring.toSemiring.{u1} R _inst_2) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Polynomial.monomial.{u1} R (Ring.toSemiring.{u1} R _inst_2) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_2) f))) (Polynomial.eraseLead.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)
but is expected to have type
  forall {R : Type.{u1}} [_inst_2 : Ring.{u1} R] (f : Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)), Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.sub.{u1} R _inst_2)) f (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R (Ring.toSemiring.{u1} R _inst_2) (Ring.toSemiring.{u1} R _inst_2) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R _inst_2) R (Ring.toSemiring.{u1} R _inst_2) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} R R R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Ring.toSemiring.{u1} R _inst_2) (Ring.toSemiring.{u1} R _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.module.{u1, u1} R (Ring.toSemiring.{u1} R _inst_2) R (Ring.toSemiring.{u1} R _inst_2) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Polynomial.monomial.{u1} R (Ring.toSemiring.{u1} R _inst_2) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_2) f))) (Polynomial.eraseLead.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)
Case conversion may be inaccurate. Consider using '#align polynomial.self_sub_monomial_nat_degree_leading_coeff Polynomial.self_sub_monomial_natDegree_leadingCoeffₓ'. -/
@[simp]
theorem self_sub_monomial_natDegree_leadingCoeff {R : Type _} [Ring R] (f : R[X]) :
    f - monomial f.natDegree f.leadingCoeff = f.eraseLead :=
  (eq_sub_iff_add_eq.mpr (eraseLead_add_monomial_natDegree_leadingCoeff f)).symm
#align polynomial.self_sub_monomial_nat_degree_leading_coeff Polynomial.self_sub_monomial_natDegree_leadingCoeff

/- warning: polynomial.self_sub_C_mul_X_pow -> Polynomial.self_sub_C_mul_X_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_2 : Ring.{u1} R] (f : Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)), Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.sub.{u1} R _inst_2)) f (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (instHMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) => R -> (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Ring.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.ring.{u1} R _inst_2)))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)))) (Polynomial.eraseLead.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)
but is expected to have type
  forall {R : Type.{u1}} [_inst_2 : Ring.{u1} R] (f : Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)), Eq.{succ u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (instHSub.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.sub.{u1} R _inst_2)) f (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)) (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)) (Polynomial.mul'.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))) R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2))))))) (Polynomial.C.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.leadingCoeff.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) Nat (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (instHPow.{u1, 0} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.semiring.{u1} R (Ring.toSemiring.{u1} R _inst_2)))))) (Polynomial.X.{u1} R (Ring.toSemiring.{u1} R _inst_2)) (Polynomial.natDegree.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)))) (Polynomial.eraseLead.{u1} R (Ring.toSemiring.{u1} R _inst_2) f)
Case conversion may be inaccurate. Consider using '#align polynomial.self_sub_C_mul_X_pow Polynomial.self_sub_C_mul_X_powₓ'. -/
@[simp]
theorem self_sub_C_mul_X_pow {R : Type _} [Ring R] (f : R[X]) :
    f - C f.leadingCoeff * X ^ f.natDegree = f.eraseLead := by
  rw [C_mul_X_pow_eq_monomial, self_sub_monomial_nat_degree_leading_coeff]
#align polynomial.self_sub_C_mul_X_pow Polynomial.self_sub_C_mul_X_pow

#print Polynomial.eraseLead_ne_zero /-
theorem eraseLead_ne_zero (f0 : 2 ≤ f.support.card) : eraseLead f ≠ 0 :=
  by
  rw [Ne, ← card_support_eq_zero, erase_lead_support]
  exact
    (zero_lt_one.trans_le <| (tsub_le_tsub_right f0 1).trans Finset.pred_card_le_card_erase).Ne.symm
#align polynomial.erase_lead_ne_zero Polynomial.eraseLead_ne_zero
-/

#print Polynomial.lt_natDegree_of_mem_eraseLead_support /-
theorem lt_natDegree_of_mem_eraseLead_support {a : ℕ} (h : a ∈ (eraseLead f).support) :
    a < f.natDegree := by
  rw [erase_lead_support, mem_erase] at h
  exact (le_nat_degree_of_mem_supp a h.2).lt_of_ne h.1
#align polynomial.lt_nat_degree_of_mem_erase_lead_support Polynomial.lt_natDegree_of_mem_eraseLead_support
-/

#print Polynomial.ne_natDegree_of_mem_eraseLead_support /-
theorem ne_natDegree_of_mem_eraseLead_support {a : ℕ} (h : a ∈ (eraseLead f).support) :
    a ≠ f.natDegree :=
  (lt_natDegree_of_mem_eraseLead_support h).Ne
#align polynomial.ne_nat_degree_of_mem_erase_lead_support Polynomial.ne_natDegree_of_mem_eraseLead_support
-/

#print Polynomial.natDegree_not_mem_eraseLead_support /-
theorem natDegree_not_mem_eraseLead_support : f.natDegree ∉ (eraseLead f).support := fun h =>
  ne_natDegree_of_mem_eraseLead_support h rfl
#align polynomial.nat_degree_not_mem_erase_lead_support Polynomial.natDegree_not_mem_eraseLead_support
-/

#print Polynomial.eraseLead_support_card_lt /-
theorem eraseLead_support_card_lt (h : f ≠ 0) : (eraseLead f).support.card < f.support.card :=
  by
  rw [erase_lead_support]
  exact card_lt_card (erase_ssubset <| nat_degree_mem_support_of_nonzero h)
#align polynomial.erase_lead_support_card_lt Polynomial.eraseLead_support_card_lt
-/

#print Polynomial.eraseLead_card_support /-
theorem eraseLead_card_support {c : ℕ} (fc : f.support.card = c) :
    f.eraseLead.support.card = c - 1 := by
  by_cases f0 : f = 0
  · rw [← fc, f0, erase_lead_zero, support_zero, card_empty]
  · rw [erase_lead_support, card_erase_of_mem (nat_degree_mem_support_of_nonzero f0), fc]
#align polynomial.erase_lead_card_support Polynomial.eraseLead_card_support
-/

#print Polynomial.eraseLead_card_support' /-
theorem eraseLead_card_support' {c : ℕ} (fc : f.support.card = c + 1) :
    f.eraseLead.support.card = c :=
  eraseLead_card_support fc
#align polynomial.erase_lead_card_support' Polynomial.eraseLead_card_support'
-/

/- warning: polynomial.erase_lead_monomial -> Polynomial.eraseLead_monomial is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (i : Nat) (r : R), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Polynomial.eraseLead.{u1} R _inst_1 (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 i) r)) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (i : Nat) (r : R), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Polynomial.eraseLead.{u1} R _inst_1 (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => Polynomial.{u1} R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 i) r)) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align polynomial.erase_lead_monomial Polynomial.eraseLead_monomialₓ'. -/
@[simp]
theorem eraseLead_monomial (i : ℕ) (r : R) : eraseLead (monomial i r) = 0 :=
  by
  by_cases hr : r = 0
  · subst r
    simp only [monomial_zero_right, erase_lead_zero]
  · rw [erase_lead, nat_degree_monomial, if_neg hr, erase_monomial]
#align polynomial.erase_lead_monomial Polynomial.eraseLead_monomial

/- warning: polynomial.erase_lead_C -> Polynomial.eraseLead_C is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (r : R), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Polynomial.eraseLead.{u1} R _inst_1 (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) r)) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (r : R), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Polynomial.eraseLead.{u1} R _inst_1 (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) r)) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align polynomial.erase_lead_C Polynomial.eraseLead_Cₓ'. -/
@[simp]
theorem eraseLead_C (r : R) : eraseLead (C r) = 0 :=
  eraseLead_monomial _ _
#align polynomial.erase_lead_C Polynomial.eraseLead_C

#print Polynomial.eraseLead_X /-
@[simp]
theorem eraseLead_X : eraseLead (X : R[X]) = 0 :=
  eraseLead_monomial _ _
#align polynomial.erase_lead_X Polynomial.eraseLead_X
-/

#print Polynomial.eraseLead_X_pow /-
@[simp]
theorem eraseLead_X_pow (n : ℕ) : eraseLead (X ^ n : R[X]) = 0 := by
  rw [X_pow_eq_monomial, erase_lead_monomial]
#align polynomial.erase_lead_X_pow Polynomial.eraseLead_X_pow
-/

/- warning: polynomial.erase_lead_C_mul_X_pow -> Polynomial.eraseLead_C_mul_X_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (r : R) (n : Nat), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Polynomial.eraseLead.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) r) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) n))) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (r : R) (n : Nat), Eq.{succ u1} (Polynomial.{u1} R _inst_1) (Polynomial.eraseLead.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) r) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) r) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) r) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) n))) (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align polynomial.erase_lead_C_mul_X_pow Polynomial.eraseLead_C_mul_X_powₓ'. -/
@[simp]
theorem eraseLead_C_mul_X_pow (r : R) (n : ℕ) : eraseLead (C r * X ^ n) = 0 := by
  rw [C_mul_X_pow_eq_monomial, erase_lead_monomial]
#align polynomial.erase_lead_C_mul_X_pow Polynomial.eraseLead_C_mul_X_pow

#print Polynomial.eraseLead_add_of_natDegree_lt_left /-
theorem eraseLead_add_of_natDegree_lt_left {p q : R[X]} (pq : q.natDegree < p.natDegree) :
    (p + q).eraseLead = p.eraseLead + q := by
  ext n
  by_cases nd : n = p.nat_degree
  · rw [nd, erase_lead_coeff, if_pos (nat_degree_add_eq_left_of_nat_degree_lt pq).symm]
    simpa using (coeff_eq_zero_of_nat_degree_lt pq).symm
  · rw [erase_lead_coeff, coeff_add, coeff_add, erase_lead_coeff, if_neg, if_neg nd]
    rintro rfl
    exact nd (nat_degree_add_eq_left_of_nat_degree_lt pq)
#align polynomial.erase_lead_add_of_nat_degree_lt_left Polynomial.eraseLead_add_of_natDegree_lt_left
-/

#print Polynomial.eraseLead_add_of_natDegree_lt_right /-
theorem eraseLead_add_of_natDegree_lt_right {p q : R[X]} (pq : p.natDegree < q.natDegree) :
    (p + q).eraseLead = p + q.eraseLead := by
  ext n
  by_cases nd : n = q.nat_degree
  · rw [nd, erase_lead_coeff, if_pos (nat_degree_add_eq_right_of_nat_degree_lt pq).symm]
    simpa using (coeff_eq_zero_of_nat_degree_lt pq).symm
  · rw [erase_lead_coeff, coeff_add, coeff_add, erase_lead_coeff, if_neg, if_neg nd]
    rintro rfl
    exact nd (nat_degree_add_eq_right_of_nat_degree_lt pq)
#align polynomial.erase_lead_add_of_nat_degree_lt_right Polynomial.eraseLead_add_of_natDegree_lt_right
-/

/- warning: polynomial.erase_lead_degree_le -> Polynomial.eraseLead_degree_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, LE.le.{0} (WithBot.{0} Nat) (Preorder.toHasLe.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} R _inst_1 (Polynomial.eraseLead.{u1} R _inst_1 f)) (Polynomial.degree.{u1} R _inst_1 f)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} R _inst_1 (Polynomial.eraseLead.{u1} R _inst_1 f)) (Polynomial.degree.{u1} R _inst_1 f)
Case conversion may be inaccurate. Consider using '#align polynomial.erase_lead_degree_le Polynomial.eraseLead_degree_leₓ'. -/
theorem eraseLead_degree_le : (eraseLead f).degree ≤ f.degree :=
  f.degree_erase_le _
#align polynomial.erase_lead_degree_le Polynomial.eraseLead_degree_le

#print Polynomial.eraseLead_natDegree_le_aux /-
theorem eraseLead_natDegree_le_aux : (eraseLead f).natDegree ≤ f.natDegree :=
  natDegree_le_natDegree eraseLead_degree_le
#align polynomial.erase_lead_nat_degree_le_aux Polynomial.eraseLead_natDegree_le_aux
-/

#print Polynomial.eraseLead_natDegree_lt /-
theorem eraseLead_natDegree_lt (f0 : 2 ≤ f.support.card) : (eraseLead f).natDegree < f.natDegree :=
  lt_of_le_of_ne eraseLead_natDegree_le_aux <|
    ne_natDegree_of_mem_eraseLead_support <|
      natDegree_mem_support_of_nonzero <| eraseLead_ne_zero f0
#align polynomial.erase_lead_nat_degree_lt Polynomial.eraseLead_natDegree_lt
-/

#print Polynomial.eraseLead_natDegree_lt_or_eraseLead_eq_zero /-
theorem eraseLead_natDegree_lt_or_eraseLead_eq_zero (f : R[X]) :
    (eraseLead f).natDegree < f.natDegree ∨ f.eraseLead = 0 :=
  by
  by_cases h : f.support.card ≤ 1
  · right
    rw [← C_mul_X_pow_eq_self h]
    simp
  · left
    apply erase_lead_nat_degree_lt (lt_of_not_ge h)
#align polynomial.erase_lead_nat_degree_lt_or_erase_lead_eq_zero Polynomial.eraseLead_natDegree_lt_or_eraseLead_eq_zero
-/

#print Polynomial.eraseLead_natDegree_le /-
theorem eraseLead_natDegree_le (f : R[X]) : (eraseLead f).natDegree ≤ f.natDegree - 1 :=
  by
  rcases f.erase_lead_nat_degree_lt_or_erase_lead_eq_zero with (h | h)
  · exact Nat.le_pred_of_lt h
  · simp only [h, nat_degree_zero, zero_le]
#align polynomial.erase_lead_nat_degree_le Polynomial.eraseLead_natDegree_le
-/

end EraseLead

/- warning: polynomial.induction_with_nat_degree_le -> Polynomial.induction_with_natDegree_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (P : (Polynomial.{u1} R _inst_1) -> Prop) (N : Nat), (P (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (OfNat.mk.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.zero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1))))) -> (forall (n : Nat) (r : R), (Ne.{succ u1} R r (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (LE.le.{0} Nat Nat.hasLe n N) -> (P (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) r) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) n)))) -> (forall (f : Polynomial.{u1} R _inst_1) (g : Polynomial.{u1} R _inst_1), (LT.lt.{0} Nat Nat.hasLt (Polynomial.natDegree.{u1} R _inst_1 f) (Polynomial.natDegree.{u1} R _inst_1 g)) -> (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_1 g) N) -> (P f) -> (P g) -> (P (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) f g))) -> (forall (f : Polynomial.{u1} R _inst_1), (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} R _inst_1 f) N) -> (P f))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (P : (Polynomial.{u1} R _inst_1) -> Prop) (N : Nat), (P (OfNat.ofNat.{u1} (Polynomial.{u1} R _inst_1) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.zero.{u1} R _inst_1)))) -> (forall (n : Nat) (r : R), (Ne.{succ u1} R r (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (LE.le.{0} Nat instLENat n N) -> (P (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) r) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) r) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) r) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) n)))) -> (forall (f : Polynomial.{u1} R _inst_1) (g : Polynomial.{u1} R _inst_1), (LT.lt.{0} Nat instLTNat (Polynomial.natDegree.{u1} R _inst_1 f) (Polynomial.natDegree.{u1} R _inst_1 g)) -> (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R _inst_1 g) N) -> (P f) -> (P g) -> (P (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) f g))) -> (forall (f : Polynomial.{u1} R _inst_1), (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u1} R _inst_1 f) N) -> (P f))
Case conversion may be inaccurate. Consider using '#align polynomial.induction_with_nat_degree_le Polynomial.induction_with_natDegree_leₓ'. -/
/-- An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is
required to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove
results where you want to change each term in a polynomial to something else depending on the
`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. -/
theorem induction_with_natDegree_le (P : R[X] → Prop) (N : ℕ) (P_0 : P 0)
    (P_C_mul_pow : ∀ n : ℕ, ∀ r : R, r ≠ 0 → n ≤ N → P (C r * X ^ n))
    (P_C_add : ∀ f g : R[X], f.natDegree < g.natDegree → g.natDegree ≤ N → P f → P g → P (f + g)) :
    ∀ f : R[X], f.natDegree ≤ N → P f := by
  intro f df
  generalize hd : card f.support = c
  revert f
  induction' c with c hc
  · intro f df f0
    convert P_0
    simpa only [support_eq_empty, card_eq_zero] using f0
  · intro f df f0
    rw [← erase_lead_add_C_mul_X_pow f]
    cases c
    · convert P_C_mul_pow f.nat_degree f.leading_coeff _ df
      · convert zero_add _
        rw [← card_support_eq_zero, erase_lead_card_support f0]
      · rw [leading_coeff_ne_zero, Ne.def, ← card_support_eq_zero, f0]
        exact zero_ne_one.symm
    refine' P_C_add f.erase_lead _ _ _ _ _
    · refine' (erase_lead_nat_degree_lt _).trans_le (le_of_eq _)
      · exact (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))).trans f0.ge
      · rw [nat_degree_C_mul_X_pow _ _ (leading_coeff_ne_zero.mpr _)]
        rintro rfl
        simpa using f0
    · exact (nat_degree_C_mul_X_pow_le f.leading_coeff f.nat_degree).trans df
    · exact hc _ (erase_lead_nat_degree_le_aux.trans df) (erase_lead_card_support f0)
    · refine' P_C_mul_pow _ _ _ df
      rw [Ne.def, leading_coeff_eq_zero, ← card_support_eq_zero, f0]
      exact Nat.succ_ne_zero _
#align polynomial.induction_with_nat_degree_le Polynomial.induction_with_natDegree_le

/- warning: polynomial.mono_map_nat_degree_eq -> Polynomial.mono_map_natDegree_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Type.{u2}} {F : Type.{u3}} [_inst_2 : Semiring.{u2} S] [_inst_3 : AddMonoidHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))] {φ : F} {p : Polynomial.{u1} R _inst_1} (k : Nat) (fu : Nat -> Nat), (forall {n : Nat}, (LE.le.{0} Nat Nat.hasLe n k) -> (Eq.{1} Nat (fu n) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))) -> (forall {n : Nat} {m : Nat}, (LE.le.{0} Nat Nat.hasLe k n) -> (LT.lt.{0} Nat Nat.hasLt n m) -> (LT.lt.{0} Nat Nat.hasLt (fu n) (fu m))) -> (forall {f : Polynomial.{u1} R _inst_1}, (LT.lt.{0} Nat Nat.hasLt (Polynomial.natDegree.{u1} R _inst_1 f) k) -> (Eq.{succ u2} (Polynomial.{u2} S _inst_2) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => (Polynomial.{u1} R _inst_1) -> (Polynomial.{u2} S _inst_2)) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => Polynomial.{u2} S _inst_2) (AddHomClass.toFunLike.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toHasAdd.{u2} (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2)))))) _inst_3))) φ f) (OfNat.ofNat.{u2} (Polynomial.{u2} S _inst_2) 0 (OfNat.mk.{u2} (Polynomial.{u2} S _inst_2) 0 (Zero.zero.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.zero.{u2} S _inst_2)))))) -> (forall (n : Nat) (c : R), (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u2} S _inst_2 (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => (Polynomial.{u1} R _inst_1) -> (Polynomial.{u2} S _inst_2)) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => Polynomial.{u2} S _inst_2) (AddHomClass.toFunLike.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toHasAdd.{u2} (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2)))))) _inst_3))) φ (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 n) c))) (fu n))) -> (Eq.{1} Nat (Polynomial.natDegree.{u2} S _inst_2 (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => (Polynomial.{u1} R _inst_1) -> (Polynomial.{u2} S _inst_2)) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => Polynomial.{u2} S _inst_2) (AddHomClass.toFunLike.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toHasAdd.{u2} (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2)))))) _inst_3))) φ p)) (fu (Polynomial.natDegree.{u1} R _inst_1 p)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Type.{u3}} {F : Type.{u2}} [_inst_2 : Semiring.{u3} S] [_inst_3 : AddMonoidHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))] {φ : F} {p : Polynomial.{u1} R _inst_1} (k : Nat) (fu : Nat -> Nat), (forall {n : Nat}, (LE.le.{0} Nat instLENat n k) -> (Eq.{1} Nat (fu n) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) -> (forall {n : Nat} {m : Nat}, (LE.le.{0} Nat instLENat k n) -> (LT.lt.{0} Nat instLTNat n m) -> (LT.lt.{0} Nat instLTNat (fu n) (fu m))) -> (forall {f : Polynomial.{u1} R _inst_1}, (LT.lt.{0} Nat instLTNat (Polynomial.natDegree.{u1} R _inst_1 f) k) -> (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) f) (FunLike.coe.{succ u2, succ u1, succ u3} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) _x) (AddHomClass.toFunLike.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddZeroClass.toAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toAdd.{u3} (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2)))))) _inst_3)) φ f) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) f) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) f) (Polynomial.zero.{u3} S _inst_2))))) -> (forall (n : Nat) (c : R), (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u3} S _inst_2 (FunLike.coe.{succ u2, succ u1, succ u3} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) _x) (AddHomClass.toFunLike.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddZeroClass.toAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toAdd.{u3} (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2)))))) _inst_3)) φ (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => Polynomial.{u1} R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 n) c))) (fu n))) -> (Eq.{1} Nat (Polynomial.natDegree.{u3} S _inst_2 (FunLike.coe.{succ u2, succ u1, succ u3} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) _x) (AddHomClass.toFunLike.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddZeroClass.toAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toAdd.{u3} (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2)))))) _inst_3)) φ p)) (fu (Polynomial.natDegree.{u1} R _inst_1 p)))
Case conversion may be inaccurate. Consider using '#align polynomial.mono_map_nat_degree_eq Polynomial.mono_map_natDegree_eqₓ'. -/
/-- Let `φ : R[x] → S[x]` be an additive map, `k : ℕ` a bound, and `fu : ℕ → ℕ` a
"sufficiently monotone" map.  Assume also that
* `φ` maps to `0` all monomials of degree less than `k`,
* `φ` maps each monomial `m` in `R[x]` to a polynomial `φ m` of degree `fu (deg m)`.
Then, `φ` maps each polynomial `p` in `R[x]` to a polynomial of degree `fu (deg p)`. -/
theorem mono_map_natDegree_eq {S F : Type _} [Semiring S] [AddMonoidHomClass F R[X] S[X]] {φ : F}
    {p : R[X]} (k : ℕ) (fu : ℕ → ℕ) (fu0 : ∀ {n}, n ≤ k → fu n = 0)
    (fc : ∀ {n m}, k ≤ n → n < m → fu n < fu m) (φ_k : ∀ {f : R[X]}, f.natDegree < k → φ f = 0)
    (φ_mon_nat : ∀ n c, c ≠ 0 → (φ (monomial n c)).natDegree = fu n) :
    (φ p).natDegree = fu p.natDegree :=
  by
  refine' induction_with_nat_degree_le (fun p => _ = fu _) p.nat_degree (by simp [fu0]) _ _ _ rfl.le
  · intro n r r0 np
    rw [nat_degree_C_mul_X_pow _ _ r0, C_mul_X_pow_eq_monomial, φ_mon_nat _ _ r0]
  · intro f g fg gp fk gk
    rw [nat_degree_add_eq_right_of_nat_degree_lt fg, _root_.map_add]
    by_cases FG : k ≤ f.nat_degree
    · rw [nat_degree_add_eq_right_of_nat_degree_lt, gk]
      rw [fk, gk]
      exact fc FG fg
    · cases k
      · exact (FG (Nat.zero_le _)).elim
      · rwa [φ_k (not_le.mp FG), zero_add]
#align polynomial.mono_map_nat_degree_eq Polynomial.mono_map_natDegree_eq

/- warning: polynomial.map_nat_degree_eq_sub -> Polynomial.map_natDegree_eq_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Type.{u2}} {F : Type.{u3}} [_inst_2 : Semiring.{u2} S] [_inst_3 : AddMonoidHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))] {φ : F} {p : Polynomial.{u1} R _inst_1} {k : Nat}, (forall (f : Polynomial.{u1} R _inst_1), (LT.lt.{0} Nat Nat.hasLt (Polynomial.natDegree.{u1} R _inst_1 f) k) -> (Eq.{succ u2} (Polynomial.{u2} S _inst_2) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => (Polynomial.{u1} R _inst_1) -> (Polynomial.{u2} S _inst_2)) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => Polynomial.{u2} S _inst_2) (AddHomClass.toFunLike.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toHasAdd.{u2} (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2)))))) _inst_3))) φ f) (OfNat.ofNat.{u2} (Polynomial.{u2} S _inst_2) 0 (OfNat.mk.{u2} (Polynomial.{u2} S _inst_2) 0 (Zero.zero.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.zero.{u2} S _inst_2)))))) -> (forall (n : Nat) (c : R), (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u2} S _inst_2 (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => (Polynomial.{u1} R _inst_1) -> (Polynomial.{u2} S _inst_2)) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => Polynomial.{u2} S _inst_2) (AddHomClass.toFunLike.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toHasAdd.{u2} (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2)))))) _inst_3))) φ (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 n) c))) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) n k))) -> (Eq.{1} Nat (Polynomial.natDegree.{u2} S _inst_2 (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => (Polynomial.{u1} R _inst_1) -> (Polynomial.{u2} S _inst_2)) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => Polynomial.{u2} S _inst_2) (AddHomClass.toFunLike.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toHasAdd.{u2} (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2)))))) _inst_3))) φ p)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Polynomial.natDegree.{u1} R _inst_1 p) k))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Type.{u3}} {F : Type.{u2}} [_inst_2 : Semiring.{u3} S] [_inst_3 : AddMonoidHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))] {φ : F} {p : Polynomial.{u1} R _inst_1} {k : Nat}, (forall (f : Polynomial.{u1} R _inst_1), (LT.lt.{0} Nat instLTNat (Polynomial.natDegree.{u1} R _inst_1 f) k) -> (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) f) (FunLike.coe.{succ u2, succ u1, succ u3} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) _x) (AddHomClass.toFunLike.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddZeroClass.toAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toAdd.{u3} (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2)))))) _inst_3)) φ f) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) f) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) f) (Polynomial.zero.{u3} S _inst_2))))) -> (forall (n : Nat) (c : R), (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u3} S _inst_2 (FunLike.coe.{succ u2, succ u1, succ u3} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) _x) (AddHomClass.toFunLike.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddZeroClass.toAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toAdd.{u3} (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2)))))) _inst_3)) φ (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => Polynomial.{u1} R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 n) c))) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) n k))) -> (Eq.{1} Nat (Polynomial.natDegree.{u3} S _inst_2 (FunLike.coe.{succ u2, succ u1, succ u3} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) _x) (AddHomClass.toFunLike.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddZeroClass.toAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toAdd.{u3} (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2)))))) _inst_3)) φ p)) (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Polynomial.natDegree.{u1} R _inst_1 p) k))
Case conversion may be inaccurate. Consider using '#align polynomial.map_nat_degree_eq_sub Polynomial.map_natDegree_eq_subₓ'. -/
theorem map_natDegree_eq_sub {S F : Type _} [Semiring S] [AddMonoidHomClass F R[X] S[X]] {φ : F}
    {p : R[X]} {k : ℕ} (φ_k : ∀ f : R[X], f.natDegree < k → φ f = 0)
    (φ_mon : ∀ n c, c ≠ 0 → (φ (monomial n c)).natDegree = n - k) :
    (φ p).natDegree = p.natDegree - k :=
  mono_map_natDegree_eq k (fun j => j - k) (by simp) (fun m n h => (tsub_lt_tsub_iff_right h).mpr)
    φ_k φ_mon
#align polynomial.map_nat_degree_eq_sub Polynomial.map_natDegree_eq_sub

/- warning: polynomial.map_nat_degree_eq_nat_degree -> Polynomial.map_natDegree_eq_natDegree is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Type.{u2}} {F : Type.{u3}} [_inst_2 : Semiring.{u2} S] [_inst_3 : AddMonoidHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))] {φ : F} (p : Polynomial.{u1} R _inst_1), (forall (n : Nat) (c : R), (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u2} S _inst_2 (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => (Polynomial.{u1} R _inst_1) -> (Polynomial.{u2} S _inst_2)) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => Polynomial.{u2} S _inst_2) (AddHomClass.toFunLike.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toHasAdd.{u2} (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2)))))) _inst_3))) φ (coeFn.{succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (LinearMap.hasCoeToFun.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 n) c))) n)) -> (Eq.{1} Nat (Polynomial.natDegree.{u2} S _inst_2 (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => (Polynomial.{u1} R _inst_1) -> (Polynomial.{u2} S _inst_2)) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => Polynomial.{u2} S _inst_2) (AddHomClass.toFunLike.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddZeroClass.toHasAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toHasAdd.{u2} (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u3, u1, u2} F (Polynomial.{u1} R _inst_1) (Polynomial.{u2} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u2} (Polynomial.{u2} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u2} (Polynomial.{u2} S _inst_2) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} S _inst_2) (Polynomial.semiring.{u2} S _inst_2)))))) _inst_3))) φ p)) (Polynomial.natDegree.{u1} R _inst_1 p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {S : Type.{u3}} {F : Type.{u2}} [_inst_2 : Semiring.{u3} S] [_inst_3 : AddMonoidHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))] {φ : F} (p : Polynomial.{u1} R _inst_1), (forall (n : Nat) (c : R), (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Polynomial.natDegree.{u3} S _inst_2 (FunLike.coe.{succ u2, succ u1, succ u3} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) _x) (AddHomClass.toFunLike.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddZeroClass.toAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toAdd.{u3} (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2)))))) _inst_3)) φ (FunLike.coe.{succ u1, succ u1, succ u1} (LinearMap.{u1, u1, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => Polynomial.{u1} R _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u1} R R R (Polynomial.{u1} R _inst_1) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Polynomial.module.{u1, u1} R _inst_1 R _inst_1 (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Polynomial.monomial.{u1} R _inst_1 n) c))) n)) -> (Eq.{1} Nat (Polynomial.natDegree.{u3} S _inst_2 (FunLike.coe.{succ u2, succ u1, succ u3} F (Polynomial.{u1} R _inst_1) (fun (_x : Polynomial.{u1} R _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Polynomial.{u1} R _inst_1) => Polynomial.{u3} S _inst_2) _x) (AddHomClass.toFunLike.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddZeroClass.toAdd.{u1} (Polynomial.{u1} R _inst_1) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))))) (AddZeroClass.toAdd.{u3} (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2))))))) (AddMonoidHomClass.toAddHomClass.{u2, u1, u3} F (Polynomial.{u1} R _inst_1) (Polynomial.{u3} S _inst_2) (AddMonoid.toAddZeroClass.{u1} (Polynomial.{u1} R _inst_1) (AddMonoidWithOne.toAddMonoid.{u1} (Polynomial.{u1} R _inst_1) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} (Polynomial.{u3} S _inst_2) (AddMonoidWithOne.toAddMonoid.{u3} (Polynomial.{u3} S _inst_2) (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (NonAssocSemiring.toAddCommMonoidWithOne.{u3} (Polynomial.{u3} S _inst_2) (Semiring.toNonAssocSemiring.{u3} (Polynomial.{u3} S _inst_2) (Polynomial.semiring.{u3} S _inst_2)))))) _inst_3)) φ p)) (Polynomial.natDegree.{u1} R _inst_1 p))
Case conversion may be inaccurate. Consider using '#align polynomial.map_nat_degree_eq_nat_degree Polynomial.map_natDegree_eq_natDegreeₓ'. -/
theorem map_natDegree_eq_natDegree {S F : Type _} [Semiring S] [AddMonoidHomClass F R[X] S[X]]
    {φ : F} (p) (φ_mon_nat : ∀ n c, c ≠ 0 → (φ (monomial n c)).natDegree = n) :
    (φ p).natDegree = p.natDegree :=
  (map_natDegree_eq_sub (fun f h => (Nat.not_lt_zero _ h).elim) (by simpa)).trans
    p.natDegree.sub_zero
#align polynomial.map_nat_degree_eq_nat_degree Polynomial.map_natDegree_eq_natDegree

open BigOperators

/- warning: polynomial.card_support_eq' -> Polynomial.card_support_eq' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {n : Nat} (k : (Fin n) -> Nat) (x : (Fin n) -> R), (Function.Injective.{1, 1} (Fin n) Nat k) -> (forall (i : Fin n), Ne.{succ u1} R (x i) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 (Finset.sum.{u1, 0} (Polynomial.{u1} R _inst_1) (Fin n) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Finset.univ.{0} (Fin n) (Fin.fintype n)) (fun (i : Fin n) => HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) (x i)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (k i)))))) n)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {n : Nat} (k : (Fin n) -> Nat) (x : (Fin n) -> R), (Function.Injective.{1, 1} (Fin n) Nat k) -> (forall (i : Fin n), Ne.{succ u1} R (x i) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) -> (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 (Finset.sum.{u1, 0} (Polynomial.{u1} R _inst_1) (Fin n) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Finset.univ.{0} (Fin n) (Fin.fintype n)) (fun (i : Fin n) => HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (x i)) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (x i)) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) (x i)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (k i)))))) n)
Case conversion may be inaccurate. Consider using '#align polynomial.card_support_eq' Polynomial.card_support_eq'ₓ'. -/
theorem card_support_eq' {n : ℕ} (k : Fin n → ℕ) (x : Fin n → R) (hk : Function.Injective k)
    (hx : ∀ i, x i ≠ 0) : (∑ i, C (x i) * X ^ k i).support.card = n :=
  by
  suffices (∑ i, C (x i) * X ^ k i).support = image k univ by
    rw [this, univ.card_image_of_injective hk, card_fin]
  simp_rw [Finset.ext_iff, mem_support_iff, finset_sum_coeff, coeff_C_mul_X_pow, mem_image,
    mem_univ, exists_true_left]
  refine' fun i => ⟨fun h => _, _⟩
  · obtain ⟨j, hj, h⟩ := exists_ne_zero_of_sum_ne_zero h
    exact ⟨j, (ite_ne_right_iff.mp h).1.symm⟩
  · rintro ⟨j, rfl⟩
    rw [sum_eq_single_of_mem j (mem_univ j), if_pos rfl]
    · exact hx j
    · exact fun m hm hmj => if_neg fun h => hmj.symm (hk h)
#align polynomial.card_support_eq' Polynomial.card_support_eq'

/- warning: polynomial.card_support_eq -> Polynomial.card_support_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1} {n : Nat}, Iff (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 f)) n) (Exists.{1} ((Fin n) -> Nat) (fun (k : (Fin n) -> Nat) => Exists.{succ u1} ((Fin n) -> R) (fun (x : (Fin n) -> R) => Exists.{0} (StrictMono.{0, 0} (Fin n) Nat (PartialOrder.toPreorder.{0} (Fin n) (Fin.partialOrder n)) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) k) (fun (hk : StrictMono.{0, 0} (Fin n) Nat (PartialOrder.toPreorder.{0} (Fin n) (Fin.partialOrder n)) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) k) => Exists.{0} (forall (i : Fin n), Ne.{succ u1} R (x i) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (fun (hx : forall (i : Fin n), Ne.{succ u1} R (x i) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) => Eq.{succ u1} (Polynomial.{u1} R _inst_1) f (Finset.sum.{u1, 0} (Polynomial.{u1} R _inst_1) (Fin n) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Finset.univ.{0} (Fin n) (Fin.fintype n)) (fun (i : Fin n) => HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) (x i)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (k i)))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1} {n : Nat}, Iff (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 f)) n) (Exists.{1} ((Fin n) -> Nat) (fun (k : (Fin n) -> Nat) => Exists.{succ u1} ((Fin n) -> R) (fun (x : (Fin n) -> R) => Exists.{0} (StrictMono.{0, 0} (Fin n) Nat (PartialOrder.toPreorder.{0} (Fin n) (Fin.instPartialOrderFin n)) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) k) (fun (hk : StrictMono.{0, 0} (Fin n) Nat (PartialOrder.toPreorder.{0} (Fin n) (Fin.instPartialOrderFin n)) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) k) => Exists.{0} (forall (i : Fin n), Ne.{succ u1} R (x i) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) (fun (hx : forall (i : Fin n), Ne.{succ u1} R (x i) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) => Eq.{succ u1} (Polynomial.{u1} R _inst_1) f (Finset.sum.{u1, 0} (Polynomial.{u1} R _inst_1) (Fin n) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (Finset.univ.{0} (Fin n) (Fin.fintype n)) (fun (i : Fin n) => HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (x i)) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) (x i)) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) (x i)) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) (k i)))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.card_support_eq Polynomial.card_support_eqₓ'. -/
theorem card_support_eq {n : ℕ} :
    f.support.card = n ↔
      ∃ (k : Fin n → ℕ)(x : Fin n → R)(hk : StrictMono k)(hx : ∀ i, x i ≠ 0),
        f = ∑ i, C (x i) * X ^ k i :=
  by
  refine' ⟨_, fun ⟨k, x, hk, hx, hf⟩ => hf.symm ▸ card_support_eq' k x hk.Injective hx⟩
  induction' n with n hn generalizing f
  · exact fun hf => ⟨0, 0, isEmptyElim, isEmptyElim, card_support_eq_zero.mp hf⟩
  · intro h
    obtain ⟨k, x, hk, hx, hf⟩ := hn (erase_lead_card_support' h)
    have H : ¬∃ k : Fin n, k.cast_succ = Fin.last n :=
      by
      rintro ⟨i, hi⟩
      exact i.cast_succ_lt_last.Ne hi
    refine'
      ⟨Function.extend Fin.castSucc k fun _ => f.nat_degree,
        Function.extend Fin.castSucc x fun _ => f.leading_coeff, _, _, _⟩
    · intro i j hij
      have hi : i ∈ Set.range (Fin.castSucc : Fin n ↪o Fin (n + 1)) :=
        by
        rw [Fin.range_castSucc, Set.mem_def]
        exact lt_of_lt_of_le hij (nat.lt_succ_iff.mp j.2)
      obtain ⟨i, rfl⟩ := hi
      rw [fin.cast_succ.injective.extend_apply]
      by_cases hj : ∃ j₀, Fin.castSucc j₀ = j
      · obtain ⟨j, rfl⟩ := hj
        rwa [fin.cast_succ.injective.extend_apply, hk.lt_iff_lt, ← Fin.castSucc_lt_castSucc_iff]
      · rw [Function.extend_apply' _ _ _ hj]
        apply lt_nat_degree_of_mem_erase_lead_support
        rw [mem_support_iff, hf, finset_sum_coeff]
        rw [sum_eq_single, coeff_C_mul, coeff_X_pow_self, mul_one]
        · exact hx i
        · intro j hj hji
          rw [coeff_C_mul, coeff_X_pow, if_neg (hk.injective.ne hji.symm), MulZeroClass.mul_zero]
        · exact fun hi => (hi (mem_univ i)).elim
    · intro i
      by_cases hi : ∃ i₀, Fin.castSucc i₀ = i
      · obtain ⟨i, rfl⟩ := hi
        rw [fin.cast_succ.injective.extend_apply]
        exact hx i
      · rw [Function.extend_apply' _ _ _ hi, Ne, leading_coeff_eq_zero, ← card_support_eq_zero, h]
        exact n.succ_ne_zero
    · rw [Fin.sum_univ_castSucc]
      simp only [fin.cast_succ.injective.extend_apply]
      rw [← hf, Function.extend_apply', Function.extend_apply', erase_lead_add_C_mul_X_pow]
      all_goals exact H
#align polynomial.card_support_eq Polynomial.card_support_eq

/- warning: polynomial.card_support_eq_one -> Polynomial.card_support_eq_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, Iff (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 f)) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Exists.{1} Nat (fun (k : Nat) => Exists.{succ u1} R (fun (x : R) => Exists.{0} (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (fun (hx : Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) => Eq.{succ u1} (Polynomial.{u1} R _inst_1) f (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) x) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) k))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, Iff (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 f)) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Exists.{1} Nat (fun (k : Nat) => Exists.{succ u1} R (fun (x : R) => Exists.{0} (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) (fun (hx : Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) => Eq.{succ u1} (Polynomial.{u1} R _inst_1) f (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) x) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) k))))))
Case conversion may be inaccurate. Consider using '#align polynomial.card_support_eq_one Polynomial.card_support_eq_oneₓ'. -/
theorem card_support_eq_one : f.support.card = 1 ↔ ∃ (k : ℕ)(x : R)(hx : x ≠ 0), f = C x * X ^ k :=
  by
  refine' ⟨fun h => _, _⟩
  · obtain ⟨k, x, hk, hx, rfl⟩ := card_support_eq.mp h
    exact ⟨k 0, x 0, hx 0, Fin.sum_univ_one _⟩
  · rintro ⟨k, x, hx, rfl⟩
    rw [support_C_mul_X_pow k hx, card_singleton]
#align polynomial.card_support_eq_one Polynomial.card_support_eq_one

/- warning: polynomial.card_support_eq_two -> Polynomial.card_support_eq_two is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, Iff (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 f)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Exists.{1} Nat (fun (k : Nat) => Exists.{1} Nat (fun (m : Nat) => Exists.{0} (LT.lt.{0} Nat Nat.hasLt k m) (fun (hkm : LT.lt.{0} Nat Nat.hasLt k m) => Exists.{succ u1} R (fun (x : R) => Exists.{succ u1} R (fun (y : R) => Exists.{0} (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (fun (hx : Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) => Exists.{0} (Ne.{succ u1} R y (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (fun (hy : Ne.{succ u1} R y (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) => Eq.{succ u1} (Polynomial.{u1} R _inst_1) f (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) x) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) k)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) y) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) m)))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, Iff (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 f)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Exists.{1} Nat (fun (k : Nat) => Exists.{1} Nat (fun (m : Nat) => Exists.{0} (LT.lt.{0} Nat instLTNat k m) (fun (hkm : LT.lt.{0} Nat instLTNat k m) => Exists.{succ u1} R (fun (x : R) => Exists.{succ u1} R (fun (y : R) => Exists.{0} (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) (fun (hx : Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) => Exists.{0} (Ne.{succ u1} R y (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) (fun (hy : Ne.{succ u1} R y (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) => Eq.{succ u1} (Polynomial.{u1} R _inst_1) f (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) y) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) x) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) k)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) y) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) y) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) y) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) y) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) m)))))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.card_support_eq_two Polynomial.card_support_eq_twoₓ'. -/
theorem card_support_eq_two :
    f.support.card = 2 ↔
      ∃ (k m : ℕ)(hkm : k < m)(x y : R)(hx : x ≠ 0)(hy : y ≠ 0), f = C x * X ^ k + C y * X ^ m :=
  by
  refine' ⟨fun h => _, _⟩
  · obtain ⟨k, x, hk, hx, rfl⟩ := card_support_eq.mp h
    refine' ⟨k 0, k 1, hk Nat.zero_lt_one, x 0, x 1, hx 0, hx 1, _⟩
    rw [Fin.sum_univ_castSucc, Fin.sum_univ_one]
    rfl
  · rintro ⟨k, m, hkm, x, y, hx, hy, rfl⟩
    exact card_support_binomial hkm.ne hx hy
#align polynomial.card_support_eq_two Polynomial.card_support_eq_two

/- warning: polynomial.card_support_eq_three -> Polynomial.card_support_eq_three is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, Iff (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 f)) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Exists.{1} Nat (fun (k : Nat) => Exists.{1} Nat (fun (m : Nat) => Exists.{1} Nat (fun (n : Nat) => Exists.{0} (LT.lt.{0} Nat Nat.hasLt k m) (fun (hkm : LT.lt.{0} Nat Nat.hasLt k m) => Exists.{0} (LT.lt.{0} Nat Nat.hasLt m n) (fun (hmn : LT.lt.{0} Nat Nat.hasLt m n) => Exists.{succ u1} R (fun (x : R) => Exists.{succ u1} R (fun (y : R) => Exists.{succ u1} R (fun (z : R) => Exists.{0} (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (fun (hx : Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) => Exists.{0} (Ne.{succ u1} R y (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (fun (hy : Ne.{succ u1} R y (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) => Exists.{0} (Ne.{succ u1} R z (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (fun (hz : Ne.{succ u1} R z (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) => Eq.{succ u1} (Polynomial.{u1} R _inst_1) f (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (HAdd.hAdd.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) x) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) k)) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) y) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) m))) (HMul.hMul.{u1, u1, u1} (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (Polynomial.{u1} R _inst_1) (instHMul.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.mul'.{u1} R _inst_1)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) => R -> (Polynomial.{u1} R _inst_1)) (RingHom.hasCoeToFun.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (Polynomial.C.{u1} R _inst_1) z) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) n)))))))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {f : Polynomial.{u1} R _inst_1}, Iff (Eq.{1} Nat (Finset.card.{0} Nat (Polynomial.support.{u1} R _inst_1 f)) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) (Exists.{1} Nat (fun (k : Nat) => Exists.{1} Nat (fun (m : Nat) => Exists.{1} Nat (fun (n : Nat) => Exists.{0} (LT.lt.{0} Nat instLTNat k m) (fun (hkm : LT.lt.{0} Nat instLTNat k m) => Exists.{0} (LT.lt.{0} Nat instLTNat m n) (fun (hmn : LT.lt.{0} Nat instLTNat m n) => Exists.{succ u1} R (fun (x : R) => Exists.{succ u1} R (fun (y : R) => Exists.{succ u1} R (fun (z : R) => Exists.{0} (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) (fun (hx : Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) => Exists.{0} (Ne.{succ u1} R y (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) (fun (hy : Ne.{succ u1} R y (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) => Exists.{0} (Ne.{succ u1} R z (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) (fun (hz : Ne.{succ u1} R z (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))))) => Eq.{succ u1} (Polynomial.{u1} R _inst_1) f (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) z) (Polynomial.{u1} R _inst_1) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (Polynomial.add'.{u1} R _inst_1)) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) y) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (Polynomial.add'.{u1} R _inst_1)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) x) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) x) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) k)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) y) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) y) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) y) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) y) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) m))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) z) (Polynomial.{u1} R _inst_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) z) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) z) (Polynomial.mul'.{u1} R _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Polynomial.{u1} R _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))) R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R (Polynomial.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1)))))) (Polynomial.C.{u1} R _inst_1) z) (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} R _inst_1) Nat (Polynomial.{u1} R _inst_1) (instHPow.{u1, 0} (Polynomial.{u1} R _inst_1) Nat (Monoid.Pow.{u1} (Polynomial.{u1} R _inst_1) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} R _inst_1) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} R _inst_1) (Polynomial.semiring.{u1} R _inst_1))))) (Polynomial.X.{u1} R _inst_1) n)))))))))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.card_support_eq_three Polynomial.card_support_eq_threeₓ'. -/
theorem card_support_eq_three :
    f.support.card = 3 ↔
      ∃ (k m n : ℕ)(hkm : k < m)(hmn : m < n)(x y z : R)(hx : x ≠ 0)(hy : y ≠ 0)(hz : z ≠ 0),
        f = C x * X ^ k + C y * X ^ m + C z * X ^ n :=
  by
  refine' ⟨fun h => _, _⟩
  · obtain ⟨k, x, hk, hx, rfl⟩ := card_support_eq.mp h
    refine'
      ⟨k 0, k 1, k 2, hk Nat.zero_lt_one, hk (Nat.lt_succ_self 1), x 0, x 1, x 2, hx 0, hx 1, hx 2,
        _⟩
    rw [Fin.sum_univ_castSucc, Fin.sum_univ_castSucc, Fin.sum_univ_one]
    rfl
  · rintro ⟨k, m, n, hkm, hmn, x, y, z, hx, hy, hz, rfl⟩
    exact card_support_trinomial hkm hmn hx hy hz
#align polynomial.card_support_eq_three Polynomial.card_support_eq_three

end Polynomial

