/-
Copyright (c) 2018 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes

! This file was ported from Lean 3 source module data.polynomial.splits
! leanprover-community/mathlib commit 31ca6f9cf5f90a6206092cd7f84b359dcb6d52e0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.List.Prime
import Mathbin.Data.Polynomial.FieldDivision
import Mathbin.Data.Polynomial.Lifts

/-!
# Split polynomials

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

A polynomial `f : K[X]` splits over a field extension `L` of `K` if it is zero or all of its
irreducible factors over `L` have degree `1`.

## Main definitions

* `polynomial.splits i f`: A predicate on a homomorphism `i : K →+* L` from a commutative ring to a
  field and a polynomial `f` saying that `f.map i` is zero or all of its irreducible factors over
  `L` have degree `1`.

## Main statements

* `lift_of_splits`: If `K` and `L` are field extensions of a field `F` and for some finite subset
  `S` of `K`, the minimal polynomial of every `x ∈ K` splits as a polynomial with coefficients in
  `L`, then `algebra.adjoin F S` embeds into `L`.

-/


noncomputable section

open Classical BigOperators Polynomial

universe u v w

variable {F : Type u} {K : Type v} {L : Type w}

namespace Polynomial

open Polynomial

section Splits

section CommRing

variable [CommRing K] [Field L] [Field F]

variable (i : K →+* L)

#print Polynomial.Splits /-
/-- A polynomial `splits` iff it is zero or all of its irreducible factors have `degree` 1. -/
def Splits (f : K[X]) : Prop :=
  f.map i = 0 ∨ ∀ {g : L[X]}, Irreducible g → g ∣ f.map i → degree g = 1
#align polynomial.splits Polynomial.Splits
-/

#print Polynomial.splits_zero /-
@[simp]
theorem splits_zero : Splits i (0 : K[X]) :=
  Or.inl (Polynomial.map_zero i)
#align polynomial.splits_zero Polynomial.splits_zero
-/

/- warning: polynomial.splits_of_map_eq_C -> Polynomial.splits_of_map_eq_C is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))} {a : L}, (Eq.{succ u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i f) (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} L (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (fun (_x : RingHom.{u2, u2} L (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) => L -> (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (RingHom.hasCoeToFun.{u2, u2} L (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (Polynomial.C.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) a)) -> (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))} {a : L}, (Eq.{succ u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.map.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i f) (FunLike.coe.{succ u2, succ u2, succ u2} (RingHom.{u2, u2} L (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) L (fun (_x : L) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : L) => Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) _x) (MulHomClass.toFunLike.{u2, u2, u2} (RingHom.{u2, u2} L (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) L (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) (NonUnitalNonAssocSemiring.toMul.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))))) (NonUnitalRingHomClass.toMulHomClass.{u2, u2, u2} (RingHom.{u2, u2} L (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) L (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) (RingHomClass.toNonUnitalRingHomClass.{u2, u2, u2} (RingHom.{u2, u2} L (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) L (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (RingHom.instRingHomClassRingHom.{u2, u2} L (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))))))) (Polynomial.C.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) a)) -> (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f)
Case conversion may be inaccurate. Consider using '#align polynomial.splits_of_map_eq_C Polynomial.splits_of_map_eq_Cₓ'. -/
theorem splits_of_map_eq_C {f : K[X]} {a : L} (h : f.map i = C a) : Splits i f :=
  if ha : a = 0 then Or.inl (h.trans (ha.symm ▸ C_0))
  else
    Or.inr fun g hg ⟨p, hp⟩ =>
      absurd hg.1 <|
        Classical.not_not.2 <|
          isUnit_iff_degree_eq_zero.2 <| by
            have := congr_arg degree hp
            rw [h, degree_C ha, degree_mul, @eq_comm (WithBot ℕ) 0, Nat.WithBot.add_eq_zero_iff] at
              this
            exact this.1
#align polynomial.splits_of_map_eq_C Polynomial.splits_of_map_eq_C

/- warning: polynomial.splits_C -> Polynomial.splits_C is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (a : K), Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))))) (fun (_x : RingHom.{u1, u1} K (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))))) => K -> (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} K (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))))) (Polynomial.C.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) a)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (a : K), Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : K) => Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))))))) (Polynomial.C.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) a)
Case conversion may be inaccurate. Consider using '#align polynomial.splits_C Polynomial.splits_Cₓ'. -/
@[simp]
theorem splits_C (a : K) : Splits i (C a) :=
  splits_of_map_eq_C i (map_C i)
#align polynomial.splits_C Polynomial.splits_C

#print Polynomial.splits_of_map_degree_eq_one /-
theorem splits_of_map_degree_eq_one {f : K[X]} (hf : degree (f.map i) = 1) : Splits i f :=
  Or.inr fun g hg ⟨p, hp⟩ => by
    have := congr_arg degree hp <;>
          simp [Nat.WithBot.add_eq_one_iff, hf, @eq_comm (WithBot ℕ) 1,
            mt is_unit_iff_degree_eq_zero.2 hg.1] at this <;>
        clear _fun_match <;>
      tauto
#align polynomial.splits_of_map_degree_eq_one Polynomial.splits_of_map_degree_eq_one
-/

/- warning: polynomial.splits_of_degree_le_one -> Polynomial.splits_of_degree_le_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))}, (LE.le.{0} (WithBot.{0} Nat) (Preorder.toHasLe.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) f) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne))))) -> (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))}, (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) f) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring))))) -> (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f)
Case conversion may be inaccurate. Consider using '#align polynomial.splits_of_degree_le_one Polynomial.splits_of_degree_le_oneₓ'. -/
theorem splits_of_degree_le_one {f : K[X]} (hf : degree f ≤ 1) : Splits i f :=
  if hif : degree (f.map i) ≤ 0 then splits_of_map_eq_C i (degree_le_zero_iff.mp hif)
  else by
    push_neg  at hif
    rw [← Order.succ_le_iff, ← WithBot.coe_zero, WithBot.succ_coe, Nat.succ_eq_succ] at hif
    exact splits_of_map_degree_eq_one i (le_antisymm ((degree_map_le i _).trans hf) hif)
#align polynomial.splits_of_degree_le_one Polynomial.splits_of_degree_le_one

#print Polynomial.splits_of_degree_eq_one /-
theorem splits_of_degree_eq_one {f : K[X]} (hf : degree f = 1) : Splits i f :=
  splits_of_degree_le_one i hf.le
#align polynomial.splits_of_degree_eq_one Polynomial.splits_of_degree_eq_one
-/

#print Polynomial.splits_of_natDegree_le_one /-
theorem splits_of_natDegree_le_one {f : K[X]} (hf : natDegree f ≤ 1) : Splits i f :=
  splits_of_degree_le_one i (degree_le_of_natDegree_le hf)
#align polynomial.splits_of_nat_degree_le_one Polynomial.splits_of_natDegree_le_one
-/

#print Polynomial.splits_of_natDegree_eq_one /-
theorem splits_of_natDegree_eq_one {f : K[X]} (hf : natDegree f = 1) : Splits i f :=
  splits_of_natDegree_le_one i (le_of_eq hf)
#align polynomial.splits_of_nat_degree_eq_one Polynomial.splits_of_natDegree_eq_one
-/

#print Polynomial.splits_mul /-
theorem splits_mul {f g : K[X]} (hf : Splits i f) (hg : Splits i g) : Splits i (f * g) :=
  if h : (f * g).map i = 0 then Or.inl h
  else
    Or.inr fun p hp hpf =>
      ((PrincipalIdealRing.irreducible_iff_prime.1 hp).2.2 _ _
            (show p ∣ map i f * map i g by convert hpf <;> rw [Polynomial.map_mul])).elim
        (hf.resolve_left (fun hf => by simpa [hf] using h) hp)
        (hg.resolve_left (fun hg => by simpa [hg] using h) hp)
#align polynomial.splits_mul Polynomial.splits_mul
-/

#print Polynomial.splits_of_splits_mul' /-
theorem splits_of_splits_mul' {f g : K[X]} (hfg : (f * g).map i ≠ 0) (h : Splits i (f * g)) :
    Splits i f ∧ Splits i g :=
  ⟨Or.inr fun g hgi hg =>
      Or.resolve_left h hfg hgi (by rw [Polynomial.map_mul] <;> exact hg.trans (dvd_mul_right _ _)),
    Or.inr fun g hgi hg =>
      Or.resolve_left h hfg hgi (by rw [Polynomial.map_mul] <;> exact hg.trans (dvd_mul_left _ _))⟩
#align polynomial.splits_of_splits_mul' Polynomial.splits_of_splits_mul'
-/

#print Polynomial.splits_map_iff /-
theorem splits_map_iff (j : L →+* F) {f : K[X]} : Splits j (f.map i) ↔ Splits (j.comp i) f := by
  simp [splits, Polynomial.map_map]
#align polynomial.splits_map_iff Polynomial.splits_map_iff
-/

#print Polynomial.splits_one /-
theorem splits_one : Splits i 1 :=
  splits_C i 1
#align polynomial.splits_one Polynomial.splits_one
-/

/- warning: polynomial.splits_of_is_unit -> Polynomial.splits_of_isUnit is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) [_inst_4 : IsDomain.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))] {u : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))}, (IsUnit.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.ring.{u1} K (CommRing.toRing.{u1} K _inst_1))) u) -> (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i u)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) [_inst_4 : IsDomain.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))] {u : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))}, (IsUnit.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) u) -> (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i u)
Case conversion may be inaccurate. Consider using '#align polynomial.splits_of_is_unit Polynomial.splits_of_isUnitₓ'. -/
theorem splits_of_isUnit [IsDomain K] {u : K[X]} (hu : IsUnit u) : u.Splits i :=
  (isUnit_iff.mp hu).choose_spec.2 ▸ splits_C _ _
#align polynomial.splits_of_is_unit Polynomial.splits_of_isUnit

/- warning: polynomial.splits_X_sub_C -> Polynomial.splits_X_sub_C is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {x : K}, Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (instHSub.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.sub.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.X.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))))) (fun (_x : RingHom.{u1, u1} K (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))))) => K -> (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)))) (RingHom.hasCoeToFun.{u1, u1} K (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))))) (Polynomial.C.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) x))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {x : K}, Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i (HSub.hSub.{u1, u1, u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : K) => Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) x) (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (instHSub.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.sub.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.X.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : K) => Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHom.instRingHomClassRingHom.{u1, u1} K (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))))))) (Polynomial.C.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) x))
Case conversion may be inaccurate. Consider using '#align polynomial.splits_X_sub_C Polynomial.splits_X_sub_Cₓ'. -/
theorem splits_X_sub_C {x : K} : (X - C x).Splits i :=
  splits_of_degree_le_one _ <| degree_X_sub_C_le _
#align polynomial.splits_X_sub_C Polynomial.splits_X_sub_C

#print Polynomial.splits_X /-
theorem splits_X : X.Splits i :=
  splits_of_degree_le_one _ degree_X_le
#align polynomial.splits_X Polynomial.splits_X
-/

#print Polynomial.splits_prod /-
theorem splits_prod {ι : Type u} {s : ι → K[X]} {t : Finset ι} :
    (∀ j ∈ t, (s j).Splits i) → (∏ x in t, s x).Splits i :=
  by
  refine' Finset.induction_on t (fun _ => splits_one i) fun a t hat ih ht => _
  rw [Finset.forall_mem_insert] at ht; rw [Finset.prod_insert hat]
  exact splits_mul i ht.1 (ih ht.2)
#align polynomial.splits_prod Polynomial.splits_prod
-/

/- warning: polynomial.splits_pow -> Polynomial.splits_pow is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))}, (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f) -> (forall (n : Nat), Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) Nat (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.ring.{u1} K (CommRing.toRing.{u1} K _inst_1))))) f n))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))}, (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f) -> (forall (n : Nat), Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) Nat (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) f n))
Case conversion may be inaccurate. Consider using '#align polynomial.splits_pow Polynomial.splits_powₓ'. -/
theorem splits_pow {f : K[X]} (hf : f.Splits i) (n : ℕ) : (f ^ n).Splits i :=
  by
  rw [← Finset.card_range n, ← Finset.prod_const]
  exact splits_prod i fun j hj => hf
#align polynomial.splits_pow Polynomial.splits_pow

/- warning: polynomial.splits_X_pow -> Polynomial.splits_X_pow is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (n : Nat), Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) Nat (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Ring.toMonoid.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) (Polynomial.ring.{u1} K (CommRing.toRing.{u1} K _inst_1))))) (Polynomial.X.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))) n)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (n : Nat), Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i (HPow.hPow.{u1, 0, u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) Nat (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (instHPow.{u1, 0} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) Nat (Monoid.Pow.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Polynomial.semiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (Polynomial.X.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) n)
Case conversion may be inaccurate. Consider using '#align polynomial.splits_X_pow Polynomial.splits_X_powₓ'. -/
theorem splits_X_pow (n : ℕ) : (X ^ n).Splits i :=
  splits_pow i (splits_X i) n
#align polynomial.splits_X_pow Polynomial.splits_X_pow

#print Polynomial.splits_id_iff_splits /-
theorem splits_id_iff_splits {f : K[X]} : (f.map i).Splits (RingHom.id L) ↔ f.Splits i := by
  rw [splits_map_iff, RingHom.id_comp]
#align polynomial.splits_id_iff_splits Polynomial.splits_id_iff_splits
-/

/- warning: polynomial.exists_root_of_splits' -> Polynomial.exists_root_of_splits' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))}, (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f) -> (Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i f)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero))))) -> (Exists.{succ u2} L (fun (x : L) => Eq.{succ u2} L (Polynomial.eval₂.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i x f) (OfNat.ofNat.{u2} L 0 (OfNat.mk.{u2} L 0 (Zero.zero.{u2} L (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))}, (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f) -> (Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (Polynomial.map.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i f)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))))) -> (Exists.{succ u2} L (fun (x : L) => Eq.{succ u2} L (Polynomial.eval₂.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i x f) (OfNat.ofNat.{u2} L 0 (Zero.toOfNat0.{u2} L (CommMonoidWithZero.toZero.{u2} L (CommGroupWithZero.toCommMonoidWithZero.{u2} L (Semifield.toCommGroupWithZero.{u2} L (Field.toSemifield.{u2} L _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_root_of_splits' Polynomial.exists_root_of_splits'ₓ'. -/
theorem exists_root_of_splits' {f : K[X]} (hs : Splits i f) (hf0 : degree (f.map i) ≠ 0) :
    ∃ x, eval₂ i x f = 0 :=
  if hf0' : f.map i = 0 then by simp [eval₂_eq_eval_map, hf0']
  else
    let ⟨g, hg⟩ :=
      WfDvdMonoid.exists_irreducible_factor
        (show ¬IsUnit (f.map i) from mt isUnit_iff_degree_eq_zero.1 hf0) hf0'
    let ⟨x, hx⟩ := exists_root_of_degree_eq_one (hs.resolve_left hf0' hg.1 hg.2)
    let ⟨i, hi⟩ := hg.2
    ⟨x, by rw [← eval_map, hi, eval_mul, show _ = _ from hx, MulZeroClass.zero_mul]⟩
#align polynomial.exists_root_of_splits' Polynomial.exists_root_of_splits'

#print Polynomial.roots_ne_zero_of_splits' /-
theorem roots_ne_zero_of_splits' {f : K[X]} (hs : Splits i f) (hf0 : natDegree (f.map i) ≠ 0) :
    (f.map i).roots ≠ 0 :=
  let ⟨x, hx⟩ := exists_root_of_splits' i hs fun h => hf0 <| natDegree_eq_of_degree_eq_some h
  fun h => by
  rw [← eval_map] at hx
  cases h.subst ((mem_roots _).2 hx); exact ne_zero_of_nat_degree_gt (Nat.pos_of_ne_zero hf0)
#align polynomial.roots_ne_zero_of_splits' Polynomial.roots_ne_zero_of_splits'
-/

#print Polynomial.rootOfSplits' /-
/-- Pick a root of a polynomial that splits. See `root_of_splits` for polynomials over a field
which has simpler assumptions. -/
def rootOfSplits' {f : K[X]} (hf : f.Splits i) (hfd : (f.map i).degree ≠ 0) : L :=
  Classical.choose <| exists_root_of_splits' i hf hfd
#align polynomial.root_of_splits' Polynomial.rootOfSplits'
-/

/- warning: polynomial.map_root_of_splits' -> Polynomial.map_rootOfSplits' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))} (hf : Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f) (hfd : Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i f)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero))))), Eq.{succ u2} L (Polynomial.eval₂.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i (Polynomial.rootOfSplits'.{u1, u2} K L _inst_1 _inst_2 i f hf hfd) f) (OfNat.ofNat.{u2} L 0 (OfNat.mk.{u2} L 0 (Zero.zero.{u2} L (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))} (hf : Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i f) (hfd : Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (Polynomial.map.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i f)) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))))), Eq.{succ u2} L (Polynomial.eval₂.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i (Polynomial.rootOfSplits'.{u1, u2} K L _inst_1 _inst_2 i f hf hfd) f) (OfNat.ofNat.{u2} L 0 (Zero.toOfNat0.{u2} L (CommMonoidWithZero.toZero.{u2} L (CommGroupWithZero.toCommMonoidWithZero.{u2} L (Semifield.toCommGroupWithZero.{u2} L (Field.toSemifield.{u2} L _inst_2))))))
Case conversion may be inaccurate. Consider using '#align polynomial.map_root_of_splits' Polynomial.map_rootOfSplits'ₓ'. -/
theorem map_rootOfSplits' {f : K[X]} (hf : f.Splits i) (hfd) :
    f.eval₂ i (rootOfSplits' i hf hfd) = 0 :=
  Classical.choose_spec <| exists_root_of_splits' i hf hfd
#align polynomial.map_root_of_splits' Polynomial.map_rootOfSplits'

/- warning: polynomial.nat_degree_eq_card_roots' -> Polynomial.natDegree_eq_card_roots' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] {p : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))} {i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))}, (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i p) -> (Eq.{1} Nat (Polynomial.natDegree.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i p)) (coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u2} L) -> Nat) (AddMonoidHom.hasCoeToFun.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i p))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] {p : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))} {i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))}, (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i p) -> (Eq.{1} Nat (Polynomial.natDegree.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (Polynomial.map.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i p)) (FunLike.coe.{succ u2, succ u2, 1} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) (fun (_x : Multiset.{u2} L) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} L) => Nat) _x) (AddHomClass.toFunLike.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) Nat (AddZeroClass.toAdd.{u2} (Multiset.{u2} L) (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i p))))
Case conversion may be inaccurate. Consider using '#align polynomial.nat_degree_eq_card_roots' Polynomial.natDegree_eq_card_roots'ₓ'. -/
theorem natDegree_eq_card_roots' {p : K[X]} {i : K →+* L} (hsplit : Splits i p) :
    (p.map i).natDegree = (p.map i).roots.card :=
  by
  by_cases hp : p.map i = 0
  · rw [hp, nat_degree_zero, roots_zero, Multiset.card_zero]
  obtain ⟨q, he, hd, hr⟩ := exists_prod_multiset_X_sub_C_mul (p.map i)
  rw [← splits_id_iff_splits, ← he] at hsplit
  rw [← he] at hp
  have hq : q ≠ 0 := fun h => hp (by rw [h, MulZeroClass.mul_zero])
  rw [← hd, add_right_eq_self]
  by_contra
  have h' : (map (RingHom.id L) q).natDegree ≠ 0 := by simp [h]
  have := roots_ne_zero_of_splits' (RingHom.id L) (splits_of_splits_mul' _ _ hsplit).2 h'
  · rw [map_id] at this; exact this hr
  · rw [map_id]; exact mul_ne_zero monic_prod_multiset_X_sub_C.ne_zero hq
#align polynomial.nat_degree_eq_card_roots' Polynomial.natDegree_eq_card_roots'

/- warning: polynomial.degree_eq_card_roots' -> Polynomial.degree_eq_card_roots' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] {p : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))} {i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))}, (Ne.{succ u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i p) (OfNat.ofNat.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) 0 (OfNat.mk.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) 0 (Zero.zero.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.zero.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))))) -> (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i p) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i p)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (WithBot.{0} Nat) (HasLiftT.mk.{1, 1} Nat (WithBot.{0} Nat) (CoeTCₓ.coe.{1, 1} Nat (WithBot.{0} Nat) (WithBot.hasCoeT.{0} Nat))) (coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u2} L) -> Nat) (AddMonoidHom.hasCoeToFun.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i p)))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : CommRing.{u1} K] [_inst_2 : Field.{u2} L] {p : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))} {i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))}, (Ne.{succ u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.map.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i p) (OfNat.ofNat.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) 0 (Zero.toOfNat0.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.zero.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))))) -> (Polynomial.Splits.{u1, u2} K L _inst_1 _inst_2 i p) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (Polynomial.map.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i p)) (Nat.cast.{0} (WithBot.{0} Nat) (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (FunLike.coe.{succ u2, succ u2, 1} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) (fun (_x : Multiset.{u2} L) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} L) => Nat) _x) (AddHomClass.toFunLike.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) Nat (AddZeroClass.toAdd.{u2} (Multiset.{u2} L) (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i p)))))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_eq_card_roots' Polynomial.degree_eq_card_roots'ₓ'. -/
theorem degree_eq_card_roots' {p : K[X]} {i : K →+* L} (p_ne_zero : p.map i ≠ 0)
    (hsplit : Splits i p) : (p.map i).degree = (p.map i).roots.card := by
  rw [degree_eq_nat_degree p_ne_zero, nat_degree_eq_card_roots' hsplit]
#align polynomial.degree_eq_card_roots' Polynomial.degree_eq_card_roots'

end CommRing

variable [Field K] [Field L] [Field F]

variable (i : K →+* L)

/- warning: polynomial.splits_iff -> Polynomial.splits_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))), Iff (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) (Or (Eq.{succ u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) f (OfNat.ofNat.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) (forall {g : Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))}, (Irreducible.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Ring.toMonoid.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.ring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) g) -> (Dvd.Dvd.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (semigroupDvd.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (SemigroupWithZero.toSemigroup.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (NonUnitalSemiring.toSemigroupWithZero.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (NonUnitalRing.toNonUnitalSemiring.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (NonUnitalCommRing.toNonUnitalRing.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (CommRing.toNonUnitalCommRing.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.commRing.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))))))))) g (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i f)) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) g) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne)))))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (f : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))), Iff (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) (Or (Eq.{succ u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) f (OfNat.ofNat.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (forall {g : Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))}, (Irreducible.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (MonoidWithZero.toMonoid.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toMonoidWithZero.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) g) -> (Dvd.dvd.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (semigroupDvd.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (SemigroupWithZero.toSemigroup.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (NonUnitalSemiring.toSemigroupWithZero.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (CommRing.toNonUnitalCommRing.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.commRing.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))))))))) g (Polynomial.map.{u1, u2} K L (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i f)) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) g) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.splits_iff Polynomial.splits_iffₓ'. -/
/-- This lemma is for polynomials over a field. -/
theorem splits_iff (f : K[X]) :
    Splits i f ↔ f = 0 ∨ ∀ {g : L[X]}, Irreducible g → g ∣ f.map i → degree g = 1 := by
  rw [splits, map_eq_zero]
#align polynomial.splits_iff Polynomial.splits_iff

/- warning: polynomial.splits.def -> Polynomial.Splits.def is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] {i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))} {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) -> (Or (Eq.{succ u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) f (OfNat.ofNat.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) (forall {g : Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))}, (Irreducible.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Ring.toMonoid.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.ring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) g) -> (Dvd.Dvd.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (semigroupDvd.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (SemigroupWithZero.toSemigroup.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (NonUnitalSemiring.toSemigroupWithZero.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (NonUnitalRing.toNonUnitalSemiring.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (NonUnitalCommRing.toNonUnitalRing.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (CommRing.toNonUnitalCommRing.{u2} (Polynomial.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Polynomial.commRing.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))))))))) g (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i f)) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) g) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne)))))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] {i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))} {f : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))}, (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) -> (Or (Eq.{succ u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) f (OfNat.ofNat.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (forall {g : Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))}, (Irreducible.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (MonoidWithZero.toMonoid.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Semiring.toMonoidWithZero.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.semiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) g) -> (Dvd.dvd.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (semigroupDvd.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (SemigroupWithZero.toSemigroup.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (NonUnitalSemiring.toSemigroupWithZero.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (CommRing.toNonUnitalCommRing.{u2} (Polynomial.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Polynomial.commRing.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))))))))) g (Polynomial.map.{u1, u2} K L (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i f)) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) g) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.splits.def Polynomial.Splits.defₓ'. -/
/-- This lemma is for polynomials over a field. -/
theorem Splits.def {i : K →+* L} {f : K[X]} (h : Splits i f) :
    f = 0 ∨ ∀ {g : L[X]}, Irreducible g → g ∣ f.map i → degree g = 1 :=
  (splits_iff i f).mp h
#align polynomial.splits.def Polynomial.Splits.def

#print Polynomial.splits_of_splits_mul /-
theorem splits_of_splits_mul {f g : K[X]} (hfg : f * g ≠ 0) (h : Splits i (f * g)) :
    Splits i f ∧ Splits i g :=
  splits_of_splits_mul' i (map_ne_zero hfg) h
#align polynomial.splits_of_splits_mul Polynomial.splits_of_splits_mul
-/

#print Polynomial.splits_of_splits_of_dvd /-
theorem splits_of_splits_of_dvd {f g : K[X]} (hf0 : f ≠ 0) (hf : Splits i f) (hgf : g ∣ f) :
    Splits i g := by obtain ⟨f, rfl⟩ := hgf; exact (splits_of_splits_mul i hf0 hf).1
#align polynomial.splits_of_splits_of_dvd Polynomial.splits_of_splits_of_dvd
-/

/- warning: polynomial.splits_of_splits_gcd_left -> Polynomial.splits_of_splits_gcd_left is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))} {g : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, (Ne.{succ u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) f (OfNat.ofNat.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i (EuclideanDomain.gcd.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (Polynomial.euclideanDomain.{u1} K _inst_1) (fun (a : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (b : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) => Classical.propDecidable (Eq.{succ u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) a b)) f g))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))} {g : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))}, (Ne.{succ u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) f (OfNat.ofNat.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i (EuclideanDomain.gcd.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (Polynomial.instEuclideanDomainPolynomialToSemiringToDivisionSemiringToSemifield.{u1} K _inst_1) (fun (a : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (b : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) => Classical.propDecidable (Eq.{succ u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) a b)) f g))
Case conversion may be inaccurate. Consider using '#align polynomial.splits_of_splits_gcd_left Polynomial.splits_of_splits_gcd_leftₓ'. -/
theorem splits_of_splits_gcd_left {f g : K[X]} (hf0 : f ≠ 0) (hf : Splits i f) :
    Splits i (EuclideanDomain.gcd f g) :=
  Polynomial.splits_of_splits_of_dvd i hf0 hf (EuclideanDomain.gcd_dvd_left f g)
#align polynomial.splits_of_splits_gcd_left Polynomial.splits_of_splits_gcd_left

/- warning: polynomial.splits_of_splits_gcd_right -> Polynomial.splits_of_splits_gcd_right is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))} {g : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, (Ne.{succ u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) g (OfNat.ofNat.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i g) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i (EuclideanDomain.gcd.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (Polynomial.euclideanDomain.{u1} K _inst_1) (fun (a : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (b : Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) => Classical.propDecidable (Eq.{succ u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) a b)) f g))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))} {g : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))}, (Ne.{succ u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) g (OfNat.ofNat.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i g) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i (EuclideanDomain.gcd.{u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (Polynomial.instEuclideanDomainPolynomialToSemiringToDivisionSemiringToSemifield.{u1} K _inst_1) (fun (a : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (b : Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) => Classical.propDecidable (Eq.{succ u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) a b)) f g))
Case conversion may be inaccurate. Consider using '#align polynomial.splits_of_splits_gcd_right Polynomial.splits_of_splits_gcd_rightₓ'. -/
theorem splits_of_splits_gcd_right {f g : K[X]} (hg0 : g ≠ 0) (hg : Splits i g) :
    Splits i (EuclideanDomain.gcd f g) :=
  Polynomial.splits_of_splits_of_dvd i hg0 hg (EuclideanDomain.gcd_dvd_right f g)
#align polynomial.splits_of_splits_gcd_right Polynomial.splits_of_splits_gcd_right

#print Polynomial.splits_mul_iff /-
theorem splits_mul_iff {f g : K[X]} (hf : f ≠ 0) (hg : g ≠ 0) :
    (f * g).Splits i ↔ f.Splits i ∧ g.Splits i :=
  ⟨splits_of_splits_mul i (mul_ne_zero hf hg), fun ⟨hfs, hgs⟩ => splits_mul i hfs hgs⟩
#align polynomial.splits_mul_iff Polynomial.splits_mul_iff
-/

#print Polynomial.splits_prod_iff /-
theorem splits_prod_iff {ι : Type u} {s : ι → K[X]} {t : Finset ι} :
    (∀ j ∈ t, s j ≠ 0) → ((∏ x in t, s x).Splits i ↔ ∀ j ∈ t, (s j).Splits i) :=
  by
  refine'
    Finset.induction_on t (fun _ => ⟨fun _ _ h => h.elim, fun _ => splits_one i⟩)
      fun a t hat ih ht => _
  rw [Finset.forall_mem_insert] at ht⊢
  rw [Finset.prod_insert hat, splits_mul_iff i ht.1 (Finset.prod_ne_zero_iff.2 ht.2), ih ht.2]
#align polynomial.splits_prod_iff Polynomial.splits_prod_iff
-/

/- warning: polynomial.degree_eq_one_of_irreducible_of_splits -> Polynomial.degree_eq_one_of_irreducible_of_splits is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {p : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, (Irreducible.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Ring.toMonoid.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Polynomial.ring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) p) -> (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) p) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (OfNat.mk.{0} (WithBot.{0} Nat) 1 (One.one.{0} (WithBot.{0} Nat) (WithBot.hasOne.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {p : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))}, (Irreducible.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (MonoidWithZero.toMonoid.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toMonoidWithZero.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Polynomial.semiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) p) -> (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) p) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) p) (OfNat.ofNat.{0} (WithBot.{0} Nat) 1 (One.toOfNat1.{0} (WithBot.{0} Nat) (WithBot.one.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring)))))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_eq_one_of_irreducible_of_splits Polynomial.degree_eq_one_of_irreducible_of_splitsₓ'. -/
theorem degree_eq_one_of_irreducible_of_splits {p : K[X]} (hp : Irreducible p)
    (hp_splits : Splits (RingHom.id K) p) : p.degree = 1 :=
  by
  rcases hp_splits with ⟨⟩
  · exfalso; simp_all
  · apply hp_splits hp; simp
#align polynomial.degree_eq_one_of_irreducible_of_splits Polynomial.degree_eq_one_of_irreducible_of_splits

/- warning: polynomial.exists_root_of_splits -> Polynomial.exists_root_of_splits is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) -> (Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) f) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero))))) -> (Exists.{succ u2} L (fun (x : L) => Eq.{succ u2} L (Polynomial.eval₂.{u1, u2} K L (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i x f) (OfNat.ofNat.{u2} L 0 (OfNat.mk.{u2} L 0 (Zero.zero.{u2} L (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))}, (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) -> (Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) f) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))))) -> (Exists.{succ u2} L (fun (x : L) => Eq.{succ u2} L (Polynomial.eval₂.{u1, u2} K L (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i x f) (OfNat.ofNat.{u2} L 0 (Zero.toOfNat0.{u2} L (CommMonoidWithZero.toZero.{u2} L (CommGroupWithZero.toCommMonoidWithZero.{u2} L (Semifield.toCommGroupWithZero.{u2} L (Field.toSemifield.{u2} L _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_root_of_splits Polynomial.exists_root_of_splitsₓ'. -/
theorem exists_root_of_splits {f : K[X]} (hs : Splits i f) (hf0 : degree f ≠ 0) :
    ∃ x, eval₂ i x f = 0 :=
  exists_root_of_splits' i hs ((f.degree_map i).symm ▸ hf0)
#align polynomial.exists_root_of_splits Polynomial.exists_root_of_splits

#print Polynomial.roots_ne_zero_of_splits /-
theorem roots_ne_zero_of_splits {f : K[X]} (hs : Splits i f) (hf0 : natDegree f ≠ 0) :
    (f.map i).roots ≠ 0 :=
  roots_ne_zero_of_splits' i hs (ne_of_eq_of_ne (natDegree_map i) hf0)
#align polynomial.roots_ne_zero_of_splits Polynomial.roots_ne_zero_of_splits
-/

#print Polynomial.rootOfSplits /-
/-- Pick a root of a polynomial that splits. This version is for polynomials over a field and has
simpler assumptions. -/
def rootOfSplits {f : K[X]} (hf : f.Splits i) (hfd : f.degree ≠ 0) : L :=
  rootOfSplits' i hf ((f.degree_map i).symm ▸ hfd)
#align polynomial.root_of_splits Polynomial.rootOfSplits
-/

#print Polynomial.rootOfSplits'_eq_rootOfSplits /-
/-- `root_of_splits'` is definitionally equal to `root_of_splits`. -/
theorem rootOfSplits'_eq_rootOfSplits {f : K[X]} (hf : f.Splits i) (hfd) :
    rootOfSplits' i hf hfd = rootOfSplits i hf (f.degree_map i ▸ hfd) :=
  rfl
#align polynomial.root_of_splits'_eq_root_of_splits Polynomial.rootOfSplits'_eq_rootOfSplits
-/

/- warning: polynomial.map_root_of_splits -> Polynomial.map_rootOfSplits is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))} (hf : Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) (hfd : Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) f) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero))))), Eq.{succ u2} L (Polynomial.eval₂.{u1, u2} K L (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i (Polynomial.rootOfSplits.{u1, u2} K L _inst_1 _inst_2 i f hf hfd) f) (OfNat.ofNat.{u2} L 0 (OfNat.mk.{u2} L 0 (Zero.zero.{u2} L (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))} (hf : Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i f) (hfd : Ne.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) f) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero))))), Eq.{succ u2} L (Polynomial.eval₂.{u1, u2} K L (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i (Polynomial.rootOfSplits.{u1, u2} K L _inst_1 _inst_2 i f hf hfd) f) (OfNat.ofNat.{u2} L 0 (Zero.toOfNat0.{u2} L (CommMonoidWithZero.toZero.{u2} L (CommGroupWithZero.toCommMonoidWithZero.{u2} L (Semifield.toCommGroupWithZero.{u2} L (Field.toSemifield.{u2} L _inst_2))))))
Case conversion may be inaccurate. Consider using '#align polynomial.map_root_of_splits Polynomial.map_rootOfSplitsₓ'. -/
theorem map_rootOfSplits {f : K[X]} (hf : f.Splits i) (hfd) :
    f.eval₂ i (rootOfSplits i hf hfd) = 0 :=
  map_rootOfSplits' i hf (ne_of_eq_of_ne (degree_map f i) hfd)
#align polynomial.map_root_of_splits Polynomial.map_rootOfSplits

/- warning: polynomial.nat_degree_eq_card_roots -> Polynomial.natDegree_eq_card_roots is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] {p : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))} {i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))}, (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i p) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) p) (coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u2} L) -> Nat) (AddMonoidHom.hasCoeToFun.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i p))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] {p : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))} {i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))}, (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i p) -> (Eq.{1} Nat (Polynomial.natDegree.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) p) (FunLike.coe.{succ u2, succ u2, 1} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) (fun (_x : Multiset.{u2} L) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} L) => Nat) _x) (AddHomClass.toFunLike.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) Nat (AddZeroClass.toAdd.{u2} (Multiset.{u2} L) (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i p))))
Case conversion may be inaccurate. Consider using '#align polynomial.nat_degree_eq_card_roots Polynomial.natDegree_eq_card_rootsₓ'. -/
theorem natDegree_eq_card_roots {p : K[X]} {i : K →+* L} (hsplit : Splits i p) :
    p.natDegree = (p.map i).roots.card :=
  (natDegree_map i).symm.trans <| natDegree_eq_card_roots' hsplit
#align polynomial.nat_degree_eq_card_roots Polynomial.natDegree_eq_card_roots

/- warning: polynomial.degree_eq_card_roots -> Polynomial.degree_eq_card_roots is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] {p : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))} {i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))}, (Ne.{succ u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) p (OfNat.ofNat.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i p) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) p) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat (WithBot.{0} Nat) (HasLiftT.mk.{1, 1} Nat (WithBot.{0} Nat) (CoeTCₓ.coe.{1, 1} Nat (WithBot.{0} Nat) (WithBot.hasCoeT.{0} Nat))) (coeFn.{succ u2, succ u2} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u2} L) -> Nat) (AddMonoidHom.hasCoeToFun.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.orderedCancelAddCommMonoid.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i p)))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] {p : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))} {i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))}, (Ne.{succ u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) p (OfNat.ofNat.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) 0 (Zero.toOfNat0.{u1} (Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Polynomial.zero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Polynomial.Splits.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_2 i p) -> (Eq.{1} (WithBot.{0} Nat) (Polynomial.degree.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) p) (Nat.cast.{0} (WithBot.{0} Nat) (Semiring.toNatCast.{0} (WithBot.{0} Nat) (OrderedSemiring.toSemiring.{0} (WithBot.{0} Nat) (OrderedCommSemiring.toOrderedSemiring.{0} (WithBot.{0} Nat) (WithBot.orderedCommSemiring.{0} Nat (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.canonicallyOrderedCommSemiring Nat.nontrivial)))) (FunLike.coe.{succ u2, succ u2, 1} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) (fun (_x : Multiset.{u2} L) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u2} L) => Nat) _x) (AddHomClass.toFunLike.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) Nat (AddZeroClass.toAdd.{u2} (Multiset.{u2} L) (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u2, u2, 0} (AddMonoidHom.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u2, 0} (Multiset.{u2} L) Nat (AddMonoid.toAddZeroClass.{u2} (Multiset.{u2} L) (AddRightCancelMonoid.toAddMonoid.{u2} (Multiset.{u2} L) (AddCancelMonoid.toAddRightCancelMonoid.{u2} (Multiset.{u2} L) (AddCancelCommMonoid.toAddCancelMonoid.{u2} (Multiset.{u2} L) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u2} (Multiset.{u2} L) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} L)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i p)))))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_eq_card_roots Polynomial.degree_eq_card_rootsₓ'. -/
theorem degree_eq_card_roots {p : K[X]} {i : K →+* L} (p_ne_zero : p ≠ 0) (hsplit : Splits i p) :
    p.degree = (p.map i).roots.card := by
  rw [degree_eq_nat_degree p_ne_zero, nat_degree_eq_card_roots hsplit]
#align polynomial.degree_eq_card_roots Polynomial.degree_eq_card_roots

/- warning: polynomial.roots_map -> Polynomial.roots_map is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) f) -> (Eq.{succ u2} (Multiset.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) i f)) (Multiset.map.{u1, u2} K L (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (fun (_x : RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) => K -> L) (RingHom.hasCoeToFun.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) i) (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) f)))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] (i : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) {f : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))}, (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) f) -> (Eq.{succ u2} (Multiset.{u2} L) (Polynomial.roots.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2)) (Field.isDomain.{u2} L _inst_2) (Polynomial.map.{u1, u2} K L (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) i f)) (Multiset.map.{u1, u2} K L (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : K) => L) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))))) i) (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) f)))
Case conversion may be inaccurate. Consider using '#align polynomial.roots_map Polynomial.roots_mapₓ'. -/
theorem roots_map {f : K[X]} (hf : f.Splits <| RingHom.id K) : (f.map i).roots = f.roots.map i :=
  (roots_map_of_injective_of_card_eq_natDegree i.Injective <| by
      convert(nat_degree_eq_card_roots hf).symm; rw [map_id]).symm
#align polynomial.roots_map Polynomial.roots_map

#print Polynomial.image_rootSet /-
theorem image_rootSet [Algebra F K] [Algebra F L] {p : F[X]} (h : p.Splits (algebraMap F K))
    (f : K →ₐ[F] L) : f '' p.rootSet K = p.rootSet L := by
  classical rw [root_set, ← Finset.coe_image, ← Multiset.toFinset_map, ← f.coe_to_ring_hom, ←
      roots_map (↑f) ((splits_id_iff_splits (algebraMap F K)).mpr h), map_map, f.comp_algebra_map, ←
      root_set]
#align polynomial.image_root_set Polynomial.image_rootSet
-/

/- warning: polynomial.adjoin_root_set_eq_range -> Polynomial.adjoin_rootSet_eq_range is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} {L : Type.{u3}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u3} L] [_inst_3 : Field.{u1} F] [_inst_4 : Algebra.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1)))] [_inst_5 : Algebra.{u1, u3} F L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u3} L (DivisionRing.toRing.{u3} L (Field.toDivisionRing.{u3} L _inst_2)))] {p : Polynomial.{u1} F (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_3)))}, (Polynomial.Splits.{u1, u2} F K (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_3)) _inst_1 (algebraMap.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) _inst_4) p) -> (forall (f : AlgHom.{u1, u2, u3} F K L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) (Ring.toSemiring.{u3} L (DivisionRing.toRing.{u3} L (Field.toDivisionRing.{u3} L _inst_2))) _inst_4 _inst_5), Iff (Eq.{succ u3} (Subalgebra.{u1, u3} F L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u3} L (DivisionRing.toRing.{u3} L (Field.toDivisionRing.{u3} L _inst_2))) _inst_5) (Algebra.adjoin.{u1, u3} F L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u3} L (DivisionRing.toRing.{u3} L (Field.toDivisionRing.{u3} L _inst_2))) _inst_5 (Polynomial.rootSet.{u1, u3} F (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_3)) p L (EuclideanDomain.toCommRing.{u3} L (Field.toEuclideanDomain.{u3} L _inst_2)) (Field.isDomain.{u3} L _inst_2) _inst_5)) (AlgHom.range.{u1, u2, u3} F K L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) _inst_4 (Ring.toSemiring.{u3} L (DivisionRing.toRing.{u3} L (Field.toDivisionRing.{u3} L _inst_2))) _inst_5 f)) (Eq.{succ u2} (Subalgebra.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) _inst_4) (Algebra.adjoin.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) _inst_4 (Polynomial.rootSet.{u1, u2} F (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_3)) p K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_1)) (Field.isDomain.{u2} K _inst_1) _inst_4)) (Top.top.{u2} (Subalgebra.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) _inst_4) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) _inst_4) (Algebra.Subalgebra.completeLattice.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) _inst_4)))))
but is expected to have type
  forall {F : Type.{u1}} {K : Type.{u2}} {L : Type.{u3}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u3} L] [_inst_3 : Field.{u1} F] [_inst_4 : Algebra.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))] [_inst_5 : Algebra.{u1, u3} F L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u3} L (Semifield.toDivisionSemiring.{u3} L (Field.toSemifield.{u3} L _inst_2)))] {p : Polynomial.{u1} F (DivisionSemiring.toSemiring.{u1} F (Semifield.toDivisionSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)))}, (Polynomial.Splits.{u1, u2} F K (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_3)) _inst_1 (algebraMap.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) _inst_4) p) -> (forall (f : AlgHom.{u1, u2, u3} F K L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (DivisionSemiring.toSemiring.{u3} L (Semifield.toDivisionSemiring.{u3} L (Field.toSemifield.{u3} L _inst_2))) _inst_4 _inst_5), Iff (Eq.{succ u3} (Subalgebra.{u1, u3} F L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u3} L (Semifield.toDivisionSemiring.{u3} L (Field.toSemifield.{u3} L _inst_2))) _inst_5) (Algebra.adjoin.{u1, u3} F L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u3} L (Semifield.toDivisionSemiring.{u3} L (Field.toSemifield.{u3} L _inst_2))) _inst_5 (Polynomial.rootSet.{u1, u3} F (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_3)) p L (EuclideanDomain.toCommRing.{u3} L (Field.toEuclideanDomain.{u3} L _inst_2)) (Field.isDomain.{u3} L _inst_2) _inst_5)) (AlgHom.range.{u1, u2, u3} F K L (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) _inst_4 (DivisionSemiring.toSemiring.{u3} L (Semifield.toDivisionSemiring.{u3} L (Field.toSemifield.{u3} L _inst_2))) _inst_5 f)) (Eq.{succ u2} (Subalgebra.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) _inst_4) (Algebra.adjoin.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) _inst_4 (Polynomial.rootSet.{u1, u2} F (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_3)) p K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_1)) (Field.isDomain.{u2} K _inst_1) _inst_4)) (Top.top.{u2} (Subalgebra.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) _inst_4) (CompleteLattice.toTop.{u2} (Subalgebra.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) _inst_4) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F K (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_3)) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) _inst_4)))))
Case conversion may be inaccurate. Consider using '#align polynomial.adjoin_root_set_eq_range Polynomial.adjoin_rootSet_eq_rangeₓ'. -/
theorem adjoin_rootSet_eq_range [Algebra F K] [Algebra F L] {p : F[X]}
    (h : p.Splits (algebraMap F K)) (f : K →ₐ[F] L) :
    Algebra.adjoin F (p.rootSet L) = f.range ↔ Algebra.adjoin F (p.rootSet K) = ⊤ :=
  by
  rw [← image_root_set h f, Algebra.adjoin_image, ← Algebra.map_top]
  exact (Subalgebra.map_injective f.to_ring_hom.injective).eq_iff
#align polynomial.adjoin_root_set_eq_range Polynomial.adjoin_rootSet_eq_range

/- warning: polynomial.eq_prod_roots_of_splits -> Polynomial.eq_prod_roots_of_splits is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align polynomial.eq_prod_roots_of_splits Polynomial.eq_prod_roots_of_splitsₓ'. -/
theorem eq_prod_roots_of_splits {p : K[X]} {i : K →+* L} (hsplit : Splits i p) :
    p.map i = C (i p.leadingCoeff) * ((p.map i).roots.map fun a => X - C a).Prod :=
  by
  rw [← leading_coeff_map]; symm
  apply C_leading_coeff_mul_prod_multiset_X_sub_C
  rw [nat_degree_map]; exact (nat_degree_eq_card_roots hsplit).symm
#align polynomial.eq_prod_roots_of_splits Polynomial.eq_prod_roots_of_splits

/- warning: polynomial.eq_prod_roots_of_splits_id -> Polynomial.eq_prod_roots_of_splits_id is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align polynomial.eq_prod_roots_of_splits_id Polynomial.eq_prod_roots_of_splits_idₓ'. -/
theorem eq_prod_roots_of_splits_id {p : K[X]} (hsplit : Splits (RingHom.id K) p) :
    p = C p.leadingCoeff * (p.roots.map fun a => X - C a).Prod := by
  simpa using eq_prod_roots_of_splits hsplit
#align polynomial.eq_prod_roots_of_splits_id Polynomial.eq_prod_roots_of_splits_id

/- warning: polynomial.eq_prod_roots_of_monic_of_splits_id -> Polynomial.eq_prod_roots_of_monic_of_splits_id is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align polynomial.eq_prod_roots_of_monic_of_splits_id Polynomial.eq_prod_roots_of_monic_of_splits_idₓ'. -/
theorem eq_prod_roots_of_monic_of_splits_id {p : K[X]} (m : Monic p)
    (hsplit : Splits (RingHom.id K) p) : p = (p.roots.map fun a => X - C a).Prod :=
  by
  convert eq_prod_roots_of_splits_id hsplit
  simp [m]
#align polynomial.eq_prod_roots_of_monic_of_splits_id Polynomial.eq_prod_roots_of_monic_of_splits_id

/- warning: polynomial.eq_X_sub_C_of_splits_of_single_root -> Polynomial.eq_X_sub_C_of_splits_of_single_root is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align polynomial.eq_X_sub_C_of_splits_of_single_root Polynomial.eq_X_sub_C_of_splits_of_single_rootₓ'. -/
theorem eq_X_sub_C_of_splits_of_single_root {x : K} {h : K[X]} (h_splits : Splits i h)
    (h_roots : (h.map i).roots = {i x}) : h = C h.leadingCoeff * (X - C x) :=
  by
  apply Polynomial.map_injective _ i.injective
  rw [eq_prod_roots_of_splits h_splits, h_roots]
  simp
#align polynomial.eq_X_sub_C_of_splits_of_single_root Polynomial.eq_X_sub_C_of_splits_of_single_root

/- warning: polynomial.mem_lift_of_splits_of_roots_mem_range -> Polynomial.mem_lift_of_splits_of_roots_mem_range is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] (R : Type.{u2}) [_inst_4 : CommRing.{u2} R] [_inst_5 : Algebra.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_4) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))] {f : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) f) -> (Polynomial.Monic.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) f) -> (forall (a : K), (Membership.Mem.{u1, u1} K (Multiset.{u1} K) (Multiset.hasMem.{u1} K) a (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) f)) -> (Membership.Mem.{u1, u1} K (Subring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (SetLike.hasMem.{u1, u1} (Subring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) K (Subring.setLike.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) a (RingHom.range.{u2, u1} R K (CommRing.toRing.{u2} R _inst_4) (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)) (algebraMap.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_4) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) _inst_5)))) -> (Membership.Mem.{u1, u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Subsemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Polynomial.semiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (SetLike.hasMem.{u1, u1} (Subsemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Polynomial.semiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Subsemiring.setLike.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Polynomial.semiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))) f (Polynomial.lifts.{u2, u1} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_4)) K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (algebraMap.{u2, u1} R K (CommRing.toCommSemiring.{u2} R _inst_4) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) _inst_5)))
but is expected to have type
  forall {K : Type.{u2}} [_inst_1 : Field.{u2} K] (R : Type.{u1}) [_inst_4 : CommRing.{u1} R] [_inst_5 : Algebra.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_4) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))] {f : Polynomial.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))}, (Polynomial.Splits.{u2, u2} K K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_1)) _inst_1 (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))))) f) -> (Polynomial.Monic.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) f) -> (forall (a : K), (Membership.mem.{u2, u2} K (Multiset.{u2} K) (Multiset.instMembershipMultiset.{u2} K) a (Polynomial.roots.{u2} K (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_1)) (Field.isDomain.{u2} K _inst_1) f)) -> (Membership.mem.{u2, u2} K (Subring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) (SetLike.instMembership.{u2, u2} (Subring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1))) K (Subring.instSetLikeSubring.{u2} K (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1)))) a (RingHom.range.{u1, u2} R K (CommRing.toRing.{u1} R _inst_4) (DivisionRing.toRing.{u2} K (Field.toDivisionRing.{u2} K _inst_1)) (algebraMap.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_4) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) _inst_5)))) -> (Membership.mem.{u2, u2} (Polynomial.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))) (Subsemiring.{u2} (Polynomial.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))) (Polynomial.semiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))))) (SetLike.instMembership.{u2, u2} (Subsemiring.{u2} (Polynomial.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))) (Polynomial.semiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))))) (Polynomial.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))) (Subsemiring.instSetLikeSubsemiring.{u2} (Polynomial.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))) (Polynomial.semiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))))))) f (Polynomial.lifts.{u1, u2} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_4)) K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (algebraMap.{u1, u2} R K (CommRing.toCommSemiring.{u1} R _inst_4) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) _inst_5)))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_lift_of_splits_of_roots_mem_range Polynomial.mem_lift_of_splits_of_roots_mem_rangeₓ'. -/
theorem mem_lift_of_splits_of_roots_mem_range (R : Type _) [CommRing R] [Algebra R K] {f : K[X]}
    (hs : f.Splits (RingHom.id K)) (hm : f.Monic) (hr : ∀ a ∈ f.roots, a ∈ (algebraMap R K).range) :
    f ∈ Polynomial.lifts (algebraMap R K) :=
  by
  rw [eq_prod_roots_of_monic_of_splits_id hm hs, lifts_iff_lifts_ring]
  refine' Subring.multiset_prod_mem _ _ fun P hP => _
  obtain ⟨b, hb, rfl⟩ := Multiset.mem_map.1 hP
  exact Subring.sub_mem _ (X_mem_lifts _) (C'_mem_lifts (hr _ hb))
#align polynomial.mem_lift_of_splits_of_roots_mem_range Polynomial.mem_lift_of_splits_of_roots_mem_range

section UFD

attribute [local instance 10] PrincipalIdealRing.to_uniqueFactorizationMonoid

-- mathport name: «expr ~ᵤ »
local infixl:50 " ~ᵤ " => Associated

open UniqueFactorizationMonoid Associates

/- warning: polynomial.splits_of_exists_multiset -> Polynomial.splits_of_exists_multiset is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align polynomial.splits_of_exists_multiset Polynomial.splits_of_exists_multisetₓ'. -/
theorem splits_of_exists_multiset {f : K[X]} {s : Multiset L}
    (hs : f.map i = C (i f.leadingCoeff) * (s.map fun a : L => X - C a).Prod) : Splits i f :=
  if hf0 : f = 0 then hf0.symm ▸ splits_zero i
  else
    Or.inr fun p hp hdp => by
      rw [irreducible_iff_prime] at hp
      rw [hs, ← Multiset.prod_toList] at hdp
      obtain hd | hd := hp.2.2 _ _ hdp
      · refine' (hp.2.1 <| isUnit_of_dvd_unit hd _).elim
        exact is_unit_C.2 ((leading_coeff_ne_zero.2 hf0).IsUnit.map i)
      · obtain ⟨q, hq, hd⟩ := hp.dvd_prod_iff.1 hd
        obtain ⟨a, ha, rfl⟩ := Multiset.mem_map.1 (Multiset.mem_toList.1 hq)
        rw [degree_eq_degree_of_associated ((hp.dvd_prime_iff_associated <| prime_X_sub_C a).1 hd)]
        exact degree_X_sub_C a
#align polynomial.splits_of_exists_multiset Polynomial.splits_of_exists_multiset

#print Polynomial.splits_of_splits_id /-
theorem splits_of_splits_id {f : K[X]} : Splits (RingHom.id K) f → Splits i f :=
  UniqueFactorizationMonoid.induction_on_prime f (fun _ => splits_zero _)
    (fun _ hu _ => splits_of_degree_le_one _ ((isUnit_iff_degree_eq_zero.1 hu).symm ▸ by decide))
    fun a p ha0 hp ih hfi =>
    splits_mul _
      (splits_of_degree_eq_one _
        ((splits_of_splits_mul _ (mul_ne_zero hp.1 ha0) hfi).1.def.resolve_left hp.1 hp.Irreducible
          (by rw [map_id])))
      (ih (splits_of_splits_mul _ (mul_ne_zero hp.1 ha0) hfi).2)
#align polynomial.splits_of_splits_id Polynomial.splits_of_splits_id
-/

end UFD

/- warning: polynomial.splits_iff_exists_multiset -> Polynomial.splits_iff_exists_multiset is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align polynomial.splits_iff_exists_multiset Polynomial.splits_iff_exists_multisetₓ'. -/
theorem splits_iff_exists_multiset {f : K[X]} :
    Splits i f ↔
      ∃ s : Multiset L, f.map i = C (i f.leadingCoeff) * (s.map fun a : L => X - C a).Prod :=
  ⟨fun hf => ⟨(f.map i).roots, eq_prod_roots_of_splits hf⟩, fun ⟨s, hs⟩ =>
    splits_of_exists_multiset i hs⟩
#align polynomial.splits_iff_exists_multiset Polynomial.splits_iff_exists_multiset

#print Polynomial.splits_comp_of_splits /-
theorem splits_comp_of_splits (j : L →+* F) {f : K[X]} (h : Splits i f) : Splits (j.comp i) f :=
  by
  change i with (RingHom.id _).comp i at h
  rw [← splits_map_iff]
  rw [← splits_map_iff i] at h
  exact splits_of_splits_id _ h
#align polynomial.splits_comp_of_splits Polynomial.splits_comp_of_splits
-/

/- warning: polynomial.splits_iff_card_roots -> Polynomial.splits_iff_card_roots is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {p : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, Iff (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) p) (Eq.{1} Nat (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.orderedCancelAddCommMonoid.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.orderedCancelAddCommMonoid.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (Multiset.{u1} K) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.orderedCancelAddCommMonoid.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.card.{u1} K) (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) p)) (Polynomial.natDegree.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) p))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {p : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))}, Iff (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) p) (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} K) => Nat) (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) p)) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} K) (fun (_x : Multiset.{u1} K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Multiset.{u1} K) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} K) Nat (AddZeroClass.toAdd.{u1} (Multiset.{u1} K) (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K))))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (Multiset.{u1} K) Nat (AddMonoid.toAddZeroClass.{u1} (Multiset.{u1} K) (AddRightCancelMonoid.toAddMonoid.{u1} (Multiset.{u1} K) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (Multiset.{u1} K) (AddCancelCommMonoid.toAddCancelMonoid.{u1} (Multiset.{u1} K) (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} (Multiset.{u1} K) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} K)))))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (Multiset.card.{u1} K) (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) p)) (Polynomial.natDegree.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) p))
Case conversion may be inaccurate. Consider using '#align polynomial.splits_iff_card_roots Polynomial.splits_iff_card_rootsₓ'. -/
/-- A polynomial splits if and only if it has as many roots as its degree. -/
theorem splits_iff_card_roots {p : K[X]} : Splits (RingHom.id K) p ↔ p.roots.card = p.natDegree :=
  by
  constructor
  · intro H; rw [nat_degree_eq_card_roots H, map_id]
  · intro hroots
    rw [splits_iff_exists_multiset (RingHom.id K)]
    use p.roots
    simp only [RingHom.id_apply, map_id]
    exact (C_leading_coeff_mul_prod_multiset_X_sub_C hroots).symm
#align polynomial.splits_iff_card_roots Polynomial.splits_iff_card_roots

#print Polynomial.aeval_root_derivative_of_splits /-
theorem aeval_root_derivative_of_splits [Algebra K L] {P : K[X]} (hmo : P.Monic)
    (hP : P.Splits (algebraMap K L)) {r : L} (hr : r ∈ (P.map (algebraMap K L)).roots) :
    aeval r P.derivative = (((P.map <| algebraMap K L).roots.eraseₓ r).map fun a => r - a).Prod :=
  by
  replace hmo := hmo.map (algebraMap K L)
  replace hP := (splits_id_iff_splits (algebraMap K L)).2 hP
  rw [aeval_def, ← eval_map, ← derivative_map]
  nth_rw 1 [eq_prod_roots_of_monic_of_splits_id hmo hP]
  rw [eval_multiset_prod_X_sub_C_derivative hr]
#align polynomial.aeval_root_derivative_of_splits Polynomial.aeval_root_derivative_of_splits
-/

/- warning: polynomial.prod_roots_eq_coeff_zero_of_monic_of_split -> Polynomial.prod_roots_eq_coeff_zero_of_monic_of_split is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {P : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, (Polynomial.Monic.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) P) -> (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) P) -> (Eq.{succ u1} K (Polynomial.coeff.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) P (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (Ring.toMonoid.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (Neg.neg.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))))) (Polynomial.natDegree.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) P)) (Multiset.prod.{u1} K (CommRing.toCommMonoid.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))) (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) P))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {P : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))}, (Polynomial.Monic.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) P) -> (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) P) -> (Eq.{succ u1} K (Polynomial.coeff.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) P (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (Semiring.toOne.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (Polynomial.natDegree.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) P)) (Multiset.prod.{u1} K (CommRing.toCommMonoid.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))) (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) P))))
Case conversion may be inaccurate. Consider using '#align polynomial.prod_roots_eq_coeff_zero_of_monic_of_split Polynomial.prod_roots_eq_coeff_zero_of_monic_of_splitₓ'. -/
/-- If `P` is a monic polynomial that splits, then `coeff P 0` equals the product of the roots. -/
theorem prod_roots_eq_coeff_zero_of_monic_of_split {P : K[X]} (hmo : P.Monic)
    (hP : P.Splits (RingHom.id K)) : coeff P 0 = (-1) ^ P.natDegree * P.roots.Prod :=
  by
  nth_rw 1 [eq_prod_roots_of_monic_of_splits_id hmo hP]
  rw [coeff_zero_eq_eval_zero, eval_multiset_prod, Multiset.map_map]
  simp_rw [Function.comp_apply, eval_sub, eval_X, zero_sub, eval_C]
  conv_lhs =>
    congr
    congr
    ext
    rw [neg_eq_neg_one_mul]
  rw [Multiset.prod_map_mul, Multiset.map_const, Multiset.prod_replicate, Multiset.map_id',
    splits_iff_card_roots.1 hP]
#align polynomial.prod_roots_eq_coeff_zero_of_monic_of_split Polynomial.prod_roots_eq_coeff_zero_of_monic_of_split

/- warning: polynomial.sum_roots_eq_next_coeff_of_monic_of_split -> Polynomial.sum_roots_eq_nextCoeff_of_monic_of_split is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {P : Polynomial.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))}, (Polynomial.Monic.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) P) -> (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) P) -> (Eq.{succ u1} K (Polynomial.nextCoeff.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) P) (Neg.neg.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (AddCommGroupWithOne.toAddGroupWithOne.{u1} K (Ring.toAddCommGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))) (Multiset.sum.{u1} K (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) P))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {P : Polynomial.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))}, (Polynomial.Monic.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) P) -> (Polynomial.Splits.{u1, u1} K K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) _inst_1 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) P) -> (Eq.{succ u1} K (Polynomial.nextCoeff.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) P) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Multiset.sum.{u1} K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Field.isDomain.{u1} K _inst_1) P))))
Case conversion may be inaccurate. Consider using '#align polynomial.sum_roots_eq_next_coeff_of_monic_of_split Polynomial.sum_roots_eq_nextCoeff_of_monic_of_splitₓ'. -/
/-- If `P` is a monic polynomial that splits, then `P.next_coeff` equals the sum of the roots. -/
theorem sum_roots_eq_nextCoeff_of_monic_of_split {P : K[X]} (hmo : P.Monic)
    (hP : P.Splits (RingHom.id K)) : P.nextCoeff = -P.roots.Sum :=
  by
  nth_rw 1 [eq_prod_roots_of_monic_of_splits_id hmo hP]
  rw [monic.next_coeff_multiset_prod _ _ fun a ha => _]
  · simp_rw [next_coeff_X_sub_C, Multiset.sum_map_neg']
  · exact monic_X_sub_C a
#align polynomial.sum_roots_eq_next_coeff_of_monic_of_split Polynomial.sum_roots_eq_nextCoeff_of_monic_of_split

end Splits

end Polynomial

