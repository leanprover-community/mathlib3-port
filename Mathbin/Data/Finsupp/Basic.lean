/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Scott Morrison

! This file was ported from Lean 3 source module data.finsupp.basic
! leanprover-community/mathlib commit 740acc0e6f9adf4423f92a485d0456fc271482da
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.BigOperators.Finsupp
import Mathbin.Algebra.Hom.GroupAction
import Mathbin.Algebra.Regular.Smul
import Mathbin.Data.Finset.Preimage
import Mathbin.Data.Rat.BigOperators

/-!
# Miscellaneous definitions, lemmas, and constructions using finsupp

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main declarations

* `finsupp.graph`: the finset of input and output pairs with non-zero outputs.
* `finsupp.map_range.equiv`: `finsupp.map_range` as an equiv.
* `finsupp.map_domain`: maps the domain of a `finsupp` by a function and by summing.
* `finsupp.comap_domain`: postcomposition of a `finsupp` with a function injective on the preimage
  of its support.
* `finsupp.some`: restrict a finitely supported function on `option α` to a finitely supported
  function on `α`.
* `finsupp.filter`: `filter p f` is the finitely supported function that is `f a` if `p a` is true
  and 0 otherwise.
* `finsupp.frange`: the image of a finitely supported function on its support.
* `finsupp.subtype_domain`: the restriction of a finitely supported function `f` to a subtype.

## Implementation notes

This file is a `noncomputable theory` and uses classical logic throughout.

## TODO

* This file is currently ~1600 lines long and is quite a miscellany of definitions and lemmas,
  so it should be divided into smaller pieces.

* Expand the list of definitions and important lemmas to the module docstring.

-/


noncomputable section

open Finset Function

open BigOperators

variable {α β γ ι M M' N P G H R S : Type _}

namespace Finsupp

/-! ### Declarations about `graph` -/


section Graph

variable [Zero M]

#print Finsupp.graph /-
/-- The graph of a finitely supported function over its support, i.e. the finset of input and output
pairs with non-zero outputs. -/
def graph (f : α →₀ M) : Finset (α × M) :=
  f.support.map ⟨fun a => Prod.mk a (f a), fun x y h => (Prod.mk.inj h).1⟩
#align finsupp.graph Finsupp.graph
-/

/- warning: finsupp.mk_mem_graph_iff -> Finsupp.mk_mem_graph_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {a : α} {m : M} {f : Finsupp.{u1, u2} α M _inst_1}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} α M) (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finset.hasMem.{max u1 u2} (Prod.{u1, u2} α M)) (Prod.mk.{u1, u2} α M a m) (Finsupp.graph.{u1, u2} α M _inst_1 f)) (And (Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f a) m) (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {a : α} {m : M} {f : Finsupp.{u2, u1} α M _inst_1}, Iff (Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} α M) (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finset.instMembershipFinset.{max u2 u1} (Prod.{u2, u1} α M)) (Prod.mk.{u2, u1} α M a m) (Finsupp.graph.{u2, u1} α M _inst_1 f)) (And (Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f a) m) (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.mk_mem_graph_iff Finsupp.mk_mem_graph_iffₓ'. -/
theorem mk_mem_graph_iff {a : α} {m : M} {f : α →₀ M} : (a, m) ∈ f.graph ↔ f a = m ∧ m ≠ 0 :=
  by
  simp_rw [graph, mem_map, mem_support_iff]
  constructor
  · rintro ⟨b, ha, rfl, -⟩
    exact ⟨rfl, ha⟩
  · rintro ⟨rfl, ha⟩
    exact ⟨a, ha, rfl⟩
#align finsupp.mk_mem_graph_iff Finsupp.mk_mem_graph_iff

/- warning: finsupp.mem_graph_iff -> Finsupp.mem_graph_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {c : Prod.{u1, u2} α M} {f : Finsupp.{u1, u2} α M _inst_1}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} α M) (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finset.hasMem.{max u1 u2} (Prod.{u1, u2} α M)) c (Finsupp.graph.{u1, u2} α M _inst_1 f)) (And (Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f (Prod.fst.{u1, u2} α M c)) (Prod.snd.{u1, u2} α M c)) (Ne.{succ u2} M (Prod.snd.{u1, u2} α M c) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {c : Prod.{u2, u1} α M} {f : Finsupp.{u2, u1} α M _inst_1}, Iff (Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} α M) (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finset.instMembershipFinset.{max u2 u1} (Prod.{u2, u1} α M)) c (Finsupp.graph.{u2, u1} α M _inst_1 f)) (And (Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) (Prod.fst.{u2, u1} α M c)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f (Prod.fst.{u2, u1} α M c)) (Prod.snd.{u2, u1} α M c)) (Ne.{succ u1} M (Prod.snd.{u2, u1} α M c) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_graph_iff Finsupp.mem_graph_iffₓ'. -/
@[simp]
theorem mem_graph_iff {c : α × M} {f : α →₀ M} : c ∈ f.graph ↔ f c.1 = c.2 ∧ c.2 ≠ 0 :=
  by
  cases c
  exact mk_mem_graph_iff
#align finsupp.mem_graph_iff Finsupp.mem_graph_iff

/- warning: finsupp.mk_mem_graph -> Finsupp.mk_mem_graph is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (f : Finsupp.{u1, u2} α M _inst_1) {a : α}, (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.support.{u1, u2} α M _inst_1 f)) -> (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} α M) (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finset.hasMem.{max u1 u2} (Prod.{u1, u2} α M)) (Prod.mk.{u1, u2} α M a (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f a)) (Finsupp.graph.{u1, u2} α M _inst_1 f))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : Finsupp.{u2, u1} α M _inst_1) {a : α}, (Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) a (Finsupp.support.{u2, u1} α M _inst_1 f)) -> (Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} α ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a)) (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finset.instMembershipFinset.{max u2 u1} (Prod.{u2, u1} α M)) (Prod.mk.{u2, u1} α ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) a (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f a)) (Finsupp.graph.{u2, u1} α M _inst_1 f))
Case conversion may be inaccurate. Consider using '#align finsupp.mk_mem_graph Finsupp.mk_mem_graphₓ'. -/
theorem mk_mem_graph (f : α →₀ M) {a : α} (ha : a ∈ f.support) : (a, f a) ∈ f.graph :=
  mk_mem_graph_iff.2 ⟨rfl, mem_support_iff.1 ha⟩
#align finsupp.mk_mem_graph Finsupp.mk_mem_graph

/- warning: finsupp.apply_eq_of_mem_graph -> Finsupp.apply_eq_of_mem_graph is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {a : α} {m : M} {f : Finsupp.{u1, u2} α M _inst_1}, (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} α M) (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finset.hasMem.{max u1 u2} (Prod.{u1, u2} α M)) (Prod.mk.{u1, u2} α M a m) (Finsupp.graph.{u1, u2} α M _inst_1 f)) -> (Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f a) m)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {a : α} {m : M} {f : Finsupp.{u2, u1} α M _inst_1}, (Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} α M) (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finset.instMembershipFinset.{max u2 u1} (Prod.{u2, u1} α M)) (Prod.mk.{u2, u1} α M a m) (Finsupp.graph.{u2, u1} α M _inst_1 f)) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f a) m)
Case conversion may be inaccurate. Consider using '#align finsupp.apply_eq_of_mem_graph Finsupp.apply_eq_of_mem_graphₓ'. -/
theorem apply_eq_of_mem_graph {a : α} {m : M} {f : α →₀ M} (h : (a, m) ∈ f.graph) : f a = m :=
  (mem_graph_iff.1 h).1
#align finsupp.apply_eq_of_mem_graph Finsupp.apply_eq_of_mem_graph

/- warning: finsupp.not_mem_graph_snd_zero -> Finsupp.not_mem_graph_snd_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (a : α) (f : Finsupp.{u1, u2} α M _inst_1), Not (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} α M) (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finset.hasMem.{max u1 u2} (Prod.{u1, u2} α M)) (Prod.mk.{u1, u2} α M a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Finsupp.graph.{u1, u2} α M _inst_1 f))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (a : α) (f : Finsupp.{u2, u1} α M _inst_1), Not (Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} α M) (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finset.instMembershipFinset.{max u2 u1} (Prod.{u2, u1} α M)) (Prod.mk.{u2, u1} α M a (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_1))) (Finsupp.graph.{u2, u1} α M _inst_1 f))
Case conversion may be inaccurate. Consider using '#align finsupp.not_mem_graph_snd_zero Finsupp.not_mem_graph_snd_zeroₓ'. -/
@[simp]
theorem not_mem_graph_snd_zero (a : α) (f : α →₀ M) : (a, (0 : M)) ∉ f.graph := fun h =>
  (mem_graph_iff.1 h).2.irrefl
#align finsupp.not_mem_graph_snd_zero Finsupp.not_mem_graph_snd_zero

/- warning: finsupp.image_fst_graph -> Finsupp.image_fst_graph is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] [_inst_2 : DecidableEq.{succ u1} α] (f : Finsupp.{u1, u2} α M _inst_1), Eq.{succ u1} (Finset.{u1} α) (Finset.image.{max u1 u2, u1} (Prod.{u1, u2} α M) α (fun (a : α) (b : α) => _inst_2 a b) (Prod.fst.{u1, u2} α M) (Finsupp.graph.{u1, u2} α M _inst_1 f)) (Finsupp.support.{u1, u2} α M _inst_1 f)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] [_inst_2 : DecidableEq.{succ u2} α] (f : Finsupp.{u2, u1} α M _inst_1), Eq.{succ u2} (Finset.{u2} α) (Finset.image.{max u1 u2, u2} (Prod.{u2, u1} α M) α (fun (a : α) (b : α) => _inst_2 a b) (Prod.fst.{u2, u1} α M) (Finsupp.graph.{u2, u1} α M _inst_1 f)) (Finsupp.support.{u2, u1} α M _inst_1 f)
Case conversion may be inaccurate. Consider using '#align finsupp.image_fst_graph Finsupp.image_fst_graphₓ'. -/
@[simp]
theorem image_fst_graph [DecidableEq α] (f : α →₀ M) : f.graph.image Prod.fst = f.support := by
  classical simp only [graph, map_eq_image, image_image, embedding.coe_fn_mk, (· ∘ ·), image_id']
#align finsupp.image_fst_graph Finsupp.image_fst_graph

/- warning: finsupp.graph_injective -> Finsupp.graph_injective is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (M : Type.{u2}) [_inst_2 : Zero.{u2} M], Function.Injective.{max (succ u1) (succ u2), succ (max u1 u2)} (Finsupp.{u1, u2} α M _inst_2) (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finsupp.graph.{u1, u2} α M _inst_2)
but is expected to have type
  forall (α : Type.{u2}) (M : Type.{u1}) [_inst_2 : Zero.{u1} M], Function.Injective.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u2, u1} α M _inst_2) (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finsupp.graph.{u2, u1} α M _inst_2)
Case conversion may be inaccurate. Consider using '#align finsupp.graph_injective Finsupp.graph_injectiveₓ'. -/
theorem graph_injective (α M) [Zero M] : Injective (@graph α M _) :=
  by
  intro f g h
  classical
    have hsup : f.support = g.support := by rw [← image_fst_graph, h, image_fst_graph]
    refine' ext_iff'.2 ⟨hsup, fun x hx => apply_eq_of_mem_graph <| h.symm ▸ _⟩
    exact mk_mem_graph _ (hsup ▸ hx)
#align finsupp.graph_injective Finsupp.graph_injective

/- warning: finsupp.graph_inj -> Finsupp.graph_inj is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {f : Finsupp.{u1, u2} α M _inst_1} {g : Finsupp.{u1, u2} α M _inst_1}, Iff (Eq.{succ (max u1 u2)} (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finsupp.graph.{u1, u2} α M _inst_1 f) (Finsupp.graph.{u1, u2} α M _inst_1 g)) (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) f g)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {f : Finsupp.{u2, u1} α M _inst_1} {g : Finsupp.{u2, u1} α M _inst_1}, Iff (Eq.{max (succ u2) (succ u1)} (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finsupp.graph.{u2, u1} α M _inst_1 f) (Finsupp.graph.{u2, u1} α M _inst_1 g)) (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M _inst_1) f g)
Case conversion may be inaccurate. Consider using '#align finsupp.graph_inj Finsupp.graph_injₓ'. -/
@[simp]
theorem graph_inj {f g : α →₀ M} : f.graph = g.graph ↔ f = g :=
  (graph_injective α M).eq_iff
#align finsupp.graph_inj Finsupp.graph_inj

/- warning: finsupp.graph_zero -> Finsupp.graph_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M], Eq.{succ (max u1 u2)} (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finsupp.graph.{u1, u2} α M _inst_1 (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1))))) (EmptyCollection.emptyCollection.{max u1 u2} (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finset.hasEmptyc.{max u1 u2} (Prod.{u1, u2} α M)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M], Eq.{max (succ u2) (succ u1)} (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finsupp.graph.{u2, u1} α M _inst_1 (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1)))) (EmptyCollection.emptyCollection.{max u2 u1} (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finset.instEmptyCollectionFinset.{max u2 u1} (Prod.{u2, u1} α M)))
Case conversion may be inaccurate. Consider using '#align finsupp.graph_zero Finsupp.graph_zeroₓ'. -/
@[simp]
theorem graph_zero : graph (0 : α →₀ M) = ∅ := by simp [graph]
#align finsupp.graph_zero Finsupp.graph_zero

/- warning: finsupp.graph_eq_empty -> Finsupp.graph_eq_empty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {f : Finsupp.{u1, u2} α M _inst_1}, Iff (Eq.{succ (max u1 u2)} (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finsupp.graph.{u1, u2} α M _inst_1 f) (EmptyCollection.emptyCollection.{max u1 u2} (Finset.{max u1 u2} (Prod.{u1, u2} α M)) (Finset.hasEmptyc.{max u1 u2} (Prod.{u1, u2} α M)))) (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) f (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1)))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {f : Finsupp.{u2, u1} α M _inst_1}, Iff (Eq.{max (succ u2) (succ u1)} (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finsupp.graph.{u2, u1} α M _inst_1 f) (EmptyCollection.emptyCollection.{max u2 u1} (Finset.{max u1 u2} (Prod.{u2, u1} α M)) (Finset.instEmptyCollectionFinset.{max u2 u1} (Prod.{u2, u1} α M)))) (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M _inst_1) f (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.graph_eq_empty Finsupp.graph_eq_emptyₓ'. -/
@[simp]
theorem graph_eq_empty {f : α →₀ M} : f.graph = ∅ ↔ f = 0 :=
  (graph_injective α M).eq_iff' graph_zero
#align finsupp.graph_eq_empty Finsupp.graph_eq_empty

end Graph

end Finsupp

/-! ### Declarations about `map_range` -/


section MapRange

namespace Finsupp

section Equiv

variable [Zero M] [Zero N] [Zero P]

#print Finsupp.mapRange.equiv /-
/-- `finsupp.map_range` as an equiv. -/
@[simps apply]
def mapRange.equiv (f : M ≃ N) (hf : f 0 = 0) (hf' : f.symm 0 = 0) : (α →₀ M) ≃ (α →₀ N)
    where
  toFun := (mapRange f hf : (α →₀ M) → α →₀ N)
  invFun := (mapRange f.symm hf' : (α →₀ N) → α →₀ M)
  left_inv x := by
    rw [← map_range_comp _ _ _ _] <;> simp_rw [Equiv.symm_comp_self]
    · exact map_range_id _
    · rfl
  right_inv x := by
    rw [← map_range_comp _ _ _ _] <;> simp_rw [Equiv.self_comp_symm]
    · exact map_range_id _
    · rfl
#align finsupp.map_range.equiv Finsupp.mapRange.equiv
-/

/- warning: finsupp.map_range.equiv_refl -> Finsupp.mapRange.equiv_refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M], Eq.{max 1 (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.{u1, u2} α M _inst_1)) (Finsupp.mapRange.equiv.{u1, u2, u2} α M M _inst_1 _inst_1 (Equiv.refl.{succ u2} M) (rfl.{succ u2} M (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} M M) (fun (_x : Equiv.{succ u2, succ u2} M M) => M -> M) (Equiv.hasCoeToFun.{succ u2, succ u2} M M) (Equiv.refl.{succ u2} M) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (rfl.{succ u2} M (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} M M) (fun (_x : Equiv.{succ u2, succ u2} M M) => M -> M) (Equiv.hasCoeToFun.{succ u2, succ u2} M M) (Equiv.symm.{succ u2, succ u2} M M (Equiv.refl.{succ u2} M)) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))))) (Equiv.refl.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M], Eq.{max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.{u2, u1} α M _inst_1)) (Finsupp.mapRange.equiv.{u2, u1, u1} α M M _inst_1 _inst_1 (Equiv.refl.{succ u1} M) (rfl.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => M) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} M M) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => M) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} M M) (Equiv.refl.{succ u1} M) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_1)))) (rfl.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => M) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} M M) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => M) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} M M) (Equiv.symm.{succ u1, succ u1} M M (Equiv.refl.{succ u1} M)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_1))))) (Equiv.refl.{max (succ u1) (succ u2)} (Finsupp.{u2, u1} α M _inst_1))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.equiv_refl Finsupp.mapRange.equiv_reflₓ'. -/
@[simp]
theorem mapRange.equiv_refl : mapRange.equiv (Equiv.refl M) rfl rfl = Equiv.refl (α →₀ M) :=
  Equiv.ext mapRange_id
#align finsupp.map_range.equiv_refl Finsupp.mapRange.equiv_refl

/- warning: finsupp.map_range.equiv_trans -> Finsupp.mapRange.equiv_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_1 : Zero.{u2} M] [_inst_2 : Zero.{u3} N] [_inst_3 : Zero.{u4} P] (f : Equiv.{succ u2, succ u3} M N) (hf : Eq.{succ u3} N (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (hf' : Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (f₂ : Equiv.{succ u3, succ u4} N P) (hf₂ : Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (hf₂' : Eq.{succ u3} N (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P N) (fun (_x : Equiv.{succ u4, succ u3} P N) => P -> N) (Equiv.hasCoeToFun.{succ u4, succ u3} P N) (Equiv.symm.{succ u3, succ u4} N P f₂) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))), Eq.{max 1 (max (max (succ u1) (succ u2)) (succ u1) (succ u4)) (max (succ u1) (succ u4)) (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u4)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.{u1, u4} α P _inst_3)) (Finsupp.mapRange.equiv.{u1, u2, u4} α M P _inst_1 _inst_3 (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂) (Eq.mpr.{0} (Eq.{succ u4} P (coeFn.{max 1 (max (succ u2) (succ u4)) (succ u4) (succ u2), max (succ u2) (succ u4)} (Equiv.{succ u2, succ u4} M P) (fun (_x : Equiv.{succ u2, succ u4} M P) => M -> P) (Equiv.hasCoeToFun.{succ u2, succ u4} M P) (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Eq.{succ u4} P (coeFn.{max 1 (max (succ u2) (succ u4)) (succ u4) (succ u2), max (succ u2) (succ u4)} (Equiv.{succ u2, succ u4} M P) (fun (_x : Equiv.{succ u2, succ u4} M P) => M -> P) (Equiv.hasCoeToFun.{succ u2, succ u4} M P) (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (Eq.ndrec.{0, succ u4} P (coeFn.{max 1 (max (succ u2) (succ u4)) (succ u4) (succ u2), max (succ u2) (succ u4)} (Equiv.{succ u2, succ u4} M P) (fun (_x : Equiv.{succ u2, succ u4} M P) => M -> P) (Equiv.hasCoeToFun.{succ u2, succ u4} M P) (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (fun (_a : P) => Eq.{1} Prop (Eq.{succ u4} P (coeFn.{max 1 (max (succ u2) (succ u4)) (succ u4) (succ u2), max (succ u2) (succ u4)} (Equiv.{succ u2, succ u4} M P) (fun (_x : Equiv.{succ u2, succ u4} M P) => M -> P) (Equiv.hasCoeToFun.{succ u2, succ u4} M P) (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (Eq.{succ u4} P _a (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (rfl.{1} Prop (Eq.{succ u4} P (coeFn.{max 1 (max (succ u2) (succ u4)) (succ u4) (succ u2), max (succ u2) (succ u4)} (Equiv.{succ u2, succ u4} M P) (fun (_x : Equiv.{succ u2, succ u4} M P) => M -> P) (Equiv.hasCoeToFun.{succ u2, succ u4} M P) (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (Equiv.trans_apply.{succ u2, succ u3, succ u4} M N P f f₂ (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))))) (Eq.mpr.{0} (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (Eq.ndrec.{0, succ u3} N (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (fun (_a : N) => Eq.{1} Prop (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ _a) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (rfl.{1} Prop (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2))) hf)) (Eq.mpr.{0} (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (Eq.{succ u4} P (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (Eq.{succ u4} P (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (Eq.ndrec.{0, succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (fun (_a : P) => Eq.{1} Prop (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (Eq.{succ u4} P _a (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (rfl.{1} Prop (Eq.{succ u4} P (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} N P) (fun (_x : Equiv.{succ u3, succ u4} N P) => N -> P) (Equiv.hasCoeToFun.{succ u3, succ u4} N P) f₂ (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))) hf₂)) (rfl.{succ u4} P (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))))) (Eq.mpr.{0} (Eq.{succ u2} M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} P M) (fun (_x : Equiv.{succ u4, succ u2} P M) => P -> M) (Equiv.hasCoeToFun.{succ u4, succ u2} P M) (Equiv.symm.{succ u2, succ u4} M P (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂)) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P N) (fun (_x : Equiv.{succ u4, succ u3} P N) => P -> N) (Equiv.hasCoeToFun.{succ u4, succ u3} P N) (Equiv.symm.{succ u3, succ u4} N P f₂) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Eq.{succ u2} M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} P M) (fun (_x : Equiv.{succ u4, succ u2} P M) => P -> M) (Equiv.hasCoeToFun.{succ u4, succ u2} P M) (Equiv.symm.{succ u2, succ u4} M P (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂)) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P N) (fun (_x : Equiv.{succ u4, succ u3} P N) => P -> N) (Equiv.hasCoeToFun.{succ u4, succ u3} P N) (Equiv.symm.{succ u3, succ u4} N P f₂) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (Eq.ndrec.{0, succ u2} M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} P M) (fun (_x : Equiv.{succ u4, succ u2} P M) => P -> M) (Equiv.hasCoeToFun.{succ u4, succ u2} P M) (Equiv.symm.{succ u2, succ u4} M P (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂)) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (fun (_a : M) => Eq.{1} Prop (Eq.{succ u2} M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} P M) (fun (_x : Equiv.{succ u4, succ u2} P M) => P -> M) (Equiv.hasCoeToFun.{succ u4, succ u2} P M) (Equiv.symm.{succ u2, succ u4} M P (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂)) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Eq.{succ u2} M _a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (rfl.{1} Prop (Eq.{succ u2} M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} P M) (fun (_x : Equiv.{succ u4, succ u2} P M) => P -> M) (Equiv.hasCoeToFun.{succ u4, succ u2} P M) (Equiv.symm.{succ u2, succ u4} M P (Equiv.trans.{succ u2, succ u3, succ u4} M N P f f₂)) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P N) (fun (_x : Equiv.{succ u4, succ u3} P N) => P -> N) (Equiv.hasCoeToFun.{succ u4, succ u3} P N) (Equiv.symm.{succ u3, succ u4} N P f₂) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (Equiv.symm_trans_apply.{succ u2, succ u3, succ u4} M N P f f₂ (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))))) (Eq.mpr.{0} (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P N) (fun (_x : Equiv.{succ u4, succ u3} P N) => P -> N) (Equiv.hasCoeToFun.{succ u4, succ u3} P N) (Equiv.symm.{succ u3, succ u4} N P f₂) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P N) (fun (_x : Equiv.{succ u4, succ u3} P N) => P -> N) (Equiv.hasCoeToFun.{succ u4, succ u3} P N) (Equiv.symm.{succ u3, succ u4} N P f₂) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (Eq.ndrec.{0, succ u3} N (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P N) (fun (_x : Equiv.{succ u4, succ u3} P N) => P -> N) (Equiv.hasCoeToFun.{succ u4, succ u3} P N) (Equiv.symm.{succ u3, succ u4} N P f₂) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3)))) (fun (_a : N) => Eq.{1} Prop (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P N) (fun (_x : Equiv.{succ u4, succ u3} P N) => P -> N) (Equiv.hasCoeToFun.{succ u4, succ u3} P N) (Equiv.symm.{succ u3, succ u4} N P f₂) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) _a) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (rfl.{1} Prop (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P N) (fun (_x : Equiv.{succ u4, succ u3} P N) => P -> N) (Equiv.hasCoeToFun.{succ u4, succ u3} P N) (Equiv.symm.{succ u3, succ u4} N P f₂) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_3))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2))) hf₂')) (Eq.mpr.{0} (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Eq.{succ u2} M (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Eq.{succ u2} M (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (Eq.ndrec.{0, succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (fun (_a : M) => Eq.{1} Prop (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Eq.{succ u2} M _a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (rfl.{1} Prop (Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))) hf')) (rfl.{succ u2} M (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))))))) (Equiv.trans.{max (succ u1) (succ u2), max (succ u1) (succ u3), max (succ u1) (succ u4)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.{u1, u3} α N _inst_2) (Finsupp.{u1, u4} α P _inst_3) (Finsupp.mapRange.equiv.{u1, u2, u3} α M N _inst_1 _inst_2 f hf hf') (Finsupp.mapRange.equiv.{u1, u3, u4} α N P _inst_2 _inst_3 f₂ hf₂ hf₂'))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} {P : Type.{u2}} [_inst_1 : Zero.{u4} M] [_inst_2 : Zero.{u3} N] [_inst_3 : Zero.{u2} P] (f : Equiv.{succ u4, succ u3} M N) (hf : Eq.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M N) f (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_2))) (hf' : Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_1))) (f₂ : Equiv.{succ u3, succ u2} N P) (hf₂ : Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_3))) (hf₂' : Eq.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} P N) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} P N) (Equiv.symm.{succ u3, succ u2} N P f₂) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_2))), Eq.{max (max (succ u1) (succ u4)) (succ u2)} (Equiv.{max (succ u4) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u1, u4} α M _inst_1) (Finsupp.{u1, u2} α P _inst_3)) (Finsupp.mapRange.equiv.{u1, u4, u2} α M P _inst_1 _inst_3 (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂) (Eq.mpr.{0} (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (Equiv.{succ u4, succ u2} M P) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u2} M P) (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M N) f (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (id.{0} (Eq.{1} Prop (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (Equiv.{succ u4, succ u2} M P) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u2} M P) (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M N) f (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3)))) (Eq.ndrec.{0, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (Equiv.{succ u4, succ u2} M P) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u2} M P) (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (fun (_a : (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) => Eq.{1} Prop (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (Equiv.{succ u4, succ u2} M P) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u2} M P) (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _a (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3)))) (Eq.refl.{1} Prop (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (Equiv.{succ u4, succ u2} M P) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u2} M P) (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3)))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M N) f (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1)))) (Equiv.trans_apply.{succ u4, succ u3, succ u2} M N P f f₂ (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))))) (Eq.mpr.{0} (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M N) f (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_2))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (id.{0} (Eq.{1} Prop (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M N) f (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_2))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3)))) (Eq.ndrec.{0, succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M N) f (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (fun (_a : (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) => Eq.{1} Prop (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M N) f (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ _a) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3)))) (Eq.refl.{1} Prop (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} M N) f (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3)))) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_2)) hf)) (Eq.mpr.{0} (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_2))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_3)) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (id.{0} (Eq.{1} Prop (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_2))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_3)) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3)))) (Eq.ndrec.{0, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) (fun (_a : (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) => Eq.{1} Prop (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_2))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3))) (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _a (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3)))) (Eq.refl.{1} Prop (Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} N P) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} N P) f₂ (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_2))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) _inst_3)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_3)) hf₂)) (Eq.refl.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => P) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_1))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => P) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_3)))))) (Eq.mpr.{0} (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u2), succ u2, succ u4} (Equiv.{succ u2, succ u4} P M) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u4} P M) (Equiv.symm.{succ u4, succ u2} M P (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂)) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} P N) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} P N) (Equiv.symm.{succ u3, succ u2} N P f₂) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3)))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (id.{0} (Eq.{1} Prop (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u2), succ u2, succ u4} (Equiv.{succ u2, succ u4} P M) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u4} P M) (Equiv.symm.{succ u4, succ u2} M P (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂)) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} P N) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} P N) (Equiv.symm.{succ u3, succ u2} N P f₂) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3)))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1)))) (Eq.ndrec.{0, succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u2), succ u2, succ u4} (Equiv.{succ u2, succ u4} P M) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u4} P M) (Equiv.symm.{succ u4, succ u2} M P (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂)) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (fun (_a : (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) => Eq.{1} Prop (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u2), succ u2, succ u4} (Equiv.{succ u2, succ u4} P M) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u4} P M) (Equiv.symm.{succ u4, succ u2} M P (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂)) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _a (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1)))) (Eq.refl.{1} Prop (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u2), succ u2, succ u4} (Equiv.{succ u2, succ u4} P M) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u4} P M) (Equiv.symm.{succ u4, succ u2} M P (Equiv.trans.{succ u4, succ u3, succ u2} M N P f f₂)) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1)))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} P N) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} P N) (Equiv.symm.{succ u3, succ u2} N P f₂) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3)))) (Equiv.symm_trans_apply.{succ u4, succ u3, succ u2} M N P f f₂ (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))))) (Eq.mpr.{0} (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} P N) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} P N) (Equiv.symm.{succ u3, succ u2} N P f₂) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3)))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_2))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (id.{0} (Eq.{1} Prop (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} P N) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} P N) (Equiv.symm.{succ u3, succ u2} N P f₂) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3)))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_2))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1)))) (Eq.ndrec.{0, succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} P N) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} P N) (Equiv.symm.{succ u3, succ u2} N P f₂) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (fun (_a : (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) => Eq.{1} Prop (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} P N) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} P N) (Equiv.symm.{succ u3, succ u2} N P f₂) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3)))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) _a) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1)))) (Eq.refl.{1} Prop (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} P N) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} P N) (Equiv.symm.{succ u3, succ u2} N P f₂) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3)))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1)))) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_2)) hf₂')) (Eq.mpr.{0} (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_2))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_1)) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (id.{0} (Eq.{1} Prop (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_2))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_1)) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1)))) (Eq.ndrec.{0, succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) (fun (_a : (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) => Eq.{1} Prop (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_2))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1))) (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _a (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1)))) (Eq.refl.{1} Prop (Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (Equiv.{succ u3, succ u4} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} N M) (Equiv.symm.{succ u4, succ u3} M N f) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => N) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_2))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) _inst_1)))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_1)) hf')) (Eq.refl.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : P) => M) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_3))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u3} N 0 (Zero.toOfNat0.{u3} N _inst_2))) _inst_1))))))) (Equiv.trans.{max (succ u4) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u1, u4} α M _inst_1) (Finsupp.{u1, u3} α N _inst_2) (Finsupp.{u1, u2} α P _inst_3) (Finsupp.mapRange.equiv.{u1, u4, u3} α M N _inst_1 _inst_2 f hf hf') (Finsupp.mapRange.equiv.{u1, u3, u2} α N P _inst_2 _inst_3 f₂ hf₂ hf₂'))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.equiv_trans Finsupp.mapRange.equiv_transₓ'. -/
theorem mapRange.equiv_trans (f : M ≃ N) (hf : f 0 = 0) (hf') (f₂ : N ≃ P) (hf₂ : f₂ 0 = 0) (hf₂') :
    (mapRange.equiv (f.trans f₂) (by rw [Equiv.trans_apply, hf, hf₂])
          (by rw [Equiv.symm_trans_apply, hf₂', hf']) :
        (α →₀ _) ≃ _) =
      (mapRange.equiv f hf hf').trans (mapRange.equiv f₂ hf₂ hf₂') :=
  Equiv.ext <| mapRange_comp _ _ _ _ _
#align finsupp.map_range.equiv_trans Finsupp.mapRange.equiv_trans

/- warning: finsupp.map_range.equiv_symm -> Finsupp.mapRange.equiv_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : Zero.{u2} M] [_inst_2 : Zero.{u3} N] (f : Equiv.{succ u2, succ u3} M N) (hf : Eq.{succ u3} N (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} M N) (fun (_x : Equiv.{succ u2, succ u3} M N) => M -> N) (Equiv.hasCoeToFun.{succ u2, succ u3} M N) f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (hf' : Eq.{succ u2} M (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} N M) (fun (_x : Equiv.{succ u3, succ u2} N M) => N -> M) (Equiv.hasCoeToFun.{succ u3, succ u2} N M) (Equiv.symm.{succ u2, succ u3} M N f) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_2)))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))), Eq.{max 1 (max (max (succ u1) (succ u3)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u2)} (Finsupp.{u1, u3} α N _inst_2) (Finsupp.{u1, u2} α M _inst_1)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u3)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.{u1, u3} α N _inst_2) (Finsupp.mapRange.equiv.{u1, u2, u3} α M N _inst_1 _inst_2 f hf hf')) (Finsupp.mapRange.equiv.{u1, u3, u2} α N M _inst_2 _inst_1 (Equiv.symm.{succ u2, succ u3} M N f) hf' hf)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : Zero.{u3} M] [_inst_2 : Zero.{u2} N] (f : Equiv.{succ u3, succ u2} M N) (hf : Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M _inst_1))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} M N) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} M N) f (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M _inst_1))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M _inst_1))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : M) => N) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M _inst_1))) _inst_2))) (hf' : Eq.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N _inst_2))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} N M) N (fun (_x : N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} N M) (Equiv.symm.{succ u3, succ u2} M N f) (OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N _inst_2))) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N _inst_2))) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : N) => M) (OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N _inst_2))) _inst_1))), Eq.{max (max (succ u1) (succ u3)) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u1, u2} α N _inst_2) (Finsupp.{u1, u3} α M _inst_1)) (Equiv.symm.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u1, u3} α M _inst_1) (Finsupp.{u1, u2} α N _inst_2) (Finsupp.mapRange.equiv.{u1, u3, u2} α M N _inst_1 _inst_2 f hf hf')) (Finsupp.mapRange.equiv.{u1, u2, u3} α N M _inst_2 _inst_1 (Equiv.symm.{succ u3, succ u2} M N f) hf' hf)
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.equiv_symm Finsupp.mapRange.equiv_symmₓ'. -/
@[simp]
theorem mapRange.equiv_symm (f : M ≃ N) (hf hf') :
    ((mapRange.equiv f hf hf').symm : (α →₀ _) ≃ _) = mapRange.equiv f.symm hf' hf :=
  Equiv.ext fun x => rfl
#align finsupp.map_range.equiv_symm Finsupp.mapRange.equiv_symm

end Equiv

section ZeroHom

variable [Zero M] [Zero N] [Zero P]

#print Finsupp.mapRange.zeroHom /-
/-- Composition with a fixed zero-preserving homomorphism is itself an zero-preserving homomorphism
on functions. -/
@[simps]
def mapRange.zeroHom (f : ZeroHom M N) : ZeroHom (α →₀ M) (α →₀ N)
    where
  toFun := (mapRange f f.map_zero : (α →₀ M) → α →₀ N)
  map_zero' := mapRange_zero
#align finsupp.map_range.zero_hom Finsupp.mapRange.zeroHom
-/

/- warning: finsupp.map_range.zero_hom_id -> Finsupp.mapRange.zeroHom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M], Eq.{succ (max u1 u2)} (ZeroHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1)) (Finsupp.mapRange.zeroHom.{u1, u2, u2} α M M _inst_1 _inst_1 (ZeroHom.id.{u2} M _inst_1)) (ZeroHom.id.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M], Eq.{max (succ u2) (succ u1)} (ZeroHom.{max u1 u2, max u1 u2} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1)) (Finsupp.mapRange.zeroHom.{u2, u1, u1} α M M _inst_1 _inst_1 (ZeroHom.id.{u1} M _inst_1)) (ZeroHom.id.{max u1 u2} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.zero_hom_id Finsupp.mapRange.zeroHom_idₓ'. -/
@[simp]
theorem mapRange.zeroHom_id : mapRange.zeroHom (ZeroHom.id M) = ZeroHom.id (α →₀ M) :=
  ZeroHom.ext mapRange_id
#align finsupp.map_range.zero_hom_id Finsupp.mapRange.zeroHom_id

/- warning: finsupp.map_range.zero_hom_comp -> Finsupp.mapRange.zeroHom_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_1 : Zero.{u2} M] [_inst_2 : Zero.{u3} N] [_inst_3 : Zero.{u4} P] (f : ZeroHom.{u3, u4} N P _inst_2 _inst_3) (f₂ : ZeroHom.{u2, u3} M N _inst_1 _inst_2), Eq.{max (succ (max u1 u4)) (succ (max u1 u2))} (ZeroHom.{max u1 u2, max u1 u4} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.{u1, u4} α P _inst_3) (Finsupp.hasZero.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u4} α P _inst_3)) (Finsupp.mapRange.zeroHom.{u1, u2, u4} α M P _inst_1 _inst_3 (ZeroHom.comp.{u2, u3, u4} M N P _inst_1 _inst_2 _inst_3 f f₂)) (ZeroHom.comp.{max u1 u2, max u1 u3, max u1 u4} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.{u1, u3} α N _inst_2) (Finsupp.{u1, u4} α P _inst_3) (Finsupp.hasZero.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u3} α N _inst_2) (Finsupp.hasZero.{u1, u4} α P _inst_3) (Finsupp.mapRange.zeroHom.{u1, u3, u4} α N P _inst_2 _inst_3 f) (Finsupp.mapRange.zeroHom.{u1, u2, u3} α M N _inst_1 _inst_2 f₂))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u4}} {P : Type.{u3}} [_inst_1 : Zero.{u2} M] [_inst_2 : Zero.{u4} N] [_inst_3 : Zero.{u3} P] (f : ZeroHom.{u4, u3} N P _inst_2 _inst_3) (f₂ : ZeroHom.{u2, u4} M N _inst_1 _inst_2), Eq.{max (max (succ u1) (succ u2)) (succ u3)} (ZeroHom.{max u2 u1, max u3 u1} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.{u1, u3} α P _inst_3) (Finsupp.zero.{u1, u2} α M _inst_1) (Finsupp.zero.{u1, u3} α P _inst_3)) (Finsupp.mapRange.zeroHom.{u1, u2, u3} α M P _inst_1 _inst_3 (ZeroHom.comp.{u2, u4, u3} M N P _inst_1 _inst_2 _inst_3 f f₂)) (ZeroHom.comp.{max u2 u1, max u4 u1, max u3 u1} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.{u1, u4} α N _inst_2) (Finsupp.{u1, u3} α P _inst_3) (Finsupp.zero.{u1, u2} α M _inst_1) (Finsupp.zero.{u1, u4} α N _inst_2) (Finsupp.zero.{u1, u3} α P _inst_3) (Finsupp.mapRange.zeroHom.{u1, u4, u3} α N P _inst_2 _inst_3 f) (Finsupp.mapRange.zeroHom.{u1, u2, u4} α M N _inst_1 _inst_2 f₂))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.zero_hom_comp Finsupp.mapRange.zeroHom_compₓ'. -/
theorem mapRange.zeroHom_comp (f : ZeroHom N P) (f₂ : ZeroHom M N) :
    (mapRange.zeroHom (f.comp f₂) : ZeroHom (α →₀ _) _) =
      (mapRange.zeroHom f).comp (mapRange.zeroHom f₂) :=
  ZeroHom.ext <| mapRange_comp _ _ _ _ _
#align finsupp.map_range.zero_hom_comp Finsupp.mapRange.zeroHom_comp

end ZeroHom

section AddMonoidHom

variable [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]

/- warning: finsupp.map_range.add_monoid_hom -> Finsupp.mapRange.addMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N], (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) -> (AddMonoidHom.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N], (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) -> (AddMonoidHom.{max u2 u1, max u3 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_monoid_hom Finsupp.mapRange.addMonoidHomₓ'. -/
/-- Composition with a fixed additive homomorphism is itself an additive homomorphism on functions.
-/
@[simps]
def mapRange.addMonoidHom (f : M →+ N) : (α →₀ M) →+ α →₀ N
    where
  toFun := (mapRange f f.map_zero : (α →₀ M) → α →₀ N)
  map_zero' := mapRange_zero
  map_add' a b := mapRange_add f.map_add _ _
#align finsupp.map_range.add_monoid_hom Finsupp.mapRange.addMonoidHom

/- warning: finsupp.map_range.add_monoid_hom_id -> Finsupp.mapRange.addMonoidHom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M], Eq.{succ (max u1 u2)} (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.mapRange.addMonoidHom.{u1, u2, u2} α M M _inst_1 _inst_1 (AddMonoidHom.id.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (AddMonoidHom.id.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M], Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.addZeroClass.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.addZeroClass.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))) (Finsupp.mapRange.addMonoidHom.{u2, u1, u1} α M M _inst_1 _inst_1 (AddMonoidHom.id.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))) (AddMonoidHom.id.{max u1 u2} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.addZeroClass.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_monoid_hom_id Finsupp.mapRange.addMonoidHom_idₓ'. -/
@[simp]
theorem mapRange.addMonoidHom_id :
    mapRange.addMonoidHom (AddMonoidHom.id M) = AddMonoidHom.id (α →₀ M) :=
  AddMonoidHom.ext mapRange_id
#align finsupp.map_range.add_monoid_hom_id Finsupp.mapRange.addMonoidHom_id

/- warning: finsupp.map_range.add_monoid_hom_comp -> Finsupp.mapRange.addMonoidHom_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N] [_inst_3 : AddCommMonoid.{u4} P] (f : AddMonoidHom.{u3, u4} N P (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3))) (f₂ : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))), Eq.{max (succ (max u1 u4)) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, max u1 u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u4} α P (AddZeroClass.toHasZero.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u4} α P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3)))) (Finsupp.mapRange.addMonoidHom.{u1, u2, u4} α M P _inst_1 _inst_3 (AddMonoidHom.comp.{u2, u3, u4} M N P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3)) f f₂)) (AddMonoidHom.comp.{max u1 u2, max u1 u3, max u1 u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.{u1, u4} α P (AddZeroClass.toHasZero.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.addZeroClass.{u1, u4} α P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3))) (Finsupp.mapRange.addMonoidHom.{u1, u3, u4} α N P _inst_2 _inst_3 f) (Finsupp.mapRange.addMonoidHom.{u1, u2, u3} α M N _inst_1 _inst_2 f₂))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u4}} {P : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u4} N] [_inst_3 : AddCommMonoid.{u3} P] (f : AddMonoidHom.{u4, u3} N P (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)) (AddMonoid.toAddZeroClass.{u3} P (AddCommMonoid.toAddMonoid.{u3} P _inst_3))) (f₂ : AddMonoidHom.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))), Eq.{max (max (succ u1) (succ u2)) (succ u3)} (AddMonoidHom.{max u2 u1, max u3 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u3} α P (AddMonoid.toZero.{u3} P (AddCommMonoid.toAddMonoid.{u3} P _inst_3))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} α P (AddMonoid.toAddZeroClass.{u3} P (AddCommMonoid.toAddMonoid.{u3} P _inst_3)))) (Finsupp.mapRange.addMonoidHom.{u1, u2, u3} α M P _inst_1 _inst_3 (AddMonoidHom.comp.{u2, u4, u3} M N P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)) (AddMonoid.toAddZeroClass.{u3} P (AddCommMonoid.toAddMonoid.{u3} P _inst_3)) f f₂)) (AddMonoidHom.comp.{max u2 u1, max u4 u1, max u3 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u4} α N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.{u1, u3} α P (AddMonoid.toZero.{u3} P (AddCommMonoid.toAddMonoid.{u3} P _inst_3))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u4} α N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.addZeroClass.{u1, u3} α P (AddMonoid.toAddZeroClass.{u3} P (AddCommMonoid.toAddMonoid.{u3} P _inst_3))) (Finsupp.mapRange.addMonoidHom.{u1, u4, u3} α N P _inst_2 _inst_3 f) (Finsupp.mapRange.addMonoidHom.{u1, u2, u4} α M N _inst_1 _inst_2 f₂))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_monoid_hom_comp Finsupp.mapRange.addMonoidHom_compₓ'. -/
theorem mapRange.addMonoidHom_comp (f : N →+ P) (f₂ : M →+ N) :
    (mapRange.addMonoidHom (f.comp f₂) : (α →₀ _) →+ _) =
      (mapRange.addMonoidHom f).comp (mapRange.addMonoidHom f₂) :=
  AddMonoidHom.ext <| mapRange_comp _ _ _ _ _
#align finsupp.map_range.add_monoid_hom_comp Finsupp.mapRange.addMonoidHom_comp

/- warning: finsupp.map_range.add_monoid_hom_to_zero_hom -> Finsupp.mapRange.addMonoidHom_toZeroHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N] (f : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))), Eq.{max (succ (max u1 u3)) (succ (max u1 u2))} (ZeroHom.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (AddZeroClass.toHasZero.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (AddZeroClass.toHasZero.{max u1 u3} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.addZeroClass.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))) (AddMonoidHom.toZeroHom.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.mapRange.addMonoidHom.{u1, u2, u3} α M N _inst_1 _inst_2 f)) (Finsupp.mapRange.zeroHom.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddMonoidHom.toZeroHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u2} N] (f : AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))), Eq.{max (max (succ u1) (succ u3)) (succ u2)} (ZeroHom.{max u3 u1, max u2 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (AddZeroClass.toZero.{max u3 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (AddZeroClass.toZero.{max u2 u1} (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.addZeroClass.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))))) (AddMonoidHom.toZeroHom.{max u3 u1, max u2 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.mapRange.addMonoidHom.{u1, u3, u2} α M N _inst_1 _inst_2 f)) (Finsupp.mapRange.zeroHom.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (AddMonoidHom.toZeroHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)) f))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_monoid_hom_to_zero_hom Finsupp.mapRange.addMonoidHom_toZeroHomₓ'. -/
@[simp]
theorem mapRange.addMonoidHom_toZeroHom (f : M →+ N) :
    (mapRange.addMonoidHom f).toZeroHom = (mapRange.zeroHom f.toZeroHom : ZeroHom (α →₀ _) _) :=
  ZeroHom.ext fun _ => rfl
#align finsupp.map_range.add_monoid_hom_to_zero_hom Finsupp.mapRange.addMonoidHom_toZeroHom

/- warning: finsupp.map_range_multiset_sum -> Finsupp.mapRange_multiset_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N] (f : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (m : Multiset.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.mapRange.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (fun (_x : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) f) (AddMonoidHom.map_zero.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) f) (Multiset.sum.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_1) m)) (Multiset.sum.{max u1 u3} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.addCommMonoid.{u1, u3} α N _inst_2) (Multiset.map.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (fun (x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) => Finsupp.mapRange.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (fun (_x : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) f) (AddMonoidHom.map_zero.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) f) x) m))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u2} N] (f : AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (m : Multiset.{max u3 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N (AddZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)))) (Finsupp.mapRange.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => N) _x) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))))) f) (AddMonoidHom.map_zero.{u2, u3} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)) f) (Multiset.sum.{max u1 u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addCommMonoid.{u1, u3} α M _inst_1) m)) (Multiset.sum.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)))) (Finsupp.addCommMonoid.{u1, u2} α N _inst_2) (Multiset.map.{max u3 u1, max u2 u1} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u1, u2} α N (AddZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)))) (fun (x : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => Finsupp.mapRange.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => N) _x) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))))) f) (AddMonoidHom.map_zero.{u2, u3} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)) f) x) m))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range_multiset_sum Finsupp.mapRange_multiset_sumₓ'. -/
theorem mapRange_multiset_sum (f : M →+ N) (m : Multiset (α →₀ M)) :
    mapRange f f.map_zero m.Sum = (m.map fun x => mapRange f f.map_zero x).Sum :=
  (mapRange.addMonoidHom f : (α →₀ _) →+ _).map_multiset_sum _
#align finsupp.map_range_multiset_sum Finsupp.mapRange_multiset_sum

/- warning: finsupp.map_range_finset_sum -> Finsupp.mapRange_finset_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u4} N] (f : AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (s : Finset.{u2} ι) (g : ι -> (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))), Eq.{max (succ u1) (succ u4)} (Finsupp.{u1, u4} α N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (Finsupp.mapRange.{u1, u3, u4} α M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (fun (_x : AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) => M -> N) (AddMonoidHom.hasCoeToFun.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) f) (AddMonoidHom.map_zero.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)) f) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_1) s (fun (x : ι) => g x))) (Finset.sum.{max u1 u4, u2} (Finsupp.{u1, u4} α N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) ι (Finsupp.addCommMonoid.{u1, u4} α N _inst_2) s (fun (x : ι) => Finsupp.mapRange.{u1, u3, u4} α M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (fun (_x : AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) => M -> N) (AddMonoidHom.hasCoeToFun.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) f) (AddMonoidHom.map_zero.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)) f) (g x)))
but is expected to have type
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u4}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u4} M] [_inst_2 : AddCommMonoid.{u3} N] (f : AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (s : Finset.{u2} ι) (g : ι -> (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α N (AddZeroClass.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.mapRange.{u1, u4, u3} α M N (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (AddZeroClass.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => N) _x) (AddHomClass.toFunLike.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M N (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (AddZeroClass.toAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) (AddMonoidHom.addMonoidHomClass.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))) f) (AddMonoidHom.map_zero.{u3, u4} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) f) (Finset.sum.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) ι (Finsupp.addCommMonoid.{u1, u4} α M _inst_1) s (fun (x : ι) => g x))) (Finset.sum.{max u3 u1, u2} (Finsupp.{u1, u3} α N (AddZeroClass.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) ι (Finsupp.addCommMonoid.{u1, u3} α N _inst_2) s (fun (x : ι) => Finsupp.mapRange.{u1, u4, u3} α M N (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (AddZeroClass.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => N) _x) (AddHomClass.toFunLike.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M N (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (AddZeroClass.toAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) (AddMonoidHom.addMonoidHomClass.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))) f) (AddMonoidHom.map_zero.{u3, u4} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) f) (g x)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range_finset_sum Finsupp.mapRange_finset_sumₓ'. -/
theorem mapRange_finset_sum (f : M →+ N) (s : Finset ι) (g : ι → α →₀ M) :
    mapRange f f.map_zero (∑ x in s, g x) = ∑ x in s, mapRange f f.map_zero (g x) :=
  (mapRange.addMonoidHom f : (α →₀ _) →+ _).map_sum _ _
#align finsupp.map_range_finset_sum Finsupp.mapRange_finset_sum

/- warning: finsupp.map_range.add_equiv -> Finsupp.mapRange.addEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N], (AddEquiv.{u2, u3} M N (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) -> (AddEquiv.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.hasAdd.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N], (AddEquiv.{u2, u3} M N (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) -> (AddEquiv.{max u2 u1, max u3 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.add.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.add.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_equiv Finsupp.mapRange.addEquivₓ'. -/
/-- `finsupp.map_range.add_monoid_hom` as an equiv. -/
@[simps apply]
def mapRange.addEquiv (f : M ≃+ N) : (α →₀ M) ≃+ (α →₀ N) :=
  {
    mapRange.addMonoidHom
      f.toAddMonoidHom with
    toFun := (mapRange f f.map_zero : (α →₀ M) → α →₀ N)
    invFun := (mapRange f.symm f.symm.map_zero : (α →₀ N) → α →₀ M)
    left_inv := fun x =>
      by
      rw [← map_range_comp _ _ _ _] <;> simp_rw [AddEquiv.symm_comp_self]
      · exact map_range_id _
      · rfl
    right_inv := fun x =>
      by
      rw [← map_range_comp _ _ _ _] <;> simp_rw [AddEquiv.self_comp_symm]
      · exact map_range_id _
      · rfl }
#align finsupp.map_range.add_equiv Finsupp.mapRange.addEquiv

/- warning: finsupp.map_range.add_equiv_refl -> Finsupp.mapRange.addEquiv_refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M], Eq.{succ (max u1 u2)} (AddEquiv.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.mapRange.addEquiv.{u1, u2, u2} α M M _inst_1 _inst_1 (AddEquiv.refl.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))) (AddEquiv.refl.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M], Eq.{max (succ u2) (succ u1)} (AddEquiv.{max u1 u2, max u1 u2} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.add.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.add.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))) (Finsupp.mapRange.addEquiv.{u2, u1, u1} α M M _inst_1 _inst_1 (AddEquiv.refl.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))))) (AddEquiv.refl.{max u1 u2} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.add.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_equiv_refl Finsupp.mapRange.addEquiv_reflₓ'. -/
@[simp]
theorem mapRange.addEquiv_refl : mapRange.addEquiv (AddEquiv.refl M) = AddEquiv.refl (α →₀ M) :=
  AddEquiv.ext mapRange_id
#align finsupp.map_range.add_equiv_refl Finsupp.mapRange.addEquiv_refl

/- warning: finsupp.map_range.add_equiv_trans -> Finsupp.mapRange.addEquiv_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N] [_inst_3 : AddCommMonoid.{u4} P] (f : AddEquiv.{u2, u3} M N (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (f₂ : AddEquiv.{u3, u4} N P (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddZeroClass.toHasAdd.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3)))), Eq.{max (succ (max u1 u2)) (succ (max u1 u4))} (AddEquiv.{max u1 u2, max u1 u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u4} α P (AddZeroClass.toHasZero.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.hasAdd.{u1, u4} α P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3)))) (Finsupp.mapRange.addEquiv.{u1, u2, u4} α M P _inst_1 _inst_3 (AddEquiv.trans.{u2, u3, u4} M N P (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddZeroClass.toHasAdd.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3))) f f₂)) (AddEquiv.trans.{max u1 u2, max u1 u3, max u1 u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.{u1, u4} α P (AddZeroClass.toHasZero.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.hasAdd.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.hasAdd.{u1, u4} α P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_3))) (Finsupp.mapRange.addEquiv.{u1, u2, u3} α M N _inst_1 _inst_2 f) (Finsupp.mapRange.addEquiv.{u1, u3, u4} α N P _inst_2 _inst_3 f₂))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} {P : Type.{u2}} [_inst_1 : AddCommMonoid.{u4} M] [_inst_2 : AddCommMonoid.{u3} N] [_inst_3 : AddCommMonoid.{u2} P] (f : AddEquiv.{u4, u3} M N (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (AddZeroClass.toAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (f₂ : AddEquiv.{u3, u2} N P (AddZeroClass.toAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddZeroClass.toAdd.{u2} P (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_3)))), Eq.{max (max (succ u1) (succ u4)) (succ u2)} (AddEquiv.{max u4 u1, max u2 u1} (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.{u1, u2} α P (AddMonoid.toZero.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_3))) (Finsupp.add.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.add.{u1, u2} α P (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_3)))) (Finsupp.mapRange.addEquiv.{u1, u4, u2} α M P _inst_1 _inst_3 (AddEquiv.trans.{u4, u3, u2} M N P (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (AddZeroClass.toAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddZeroClass.toAdd.{u2} P (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_3))) f f₂)) (AddEquiv.trans.{max u4 u1, max u3 u1, max u2 u1} (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.{u1, u2} α P (AddMonoid.toZero.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_3))) (Finsupp.add.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.add.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.add.{u1, u2} α P (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_3))) (Finsupp.mapRange.addEquiv.{u1, u4, u3} α M N _inst_1 _inst_2 f) (Finsupp.mapRange.addEquiv.{u1, u3, u2} α N P _inst_2 _inst_3 f₂))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_equiv_trans Finsupp.mapRange.addEquiv_transₓ'. -/
theorem mapRange.addEquiv_trans (f : M ≃+ N) (f₂ : N ≃+ P) :
    (mapRange.addEquiv (f.trans f₂) : (α →₀ _) ≃+ _) =
      (mapRange.addEquiv f).trans (mapRange.addEquiv f₂) :=
  AddEquiv.ext <| mapRange_comp _ _ _ _ _
#align finsupp.map_range.add_equiv_trans Finsupp.mapRange.addEquiv_trans

/- warning: finsupp.map_range.add_equiv_symm -> Finsupp.mapRange.addEquiv_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N] (f : AddEquiv.{u2, u3} M N (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))), Eq.{max (succ (max u1 u3)) (succ (max u1 u2))} (AddEquiv.{max u1 u3, max u1 u2} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.hasAdd.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (AddEquiv.symm.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.hasAdd.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.mapRange.addEquiv.{u1, u2, u3} α M N _inst_1 _inst_2 f)) (Finsupp.mapRange.addEquiv.{u1, u3, u2} α N M _inst_2 _inst_1 (AddEquiv.symm.{u2, u3} M N (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) f))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u2} N] (f : AddEquiv.{u3, u2} M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)))), Eq.{max (max (succ u1) (succ u3)) (succ u2)} (AddEquiv.{max u2 u1, max u3 u1} (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.add.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.add.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (AddEquiv.symm.{max u3 u1, max u2 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.add.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.add.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.mapRange.addEquiv.{u1, u3, u2} α M N _inst_1 _inst_2 f)) (Finsupp.mapRange.addEquiv.{u1, u2, u3} α N M _inst_2 _inst_1 (AddEquiv.symm.{u3, u2} M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) f))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_equiv_symm Finsupp.mapRange.addEquiv_symmₓ'. -/
@[simp]
theorem mapRange.addEquiv_symm (f : M ≃+ N) :
    ((mapRange.addEquiv f).symm : (α →₀ _) ≃+ _) = mapRange.addEquiv f.symm :=
  AddEquiv.ext fun x => rfl
#align finsupp.map_range.add_equiv_symm Finsupp.mapRange.addEquiv_symm

/- warning: finsupp.map_range.add_equiv_to_add_monoid_hom -> Finsupp.mapRange.addEquiv_toAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N] (f : AddEquiv.{u2, u3} M N (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))), Eq.{max (succ (max u1 u3)) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (AddEquiv.toAddMonoidHom.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.mapRange.addEquiv.{u1, u2, u3} α M N _inst_1 _inst_2 f)) (Finsupp.mapRange.addMonoidHom.{u1, u2, u3} α M N _inst_1 _inst_2 (AddEquiv.toAddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u2} N] (f : AddEquiv.{u3, u2} M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)))), Eq.{max (max (succ u1) (succ u3)) (succ u2)} (AddMonoidHom.{max u1 u3, max u1 u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)))) (AddEquiv.toAddMonoidHom.{max u1 u3, max u1 u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.mapRange.addEquiv.{u1, u3, u2} α M N _inst_1 _inst_2 f)) (Finsupp.mapRange.addMonoidHom.{u1, u3, u2} α M N _inst_1 _inst_2 (AddEquiv.toAddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)) f))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_equiv_to_add_monoid_hom Finsupp.mapRange.addEquiv_toAddMonoidHomₓ'. -/
@[simp]
theorem mapRange.addEquiv_toAddMonoidHom (f : M ≃+ N) :
    (mapRange.addEquiv f : (α →₀ _) ≃+ _).toAddMonoidHom =
      (mapRange.addMonoidHom f.toAddMonoidHom : (α →₀ _) →+ _) :=
  AddMonoidHom.ext fun _ => rfl
#align finsupp.map_range.add_equiv_to_add_monoid_hom Finsupp.mapRange.addEquiv_toAddMonoidHom

/- warning: finsupp.map_range.add_equiv_to_equiv -> Finsupp.mapRange.addEquiv_toEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N] (f : AddEquiv.{u2, u3} M N (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))), Eq.{max 1 (max (succ (max u1 u2)) (succ (max u1 u3))) (succ (max u1 u3)) (succ (max u1 u2))} (Equiv.{succ (max u1 u2), succ (max u1 u3)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))) (AddEquiv.toEquiv.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.hasAdd.{u1, u3} α N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (Finsupp.mapRange.addEquiv.{u1, u2, u3} α M N _inst_1 _inst_2 f)) (Finsupp.mapRange.equiv.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddEquiv.toEquiv.{u2, u3} M N (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) f) (AddEquiv.map_zero.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) f) (AddEquiv.map_zero.{u3, u2} N M (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddEquiv.symm.{u2, u3} M N (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) f)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u2} N] (f : AddEquiv.{u3, u2} M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)))), Eq.{max (max (succ u1) (succ u3)) (succ u2)} (Equiv.{succ (max u3 u1), succ (max u2 u1)} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)))) (AddEquiv.toEquiv.{max u3 u1, max u2 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.add.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.add.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (Finsupp.mapRange.addEquiv.{u1, u3, u2} α M N _inst_1 _inst_2 f)) (Finsupp.mapRange.equiv.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => N) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) (AddEquiv.toEquiv.{u3, u2} M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) f) (AddEquiv.map_zero.{u2, u3} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)) f) (AddEquiv.map_zero.{u3, u2} N M (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2)) (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddEquiv.symm.{u3, u2} M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_2))) f)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.add_equiv_to_equiv Finsupp.mapRange.addEquiv_toEquivₓ'. -/
@[simp]
theorem mapRange.addEquiv_toEquiv (f : M ≃+ N) :
    (mapRange.addEquiv f).toEquiv =
      (mapRange.equiv f.toEquiv f.map_zero f.symm.map_zero : (α →₀ _) ≃ _) :=
  Equiv.ext fun _ => rfl
#align finsupp.map_range.add_equiv_to_equiv Finsupp.mapRange.addEquiv_toEquiv

end AddMonoidHom

end Finsupp

end MapRange

/-! ### Declarations about `equiv_congr_left` -/


section EquivCongrLeft

variable [Zero M]

namespace Finsupp

#print Finsupp.equivMapDomain /-
/-- Given `f : α ≃ β`, we can map `l : α →₀ M` to  `equiv_map_domain f l : β →₀ M` (computably)
by mapping the support forwards and the function backwards. -/
def equivMapDomain (f : α ≃ β) (l : α →₀ M) : β →₀ M
    where
  support := l.support.map f.toEmbedding
  toFun a := l (f.symm a)
  mem_support_toFun a := by simp only [Finset.mem_map_equiv, mem_support_to_fun] <;> rfl
#align finsupp.equiv_map_domain Finsupp.equivMapDomain
-/

/- warning: finsupp.equiv_map_domain_apply -> Finsupp.equivMapDomain_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : Zero.{u3} M] (f : Equiv.{succ u1, succ u2} α β) (l : Finsupp.{u1, u3} α M _inst_1) (b : β), Eq.{succ u3} M (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M _inst_1) (fun (_x : Finsupp.{u2, u3} β M _inst_1) => β -> M) (Finsupp.hasCoeToFun.{u2, u3} β M _inst_1) (Finsupp.equivMapDomain.{u1, u2, u3} α β M _inst_1 f l) b) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M _inst_1) (fun (_x : Finsupp.{u1, u3} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u3} α M _inst_1) l (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} β α) (fun (_x : Equiv.{succ u2, succ u1} β α) => β -> α) (Equiv.hasCoeToFun.{succ u2, succ u1} β α) (Equiv.symm.{succ u1, succ u2} α β f) b))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : Equiv.{succ u3, succ u2} α β) (l : Finsupp.{u3, u1} α M _inst_1) (b : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) b) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β M _inst_1) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u2, u1} β M _inst_1) (Finsupp.equivMapDomain.{u3, u2, u1} α β M _inst_1 f l) b) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u1} α M _inst_1) l (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : β) => α) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} β α) (Equiv.symm.{succ u3, succ u2} α β f) b))
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_map_domain_apply Finsupp.equivMapDomain_applyₓ'. -/
@[simp]
theorem equivMapDomain_apply (f : α ≃ β) (l : α →₀ M) (b : β) :
    equivMapDomain f l b = l (f.symm b) :=
  rfl
#align finsupp.equiv_map_domain_apply Finsupp.equivMapDomain_apply

/- warning: finsupp.equiv_map_domain_symm_apply -> Finsupp.equivMapDomain_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : Zero.{u3} M] (f : Equiv.{succ u1, succ u2} α β) (l : Finsupp.{u2, u3} β M _inst_1) (a : α), Eq.{succ u3} M (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M _inst_1) (fun (_x : Finsupp.{u1, u3} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u3} α M _inst_1) (Finsupp.equivMapDomain.{u2, u1, u3} β α M _inst_1 (Equiv.symm.{succ u1, succ u2} α β f) l) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M _inst_1) (fun (_x : Finsupp.{u2, u3} β M _inst_1) => β -> M) (Finsupp.hasCoeToFun.{u2, u3} β M _inst_1) l (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} α β) (fun (_x : Equiv.{succ u1, succ u2} α β) => α -> β) (Equiv.hasCoeToFun.{succ u1, succ u2} α β) f a))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : Equiv.{succ u3, succ u2} α β) (l : Finsupp.{u2, u1} β M _inst_1) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u1} α M _inst_1) (Finsupp.equivMapDomain.{u2, u3, u1} β α M _inst_1 (Equiv.symm.{succ u3, succ u2} α β f) l) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β M _inst_1) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u2, u1} β M _inst_1) l (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α) => β) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} α β) f a))
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_map_domain_symm_apply Finsupp.equivMapDomain_symm_applyₓ'. -/
theorem equivMapDomain_symm_apply (f : α ≃ β) (l : β →₀ M) (a : α) :
    equivMapDomain f.symm l a = l (f a) :=
  rfl
#align finsupp.equiv_map_domain_symm_apply Finsupp.equivMapDomain_symm_apply

/- warning: finsupp.equiv_map_domain_refl -> Finsupp.equivMapDomain_refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (l : Finsupp.{u1, u2} α M _inst_1), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.equivMapDomain.{u1, u1, u2} α α M _inst_1 (Equiv.refl.{succ u1} α) l) l
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (l : Finsupp.{u2, u1} α M _inst_1), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.equivMapDomain.{u2, u2, u1} α α M _inst_1 (Equiv.refl.{succ u2} α) l) l
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_map_domain_refl Finsupp.equivMapDomain_reflₓ'. -/
@[simp]
theorem equivMapDomain_refl (l : α →₀ M) : equivMapDomain (Equiv.refl _) l = l := by ext x <;> rfl
#align finsupp.equiv_map_domain_refl Finsupp.equivMapDomain_refl

/- warning: finsupp.equiv_map_domain_refl' -> Finsupp.equivMapDomain_refl' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M], Eq.{max (succ u1) (succ u2)} ((Finsupp.{u1, u2} α M _inst_1) -> (Finsupp.{u1, u2} α M _inst_1)) (Finsupp.equivMapDomain.{u1, u1, u2} α α M _inst_1 (Equiv.refl.{succ u1} α)) (id.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M], Eq.{max (succ u2) (succ u1)} ((Finsupp.{u2, u1} α M _inst_1) -> (Finsupp.{u2, u1} α M _inst_1)) (Finsupp.equivMapDomain.{u2, u2, u1} α α M _inst_1 (Equiv.refl.{succ u2} α)) (id.{max (succ u1) (succ u2)} (Finsupp.{u2, u1} α M _inst_1))
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_map_domain_refl' Finsupp.equivMapDomain_refl'ₓ'. -/
theorem equivMapDomain_refl' : equivMapDomain (Equiv.refl _) = @id (α →₀ M) := by ext x <;> rfl
#align finsupp.equiv_map_domain_refl' Finsupp.equivMapDomain_refl'

/- warning: finsupp.equiv_map_domain_trans -> Finsupp.equivMapDomain_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {M : Type.{u4}} [_inst_1 : Zero.{u4} M] (f : Equiv.{succ u1, succ u2} α β) (g : Equiv.{succ u2, succ u3} β γ) (l : Finsupp.{u1, u4} α M _inst_1), Eq.{max (succ u3) (succ u4)} (Finsupp.{u3, u4} γ M _inst_1) (Finsupp.equivMapDomain.{u1, u3, u4} α γ M _inst_1 (Equiv.trans.{succ u1, succ u2, succ u3} α β γ f g) l) (Finsupp.equivMapDomain.{u2, u3, u4} β γ M _inst_1 g (Finsupp.equivMapDomain.{u1, u2, u4} α β M _inst_1 f l))
but is expected to have type
  forall {α : Type.{u4}} {β : Type.{u3}} {γ : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : Equiv.{succ u4, succ u3} α β) (g : Equiv.{succ u3, succ u2} β γ) (l : Finsupp.{u4, u1} α M _inst_1), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} γ M _inst_1) (Finsupp.equivMapDomain.{u4, u2, u1} α γ M _inst_1 (Equiv.trans.{succ u4, succ u3, succ u2} α β γ f g) l) (Finsupp.equivMapDomain.{u3, u2, u1} β γ M _inst_1 g (Finsupp.equivMapDomain.{u4, u3, u1} α β M _inst_1 f l))
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_map_domain_trans Finsupp.equivMapDomain_transₓ'. -/
theorem equivMapDomain_trans (f : α ≃ β) (g : β ≃ γ) (l : α →₀ M) :
    equivMapDomain (f.trans g) l = equivMapDomain g (equivMapDomain f l) := by ext x <;> rfl
#align finsupp.equiv_map_domain_trans Finsupp.equivMapDomain_trans

/- warning: finsupp.equiv_map_domain_trans' -> Finsupp.equivMapDomain_trans' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {M : Type.{u4}} [_inst_1 : Zero.{u4} M] (f : Equiv.{succ u1, succ u2} α β) (g : Equiv.{succ u2, succ u3} β γ), Eq.{max (max (succ u1) (succ u4)) (succ u3) (succ u4)} ((Finsupp.{u1, u4} α M _inst_1) -> (Finsupp.{u3, u4} γ M _inst_1)) (Finsupp.equivMapDomain.{u1, u3, u4} α γ M _inst_1 (Equiv.trans.{succ u1, succ u2, succ u3} α β γ f g)) (Function.comp.{max (succ u1) (succ u4), max (succ u2) (succ u4), max (succ u3) (succ u4)} (Finsupp.{u1, u4} α M _inst_1) (Finsupp.{u2, u4} β M _inst_1) (Finsupp.{u3, u4} γ M _inst_1) (Finsupp.equivMapDomain.{u2, u3, u4} β γ M _inst_1 g) (Finsupp.equivMapDomain.{u1, u2, u4} α β M _inst_1 f))
but is expected to have type
  forall {α : Type.{u4}} {β : Type.{u3}} {γ : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : Equiv.{succ u4, succ u3} α β) (g : Equiv.{succ u3, succ u2} β γ), Eq.{max (max (succ u4) (succ u2)) (succ u1)} ((Finsupp.{u4, u1} α M _inst_1) -> (Finsupp.{u2, u1} γ M _inst_1)) (Finsupp.equivMapDomain.{u4, u2, u1} α γ M _inst_1 (Equiv.trans.{succ u4, succ u3, succ u2} α β γ f g)) (Function.comp.{max (succ u1) (succ u4), max (succ u1) (succ u3), max (succ u1) (succ u2)} (Finsupp.{u4, u1} α M _inst_1) (Finsupp.{u3, u1} β M _inst_1) (Finsupp.{u2, u1} γ M _inst_1) (Finsupp.equivMapDomain.{u3, u2, u1} β γ M _inst_1 g) (Finsupp.equivMapDomain.{u4, u3, u1} α β M _inst_1 f))
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_map_domain_trans' Finsupp.equivMapDomain_trans'ₓ'. -/
theorem equivMapDomain_trans' (f : α ≃ β) (g : β ≃ γ) :
    @equivMapDomain _ _ M _ (f.trans g) = equivMapDomain g ∘ equivMapDomain f := by ext x <;> rfl
#align finsupp.equiv_map_domain_trans' Finsupp.equivMapDomain_trans'

/- warning: finsupp.equiv_map_domain_single -> Finsupp.equivMapDomain_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : Zero.{u3} M] (f : Equiv.{succ u1, succ u2} α β) (a : α) (b : M), Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M _inst_1) (Finsupp.equivMapDomain.{u1, u2, u3} α β M _inst_1 f (Finsupp.single.{u1, u3} α M _inst_1 a b)) (Finsupp.single.{u2, u3} β M _inst_1 (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} α β) (fun (_x : Equiv.{succ u1, succ u2} α β) => α -> β) (Equiv.hasCoeToFun.{succ u1, succ u2} α β) f a) b)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : Equiv.{succ u3, succ u2} α β) (a : α) (b : M), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} β M _inst_1) (Finsupp.equivMapDomain.{u3, u2, u1} α β M _inst_1 f (Finsupp.single.{u3, u1} α M _inst_1 a b)) (Finsupp.single.{u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α) => β) a) M _inst_1 (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α) => β) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} α β) f a) b)
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_map_domain_single Finsupp.equivMapDomain_singleₓ'. -/
@[simp]
theorem equivMapDomain_single (f : α ≃ β) (a : α) (b : M) :
    equivMapDomain f (single a b) = single (f a) b := by
  classical
    ext x
    simp only [single_apply, Equiv.apply_eq_iff_eq_symm_apply, equiv_map_domain_apply]
#align finsupp.equiv_map_domain_single Finsupp.equivMapDomain_single

/- warning: finsupp.equiv_map_domain_zero -> Finsupp.equivMapDomain_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : Zero.{u3} M] {f : Equiv.{succ u1, succ u2} α β}, Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M _inst_1) (Finsupp.equivMapDomain.{u1, u2, u3} α β M _inst_1 f (OfNat.ofNat.{max u1 u3} (Finsupp.{u1, u3} α M _inst_1) 0 (OfNat.mk.{max u1 u3} (Finsupp.{u1, u3} α M _inst_1) 0 (Zero.zero.{max u1 u3} (Finsupp.{u1, u3} α M _inst_1) (Finsupp.hasZero.{u1, u3} α M _inst_1))))) (OfNat.ofNat.{max u2 u3} (Finsupp.{u2, u3} β M _inst_1) 0 (OfNat.mk.{max u2 u3} (Finsupp.{u2, u3} β M _inst_1) 0 (Zero.zero.{max u2 u3} (Finsupp.{u2, u3} β M _inst_1) (Finsupp.hasZero.{u2, u3} β M _inst_1))))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {f : Equiv.{succ u3, succ u2} α β}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} β M _inst_1) (Finsupp.equivMapDomain.{u3, u2, u1} α β M _inst_1 f (OfNat.ofNat.{max u3 u1} (Finsupp.{u3, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u3 u1} (Finsupp.{u3, u1} α M _inst_1) (Finsupp.zero.{u3, u1} α M _inst_1)))) (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} β M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} β M _inst_1) (Finsupp.zero.{u2, u1} β M _inst_1)))
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_map_domain_zero Finsupp.equivMapDomain_zeroₓ'. -/
@[simp]
theorem equivMapDomain_zero {f : α ≃ β} : equivMapDomain f (0 : α →₀ M) = (0 : β →₀ M) := by
  ext x <;> simp only [equiv_map_domain_apply, coe_zero, Pi.zero_apply]
#align finsupp.equiv_map_domain_zero Finsupp.equivMapDomain_zero

#print Finsupp.equivCongrLeft /-
/-- Given `f : α ≃ β`, the finitely supported function spaces are also in bijection:
`(α →₀ M) ≃ (β →₀ M)`.

This is the finitely-supported version of `equiv.Pi_congr_left`. -/
def equivCongrLeft (f : α ≃ β) : (α →₀ M) ≃ (β →₀ M) := by
  refine' ⟨equiv_map_domain f, equiv_map_domain f.symm, fun f => _, fun f => _⟩ <;> ext x <;>
    simp only [equiv_map_domain_apply, Equiv.symm_symm, Equiv.symm_apply_apply,
      Equiv.apply_symm_apply]
#align finsupp.equiv_congr_left Finsupp.equivCongrLeft
-/

/- warning: finsupp.equiv_congr_left_apply -> Finsupp.equivCongrLeft_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : Zero.{u3} M] (f : Equiv.{succ u1, succ u2} α β) (l : Finsupp.{u1, u3} α M _inst_1), Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M _inst_1) (coeFn.{max 1 (max (max (succ u1) (succ u3)) (succ u2) (succ u3)) (max (succ u2) (succ u3)) (succ u1) (succ u3), max (max (succ u1) (succ u3)) (succ u2) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u1, u3} α M _inst_1) (Finsupp.{u2, u3} β M _inst_1)) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u1, u3} α M _inst_1) (Finsupp.{u2, u3} β M _inst_1)) => (Finsupp.{u1, u3} α M _inst_1) -> (Finsupp.{u2, u3} β M _inst_1)) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u1, u3} α M _inst_1) (Finsupp.{u2, u3} β M _inst_1)) (Finsupp.equivCongrLeft.{u1, u2, u3} α β M _inst_1 f) l) (Finsupp.equivMapDomain.{u1, u2, u3} α β M _inst_1 f l)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : Equiv.{succ u3, succ u2} α β) (l : Finsupp.{u3, u1} α M _inst_1), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{u3, u1} α M _inst_1) => Finsupp.{u2, u1} β M _inst_1) l) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u2)} (Finsupp.{u3, u1} α M _inst_1) (Finsupp.{u2, u1} β M _inst_1)) (Finsupp.{u3, u1} α M _inst_1) (fun (_x : Finsupp.{u3, u1} α M _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{u3, u1} α M _inst_1) => Finsupp.{u2, u1} β M _inst_1) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u3, u1} α M _inst_1) (Finsupp.{u2, u1} β M _inst_1)) (Finsupp.equivCongrLeft.{u3, u2, u1} α β M _inst_1 f) l) (Finsupp.equivMapDomain.{u3, u2, u1} α β M _inst_1 f l)
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_congr_left_apply Finsupp.equivCongrLeft_applyₓ'. -/
@[simp]
theorem equivCongrLeft_apply (f : α ≃ β) (l : α →₀ M) : equivCongrLeft f l = equivMapDomain f l :=
  rfl
#align finsupp.equiv_congr_left_apply Finsupp.equivCongrLeft_apply

/- warning: finsupp.equiv_congr_left_symm -> Finsupp.equivCongrLeft_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : Zero.{u3} M] (f : Equiv.{succ u1, succ u2} α β), Eq.{max 1 (max (max (succ u2) (succ u3)) (succ u1) (succ u3)) (max (succ u1) (succ u3)) (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u2, u3} β M _inst_1) (Finsupp.{u1, u3} α M _inst_1)) (Equiv.symm.{max (succ u1) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u1, u3} α M _inst_1) (Finsupp.{u2, u3} β M _inst_1) (Finsupp.equivCongrLeft.{u1, u2, u3} α β M _inst_1 f)) (Finsupp.equivCongrLeft.{u2, u1, u3} β α M _inst_1 (Equiv.symm.{succ u1, succ u2} α β f))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : Equiv.{succ u3, succ u2} α β), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u2, u1} β M _inst_1) (Finsupp.{u3, u1} α M _inst_1)) (Equiv.symm.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u3, u1} α M _inst_1) (Finsupp.{u2, u1} β M _inst_1) (Finsupp.equivCongrLeft.{u3, u2, u1} α β M _inst_1 f)) (Finsupp.equivCongrLeft.{u2, u3, u1} β α M _inst_1 (Equiv.symm.{succ u3, succ u2} α β f))
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_congr_left_symm Finsupp.equivCongrLeft_symmₓ'. -/
@[simp]
theorem equivCongrLeft_symm (f : α ≃ β) :
    (@equivCongrLeft _ _ M _ f).symm = equivCongrLeft f.symm :=
  rfl
#align finsupp.equiv_congr_left_symm Finsupp.equivCongrLeft_symm

end Finsupp

end EquivCongrLeft

section CastFinsupp

variable [Zero M] (f : α →₀ M)

namespace Nat

/- warning: nat.cast_finsupp_prod -> Nat.cast_finsupp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Zero.{u2} M] (f : Finsupp.{u1, u2} α M _inst_1) [_inst_2 : CommSemiring.{u3} R] (g : α -> M -> Nat), Eq.{succ u3} R ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u3} Nat R (CoeTCₓ.coe.{1, succ u3} Nat R (Nat.castCoe.{u3} R (AddMonoidWithOne.toNatCast.{u3} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} R (NonAssocSemiring.toAddCommMonoidWithOne.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)))))))) (Finsupp.prod.{u1, u2, 0} α M Nat _inst_1 Nat.commMonoid f g)) (Finsupp.prod.{u1, u2, u3} α M R _inst_1 (CommSemiring.toCommMonoid.{u3} R _inst_2) f (fun (a : α) (b : M) => (fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u3} Nat R (CoeTCₓ.coe.{1, succ u3} Nat R (Nat.castCoe.{u3} R (AddMonoidWithOne.toNatCast.{u3} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} R (NonAssocSemiring.toAddCommMonoidWithOne.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)))))))) (g a b)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {R : Type.{u3}} [_inst_1 : Zero.{u1} M] (f : Finsupp.{u2, u1} α M _inst_1) [_inst_2 : CommSemiring.{u3} R] (g : α -> M -> Nat), Eq.{succ u3} R (Nat.cast.{u3} R (Semiring.toNatCast.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)) (Finsupp.prod.{u2, u1, 0} α M Nat _inst_1 Nat.commMonoid f g)) (Finsupp.prod.{u2, u1, u3} α M R _inst_1 (CommSemiring.toCommMonoid.{u3} R _inst_2) f (fun (a : α) (b : M) => Nat.cast.{u3} R (Semiring.toNatCast.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)) (g a b)))
Case conversion may be inaccurate. Consider using '#align nat.cast_finsupp_prod Nat.cast_finsupp_prodₓ'. -/
@[simp, norm_cast]
theorem cast_finsupp_prod [CommSemiring R] (g : α → M → ℕ) :
    (↑(f.Prod g) : R) = f.Prod fun a b => ↑(g a b) :=
  Nat.cast_prod _ _
#align nat.cast_finsupp_prod Nat.cast_finsupp_prod

/- warning: nat.cast_finsupp_sum -> Nat.cast_finsupp_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Zero.{u2} M] (f : Finsupp.{u1, u2} α M _inst_1) [_inst_2 : CommSemiring.{u3} R] (g : α -> M -> Nat), Eq.{succ u3} R ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u3} Nat R (CoeTCₓ.coe.{1, succ u3} Nat R (Nat.castCoe.{u3} R (AddMonoidWithOne.toNatCast.{u3} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} R (NonAssocSemiring.toAddCommMonoidWithOne.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)))))))) (Finsupp.sum.{u1, u2, 0} α M Nat _inst_1 Nat.addCommMonoid f g)) (Finsupp.sum.{u1, u2, u3} α M R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)))) f (fun (a : α) (b : M) => (fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u3} Nat R (CoeTCₓ.coe.{1, succ u3} Nat R (Nat.castCoe.{u3} R (AddMonoidWithOne.toNatCast.{u3} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} R (NonAssocSemiring.toAddCommMonoidWithOne.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)))))))) (g a b)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {R : Type.{u3}} [_inst_1 : Zero.{u1} M] (f : Finsupp.{u2, u1} α M _inst_1) [_inst_2 : CommSemiring.{u3} R] (g : α -> M -> Nat), Eq.{succ u3} R (Nat.cast.{u3} R (Semiring.toNatCast.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)) (Finsupp.sum.{u2, u1, 0} α M Nat _inst_1 Nat.addCommMonoid f g)) (Finsupp.sum.{u2, u1, u3} α M R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)))) f (fun (a : α) (b : M) => Nat.cast.{u3} R (Semiring.toNatCast.{u3} R (CommSemiring.toSemiring.{u3} R _inst_2)) (g a b)))
Case conversion may be inaccurate. Consider using '#align nat.cast_finsupp_sum Nat.cast_finsupp_sumₓ'. -/
@[simp, norm_cast]
theorem cast_finsupp_sum [CommSemiring R] (g : α → M → ℕ) :
    (↑(f.Sum g) : R) = f.Sum fun a b => ↑(g a b) :=
  Nat.cast_sum _ _
#align nat.cast_finsupp_sum Nat.cast_finsupp_sum

end Nat

namespace Int

/- warning: int.cast_finsupp_prod -> Int.cast_finsupp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Zero.{u2} M] (f : Finsupp.{u1, u2} α M _inst_1) [_inst_2 : CommRing.{u3} R] (g : α -> M -> Int), Eq.{succ u3} R ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Int R (HasLiftT.mk.{1, succ u3} Int R (CoeTCₓ.coe.{1, succ u3} Int R (Int.castCoe.{u3} R (AddGroupWithOne.toHasIntCast.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_2))))))) (Finsupp.prod.{u1, u2, 0} α M Int _inst_1 Int.commMonoid f g)) (Finsupp.prod.{u1, u2, u3} α M R _inst_1 (CommRing.toCommMonoid.{u3} R _inst_2) f (fun (a : α) (b : M) => (fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Int R (HasLiftT.mk.{1, succ u3} Int R (CoeTCₓ.coe.{1, succ u3} Int R (Int.castCoe.{u3} R (AddGroupWithOne.toHasIntCast.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_2))))))) (g a b)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {R : Type.{u3}} [_inst_1 : Zero.{u1} M] (f : Finsupp.{u2, u1} α M _inst_1) [_inst_2 : CommRing.{u3} R] (g : α -> M -> Int), Eq.{succ u3} R (Int.cast.{u3} R (Ring.toIntCast.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Finsupp.prod.{u2, u1, 0} α M Int _inst_1 Int.instCommMonoidInt f g)) (Finsupp.prod.{u2, u1, u3} α M R _inst_1 (CommRing.toCommMonoid.{u3} R _inst_2) f (fun (a : α) (b : M) => Int.cast.{u3} R (Ring.toIntCast.{u3} R (CommRing.toRing.{u3} R _inst_2)) (g a b)))
Case conversion may be inaccurate. Consider using '#align int.cast_finsupp_prod Int.cast_finsupp_prodₓ'. -/
@[simp, norm_cast]
theorem cast_finsupp_prod [CommRing R] (g : α → M → ℤ) :
    (↑(f.Prod g) : R) = f.Prod fun a b => ↑(g a b) :=
  Int.cast_prod _ _
#align int.cast_finsupp_prod Int.cast_finsupp_prod

/- warning: int.cast_finsupp_sum -> Int.cast_finsupp_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Zero.{u2} M] (f : Finsupp.{u1, u2} α M _inst_1) [_inst_2 : CommRing.{u3} R] (g : α -> M -> Int), Eq.{succ u3} R ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Int R (HasLiftT.mk.{1, succ u3} Int R (CoeTCₓ.coe.{1, succ u3} Int R (Int.castCoe.{u3} R (AddGroupWithOne.toHasIntCast.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_2))))))) (Finsupp.sum.{u1, u2, 0} α M Int _inst_1 Int.addCommMonoid f g)) (Finsupp.sum.{u1, u2, u3} α M R _inst_1 (AddCommGroup.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toAddCommGroup.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_2))))) f (fun (a : α) (b : M) => (fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Int R (HasLiftT.mk.{1, succ u3} Int R (CoeTCₓ.coe.{1, succ u3} Int R (Int.castCoe.{u3} R (AddGroupWithOne.toHasIntCast.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_2))))))) (g a b)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {R : Type.{u3}} [_inst_1 : Zero.{u1} M] (f : Finsupp.{u2, u1} α M _inst_1) [_inst_2 : CommRing.{u3} R] (g : α -> M -> Int), Eq.{succ u3} R (Int.cast.{u3} R (Ring.toIntCast.{u3} R (CommRing.toRing.{u3} R _inst_2)) (Finsupp.sum.{u2, u1, 0} α M Int _inst_1 Int.instAddCommMonoidInt f g)) (Finsupp.sum.{u2, u1, u3} α M R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_2))))) f (fun (a : α) (b : M) => Int.cast.{u3} R (Ring.toIntCast.{u3} R (CommRing.toRing.{u3} R _inst_2)) (g a b)))
Case conversion may be inaccurate. Consider using '#align int.cast_finsupp_sum Int.cast_finsupp_sumₓ'. -/
@[simp, norm_cast]
theorem cast_finsupp_sum [CommRing R] (g : α → M → ℤ) :
    (↑(f.Sum g) : R) = f.Sum fun a b => ↑(g a b) :=
  Int.cast_sum _ _
#align int.cast_finsupp_sum Int.cast_finsupp_sum

end Int

namespace Rat

/- warning: rat.cast_finsupp_sum -> Rat.cast_finsupp_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Zero.{u2} M] (f : Finsupp.{u1, u2} α M _inst_1) [_inst_2 : DivisionRing.{u3} R] [_inst_3 : CharZero.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (DivisionRing.toRing.{u3} R _inst_2))))] (g : α -> M -> Rat), Eq.{succ u3} R ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Rat R (HasLiftT.mk.{1, succ u3} Rat R (CoeTCₓ.coe.{1, succ u3} Rat R (Rat.castCoe.{u3} R (DivisionRing.toHasRatCast.{u3} R _inst_2)))) (Finsupp.sum.{u1, u2, 0} α M Rat _inst_1 Rat.addCommMonoid f g)) (Finsupp.sum.{u1, u2, u3} α M R _inst_1 (AddCommGroup.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toAddCommGroup.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (DivisionRing.toRing.{u3} R _inst_2))))) f (fun (a : α) (b : M) => (fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Rat R (HasLiftT.mk.{1, succ u3} Rat R (CoeTCₓ.coe.{1, succ u3} Rat R (Rat.castCoe.{u3} R (DivisionRing.toHasRatCast.{u3} R _inst_2)))) (g a b)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {R : Type.{u3}} [_inst_1 : Zero.{u1} M] (f : Finsupp.{u2, u1} α M _inst_1) [_inst_2 : DivisionRing.{u3} R] [_inst_3 : CharZero.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R _inst_2)))] (g : α -> M -> Rat), Eq.{succ u3} R (RatCast.ratCast.{u3} R (DivisionRing.toRatCast.{u3} R _inst_2) (Finsupp.sum.{u2, u1, 0} α M Rat _inst_1 Rat.addCommMonoid f g)) (Finsupp.sum.{u2, u1, u3} α M R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (DivisionRing.toRing.{u3} R _inst_2))))) f (fun (a : α) (b : M) => RatCast.ratCast.{u3} R (DivisionRing.toRatCast.{u3} R _inst_2) (g a b)))
Case conversion may be inaccurate. Consider using '#align rat.cast_finsupp_sum Rat.cast_finsupp_sumₓ'. -/
@[simp, norm_cast]
theorem cast_finsupp_sum [DivisionRing R] [CharZero R] (g : α → M → ℚ) :
    (↑(f.Sum g) : R) = f.Sum fun a b => g a b :=
  cast_sum _ _
#align rat.cast_finsupp_sum Rat.cast_finsupp_sum

/- warning: rat.cast_finsupp_prod -> Rat.cast_finsupp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Zero.{u2} M] (f : Finsupp.{u1, u2} α M _inst_1) [_inst_2 : Field.{u3} R] [_inst_3 : CharZero.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (NonAssocRing.toAddGroupWithOne.{u3} R (Ring.toNonAssocRing.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R _inst_2)))))] (g : α -> M -> Rat), Eq.{succ u3} R ((fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Rat R (HasLiftT.mk.{1, succ u3} Rat R (CoeTCₓ.coe.{1, succ u3} Rat R (Rat.castCoe.{u3} R (DivisionRing.toHasRatCast.{u3} R (Field.toDivisionRing.{u3} R _inst_2))))) (Finsupp.prod.{u1, u2, 0} α M Rat _inst_1 Rat.commMonoid f g)) (Finsupp.prod.{u1, u2, u3} α M R _inst_1 (CommRing.toCommMonoid.{u3} R (Field.toCommRing.{u3} R _inst_2)) f (fun (a : α) (b : M) => (fun (a : Type) (b : Type.{u3}) [self : HasLiftT.{1, succ u3} a b] => self.0) Rat R (HasLiftT.mk.{1, succ u3} Rat R (CoeTCₓ.coe.{1, succ u3} Rat R (Rat.castCoe.{u3} R (DivisionRing.toHasRatCast.{u3} R (Field.toDivisionRing.{u3} R _inst_2))))) (g a b)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {R : Type.{u3}} [_inst_1 : Zero.{u1} M] (f : Finsupp.{u2, u1} α M _inst_1) [_inst_2 : Field.{u3} R] [_inst_3 : CharZero.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (DivisionRing.toRing.{u3} R (Field.toDivisionRing.{u3} R _inst_2))))] (g : α -> M -> Rat), Eq.{succ u3} R (RatCast.ratCast.{u3} R (Field.toRatCast.{u3} R _inst_2) (Finsupp.prod.{u2, u1, 0} α M Rat _inst_1 Rat.commMonoid f g)) (Finsupp.prod.{u2, u1, u3} α M R _inst_1 (CommRing.toCommMonoid.{u3} R (Field.toCommRing.{u3} R _inst_2)) f (fun (a : α) (b : M) => RatCast.ratCast.{u3} R (Field.toRatCast.{u3} R _inst_2) (g a b)))
Case conversion may be inaccurate. Consider using '#align rat.cast_finsupp_prod Rat.cast_finsupp_prodₓ'. -/
@[simp, norm_cast]
theorem cast_finsupp_prod [Field R] [CharZero R] (g : α → M → ℚ) :
    (↑(f.Prod g) : R) = f.Prod fun a b => g a b :=
  cast_prod _ _
#align rat.cast_finsupp_prod Rat.cast_finsupp_prod

end Rat

end CastFinsupp

/-! ### Declarations about `map_domain` -/


namespace Finsupp

section MapDomain

variable [AddCommMonoid M] {v v₁ v₂ : α →₀ M}

/- warning: finsupp.map_domain -> Finsupp.mapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (α -> β) -> (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) -> (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (α -> β) -> (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) -> (Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain Finsupp.mapDomainₓ'. -/
/-- Given `f : α → β` and `v : α →₀ M`, `map_domain f v : β →₀ M`
  is the finitely supported function whose value at `a : β` is the sum
  of `v x` over all `x` such that `f x = a`. -/
def mapDomain (f : α → β) (v : α →₀ M) : β →₀ M :=
  v.Sum fun a => single (f a)
#align finsupp.map_domain Finsupp.mapDomain

/- warning: finsupp.map_domain_apply -> Finsupp.mapDomain_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {f : α -> β}, (Function.Injective.{succ u1, succ u2} α β f) -> (forall (x : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (a : α), Eq.{succ u3} M (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (_x : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => β -> M) (Finsupp.hasCoeToFun.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f x) (f a)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (_x : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => α -> M) (Finsupp.hasCoeToFun.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) x a))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] {f : α -> β}, (Function.Injective.{succ u3, succ u2} α β f) -> (forall (x : Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) (f a)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.mapDomain.{u3, u2, u1} α β M _inst_1 f x) (f a)) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) x a))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_apply Finsupp.mapDomain_applyₓ'. -/
theorem mapDomain_apply {f : α → β} (hf : Function.Injective f) (x : α →₀ M) (a : α) :
    mapDomain f x (f a) = x a :=
  by
  rw [map_domain, sum_apply, Sum, Finset.sum_eq_single a, single_eq_same]
  · intro b _ hba
    exact single_eq_of_ne (hf.ne hba)
  · intro h
    rw [not_mem_support_iff.1 h, single_zero, zero_apply]
#align finsupp.map_domain_apply Finsupp.mapDomain_apply

/- warning: finsupp.map_domain_notin_range -> Finsupp.mapDomain_notin_range is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {f : α -> β} (x : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (a : β), (Not (Membership.Mem.{u2, u2} β (Set.{u2} β) (Set.hasMem.{u2} β) a (Set.range.{u2, succ u1} β α f))) -> (Eq.{succ u3} M (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (_x : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => β -> M) (Finsupp.hasCoeToFun.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f x) a) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] {f : α -> β} (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (a : β), (Not (Membership.mem.{u1, u1} β (Set.{u1} β) (Set.instMembershipSet.{u1} β) a (Set.range.{u1, succ u3} β α f))) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f x) a) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) a) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) a) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) a) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) a) _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_notin_range Finsupp.mapDomain_notin_rangeₓ'. -/
theorem mapDomain_notin_range {f : α → β} (x : α →₀ M) (a : β) (h : a ∉ Set.range f) :
    mapDomain f x a = 0 := by
  rw [map_domain, sum_apply, Sum]
  exact Finset.sum_eq_zero fun a' h' => single_eq_of_ne fun eq => h <| Eq ▸ Set.mem_range_self _
#align finsupp.map_domain_notin_range Finsupp.mapDomain_notin_range

/- warning: finsupp.map_domain_id -> Finsupp.mapDomain_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] {v : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.mapDomain.{u1, u1, u2} α α M _inst_1 (id.{succ u1} α) v) v
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] {v : Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.mapDomain.{u2, u2, u1} α α M _inst_1 (id.{succ u2} α) v) v
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_id Finsupp.mapDomain_idₓ'. -/
@[simp]
theorem mapDomain_id : mapDomain id v = v :=
  sum_single _
#align finsupp.map_domain_id Finsupp.mapDomain_id

/- warning: finsupp.map_domain_comp -> Finsupp.mapDomain_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {M : Type.{u4}} [_inst_1 : AddCommMonoid.{u4} M] {v : Finsupp.{u1, u4} α M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))} {f : α -> β} {g : β -> γ}, Eq.{max (succ u3) (succ u4)} (Finsupp.{u3, u4} γ M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.mapDomain.{u1, u3, u4} α γ M _inst_1 (Function.comp.{succ u1, succ u2, succ u3} α β γ g f) v) (Finsupp.mapDomain.{u2, u3, u4} β γ M _inst_1 g (Finsupp.mapDomain.{u1, u2, u4} α β M _inst_1 f v))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {γ : Type.{u4}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {v : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))} {f : α -> β} {g : β -> γ}, Eq.{max (succ u4) (succ u3)} (Finsupp.{u4, u3} γ M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.mapDomain.{u2, u4, u3} α γ M _inst_1 (Function.comp.{succ u2, succ u1, succ u4} α β γ g f) v) (Finsupp.mapDomain.{u1, u4, u3} β γ M _inst_1 g (Finsupp.mapDomain.{u2, u1, u3} α β M _inst_1 f v))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_comp Finsupp.mapDomain_compₓ'. -/
theorem mapDomain_comp {f : α → β} {g : β → γ} :
    mapDomain (g ∘ f) v = mapDomain g (mapDomain f v) :=
  by
  refine' ((sum_sum_index _ _).trans _).symm
  · intro
    exact single_zero _
  · intro
    exact single_add _
  refine' sum_congr fun _ _ => sum_single_index _
  · exact single_zero _
#align finsupp.map_domain_comp Finsupp.mapDomain_comp

/- warning: finsupp.map_domain_single -> Finsupp.mapDomain_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {f : α -> β} {a : α} {b : M}, Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f (Finsupp.single.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) a b)) (Finsupp.single.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (f a) b)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] {f : α -> β} {a : α} {b : M}, Eq.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.mapDomain.{u1, u3, u2} α β M _inst_1 f (Finsupp.single.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) a b)) (Finsupp.single.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (f a) b)
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_single Finsupp.mapDomain_singleₓ'. -/
@[simp]
theorem mapDomain_single {f : α → β} {a : α} {b : M} : mapDomain f (single a b) = single (f a) b :=
  sum_single_index <| single_zero _
#align finsupp.map_domain_single Finsupp.mapDomain_single

/- warning: finsupp.map_domain_zero -> Finsupp.mapDomain_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {f : α -> β}, Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f (OfNat.ofNat.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) 0 (OfNat.mk.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) 0 (Zero.zero.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))))) (OfNat.ofNat.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) 0 (OfNat.mk.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) 0 (Zero.zero.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] {f : α -> β}, Eq.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.mapDomain.{u1, u3, u2} α β M _inst_1 f (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) 0 (Zero.toOfNat0.{max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.zero.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))))) (OfNat.ofNat.{max u3 u2} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) 0 (Zero.toOfNat0.{max u3 u2} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.zero.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_zero Finsupp.mapDomain_zeroₓ'. -/
@[simp]
theorem mapDomain_zero {f : α → β} : mapDomain f (0 : α →₀ M) = (0 : β →₀ M) :=
  sum_zero_index
#align finsupp.map_domain_zero Finsupp.mapDomain_zero

/- warning: finsupp.map_domain_congr -> Finsupp.mapDomain_congr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {v : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))} {f : α -> β} {g : α -> β}, (forall (x : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) v)) -> (Eq.{succ u2} β (f x) (g x))) -> (Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f v) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 g v))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] {v : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))} {f : α -> β} {g : α -> β}, (forall (x : α), (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) x (Finsupp.support.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) v)) -> (Eq.{succ u1} β (f x) (g x))) -> (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f v) (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 g v))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_congr Finsupp.mapDomain_congrₓ'. -/
theorem mapDomain_congr {f g : α → β} (h : ∀ x ∈ v.support, f x = g x) :
    v.mapDomain f = v.mapDomain g :=
  Finset.sum_congr rfl fun _ H => by simp only [h _ H]
#align finsupp.map_domain_congr Finsupp.mapDomain_congr

/- warning: finsupp.map_domain_add -> Finsupp.mapDomain_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {v₁ : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))} {v₂ : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))} {f : α -> β}, Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f (HAdd.hAdd.{max u1 u3, max u1 u3, max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (instHAdd.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasAdd.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) v₁ v₂)) (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (instHAdd.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasAdd.{u2, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f v₁) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f v₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] {v₁ : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))} {v₂ : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))} {f : α -> β}, Eq.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.mapDomain.{u1, u3, u2} α β M _inst_1 f (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.add.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) v₁ v₂)) (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (instHAdd.{max u3 u2} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.add.{u3, u2} β M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.mapDomain.{u1, u3, u2} α β M _inst_1 f v₁) (Finsupp.mapDomain.{u1, u3, u2} α β M _inst_1 f v₂))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_add Finsupp.mapDomain_addₓ'. -/
theorem mapDomain_add {f : α → β} : mapDomain f (v₁ + v₂) = mapDomain f v₁ + mapDomain f v₂ :=
  sum_add_index' (fun _ => single_zero _) fun _ => single_add _
#align finsupp.map_domain_add Finsupp.mapDomain_add

/- warning: finsupp.map_domain_equiv_apply -> Finsupp.mapDomain_equiv_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {f : Equiv.{succ u1, succ u2} α β} (x : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (a : β), Eq.{succ u3} M (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (_x : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => β -> M) (Finsupp.hasCoeToFun.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} α β) (fun (_x : Equiv.{succ u1, succ u2} α β) => α -> β) (Equiv.hasCoeToFun.{succ u1, succ u2} α β) f) x) a) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (_x : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => α -> M) (Finsupp.hasCoeToFun.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) x (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} β α) (fun (_x : Equiv.{succ u2, succ u1} β α) => β -> α) (Equiv.hasCoeToFun.{succ u2, succ u1} β α) (Equiv.symm.{succ u1, succ u2} α β f) a))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] {f : Equiv.{succ u3, succ u2} α β} (x : Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (a : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.mapDomain.{u3, u2, u1} α β M _inst_1 (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α) => β) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} α β) f) x) a) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) x (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : β) => α) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} β α) (Equiv.symm.{succ u3, succ u2} α β f) a))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_equiv_apply Finsupp.mapDomain_equiv_applyₓ'. -/
@[simp]
theorem mapDomain_equiv_apply {f : α ≃ β} (x : α →₀ M) (a : β) : mapDomain f x a = x (f.symm a) :=
  by
  conv_lhs => rw [← f.apply_symm_apply a]
  exact map_domain_apply f.injective _ _
#align finsupp.map_domain_equiv_apply Finsupp.mapDomain_equiv_apply

/- warning: finsupp.map_domain.add_monoid_hom -> Finsupp.mapDomain.addMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (α -> β) -> (AddMonoidHom.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u2, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (α -> β) -> (AddMonoidHom.{max u3 u1, max u3 u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u2, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain.add_monoid_hom Finsupp.mapDomain.addMonoidHomₓ'. -/
/-- `finsupp.map_domain` is an `add_monoid_hom`. -/
@[simps]
def mapDomain.addMonoidHom (f : α → β) : (α →₀ M) →+ β →₀ M
    where
  toFun := mapDomain f
  map_zero' := mapDomain_zero
  map_add' _ _ := mapDomain_add
#align finsupp.map_domain.add_monoid_hom Finsupp.mapDomain.addMonoidHom

/- warning: finsupp.map_domain.add_monoid_hom_id -> Finsupp.mapDomain.addMonoidHom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M], Eq.{succ (max u1 u2)} (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.mapDomain.addMonoidHom.{u1, u1, u2} α α M _inst_1 (id.{succ u1} α)) (AddMonoidHom.id.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M], Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.addZeroClass.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.addZeroClass.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))) (Finsupp.mapDomain.addMonoidHom.{u2, u2, u1} α α M _inst_1 (id.{succ u2} α)) (AddMonoidHom.id.{max u1 u2} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.addZeroClass.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain.add_monoid_hom_id Finsupp.mapDomain.addMonoidHom_idₓ'. -/
@[simp]
theorem mapDomain.addMonoidHom_id : mapDomain.addMonoidHom id = AddMonoidHom.id (α →₀ M) :=
  AddMonoidHom.ext fun _ => mapDomain_id
#align finsupp.map_domain.add_monoid_hom_id Finsupp.mapDomain.addMonoidHom_id

/- warning: finsupp.map_domain.add_monoid_hom_comp -> Finsupp.mapDomain.addMonoidHom_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {M : Type.{u4}} [_inst_1 : AddCommMonoid.{u4} M] (f : β -> γ) (g : α -> β), Eq.{max (succ (max u3 u4)) (succ (max u1 u4))} (AddMonoidHom.{max u1 u4, max u3 u4} (Finsupp.{u1, u4} α M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.{u3, u4} γ M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.addZeroClass.{u3, u4} γ M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.mapDomain.addMonoidHom.{u1, u3, u4} α γ M _inst_1 (Function.comp.{succ u1, succ u2, succ u3} α β γ f g)) (AddMonoidHom.comp.{max u1 u4, max u2 u4, max u3 u4} (Finsupp.{u1, u4} α M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.{u3, u4} γ M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.addZeroClass.{u2, u4} β M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.addZeroClass.{u3, u4} γ M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.mapDomain.addMonoidHom.{u2, u3, u4} β γ M _inst_1 f) (Finsupp.mapDomain.addMonoidHom.{u1, u2, u4} α β M _inst_1 g))
but is expected to have type
  forall {α : Type.{u4}} {β : Type.{u1}} {γ : Type.{u3}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] (f : β -> γ) (g : α -> β), Eq.{max (max (succ u4) (succ u3)) (succ u2)} (AddMonoidHom.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u3, u2} γ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u4, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u3, u2} γ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.mapDomain.addMonoidHom.{u4, u3, u2} α γ M _inst_1 (Function.comp.{succ u4, succ u1, succ u3} α β γ f g)) (AddMonoidHom.comp.{max u2 u4, max u1 u2, max u3 u2} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u3, u2} γ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u4, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u1, u2} β M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addZeroClass.{u3, u2} γ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.mapDomain.addMonoidHom.{u1, u3, u2} β γ M _inst_1 f) (Finsupp.mapDomain.addMonoidHom.{u4, u1, u2} α β M _inst_1 g))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain.add_monoid_hom_comp Finsupp.mapDomain.addMonoidHom_compₓ'. -/
theorem mapDomain.addMonoidHom_comp (f : β → γ) (g : α → β) :
    (mapDomain.addMonoidHom (f ∘ g) : (α →₀ M) →+ γ →₀ M) =
      (mapDomain.addMonoidHom f).comp (mapDomain.addMonoidHom g) :=
  AddMonoidHom.ext fun _ => mapDomain_comp
#align finsupp.map_domain.add_monoid_hom_comp Finsupp.mapDomain.addMonoidHom_comp

/- warning: finsupp.map_domain_finset_sum -> Finsupp.mapDomain_finset_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {ι : Type.{u3}} {M : Type.{u4}} [_inst_1 : AddCommMonoid.{u4} M] {f : α -> β} {s : Finset.{u3} ι} {v : ι -> (Finsupp.{u1, u4} α M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))))}, Eq.{max (succ u2) (succ u4)} (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u4} α β M _inst_1 f (Finset.sum.{max u1 u4, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) ι (Finsupp.addCommMonoid.{u1, u4} α M _inst_1) s (fun (i : ι) => v i))) (Finset.sum.{max u2 u4, u3} (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) ι (Finsupp.addCommMonoid.{u2, u4} β M _inst_1) s (fun (i : ι) => Finsupp.mapDomain.{u1, u2, u4} α β M _inst_1 f (v i)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {ι : Type.{u4}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] {f : α -> β} {s : Finset.{u4} ι} {v : ι -> (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f (Finset.sum.{max u3 u2, u4} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) ι (Finsupp.addCommMonoid.{u3, u2} α M _inst_1) s (fun (i : ι) => v i))) (Finset.sum.{max u2 u1, u4} (Finsupp.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) ι (Finsupp.addCommMonoid.{u1, u2} β M _inst_1) s (fun (i : ι) => Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f (v i)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_finset_sum Finsupp.mapDomain_finset_sumₓ'. -/
theorem mapDomain_finset_sum {f : α → β} {s : Finset ι} {v : ι → α →₀ M} :
    mapDomain f (∑ i in s, v i) = ∑ i in s, mapDomain f (v i) :=
  (mapDomain.addMonoidHom f : (α →₀ M) →+ β →₀ M).map_sum _ _
#align finsupp.map_domain_finset_sum Finsupp.mapDomain_finset_sum

/- warning: finsupp.map_domain_sum -> Finsupp.mapDomain_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : Zero.{u4} N] {f : α -> β} {s : Finsupp.{u1, u4} α N _inst_2} {v : α -> N -> (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))}, Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f (Finsupp.sum.{u1, u4, max u1 u3} α N (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α M _inst_1) s v)) (Finsupp.sum.{u1, u4, max u2 u3} α N (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) _inst_2 (Finsupp.addCommMonoid.{u2, u3} β M _inst_1) s (fun (a : α) (b : N) => Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f (v a b)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {M : Type.{u2}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : Zero.{u4} N] {f : α -> β} {s : Finsupp.{u3, u4} α N _inst_2} {v : α -> N -> (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f (Finsupp.sum.{u3, u4, max u3 u2} α N (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u3, u2} α M _inst_1) s v)) (Finsupp.sum.{u3, u4, max u2 u1} α N (Finsupp.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u1, u2} β M _inst_1) s (fun (a : α) (b : N) => Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f (v a b)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_sum Finsupp.mapDomain_sumₓ'. -/
theorem mapDomain_sum [Zero N] {f : α → β} {s : α →₀ N} {v : α → N → α →₀ M} :
    mapDomain f (s.Sum v) = s.Sum fun a b => mapDomain f (v a b) :=
  (mapDomain.addMonoidHom f : (α →₀ M) →+ β →₀ M).map_finsupp_sum _ _
#align finsupp.map_domain_sum Finsupp.mapDomain_sum

/- warning: finsupp.map_domain_support -> Finsupp.mapDomain_support is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : DecidableEq.{succ u2} β] {f : α -> β} {s : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))}, HasSubset.Subset.{u2} (Finset.{u2} β) (Finset.hasSubset.{u2} β) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f s)) (Finset.image.{u1, u2} α β (fun (a : β) (b : β) => _inst_2 a b) f (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) s))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] [_inst_2 : DecidableEq.{succ u3} β] {f : α -> β} {s : Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))}, HasSubset.Subset.{u3} (Finset.{u3} β) (Finset.instHasSubsetFinset.{u3} β) (Finsupp.support.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) (Finsupp.mapDomain.{u2, u3, u1} α β M _inst_1 f s)) (Finset.image.{u2, u3} α β (fun (a : β) (b : β) => _inst_2 a b) f (Finsupp.support.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) s))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_support Finsupp.mapDomain_supportₓ'. -/
theorem mapDomain_support [DecidableEq β] {f : α → β} {s : α →₀ M} :
    (s.mapDomain f).support ⊆ s.support.image f :=
  Finset.Subset.trans support_sum <|
    Finset.Subset.trans (Finset.bunionᵢ_mono fun a ha => support_single_subset) <| by
      rw [Finset.bunionᵢ_singleton] <;> exact subset.refl _
#align finsupp.map_domain_support Finsupp.mapDomain_support

/- warning: finsupp.map_domain_apply' -> Finsupp.mapDomain_apply' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (S : Set.{u1} α) {f : α -> β} (x : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))), (HasSubset.Subset.{u1} (Set.{u1} α) (Set.hasSubset.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) x)) S) -> (Set.InjOn.{u1, u2} α β f S) -> (forall {a : α}, (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a S) -> (Eq.{succ u3} M (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (_x : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => β -> M) (Finsupp.hasCoeToFun.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f x) (f a)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (_x : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => α -> M) (Finsupp.hasCoeToFun.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) x a)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] (S : Set.{u3} α) {f : α -> β} (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))), (HasSubset.Subset.{u3} (Set.{u3} α) (Set.instHasSubsetSet.{u3} α) (Finset.toSet.{u3} α (Finsupp.support.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) x)) S) -> (Set.InjOn.{u3, u1} α β f S) -> (forall {a : α}, (Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a S) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) (f a)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u1, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f x) (f a)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) x a)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_apply' Finsupp.mapDomain_apply'ₓ'. -/
theorem mapDomain_apply' (S : Set α) {f : α → β} (x : α →₀ M) (hS : (x.support : Set α) ⊆ S)
    (hf : Set.InjOn f S) {a : α} (ha : a ∈ S) : mapDomain f x (f a) = x a := by
  classical
    rw [map_domain, sum_apply, Sum]
    simp_rw [single_apply]
    by_cases hax : a ∈ x.support
    · rw [← Finset.add_sum_erase _ _ hax, if_pos rfl]
      convert add_zero _
      refine' Finset.sum_eq_zero fun i hi => if_neg _
      exact (hf.mono hS).Ne (Finset.mem_of_mem_erase hi) hax (Finset.ne_of_mem_erase hi)
    · rw [not_mem_support_iff.1 hax]
      refine' Finset.sum_eq_zero fun i hi => if_neg _
      exact hf.ne (hS hi) ha (ne_of_mem_of_not_mem hi hax)
#align finsupp.map_domain_apply' Finsupp.mapDomain_apply'

/- warning: finsupp.map_domain_support_of_inj_on -> Finsupp.mapDomain_support_of_injOn is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : DecidableEq.{succ u2} β] {f : α -> β} (s : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))), (Set.InjOn.{u1, u2} α β f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) s))) -> (Eq.{succ u2} (Finset.{u2} β) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f s)) (Finset.image.{u1, u2} α β (fun (a : β) (b : β) => _inst_2 a b) f (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) s)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] [_inst_2 : DecidableEq.{succ u3} β] {f : α -> β} (s : Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))), (Set.InjOn.{u2, u3} α β f (Finset.toSet.{u2} α (Finsupp.support.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) s))) -> (Eq.{succ u3} (Finset.{u3} β) (Finsupp.support.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) (Finsupp.mapDomain.{u2, u3, u1} α β M _inst_1 f s)) (Finset.image.{u2, u3} α β (fun (a : β) (b : β) => _inst_2 a b) f (Finsupp.support.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) s)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_support_of_inj_on Finsupp.mapDomain_support_of_injOnₓ'. -/
theorem mapDomain_support_of_injOn [DecidableEq β] {f : α → β} (s : α →₀ M)
    (hf : Set.InjOn f s.support) : (mapDomain f s).support = Finset.image f s.support :=
  Finset.Subset.antisymm mapDomain_support <|
    by
    intro x hx
    simp only [mem_image, exists_prop, mem_support_iff, Ne.def] at hx
    rcases hx with ⟨hx_w, hx_h_left, rfl⟩
    simp only [mem_support_iff, Ne.def]
    rw [map_domain_apply' (↑s.support : Set _) _ _ hf]
    · exact hx_h_left
    · simp only [mem_coe, mem_support_iff, Ne.def]
      exact hx_h_left
    · exact subset.refl _
#align finsupp.map_domain_support_of_inj_on Finsupp.mapDomain_support_of_injOn

/- warning: finsupp.map_domain_support_of_injective -> Finsupp.mapDomain_support_of_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : DecidableEq.{succ u2} β] {f : α -> β}, (Function.Injective.{succ u1, succ u2} α β f) -> (forall (s : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))), Eq.{succ u2} (Finset.{u2} β) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f s)) (Finset.image.{u1, u2} α β (fun (a : β) (b : β) => _inst_2 a b) f (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) s)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] [_inst_2 : DecidableEq.{succ u3} β] {f : α -> β}, (Function.Injective.{succ u2, succ u3} α β f) -> (forall (s : Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))), Eq.{succ u3} (Finset.{u3} β) (Finsupp.support.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) (Finsupp.mapDomain.{u2, u3, u1} α β M _inst_1 f s)) (Finset.image.{u2, u3} α β (fun (a : β) (b : β) => _inst_2 a b) f (Finsupp.support.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) s)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_support_of_injective Finsupp.mapDomain_support_of_injectiveₓ'. -/
theorem mapDomain_support_of_injective [DecidableEq β] {f : α → β} (hf : Function.Injective f)
    (s : α →₀ M) : (mapDomain f s).support = Finset.image f s.support :=
  mapDomain_support_of_injOn s (hf.InjOn _)
#align finsupp.map_domain_support_of_injective Finsupp.mapDomain_support_of_injective

/- warning: finsupp.prod_map_domain_index -> Finsupp.prod_mapDomain_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : CommMonoid.{u4} N] {f : α -> β} {s : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))} {h : β -> M -> N}, (forall (b : β), Eq.{succ u4} N (h b (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))))) (OfNat.ofNat.{u4} N 1 (OfNat.mk.{u4} N 1 (One.one.{u4} N (MulOneClass.toHasOne.{u4} N (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_2))))))) -> (forall (b : β) (m₁ : M) (m₂ : M), Eq.{succ u4} N (h b (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) m₁ m₂)) (HMul.hMul.{u4, u4, u4} N N N (instHMul.{u4} N (MulOneClass.toHasMul.{u4} N (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_2)))) (h b m₁) (h b m₂))) -> (Eq.{succ u4} N (Finsupp.prod.{u2, u3, u4} β M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) _inst_2 (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f s) h) (Finsupp.prod.{u1, u3, u4} α M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) _inst_2 s (fun (a : α) (m : M) => h (f a) m)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {M : Type.{u2}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : CommMonoid.{u4} N] {f : α -> β} {s : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))} {h : β -> M -> N}, (forall (b : β), Eq.{succ u4} N (h b (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))) (OfNat.ofNat.{u4} N 1 (One.toOfNat1.{u4} N (Monoid.toOne.{u4} N (CommMonoid.toMonoid.{u4} N _inst_2))))) -> (forall (b : β) (m₁ : M) (m₂ : M), Eq.{succ u4} N (h b (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) m₁ m₂)) (HMul.hMul.{u4, u4, u4} N N N (instHMul.{u4} N (MulOneClass.toMul.{u4} N (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_2)))) (h b m₁) (h b m₂))) -> (Eq.{succ u4} N (Finsupp.prod.{u1, u2, u4} β M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) _inst_2 (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f s) h) (Finsupp.prod.{u3, u2, u4} α M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) _inst_2 s (fun (a : α) (m : M) => h (f a) m)))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_map_domain_index Finsupp.prod_mapDomain_indexₓ'. -/
@[to_additive]
theorem prod_mapDomain_index [CommMonoid N] {f : α → β} {s : α →₀ M} {h : β → M → N}
    (h_zero : ∀ b, h b 0 = 1) (h_add : ∀ b m₁ m₂, h b (m₁ + m₂) = h b m₁ * h b m₂) :
    (mapDomain f s).Prod h = s.Prod fun a m => h (f a) m :=
  (prod_sum_index h_zero h_add).trans <| prod_congr fun _ _ => prod_single_index (h_zero _)
#align finsupp.prod_map_domain_index Finsupp.prod_mapDomain_index
#align finsupp.sum_map_domain_index Finsupp.sum_mapDomain_index

/- warning: finsupp.sum_map_domain_index_add_monoid_hom -> Finsupp.sum_mapDomain_index_addMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u4} N] {f : α -> β} {s : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))} (h : β -> (AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))), Eq.{succ u4} N (Finsupp.sum.{u2, u3, u4} β M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) _inst_2 (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f s) (fun (b : β) (m : M) => coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (fun (_x : AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) => M -> N) (AddMonoidHom.hasCoeToFun.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (h b) m)) (Finsupp.sum.{u1, u3, u4} α M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) _inst_2 s (fun (a : α) (m : M) => coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (fun (_x : AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) => M -> N) (AddMonoidHom.hasCoeToFun.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (h (f a)) m))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {M : Type.{u2}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u4} N] {f : α -> β} {s : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))} (h : β -> (AddMonoidHom.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))), Eq.{succ u4} N (Finsupp.sum.{u1, u2, u4} β M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) _inst_2 (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f s) (fun (b : β) (m : M) => FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (AddMonoidHom.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => N) _x) (AddHomClass.toFunLike.{max u2 u4, u2, u4} (AddMonoidHom.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) M N (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toAdd.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u2 u4, u2, u4} (AddMonoidHom.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)) (AddMonoidHom.addMonoidHomClass.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))))) (h b) m)) (Finsupp.sum.{u3, u2, u4} α M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) _inst_2 s (fun (a : α) (m : M) => FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (AddMonoidHom.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => N) _x) (AddHomClass.toFunLike.{max u2 u4, u2, u4} (AddMonoidHom.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) M N (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (AddZeroClass.toAdd.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u2 u4, u2, u4} (AddMonoidHom.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)) (AddMonoidHom.addMonoidHomClass.{u2, u4} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))))) (h (f a)) m))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_map_domain_index_add_monoid_hom Finsupp.sum_mapDomain_index_addMonoidHomₓ'. -/
-- Note that in `prod_map_domain_index`, `M` is still an additive monoid,
-- so there is no analogous version in terms of `monoid_hom`.
/-- A version of `sum_map_domain_index` that takes a bundled `add_monoid_hom`,
rather than separate linearity hypotheses.
-/
@[simp]
theorem sum_mapDomain_index_addMonoidHom [AddCommMonoid N] {f : α → β} {s : α →₀ M}
    (h : β → M →+ N) : ((mapDomain f s).Sum fun b m => h b m) = s.Sum fun a m => h (f a) m :=
  @sum_mapDomain_index _ _ _ _ _ _ _ _ (fun b m => h b m) (fun b => (h b).map_zero) fun b m₁ m₂ =>
    (h b).map_add _ _
#align finsupp.sum_map_domain_index_add_monoid_hom Finsupp.sum_mapDomain_index_addMonoidHom

/- warning: finsupp.emb_domain_eq_map_domain -> Finsupp.embDomain_eq_mapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (f : Function.Embedding.{succ u1, succ u2} α β) (v : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))), Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.embDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) f v) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Function.Embedding.{succ u1, succ u2} α β) (fun (_x : Function.Embedding.{succ u1, succ u2} α β) => α -> β) (Function.Embedding.hasCoeToFun.{succ u1, succ u2} α β) f) v)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] (f : Function.Embedding.{succ u3, succ u2} α β) (v : Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.embDomain.{u3, u2, u1} α β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) f v) (Finsupp.mapDomain.{u3, u2, u1} α β M _inst_1 (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Function.Embedding.{succ u3, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u2} (Function.Embedding.{succ u3, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u3, succ u2} α β)) f) v)
Case conversion may be inaccurate. Consider using '#align finsupp.emb_domain_eq_map_domain Finsupp.embDomain_eq_mapDomainₓ'. -/
theorem embDomain_eq_mapDomain (f : α ↪ β) (v : α →₀ M) : embDomain f v = mapDomain f v :=
  by
  ext a
  by_cases a ∈ Set.range f
  · rcases h with ⟨a, rfl⟩
    rw [map_domain_apply f.injective, emb_domain_apply]
  · rw [map_domain_notin_range, emb_domain_notin_range] <;> assumption
#align finsupp.emb_domain_eq_map_domain Finsupp.embDomain_eq_mapDomain

/- warning: finsupp.prod_map_domain_index_inj -> Finsupp.prod_mapDomain_index_inj is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : CommMonoid.{u4} N] {f : α -> β} {s : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))} {h : β -> M -> N}, (Function.Injective.{succ u1, succ u2} α β f) -> (Eq.{succ u4} N (Finsupp.prod.{u2, u3, u4} β M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) _inst_2 (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f s) h) (Finsupp.prod.{u1, u3, u4} α M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) _inst_2 s (fun (a : α) (b : M) => h (f a) b)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {M : Type.{u2}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : CommMonoid.{u4} N] {f : α -> β} {s : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))} {h : β -> M -> N}, (Function.Injective.{succ u3, succ u1} α β f) -> (Eq.{succ u4} N (Finsupp.prod.{u1, u2, u4} β M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) _inst_2 (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f s) h) (Finsupp.prod.{u3, u2, u4} α M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) _inst_2 s (fun (a : α) (b : M) => h (f a) b)))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_map_domain_index_inj Finsupp.prod_mapDomain_index_injₓ'. -/
@[to_additive]
theorem prod_mapDomain_index_inj [CommMonoid N] {f : α → β} {s : α →₀ M} {h : β → M → N}
    (hf : Function.Injective f) : (s.mapDomain f).Prod h = s.Prod fun a b => h (f a) b := by
  rw [← Function.Embedding.coeFn_mk f hf, ← emb_domain_eq_map_domain, prod_emb_domain]
#align finsupp.prod_map_domain_index_inj Finsupp.prod_mapDomain_index_inj
#align finsupp.sum_map_domain_index_inj Finsupp.sum_mapDomain_index_inj

/- warning: finsupp.map_domain_injective -> Finsupp.mapDomain_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {f : α -> β}, (Function.Injective.{succ u1, succ u2} α β f) -> (Function.Injective.{max (succ u1) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] {f : α -> β}, (Function.Injective.{succ u3, succ u2} α β f) -> (Function.Injective.{max (succ u3) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.mapDomain.{u3, u2, u1} α β M _inst_1 f))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_injective Finsupp.mapDomain_injectiveₓ'. -/
theorem mapDomain_injective {f : α → β} (hf : Function.Injective f) :
    Function.Injective (mapDomain f : (α →₀ M) → β →₀ M) :=
  by
  intro v₁ v₂ eq
  ext a
  have : map_domain f v₁ (f a) = map_domain f v₂ (f a) := by rw [Eq]
  rwa [map_domain_apply hf, map_domain_apply hf] at this
#align finsupp.map_domain_injective Finsupp.mapDomain_injective

#print Finsupp.mapDomainEmbedding /-
/-- When `f` is an embedding we have an embedding `(α →₀ ℕ)  ↪ (β →₀ ℕ)` given by `map_domain`. -/
@[simps]
def mapDomainEmbedding {α β : Type _} (f : α ↪ β) : (α →₀ ℕ) ↪ β →₀ ℕ :=
  ⟨Finsupp.mapDomain f, Finsupp.mapDomain_injective f.Injective⟩
#align finsupp.map_domain_embedding Finsupp.mapDomainEmbedding
-/

/- warning: finsupp.map_domain.add_monoid_hom_comp_map_range -> Finsupp.mapDomain.addMonoidHom_comp_mapRange is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u4} N] (f : α -> β) (g : AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))), Eq.{max (succ (max u2 u4)) (succ (max u1 u3))} (AddMonoidHom.{max u1 u3, max u2 u4} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u2, u4} β N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (AddMonoidHom.comp.{max u1 u3, max u1 u4, max u2 u4} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u1, u4} α N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u1, u4} α N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.addZeroClass.{u2, u4} β N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.mapDomain.addMonoidHom.{u1, u2, u4} α β N _inst_2 f) (Finsupp.mapRange.addMonoidHom.{u1, u3, u4} α M N _inst_1 _inst_2 g)) (AddMonoidHom.comp.{max u1 u3, max u2 u3, max u2 u4} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u2, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u2, u4} β N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.mapRange.addMonoidHom.{u2, u3, u4} β M N _inst_1 _inst_2 g) (Finsupp.mapDomain.addMonoidHom.{u1, u2, u3} α β M _inst_1 f))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u4} N] (f : α -> β) (g : AddMonoidHom.{u3, u4} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))), Eq.{max (max (max (succ u2) (succ u1)) (succ u3)) (succ u4)} (AddMonoidHom.{max u3 u2, max u1 u4} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u4} β N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.addZeroClass.{u2, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u1, u4} β N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (AddMonoidHom.comp.{max u3 u2, max u2 u4, max u1 u4} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u2, u4} α N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.{u1, u4} β N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.addZeroClass.{u2, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u2, u4} α N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.addZeroClass.{u1, u4} β N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.mapDomain.addMonoidHom.{u2, u1, u4} α β N _inst_2 f) (Finsupp.mapRange.addMonoidHom.{u2, u3, u4} α M N _inst_1 _inst_2 g)) (AddMonoidHom.comp.{max u3 u2, max u3 u1, max u4 u1} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u4} β N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.addZeroClass.{u2, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u1, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.addZeroClass.{u1, u4} β N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.mapRange.addMonoidHom.{u1, u3, u4} β M N _inst_1 _inst_2 g) (Finsupp.mapDomain.addMonoidHom.{u2, u1, u3} α β M _inst_1 f))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain.add_monoid_hom_comp_map_range Finsupp.mapDomain.addMonoidHom_comp_mapRangeₓ'. -/
theorem mapDomain.addMonoidHom_comp_mapRange [AddCommMonoid N] (f : α → β) (g : M →+ N) :
    (mapDomain.addMonoidHom f).comp (mapRange.addMonoidHom g) =
      (mapRange.addMonoidHom g).comp (mapDomain.addMonoidHom f) :=
  by
  ext
  simp
#align finsupp.map_domain.add_monoid_hom_comp_map_range Finsupp.mapDomain.addMonoidHom_comp_mapRange

/- warning: finsupp.map_domain_map_range -> Finsupp.mapDomain_mapRange is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u4} N] (f : α -> β) (v : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (g : M -> N) (h0 : Eq.{succ u4} N (g (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))))) (OfNat.ofNat.{u4} N 0 (OfNat.mk.{u4} N 0 (Zero.zero.{u4} N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))))))), (forall (x : M) (y : M), Eq.{succ u4} N (g (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) x y)) (HAdd.hAdd.{u4, u4, u4} N N N (instHAdd.{u4} N (AddZeroClass.toHasAdd.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (g x) (g y))) -> (Eq.{max (succ u2) (succ u4)} (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (Finsupp.mapDomain.{u1, u2, u4} α β N _inst_2 f (Finsupp.mapRange.{u1, u3, u4} α M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) g h0 v)) (Finsupp.mapRange.{u2, u3, u4} β M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) g h0 (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f v)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {M : Type.{u2}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u4} N] (f : α -> β) (v : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (g : M -> N) (h0 : Eq.{succ u4} N (g (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))) (OfNat.ofNat.{u4} N 0 (Zero.toOfNat0.{u4} N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))))), (forall (x : M) (y : M), Eq.{succ u4} N (g (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) x y)) (HAdd.hAdd.{u4, u4, u4} N N N (instHAdd.{u4} N (AddZeroClass.toAdd.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (g x) (g y))) -> (Eq.{max (succ u1) (succ u4)} (Finsupp.{u1, u4} β N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Finsupp.mapDomain.{u3, u1, u4} α β N _inst_2 f (Finsupp.mapRange.{u3, u2, u4} α M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)) g h0 v)) (Finsupp.mapRange.{u1, u2, u4} β M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)) g h0 (Finsupp.mapDomain.{u3, u1, u2} α β M _inst_1 f v)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_map_range Finsupp.mapDomain_mapRangeₓ'. -/
/-- When `g` preserves addition, `map_range` and `map_domain` commute. -/
theorem mapDomain_mapRange [AddCommMonoid N] (f : α → β) (v : α →₀ M) (g : M → N) (h0 : g 0 = 0)
    (hadd : ∀ x y, g (x + y) = g x + g y) :
    mapDomain f (mapRange g h0 v) = mapRange g h0 (mapDomain f v) :=
  let g' : M →+ N :=
    { toFun := g
      map_zero' := h0
      map_add' := hadd }
  AddMonoidHom.congr_fun (mapDomain.addMonoidHom_comp_mapRange f g') v
#align finsupp.map_domain_map_range Finsupp.mapDomain_mapRange

/- warning: finsupp.sum_update_add -> Finsupp.sum_update_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {ι : Type.{u3}} [_inst_2 : AddCommMonoid.{u1} α] [_inst_3 : AddCommMonoid.{u2} β] (f : Finsupp.{u3, u1} ι α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_2)))) (i : ι) (a : α) (g : ι -> α -> β), (forall (i : ι), Eq.{succ u2} β (g i (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_2))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_3))))))) -> (forall (j : ι) (a₁ : α) (a₂ : α), Eq.{succ u2} β (g j (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_2)))) a₁ a₂)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_3)))) (g j a₁) (g j a₂))) -> (Eq.{succ u2} β (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_3)))) (Finsupp.sum.{u3, u1, u2} ι α β (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_2))) _inst_3 (Finsupp.update.{u3, u1} ι α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_2))) f i a) g) (g i (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} ι α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_2)))) (fun (_x : Finsupp.{u3, u1} ι α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_2)))) => ι -> α) (Finsupp.hasCoeToFun.{u3, u1} ι α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_2)))) f i))) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_3)))) (Finsupp.sum.{u3, u1, u2} ι α β (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_2))) _inst_3 f g) (g i a)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {ι : Type.{u1}} [_inst_2 : AddCommMonoid.{u3} α] [_inst_3 : AddCommMonoid.{u2} β] (f : Finsupp.{u1, u3} ι α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_2))) (i : ι) (a : α) (g : ι -> α -> β), (forall (i : ι), Eq.{succ u2} β (g i (OfNat.ofNat.{u3} α 0 (Zero.toOfNat0.{u3} α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_2))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (AddMonoid.toZero.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_3))))) -> (forall (j : ι) (a₁ : α) (a₂ : α), Eq.{succ u2} β (g j (HAdd.hAdd.{u3, u3, u3} α α α (instHAdd.{u3} α (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_2)))) a₁ a₂)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_3)))) (g j a₁) (g j a₂))) -> (Eq.{succ u2} β (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_3)))) (Finsupp.sum.{u1, u3, u2} ι α β (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_2)) _inst_3 (Finsupp.update.{u1, u3} ι α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_2)) f i a) g) (g i (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} ι α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_2))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u1, u3} ι α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_2))) f i))) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β _inst_3)))) (Finsupp.sum.{u1, u3, u2} ι α β (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_2)) _inst_3 f g) (g i a)))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_update_add Finsupp.sum_update_addₓ'. -/
theorem sum_update_add [AddCommMonoid α] [AddCommMonoid β] (f : ι →₀ α) (i : ι) (a : α)
    (g : ι → α → β) (hg : ∀ i, g i 0 = 0)
    (hgg : ∀ (j : ι) (a₁ a₂ : α), g j (a₁ + a₂) = g j a₁ + g j a₂) :
    (f.update i a).Sum g + g i (f i) = f.Sum g + g i a :=
  by
  rw [update_eq_erase_add_single, sum_add_index' hg hgg]
  conv_rhs => rw [← Finsupp.update_self f i]
  rw [update_eq_erase_add_single, sum_add_index' hg hgg, add_assoc, add_assoc]
  congr 1
  rw [add_comm, sum_single_index (hg _), sum_single_index (hg _)]
#align finsupp.sum_update_add Finsupp.sum_update_add

/- warning: finsupp.map_domain_inj_on -> Finsupp.mapDomain_injOn is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (S : Set.{u1} α) {f : α -> β}, (Set.InjOn.{u1, u2} α β f S) -> (Set.InjOn.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f) (setOf.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (w : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => HasSubset.Subset.{u1} (Set.{u1} α) (Set.hasSubset.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) w)) S)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] (S : Set.{u3} α) {f : α -> β}, (Set.InjOn.{u3, u2} α β f S) -> (Set.InjOn.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.mapDomain.{u3, u2, u1} α β M _inst_1 f) (setOf.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (fun (w : Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) => HasSubset.Subset.{u3} (Set.{u3} α) (Set.instHasSubsetSet.{u3} α) (Finset.toSet.{u3} α (Finsupp.support.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) w)) S)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_inj_on Finsupp.mapDomain_injOnₓ'. -/
theorem mapDomain_injOn (S : Set α) {f : α → β} (hf : Set.InjOn f S) :
    Set.InjOn (mapDomain f : (α →₀ M) → β →₀ M) { w | (w.support : Set α) ⊆ S } :=
  by
  intro v₁ hv₁ v₂ hv₂ eq
  ext a
  classical
    by_cases h : a ∈ v₁.support ∪ v₂.support
    ·
      rw [← map_domain_apply' S _ hv₁ hf _, ← map_domain_apply' S _ hv₂ hf _, Eq] <;>
        · apply Set.union_subset hv₁ hv₂
          exact_mod_cast h
    · simp only [Decidable.not_or_iff_and_not, mem_union, Classical.not_not, mem_support_iff] at h
      simp [h]
#align finsupp.map_domain_inj_on Finsupp.mapDomain_injOn

/- warning: finsupp.equiv_map_domain_eq_map_domain -> Finsupp.equivMapDomain_eq_mapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] (f : Equiv.{succ u1, succ u2} α β) (l : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)))), Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)))) (Finsupp.equivMapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) f l) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_2 (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} α β) (fun (_x : Equiv.{succ u1, succ u2} α β) => α -> β) (Equiv.hasCoeToFun.{succ u1, succ u2} α β) f) l)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] (f : Equiv.{succ u2, succ u1} α β) (l : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.equivMapDomain.{u2, u1, u3} α β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) f l) (Finsupp.mapDomain.{u2, u1, u3} α β M _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α) => β) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} α β) f) l)
Case conversion may be inaccurate. Consider using '#align finsupp.equiv_map_domain_eq_map_domain Finsupp.equivMapDomain_eq_mapDomainₓ'. -/
theorem equivMapDomain_eq_mapDomain {M} [AddCommMonoid M] (f : α ≃ β) (l : α →₀ M) :
    equivMapDomain f l = mapDomain f l := by ext x <;> simp [map_domain_equiv_apply]
#align finsupp.equiv_map_domain_eq_map_domain Finsupp.equivMapDomain_eq_mapDomain

end MapDomain

/-! ### Declarations about `comap_domain` -/


section ComapDomain

#print Finsupp.comapDomain /-
/-- Given `f : α → β`, `l : β →₀ M` and a proof `hf` that `f` is injective on
the preimage of `l.support`, `comap_domain f l hf` is the finitely supported function
from `α` to `M` given by composing `l` with `f`. -/
@[simps support]
def comapDomain [Zero M] (f : α → β) (l : β →₀ M) (hf : Set.InjOn f (f ⁻¹' ↑l.support)) : α →₀ M
    where
  support := l.support.Preimage f hf
  toFun a := l (f a)
  mem_support_toFun := by
    intro a
    simp only [finset.mem_def.symm, Finset.mem_preimage]
    exact l.mem_support_to_fun (f a)
#align finsupp.comap_domain Finsupp.comapDomain
-/

#print Finsupp.comapDomain_apply /-
@[simp]
theorem comapDomain_apply [Zero M] (f : α → β) (l : β →₀ M) (hf : Set.InjOn f (f ⁻¹' ↑l.support))
    (a : α) : comapDomain f l hf a = l (f a) :=
  rfl
#align finsupp.comap_domain_apply Finsupp.comapDomain_apply
-/

/- warning: finsupp.sum_comap_domain -> Finsupp.sum_comapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : Zero.{u3} M] [_inst_2 : AddCommMonoid.{u4} N] (f : α -> β) (l : Finsupp.{u2, u3} β M _inst_1) (g : β -> M -> N) (hf : Set.BijOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M _inst_1 l))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M _inst_1 l))), Eq.{succ u4} N (Finsupp.sum.{u1, u3, u4} α M N _inst_1 _inst_2 (Finsupp.comapDomain.{u1, u2, u3} α β M _inst_1 f l (Set.BijOn.injOn.{u1, u2} α β (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M _inst_1 l))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M _inst_1 l)) f hf)) (Function.comp.{succ u1, succ u2, max (succ u3) (succ u4)} α β (M -> N) g f)) (Finsupp.sum.{u2, u3, u4} β M N _inst_1 _inst_2 l g)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u4}} {N : Type.{u3}} [_inst_1 : Zero.{u4} M] [_inst_2 : AddCommMonoid.{u3} N] (f : α -> β) (l : Finsupp.{u2, u4} β M _inst_1) (g : β -> M -> N) (hf : Set.BijOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M _inst_1 l))) (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M _inst_1 l))), Eq.{succ u3} N (Finsupp.sum.{u1, u4, u3} α M N _inst_1 _inst_2 (Finsupp.comapDomain.{u1, u2, u4} α β M _inst_1 f l (Set.BijOn.injOn.{u2, u1} α β (Set.preimage.{u1, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M _inst_1 l))) (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M _inst_1 l)) f hf)) (Function.comp.{succ u1, succ u2, max (succ u4) (succ u3)} α β (M -> N) g f)) (Finsupp.sum.{u2, u4, u3} β M N _inst_1 _inst_2 l g)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_comap_domain Finsupp.sum_comapDomainₓ'. -/
theorem sum_comapDomain [Zero M] [AddCommMonoid N] (f : α → β) (l : β →₀ M) (g : β → M → N)
    (hf : Set.BijOn f (f ⁻¹' ↑l.support) ↑l.support) :
    (comapDomain f l hf.InjOn).Sum (g ∘ f) = l.Sum g :=
  by
  simp only [Sum, comap_domain_apply, (· ∘ ·)]
  simp [comap_domain, Finset.sum_preimage_of_bij f _ _ fun x => g x (l x)]
#align finsupp.sum_comap_domain Finsupp.sum_comapDomain

/- warning: finsupp.eq_zero_of_comap_domain_eq_zero -> Finsupp.eq_zero_of_comapDomain_eq_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (f : α -> β) (l : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (hf : Set.BijOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) l))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) l))), (Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) f l (Set.BijOn.injOn.{u1, u2} α β (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) l))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) l)) f hf)) (OfNat.ofNat.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) 0 (OfNat.mk.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) 0 (Zero.zero.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))))) -> (Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) l (OfNat.ofNat.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) 0 (OfNat.mk.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) 0 (Zero.zero.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (f : α -> β) (l : Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (hf : Set.BijOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) l))) (Finset.toSet.{u2} β (Finsupp.support.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) l))), (Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) f l (Set.BijOn.injOn.{u2, u1} α β (Set.preimage.{u1, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) l))) (Finset.toSet.{u2} β (Finsupp.support.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) l)) f hf)) (OfNat.ofNat.{max u1 u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) 0 (Zero.toOfNat0.{max u1 u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.zero.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))) -> (Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) l (OfNat.ofNat.{max u2 u3} (Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) 0 (Zero.toOfNat0.{max u2 u3} (Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.zero.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finsupp.eq_zero_of_comap_domain_eq_zero Finsupp.eq_zero_of_comapDomain_eq_zeroₓ'. -/
theorem eq_zero_of_comapDomain_eq_zero [AddCommMonoid M] (f : α → β) (l : β →₀ M)
    (hf : Set.BijOn f (f ⁻¹' ↑l.support) ↑l.support) : comapDomain f l hf.InjOn = 0 → l = 0 :=
  by
  rw [← support_eq_empty, ← support_eq_empty, comap_domain]
  simp only [Finset.ext_iff, Finset.not_mem_empty, iff_false_iff, mem_preimage]
  intro h a ha
  cases' hf.2.2 ha with b hb
  exact h b (hb.2.symm ▸ ha)
#align finsupp.eq_zero_of_comap_domain_eq_zero Finsupp.eq_zero_of_comapDomain_eq_zero

section FInjective

section Zero

variable [Zero M]

/- warning: finsupp.comap_domain_zero -> Finsupp.comapDomain_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : Zero.{u3} M] (f : α -> β) (hif : optParam.{0} (Set.InjOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M _inst_1 (OfNat.ofNat.{max u2 u3} (Finsupp.{u2, u3} β M _inst_1) 0 (OfNat.mk.{max u2 u3} (Finsupp.{u2, u3} β M _inst_1) 0 (Zero.zero.{max u2 u3} (Finsupp.{u2, u3} β M _inst_1) (Finsupp.hasZero.{u2, u3} β M _inst_1)))))))) (Set.injOn_empty.{u1, u2} α β f)), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M _inst_1) (Finsupp.comapDomain.{u1, u2, u3} α β M _inst_1 f (OfNat.ofNat.{max u2 u3} (Finsupp.{u2, u3} β M _inst_1) 0 (OfNat.mk.{max u2 u3} (Finsupp.{u2, u3} β M _inst_1) 0 (Zero.zero.{max u2 u3} (Finsupp.{u2, u3} β M _inst_1) (Finsupp.hasZero.{u2, u3} β M _inst_1)))) hif) (OfNat.ofNat.{max u1 u3} (Finsupp.{u1, u3} α M _inst_1) 0 (OfNat.mk.{max u1 u3} (Finsupp.{u1, u3} α M _inst_1) 0 (Zero.zero.{max u1 u3} (Finsupp.{u1, u3} α M _inst_1) (Finsupp.hasZero.{u1, u3} α M _inst_1))))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : α -> β) (hif : optParam.{0} (Set.InjOn.{u3, u2} α β f (Set.preimage.{u3, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u1} β M _inst_1 (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} β M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} β M _inst_1) (Finsupp.zero.{u2, u1} β M _inst_1))))))) (Eq.rec.{0, succ u2} (Set.{u2} β) (EmptyCollection.emptyCollection.{u2} (Set.{u2} β) (Set.instEmptyCollectionSet.{u2} β)) (fun (x._@.Mathlib.Data.Finsupp.Basic._hyg.7193 : Set.{u2} β) (h._@.Mathlib.Data.Finsupp.Basic._hyg.7194 : Eq.{succ u2} (Set.{u2} β) (EmptyCollection.emptyCollection.{u2} (Set.{u2} β) (Set.instEmptyCollectionSet.{u2} β)) x._@.Mathlib.Data.Finsupp.Basic._hyg.7193) => Set.InjOn.{u3, u2} α β f (Set.preimage.{u3, u2} α β f x._@.Mathlib.Data.Finsupp.Basic._hyg.7193)) (Set.injOn_empty.{u2, u3} α β f) (Finset.toSet.{u2} β (EmptyCollection.emptyCollection.{u2} (Finset.{u2} β) (Finset.instEmptyCollectionFinset.{u2} β))) (Eq.symm.{succ u2} (Set.{u2} β) (Finset.toSet.{u2} β (EmptyCollection.emptyCollection.{u2} (Finset.{u2} β) (Finset.instEmptyCollectionFinset.{u2} β))) (EmptyCollection.emptyCollection.{u2} (Set.{u2} β) (Set.instEmptyCollectionSet.{u2} β)) (Finset.coe_empty.{u2} β)))), Eq.{max (succ u3) (succ u1)} (Finsupp.{u3, u1} α M _inst_1) (Finsupp.comapDomain.{u3, u2, u1} α β M _inst_1 f (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} β M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} β M _inst_1) (Finsupp.zero.{u2, u1} β M _inst_1))) hif) (OfNat.ofNat.{max u3 u1} (Finsupp.{u3, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u3 u1} (Finsupp.{u3, u1} α M _inst_1) (Finsupp.zero.{u3, u1} α M _inst_1)))
Case conversion may be inaccurate. Consider using '#align finsupp.comap_domain_zero Finsupp.comapDomain_zeroₓ'. -/
/-- Note the `hif` argument is needed for this to work in `rw`. -/
@[simp]
theorem comapDomain_zero (f : α → β)
    (hif : Set.InjOn f (f ⁻¹' ↑(0 : β →₀ M).support) := Set.injOn_empty _) :
    comapDomain f (0 : β →₀ M) hif = (0 : α →₀ M) :=
  by
  ext
  rfl
#align finsupp.comap_domain_zero Finsupp.comapDomain_zero

/- warning: finsupp.comap_domain_single -> Finsupp.comapDomain_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : Zero.{u3} M] (f : α -> β) (a : α) (m : M) (hif : Set.InjOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M _inst_1 (Finsupp.single.{u2, u3} β M _inst_1 (f a) m))))), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M _inst_1) (Finsupp.comapDomain.{u1, u2, u3} α β M _inst_1 f (Finsupp.single.{u2, u3} β M _inst_1 (f a) m) hif) (Finsupp.single.{u1, u3} α M _inst_1 a m)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (f : α -> β) (a : α) (m : M) (hif : Set.InjOn.{u3, u2} α β f (Set.preimage.{u3, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u1} β M _inst_1 (Finsupp.single.{u2, u1} β M _inst_1 (f a) m))))), Eq.{max (succ u3) (succ u1)} (Finsupp.{u3, u1} α M _inst_1) (Finsupp.comapDomain.{u3, u2, u1} α β M _inst_1 f (Finsupp.single.{u2, u1} β M _inst_1 (f a) m) hif) (Finsupp.single.{u3, u1} α M _inst_1 a m)
Case conversion may be inaccurate. Consider using '#align finsupp.comap_domain_single Finsupp.comapDomain_singleₓ'. -/
@[simp]
theorem comapDomain_single (f : α → β) (a : α) (m : M)
    (hif : Set.InjOn f (f ⁻¹' (single (f a) m).support)) :
    comapDomain f (Finsupp.single (f a) m) hif = Finsupp.single a m :=
  by
  rcases eq_or_ne m 0 with (rfl | hm)
  · simp only [single_zero, comap_domain_zero]
  · rw [eq_single_iff, comap_domain_apply, comap_domain_support, ← Finset.coe_subset, coe_preimage,
      support_single_ne_zero _ hm, coe_singleton, coe_singleton, single_eq_same]
    rw [support_single_ne_zero _ hm, coe_singleton] at hif
    exact ⟨fun x hx => hif hx rfl hx, rfl⟩
#align finsupp.comap_domain_single Finsupp.comapDomain_single

end Zero

section AddZeroClass

variable [AddZeroClass M] {f : α → β}

/- warning: finsupp.comap_domain_add -> Finsupp.comapDomain_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddZeroClass.{u3} M] {f : α -> β} (v₁ : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (v₂ : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (hv₁ : Set.InjOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1) v₁)))) (hv₂ : Set.InjOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1) v₂)))) (hv₁₂ : Set.InjOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1) (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (instHAdd.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.hasAdd.{u2, u3} β M _inst_1)) v₁ v₂))))), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M _inst_1) f (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (instHAdd.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.hasAdd.{u2, u3} β M _inst_1)) v₁ v₂) hv₁₂) (HAdd.hAdd.{max u1 u3, max u1 u3, max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (instHAdd.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.hasAdd.{u1, u3} α M _inst_1)) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M _inst_1) f v₁ hv₁) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M _inst_1) f v₂ hv₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M] {f : α -> β} (v₁ : Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (v₂ : Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (hv₁ : Set.InjOn.{u1, u3} α β f (Set.preimage.{u1, u3} α β f (Finset.toSet.{u3} β (Finsupp.support.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1) v₁)))) (hv₂ : Set.InjOn.{u1, u3} α β f (Set.preimage.{u1, u3} α β f (Finset.toSet.{u3} β (Finsupp.support.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1) v₂)))) (hv₁₂ : Set.InjOn.{u1, u3} α β f (Set.preimage.{u1, u3} α β f (Finset.toSet.{u3} β (Finsupp.support.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1) (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (instHAdd.{max u3 u2} (Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.add.{u3, u2} β M _inst_1)) v₁ v₂))))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.comapDomain.{u1, u3, u2} α β M (AddZeroClass.toZero.{u2} M _inst_1) f (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (instHAdd.{max u3 u2} (Finsupp.{u3, u2} β M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.add.{u3, u2} β M _inst_1)) v₁ v₂) hv₁₂) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.add.{u1, u2} α M _inst_1)) (Finsupp.comapDomain.{u1, u3, u2} α β M (AddZeroClass.toZero.{u2} M _inst_1) f v₁ hv₁) (Finsupp.comapDomain.{u1, u3, u2} α β M (AddZeroClass.toZero.{u2} M _inst_1) f v₂ hv₂))
Case conversion may be inaccurate. Consider using '#align finsupp.comap_domain_add Finsupp.comapDomain_addₓ'. -/
theorem comapDomain_add (v₁ v₂ : β →₀ M) (hv₁ : Set.InjOn f (f ⁻¹' ↑v₁.support))
    (hv₂ : Set.InjOn f (f ⁻¹' ↑v₂.support)) (hv₁₂ : Set.InjOn f (f ⁻¹' ↑(v₁ + v₂).support)) :
    comapDomain f (v₁ + v₂) hv₁₂ = comapDomain f v₁ hv₁ + comapDomain f v₂ hv₂ :=
  by
  ext
  simp only [comap_domain_apply, coe_add, Pi.add_apply]
#align finsupp.comap_domain_add Finsupp.comapDomain_add

/- warning: finsupp.comap_domain_add_of_injective -> Finsupp.comapDomain_add_of_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddZeroClass.{u3} M] {f : α -> β} (hf : Function.Injective.{succ u1, succ u2} α β f) (v₁ : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (v₂ : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M _inst_1) f (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (instHAdd.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.hasAdd.{u2, u3} β M _inst_1)) v₁ v₂) (Function.Injective.injOn.{u1, u2} α β f hf (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1) (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (instHAdd.{max u2 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.hasAdd.{u2, u3} β M _inst_1)) v₁ v₂)))))) (HAdd.hAdd.{max u1 u3, max u1 u3, max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (instHAdd.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.hasAdd.{u1, u3} α M _inst_1)) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M _inst_1) f v₁ (Function.Injective.injOn.{u1, u2} α β f hf (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1) v₁))))) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M _inst_1) f v₂ (Function.Injective.injOn.{u1, u2} α β f hf (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1) v₂))))))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddZeroClass.{u1} M] {f : α -> β} (hf : Function.Injective.{succ u3, succ u2} α β f) (v₁ : Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)) (v₂ : Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)), Eq.{max (succ u3) (succ u1)} (Finsupp.{u3, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.comapDomain.{u3, u2, u1} α β M (AddZeroClass.toZero.{u1} M _inst_1) f (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)) (instHAdd.{max u2 u1} (Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M _inst_1)) v₁ v₂) (Function.Injective.injOn.{u2, u3} α β f hf (Set.preimage.{u3, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)) (instHAdd.{max u2 u1} (Finsupp.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M _inst_1)) v₁ v₂)))))) (HAdd.hAdd.{max u3 u1, max u3 u1, max u3 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u3, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u3, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (instHAdd.{max u3 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M _inst_1)) (Finsupp.comapDomain.{u3, u2, u1} α β M (AddZeroClass.toZero.{u1} M _inst_1) f v₁ (Function.Injective.injOn.{u2, u3} α β f hf (Set.preimage.{u3, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1) v₁))))) (Finsupp.comapDomain.{u3, u2, u1} α β M (AddZeroClass.toZero.{u1} M _inst_1) f v₂ (Function.Injective.injOn.{u2, u3} α β f hf (Set.preimage.{u3, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u1} β M (AddZeroClass.toZero.{u1} M _inst_1) v₂))))))
Case conversion may be inaccurate. Consider using '#align finsupp.comap_domain_add_of_injective Finsupp.comapDomain_add_of_injectiveₓ'. -/
/-- A version of `finsupp.comap_domain_add` that's easier to use. -/
theorem comapDomain_add_of_injective (hf : Function.Injective f) (v₁ v₂ : β →₀ M) :
    comapDomain f (v₁ + v₂) (hf.InjOn _) =
      comapDomain f v₁ (hf.InjOn _) + comapDomain f v₂ (hf.InjOn _) :=
  comapDomain_add _ _ _ _ _
#align finsupp.comap_domain_add_of_injective Finsupp.comapDomain_add_of_injective

/- warning: finsupp.comap_domain.add_monoid_hom -> Finsupp.comapDomain.addMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddZeroClass.{u3} M] {f : α -> β}, (Function.Injective.{succ u1, succ u2} α β f) -> (AddMonoidHom.{max u2 u3, max u1 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M _inst_1)) (Finsupp.addZeroClass.{u2, u3} β M _inst_1) (Finsupp.addZeroClass.{u1, u3} α M _inst_1))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddZeroClass.{u3} M] {f : α -> β}, (Function.Injective.{succ u1, succ u2} α β f) -> (AddMonoidHom.{max u3 u2, max u3 u1} (Finsupp.{u2, u3} β M (AddZeroClass.toZero.{u3} M _inst_1)) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_1)) (Finsupp.addZeroClass.{u2, u3} β M _inst_1) (Finsupp.addZeroClass.{u1, u3} α M _inst_1))
Case conversion may be inaccurate. Consider using '#align finsupp.comap_domain.add_monoid_hom Finsupp.comapDomain.addMonoidHomₓ'. -/
/-- `finsupp.comap_domain` is an `add_monoid_hom`. -/
@[simps]
def comapDomain.addMonoidHom (hf : Function.Injective f) : (β →₀ M) →+ α →₀ M
    where
  toFun x := comapDomain f x (hf.InjOn _)
  map_zero' := comapDomain_zero f
  map_add' := comapDomain_add_of_injective hf
#align finsupp.comap_domain.add_monoid_hom Finsupp.comapDomain.addMonoidHom

end AddZeroClass

variable [AddCommMonoid M] (f : α → β)

/- warning: finsupp.map_domain_comap_domain -> Finsupp.mapDomain_comapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (f : α -> β) (hf : Function.Injective.{succ u1, succ u2} α β f) (l : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))), (HasSubset.Subset.{u2} (Set.{u2} β) (Set.hasSubset.{u2} β) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) l)) (Set.range.{u2, succ u1} β α f)) -> (Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) f l (Function.Injective.injOn.{u1, u2} α β f hf (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) l)))))) l)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] (f : α -> β) (hf : Function.Injective.{succ u3, succ u2} α β f) (l : Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))), (HasSubset.Subset.{u2} (Set.{u2} β) (Set.instHasSubsetSet.{u2} β) (Finset.toSet.{u2} β (Finsupp.support.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) l)) (Set.range.{u2, succ u3} β α f)) -> (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.mapDomain.{u3, u2, u1} α β M _inst_1 f (Finsupp.comapDomain.{u3, u2, u1} α β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) f l (Function.Injective.injOn.{u2, u3} α β f hf (Set.preimage.{u3, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) l)))))) l)
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_comap_domain Finsupp.mapDomain_comapDomainₓ'. -/
theorem mapDomain_comapDomain (hf : Function.Injective f) (l : β →₀ M)
    (hl : ↑l.support ⊆ Set.range f) : mapDomain f (comapDomain f l (hf.InjOn _)) = l :=
  by
  ext a
  by_cases h_cases : a ∈ Set.range f
  · rcases Set.mem_range.1 h_cases with ⟨b, hb⟩
    rw [hb.symm, map_domain_apply hf, comap_domain_apply]
  · rw [map_domain_notin_range _ _ h_cases]
    by_contra h_contr
    apply h_cases (hl <| Finset.mem_coe.2 <| mem_support_iff.2 fun h => h_contr h.symm)
#align finsupp.map_domain_comap_domain Finsupp.mapDomain_comapDomain

end FInjective

end ComapDomain

/-! ### Declarations about finitely supported functions whose support is an `option` type -/


section Option

#print Finsupp.some /-
/-- Restrict a finitely supported function on `option α` to a finitely supported function on `α`. -/
def some [Zero M] (f : Option α →₀ M) : α →₀ M :=
  f.comapDomain Option.some fun _ => by simp
#align finsupp.some Finsupp.some
-/

#print Finsupp.some_apply /-
@[simp]
theorem some_apply [Zero M] (f : Option α →₀ M) (a : α) : f.some a = f (Option.some a) :=
  rfl
#align finsupp.some_apply Finsupp.some_apply
-/

#print Finsupp.some_zero /-
@[simp]
theorem some_zero [Zero M] : (0 : Option α →₀ M).some = 0 :=
  by
  ext
  simp
#align finsupp.some_zero Finsupp.some_zero
-/

/- warning: finsupp.some_add -> Finsupp.some_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] (f : Finsupp.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (g : Finsupp.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.some.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.hasAdd.{u1, u2} (Option.{u1} α) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.some.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) f) (Finsupp.some.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) g))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] (f : Finsupp.{u1, u2} (Option.{u1} α) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (g : Finsupp.{u1, u2} (Option.{u1} α) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.some.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} (Option.{u1} α) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u2} (Option.{u1} α) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u2} (Option.{u1} α) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} (Option.{u1} α) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.add.{u1, u2} (Option.{u1} α) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.add.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.some.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) f) (Finsupp.some.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) g))
Case conversion may be inaccurate. Consider using '#align finsupp.some_add Finsupp.some_addₓ'. -/
@[simp]
theorem some_add [AddCommMonoid M] (f g : Option α →₀ M) : (f + g).some = f.some + g.some :=
  by
  ext
  simp
#align finsupp.some_add Finsupp.some_add

#print Finsupp.some_single_none /-
@[simp]
theorem some_single_none [Zero M] (m : M) : (single none m : Option α →₀ M).some = 0 :=
  by
  ext
  simp
#align finsupp.some_single_none Finsupp.some_single_none
-/

#print Finsupp.some_single_some /-
@[simp]
theorem some_single_some [Zero M] (a : α) (m : M) :
    (single (Option.some a) m : Option α →₀ M).some = single a m := by
  classical
    ext b
    simp [single_apply]
#align finsupp.some_single_some Finsupp.some_single_some
-/

/- warning: finsupp.prod_option_index -> Finsupp.prod_option_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : CommMonoid.{u3} N] (f : Finsupp.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (b : (Option.{u1} α) -> M -> N), (forall (o : Option.{u1} α), Eq.{succ u3} N (b o (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))))) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_2))))))) -> (forall (o : Option.{u1} α) (m₁ : M) (m₂ : M), Eq.{succ u3} N (b o (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) m₁ m₂)) (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_2)))) (b o m₁) (b o m₂))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} (Option.{u1} α) M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) _inst_2 f b) (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_2)))) (b (Option.none.{u1} α) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (fun (_x : Finsupp.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) => (Option.{u1} α) -> M) (Finsupp.hasCoeToFun.{u1, u2} (Option.{u1} α) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) f (Option.none.{u1} α))) (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) _inst_2 (Finsupp.some.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) f) (fun (a : α) => b (Option.some.{u1} α a)))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : CommMonoid.{u2} N] (f : Finsupp.{u1, u3} (Option.{u1} α) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (b : (Option.{u1} α) -> M -> N), (forall (o : Option.{u1} α), Eq.{succ u2} N (b o (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))) (OfNat.ofNat.{u2} N 1 (One.toOfNat1.{u2} N (Monoid.toOne.{u2} N (CommMonoid.toMonoid.{u2} N _inst_2))))) -> (forall (o : Option.{u1} α) (m₁ : M) (m₂ : M), Eq.{succ u2} N (b o (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) m₁ m₂)) (HMul.hMul.{u2, u2, u2} N N N (instHMul.{u2} N (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_2)))) (b o m₁) (b o m₂))) -> (Eq.{succ u2} N (Finsupp.prod.{u1, u3, u2} (Option.{u1} α) M N (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) _inst_2 f b) (HMul.hMul.{u2, u2, u2} N N N (instHMul.{u2} N (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_2)))) (b (Option.none.{u1} α) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} (Option.{u1} α) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Option.{u1} α) (fun (_x : Option.{u1} α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => M) _x) (Finsupp.funLike.{u1, u3} (Option.{u1} α) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) f (Option.none.{u1} α))) (Finsupp.prod.{u1, u3, u2} α M N (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) _inst_2 (Finsupp.some.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) f) (fun (a : α) => b (Option.some.{u1} α a)))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_option_index Finsupp.prod_option_indexₓ'. -/
@[to_additive]
theorem prod_option_index [AddCommMonoid M] [CommMonoid N] (f : Option α →₀ M)
    (b : Option α → M → N) (h_zero : ∀ o, b o 0 = 1)
    (h_add : ∀ o m₁ m₂, b o (m₁ + m₂) = b o m₁ * b o m₂) :
    f.Prod b = b none (f none) * f.some.Prod fun a => b (Option.some a) := by
  classical
    apply induction_linear f
    · simp [some_zero, h_zero]
    · intro f₁ f₂ h₁ h₂
      rw [Finsupp.prod_add_index, h₁, h₂, some_add, Finsupp.prod_add_index]
      simp only [h_add, Pi.add_apply, Finsupp.coe_add]
      rw [mul_mul_mul_comm]
      all_goals simp [h_zero, h_add]
    · rintro (_ | a) m <;> simp [h_zero, h_add]
#align finsupp.prod_option_index Finsupp.prod_option_index
#align finsupp.sum_option_index Finsupp.sum_option_index

/- warning: finsupp.sum_option_index_smul -> Finsupp.sum_option_index_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] (f : Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (b : (Option.{u1} α) -> M), Eq.{succ u2} M (Finsupp.sum.{u1, u3, u2} (Option.{u1} α) R M (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_2 f (fun (o : Option.{u1} α) (r : R) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3)))) r (b o))) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3)))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (fun (_x : Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) => (Option.{u1} α) -> R) (Finsupp.hasCoeToFun.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) f (Option.none.{u1} α)) (b (Option.none.{u1} α))) (Finsupp.sum.{u1, u3, u2} α R M (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_2 (Finsupp.some.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) f) (fun (a : α) (r : R) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3)))) r (b (Option.some.{u1} α a)))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] (f : Finsupp.{u1, u3} (Option.{u1} α) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (b : (Option.{u1} α) -> M), Eq.{succ u2} M (Finsupp.sum.{u1, u3, u2} (Option.{u1} α) R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) _inst_2 f (fun (o : Option.{u1} α) (r : R) => HSMul.hSMul.{u3, u2, u2} R M M (instHSMul.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3))))) r (b o))) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (HSMul.hSMul.{u3, u2, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) (Option.none.{u1} α)) M M (instHSMul.{u3, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) (Option.none.{u1} α)) M (SMulZeroClass.toSMul.{u3, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) (Option.none.{u1} α)) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) (Option.none.{u1} α)) M (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) (Option.none.{u1} α)) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) (Option.none.{u1} α)) _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) (Option.none.{u1} α)) M (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) (Option.none.{u1} α)) _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u3, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) (Option.none.{u1} α)) M _inst_1 _inst_2 _inst_3))))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} (Option.{u1} α) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Option.{u1} α) (fun (_x : Option.{u1} α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u1} α) => R) _x) (Finsupp.funLike.{u1, u3} (Option.{u1} α) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) f (Option.none.{u1} α)) (b (Option.none.{u1} α))) (Finsupp.sum.{u1, u3, u2} α R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) _inst_2 (Finsupp.some.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) f) (fun (a : α) (r : R) => HSMul.hSMul.{u3, u2, u2} R M M (instHSMul.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3))))) r (b (Option.some.{u1} α a)))))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_option_index_smul Finsupp.sum_option_index_smulₓ'. -/
theorem sum_option_index_smul [Semiring R] [AddCommMonoid M] [Module R M] (f : Option α →₀ R)
    (b : Option α → M) :
    (f.Sum fun o r => r • b o) = f none • b none + f.some.Sum fun a r => r • b (Option.some a) :=
  f.sum_option_index _ (fun _ => zero_smul _ _) fun _ _ _ => add_smul _ _ _
#align finsupp.sum_option_index_smul Finsupp.sum_option_index_smul

end Option

/-! ### Declarations about `filter` -/


section Filter

section Zero

variable [Zero M] (p : α → Prop) (f : α →₀ M)

#print Finsupp.filter /-
/--
`filter p f` is the finitely supported function that is `f a` if `p a` is true and 0 otherwise. -/
def filter (p : α → Prop) (f : α →₀ M) : α →₀ M
    where
  toFun a :=
    haveI := Classical.decPred p
    if p a then f a else 0
  support :=
    haveI := Classical.decPred p
    f.support.filter fun a => p a
  mem_support_toFun a := by
    split_ifs <;>
      · simp only [h, mem_filter, mem_support_iff]
        tauto
#align finsupp.filter Finsupp.filter
-/

#print Finsupp.filter_apply /-
theorem filter_apply (a : α) [D : Decidable (p a)] : f.filterₓ p a = if p a then f a else 0 := by
  rw [Subsingleton.elim D] <;> rfl
#align finsupp.filter_apply Finsupp.filter_apply
-/

/- warning: finsupp.filter_eq_indicator -> Finsupp.filter_eq_indicator is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (p : α -> Prop) (f : Finsupp.{u1, u2} α M _inst_1), Eq.{max (succ u1) (succ u2)} (α -> M) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) (Finsupp.filter.{u1, u2} α M _inst_1 p f)) (Set.indicator.{u1, u2} α M _inst_1 (setOf.{u1} α (fun (x : α) => p x)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (p : α -> Prop) (f : Finsupp.{u2, u1} α M _inst_1), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) (Finsupp.filter.{u2, u1} α M _inst_1 p f)) (Set.indicator.{u2, u1} α M _inst_1 (setOf.{u2} α (fun (x : α) => p x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_eq_indicator Finsupp.filter_eq_indicatorₓ'. -/
theorem filter_eq_indicator : ⇑(f.filterₓ p) = Set.indicator { x | p x } f :=
  rfl
#align finsupp.filter_eq_indicator Finsupp.filter_eq_indicator

/- warning: finsupp.filter_eq_zero_iff -> Finsupp.filter_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (p : α -> Prop) (f : Finsupp.{u1, u2} α M _inst_1), Iff (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.filter.{u1, u2} α M _inst_1 p f) (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1))))) (forall (x : α), (p x) -> (Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (p : α -> Prop) (f : Finsupp.{u2, u1} α M _inst_1), Iff (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.filter.{u2, u1} α M _inst_1 p f) (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1)))) (forall (x : α), (p x) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_eq_zero_iff Finsupp.filter_eq_zero_iffₓ'. -/
theorem filter_eq_zero_iff : f.filterₓ p = 0 ↔ ∀ x, p x → f x = 0 := by
  simp only [FunLike.ext_iff, filter_eq_indicator, zero_apply, Set.indicator_apply_eq_zero,
    Set.mem_setOf_eq]
#align finsupp.filter_eq_zero_iff Finsupp.filter_eq_zero_iff

/- warning: finsupp.filter_eq_self_iff -> Finsupp.filter_eq_self_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (p : α -> Prop) (f : Finsupp.{u1, u2} α M _inst_1), Iff (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.filter.{u1, u2} α M _inst_1 p f) f) (forall (x : α), (Ne.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) -> (p x))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (p : α -> Prop) (f : Finsupp.{u2, u1} α M _inst_1), Iff (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.filter.{u2, u1} α M _inst_1 p f) f) (forall (x : α), (Ne.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) _inst_1))) -> (p x))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_eq_self_iff Finsupp.filter_eq_self_iffₓ'. -/
theorem filter_eq_self_iff : f.filterₓ p = f ↔ ∀ x, f x ≠ 0 → p x := by
  simp only [FunLike.ext_iff, filter_eq_indicator, Set.indicator_apply_eq_self, Set.mem_setOf_eq,
    not_imp_comm]
#align finsupp.filter_eq_self_iff Finsupp.filter_eq_self_iff

#print Finsupp.filter_apply_pos /-
@[simp]
theorem filter_apply_pos {a : α} (h : p a) : f.filterₓ p a = f a := by classical convert if_pos h
#align finsupp.filter_apply_pos Finsupp.filter_apply_pos
-/

#print Finsupp.filter_apply_neg /-
@[simp]
theorem filter_apply_neg {a : α} (h : ¬p a) : f.filterₓ p a = 0 := by classical convert if_neg h
#align finsupp.filter_apply_neg Finsupp.filter_apply_neg
-/

/- warning: finsupp.support_filter -> Finsupp.support_filter is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (p : α -> Prop) (f : Finsupp.{u1, u2} α M _inst_1) [D : DecidablePred.{succ u1} α p], Eq.{succ u1} (Finset.{u1} α) (Finsupp.support.{u1, u2} α M _inst_1 (Finsupp.filter.{u1, u2} α M _inst_1 p f)) (Finset.filter.{u1} α p (fun (a : α) => D a) (Finsupp.support.{u1, u2} α M _inst_1 f))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (p : α -> Prop) (f : Finsupp.{u2, u1} α M _inst_1) [D : DecidablePred.{succ u2} α p], Eq.{succ u2} (Finset.{u2} α) (Finsupp.support.{u2, u1} α M _inst_1 (Finsupp.filter.{u2, u1} α M _inst_1 p f)) (Finset.filter.{u2} α p (fun (a : α) => D a) (Finsupp.support.{u2, u1} α M _inst_1 f))
Case conversion may be inaccurate. Consider using '#align finsupp.support_filter Finsupp.support_filterₓ'. -/
@[simp]
theorem support_filter [D : DecidablePred p] : (f.filterₓ p).support = f.support.filterₓ p := by
  rw [Subsingleton.elim D] <;> rfl
#align finsupp.support_filter Finsupp.support_filter

/- warning: finsupp.filter_zero -> Finsupp.filter_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (p : α -> Prop), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.filter.{u1, u2} α M _inst_1 p (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1))))) (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (p : α -> Prop), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.filter.{u2, u1} α M _inst_1 p (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1)))) (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1)))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_zero Finsupp.filter_zeroₓ'. -/
theorem filter_zero : (0 : α →₀ M).filterₓ p = 0 := by
  classical rw [← support_eq_empty, support_filter, support_zero, Finset.filter_empty]
#align finsupp.filter_zero Finsupp.filter_zero

/- warning: finsupp.filter_single_of_pos -> Finsupp.filter_single_of_pos is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (p : α -> Prop) {a : α} {b : M}, (p a) -> (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.filter.{u1, u2} α M _inst_1 p (Finsupp.single.{u1, u2} α M _inst_1 a b)) (Finsupp.single.{u1, u2} α M _inst_1 a b))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (p : α -> Prop) {a : α} {b : M}, (p a) -> (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.filter.{u2, u1} α M _inst_1 p (Finsupp.single.{u2, u1} α M _inst_1 a b)) (Finsupp.single.{u2, u1} α M _inst_1 a b))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_single_of_pos Finsupp.filter_single_of_posₓ'. -/
@[simp]
theorem filter_single_of_pos {a : α} {b : M} (h : p a) : (single a b).filterₓ p = single a b :=
  (filter_eq_self_iff _ _).2 fun x hx => (single_apply_ne_zero.1 hx).1.symm ▸ h
#align finsupp.filter_single_of_pos Finsupp.filter_single_of_pos

/- warning: finsupp.filter_single_of_neg -> Finsupp.filter_single_of_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] (p : α -> Prop) {a : α} {b : M}, (Not (p a)) -> (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.filter.{u1, u2} α M _inst_1 p (Finsupp.single.{u1, u2} α M _inst_1 a b)) (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1)))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] (p : α -> Prop) {a : α} {b : M}, (Not (p a)) -> (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.filter.{u2, u1} α M _inst_1 p (Finsupp.single.{u2, u1} α M _inst_1 a b)) (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_single_of_neg Finsupp.filter_single_of_negₓ'. -/
@[simp]
theorem filter_single_of_neg {a : α} {b : M} (h : ¬p a) : (single a b).filterₓ p = 0 :=
  (filter_eq_zero_iff _ _).2 fun x hpx =>
    single_apply_eq_zero.2 fun hxa => absurd hpx (hxa.symm ▸ h)
#align finsupp.filter_single_of_neg Finsupp.filter_single_of_neg

/- warning: finsupp.prod_filter_index -> Finsupp.prod_filter_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : Zero.{u2} M] (p : α -> Prop) (f : Finsupp.{u1, u2} α M _inst_1) [_inst_2 : CommMonoid.{u3} N] (g : α -> M -> N), Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_1 _inst_2 (Finsupp.filter.{u1, u2} α M _inst_1 p f) g) (Finset.prod.{u3, u1} N α _inst_2 (Finsupp.support.{u1, u2} α M _inst_1 (Finsupp.filter.{u1, u2} α M _inst_1 p f)) (fun (x : α) => g x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f x)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {N : Type.{u3}} [_inst_1 : Zero.{u1} M] (p : α -> Prop) (f : Finsupp.{u2, u1} α M _inst_1) [_inst_2 : CommMonoid.{u3} N] (g : α -> M -> N), Eq.{succ u3} N (Finsupp.prod.{u2, u1, u3} α M N _inst_1 _inst_2 (Finsupp.filter.{u2, u1} α M _inst_1 p f) g) (Finset.prod.{u3, u2} N α _inst_2 (Finsupp.support.{u2, u1} α M _inst_1 (Finsupp.filter.{u2, u1} α M _inst_1 p f)) (fun (x : α) => g x (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f x)))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_filter_index Finsupp.prod_filter_indexₓ'. -/
@[to_additive]
theorem prod_filter_index [CommMonoid N] (g : α → M → N) :
    (f.filterₓ p).Prod g = ∏ x in (f.filterₓ p).support, g x (f x) := by
  classical
    refine' Finset.prod_congr rfl fun x hx => _
    rw [support_filter, Finset.mem_filter] at hx
    rw [filter_apply_pos _ _ hx.2]
#align finsupp.prod_filter_index Finsupp.prod_filter_index
#align finsupp.sum_filter_index Finsupp.sum_filter_index

/- warning: finsupp.prod_filter_mul_prod_filter_not -> Finsupp.prod_filter_mul_prod_filter_not is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : Zero.{u2} M] (p : α -> Prop) (f : Finsupp.{u1, u2} α M _inst_1) [_inst_2 : CommMonoid.{u3} N] (g : α -> M -> N), Eq.{succ u3} N (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_2)))) (Finsupp.prod.{u1, u2, u3} α M N _inst_1 _inst_2 (Finsupp.filter.{u1, u2} α M _inst_1 p f) g) (Finsupp.prod.{u1, u2, u3} α M N _inst_1 _inst_2 (Finsupp.filter.{u1, u2} α M _inst_1 (fun (a : α) => Not (p a)) f) g)) (Finsupp.prod.{u1, u2, u3} α M N _inst_1 _inst_2 f g)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {N : Type.{u3}} [_inst_1 : Zero.{u1} M] (p : α -> Prop) (f : Finsupp.{u2, u1} α M _inst_1) [_inst_2 : CommMonoid.{u3} N] (g : α -> M -> N), Eq.{succ u3} N (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_2)))) (Finsupp.prod.{u2, u1, u3} α M N _inst_1 _inst_2 (Finsupp.filter.{u2, u1} α M _inst_1 p f) g) (Finsupp.prod.{u2, u1, u3} α M N _inst_1 _inst_2 (Finsupp.filter.{u2, u1} α M _inst_1 (fun (a : α) => Not (p a)) f) g)) (Finsupp.prod.{u2, u1, u3} α M N _inst_1 _inst_2 f g)
Case conversion may be inaccurate. Consider using '#align finsupp.prod_filter_mul_prod_filter_not Finsupp.prod_filter_mul_prod_filter_notₓ'. -/
@[simp, to_additive]
theorem prod_filter_mul_prod_filter_not [CommMonoid N] (g : α → M → N) :
    (f.filterₓ p).Prod g * (f.filterₓ fun a => ¬p a).Prod g = f.Prod g := by
  classical simp_rw [prod_filter_index, support_filter, prod_filter_mul_prod_filter_not,
      Finsupp.prod]
#align finsupp.prod_filter_mul_prod_filter_not Finsupp.prod_filter_mul_prod_filter_not
#align finsupp.sum_filter_add_sum_filter_not Finsupp.sum_filter_add_sum_filter_not

/- warning: finsupp.prod_div_prod_filter -> Finsupp.prod_div_prod_filter is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Zero.{u2} M] (p : α -> Prop) (f : Finsupp.{u1, u2} α M _inst_1) [_inst_2 : CommGroup.{u3} G] (g : α -> M -> G), Eq.{succ u3} G (HDiv.hDiv.{u3, u3, u3} G G G (instHDiv.{u3} G (DivInvMonoid.toHasDiv.{u3} G (Group.toDivInvMonoid.{u3} G (CommGroup.toGroup.{u3} G _inst_2)))) (Finsupp.prod.{u1, u2, u3} α M G _inst_1 (CommGroup.toCommMonoid.{u3} G _inst_2) f g) (Finsupp.prod.{u1, u2, u3} α M G _inst_1 (CommGroup.toCommMonoid.{u3} G _inst_2) (Finsupp.filter.{u1, u2} α M _inst_1 p f) g)) (Finsupp.prod.{u1, u2, u3} α M G _inst_1 (CommGroup.toCommMonoid.{u3} G _inst_2) (Finsupp.filter.{u1, u2} α M _inst_1 (fun (a : α) => Not (p a)) f) g)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {G : Type.{u3}} [_inst_1 : Zero.{u1} M] (p : α -> Prop) (f : Finsupp.{u2, u1} α M _inst_1) [_inst_2 : CommGroup.{u3} G] (g : α -> M -> G), Eq.{succ u3} G (HDiv.hDiv.{u3, u3, u3} G G G (instHDiv.{u3} G (DivInvMonoid.toDiv.{u3} G (Group.toDivInvMonoid.{u3} G (CommGroup.toGroup.{u3} G _inst_2)))) (Finsupp.prod.{u2, u1, u3} α M G _inst_1 (CommGroup.toCommMonoid.{u3} G _inst_2) f g) (Finsupp.prod.{u2, u1, u3} α M G _inst_1 (CommGroup.toCommMonoid.{u3} G _inst_2) (Finsupp.filter.{u2, u1} α M _inst_1 p f) g)) (Finsupp.prod.{u2, u1, u3} α M G _inst_1 (CommGroup.toCommMonoid.{u3} G _inst_2) (Finsupp.filter.{u2, u1} α M _inst_1 (fun (a : α) => Not (p a)) f) g)
Case conversion may be inaccurate. Consider using '#align finsupp.prod_div_prod_filter Finsupp.prod_div_prod_filterₓ'. -/
@[simp, to_additive]
theorem prod_div_prod_filter [CommGroup G] (g : α → M → G) :
    f.Prod g / (f.filterₓ p).Prod g = (f.filterₓ fun a => ¬p a).Prod g :=
  div_eq_of_eq_mul' (prod_filter_mul_prod_filter_not _ _ _).symm
#align finsupp.prod_div_prod_filter Finsupp.prod_div_prod_filter
#align finsupp.sum_sub_sum_filter Finsupp.sum_sub_sum_filter

end Zero

/- warning: finsupp.filter_pos_add_filter_neg -> Finsupp.filter_pos_add_filter_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M] (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (p : α -> Prop), Eq.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.hasAdd.{u1, u2} α M _inst_1)) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1) p f) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1) (fun (a : α) => Not (p a)) f)) f
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M] (f : Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (p : α -> Prop), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.add.{u1, u2} α M _inst_1)) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1) p f) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1) (fun (a : α) => Not (p a)) f)) f
Case conversion may be inaccurate. Consider using '#align finsupp.filter_pos_add_filter_neg Finsupp.filter_pos_add_filter_negₓ'. -/
theorem filter_pos_add_filter_neg [AddZeroClass M] (f : α →₀ M) (p : α → Prop) :
    (f.filterₓ p + f.filterₓ fun a => ¬p a) = f :=
  coeFn_injective <| Set.indicator_self_add_compl { x | p x } f
#align finsupp.filter_pos_add_filter_neg Finsupp.filter_pos_add_filter_neg

end Filter

/-! ### Declarations about `frange` -/


section Frange

variable [Zero M]

#print Finsupp.frange /-
/-- `frange f` is the image of `f` on the support of `f`. -/
def frange (f : α →₀ M) : Finset M :=
  haveI := Classical.decEq M
  Finset.image f f.support
#align finsupp.frange Finsupp.frange
-/

/- warning: finsupp.mem_frange -> Finsupp.mem_frange is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {f : Finsupp.{u1, u2} α M _inst_1} {y : M}, Iff (Membership.Mem.{u2, u2} M (Finset.{u2} M) (Finset.hasMem.{u2} M) y (Finsupp.frange.{u1, u2} α M _inst_1 f)) (And (Ne.{succ u2} M y (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))) (Exists.{succ u1} α (fun (x : α) => Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f x) y)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {f : Finsupp.{u2, u1} α M _inst_1} {y : M}, Iff (Membership.mem.{u1, u1} M (Finset.{u1} M) (Finset.instMembershipFinset.{u1} M) y (Finsupp.frange.{u2, u1} α M _inst_1 f)) (And (Ne.{succ u1} M y (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_1))) (Exists.{succ u2} α (fun (x : α) => Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f x) y)))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_frange Finsupp.mem_frangeₓ'. -/
theorem mem_frange {f : α →₀ M} {y : M} : y ∈ f.frange ↔ y ≠ 0 ∧ ∃ x, f x = y := by
  classical exact
      finset.mem_image.trans
        ⟨fun ⟨x, hx1, hx2⟩ => ⟨hx2 ▸ mem_support_iff.1 hx1, x, hx2⟩, fun ⟨hy, x, hx⟩ =>
          ⟨x, mem_support_iff.2 (hx.symm ▸ hy), hx⟩⟩
#align finsupp.mem_frange Finsupp.mem_frange

/- warning: finsupp.zero_not_mem_frange -> Finsupp.zero_not_mem_frange is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {f : Finsupp.{u1, u2} α M _inst_1}, Not (Membership.Mem.{u2, u2} M (Finset.{u2} M) (Finset.hasMem.{u2} M) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1))) (Finsupp.frange.{u1, u2} α M _inst_1 f))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {f : Finsupp.{u2, u1} α M _inst_1}, Not (Membership.mem.{u1, u1} M (Finset.{u1} M) (Finset.instMembershipFinset.{u1} M) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_1)) (Finsupp.frange.{u2, u1} α M _inst_1 f))
Case conversion may be inaccurate. Consider using '#align finsupp.zero_not_mem_frange Finsupp.zero_not_mem_frangeₓ'. -/
theorem zero_not_mem_frange {f : α →₀ M} : (0 : M) ∉ f.frange := fun H => (mem_frange.1 H).1 rfl
#align finsupp.zero_not_mem_frange Finsupp.zero_not_mem_frange

#print Finsupp.frange_single /-
theorem frange_single {x : α} {y : M} : frange (single x y) ⊆ {y} := fun r hr =>
  let ⟨t, ht1, ht2⟩ := mem_frange.1 hr
  ht2 ▸ by
    classical
      rw [single_apply] at ht2⊢
      split_ifs  at ht2⊢
      · exact Finset.mem_singleton_self _
      · exact (t ht2.symm).elim
#align finsupp.frange_single Finsupp.frange_single
-/

end Frange

/-! ### Declarations about `subtype_domain` -/


section SubtypeDomain

section Zero

variable [Zero M] {p : α → Prop}

#print Finsupp.subtypeDomain /-
/--
`subtype_domain p f` is the restriction of the finitely supported function `f` to subtype `p`. -/
def subtypeDomain (p : α → Prop) (f : α →₀ M) : Subtype p →₀ M
    where
  support :=
    haveI := Classical.decPred p
    f.support.subtype p
  toFun := f ∘ coe
  mem_support_toFun a := by simp only [mem_subtype, mem_support_iff]
#align finsupp.subtype_domain Finsupp.subtypeDomain
-/

/- warning: finsupp.support_subtype_domain -> Finsupp.support_subtypeDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {p : α -> Prop} [D : DecidablePred.{succ u1} α p] {f : Finsupp.{u1, u2} α M _inst_1}, Eq.{succ u1} (Finset.{u1} (Subtype.{succ u1} α p)) (Finsupp.support.{u1, u2} (Subtype.{succ u1} α p) M _inst_1 (Finsupp.subtypeDomain.{u1, u2} α M _inst_1 p f)) (Finset.subtype.{u1} α p (fun (a : α) => D a) (Finsupp.support.{u1, u2} α M _inst_1 f))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {p : α -> Prop} [D : DecidablePred.{succ u2} α p] {f : Finsupp.{u2, u1} α M _inst_1}, Eq.{succ u2} (Finset.{u2} (Subtype.{succ u2} α p)) (Finsupp.support.{u2, u1} (Subtype.{succ u2} α p) M _inst_1 (Finsupp.subtypeDomain.{u2, u1} α M _inst_1 p f)) (Finset.subtype.{u2} α p (fun (a : α) => D a) (Finsupp.support.{u2, u1} α M _inst_1 f))
Case conversion may be inaccurate. Consider using '#align finsupp.support_subtype_domain Finsupp.support_subtypeDomainₓ'. -/
@[simp]
theorem support_subtypeDomain [D : DecidablePred p] {f : α →₀ M} :
    (subtypeDomain p f).support = f.support.Subtype p := by rw [Subsingleton.elim D] <;> rfl
#align finsupp.support_subtype_domain Finsupp.support_subtypeDomain

/- warning: finsupp.subtype_domain_apply -> Finsupp.subtypeDomain_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {p : α -> Prop} {a : Subtype.{succ u1} α p} {v : Finsupp.{u1, u2} α M _inst_1}, Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) (fun (_x : Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) => (Subtype.{succ u1} α p) -> M) (Finsupp.hasCoeToFun.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) (Finsupp.subtypeDomain.{u1, u2} α M _inst_1 p v) a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) v (Subtype.val.{succ u1} α p a))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {p : α -> Prop} {a : Subtype.{succ u2} α p} {v : Finsupp.{u2, u1} α M _inst_1}, Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Subtype.{succ u2} α p) => M) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) (Subtype.{succ u2} α p) (fun (_x : Subtype.{succ u2} α p) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Subtype.{succ u2} α p) => M) _x) (Finsupp.funLike.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) (Finsupp.subtypeDomain.{u2, u1} α M _inst_1 p v) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) v (Subtype.val.{succ u2} α p a))
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_apply Finsupp.subtypeDomain_applyₓ'. -/
@[simp]
theorem subtypeDomain_apply {a : Subtype p} {v : α →₀ M} : (subtypeDomain p v) a = v a.val :=
  rfl
#align finsupp.subtype_domain_apply Finsupp.subtypeDomain_apply

/- warning: finsupp.subtype_domain_zero -> Finsupp.subtypeDomain_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {p : α -> Prop}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) (Finsupp.subtypeDomain.{u1, u2} α M _inst_1 p (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1))))) (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) (Finsupp.hasZero.{u1, u2} (Subtype.{succ u1} α p) M _inst_1))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {p : α -> Prop}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) (Finsupp.subtypeDomain.{u2, u1} α M _inst_1 p (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1)))) (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) (Finsupp.zero.{u2, u1} (Subtype.{succ u2} α p) M _inst_1)))
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_zero Finsupp.subtypeDomain_zeroₓ'. -/
@[simp]
theorem subtypeDomain_zero : subtypeDomain p (0 : α →₀ M) = 0 :=
  rfl
#align finsupp.subtype_domain_zero Finsupp.subtypeDomain_zero

/- warning: finsupp.subtype_domain_eq_zero_iff' -> Finsupp.subtypeDomain_eq_zero_iff' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {p : α -> Prop} {f : Finsupp.{u1, u2} α M _inst_1}, Iff (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) (Finsupp.subtypeDomain.{u1, u2} α M _inst_1 p f) (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) (Finsupp.hasZero.{u1, u2} (Subtype.{succ u1} α p) M _inst_1))))) (forall (x : α), (p x) -> (Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) f x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_1)))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {p : α -> Prop} {f : Finsupp.{u2, u1} α M _inst_1}, Iff (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) (Finsupp.subtypeDomain.{u2, u1} α M _inst_1 p f) (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) (Finsupp.zero.{u2, u1} (Subtype.{succ u2} α p) M _inst_1)))) (forall (x : α), (p x) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_1) f x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_eq_zero_iff' Finsupp.subtypeDomain_eq_zero_iff'ₓ'. -/
theorem subtypeDomain_eq_zero_iff' {f : α →₀ M} : f.subtypeDomain p = 0 ↔ ∀ x, p x → f x = 0 := by
  classical simp_rw [← support_eq_empty, support_subtype_domain, subtype_eq_empty,
      not_mem_support_iff]
#align finsupp.subtype_domain_eq_zero_iff' Finsupp.subtypeDomain_eq_zero_iff'

/- warning: finsupp.subtype_domain_eq_zero_iff -> Finsupp.subtypeDomain_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Zero.{u2} M] {p : α -> Prop} {f : Finsupp.{u1, u2} α M _inst_1}, (forall (x : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x (Finsupp.support.{u1, u2} α M _inst_1 f)) -> (p x)) -> (Iff (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) (Finsupp.subtypeDomain.{u1, u2} α M _inst_1 p f) (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M _inst_1) (Finsupp.hasZero.{u1, u2} (Subtype.{succ u1} α p) M _inst_1))))) (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) f (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α M _inst_1) (Finsupp.hasZero.{u1, u2} α M _inst_1))))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Zero.{u1} M] {p : α -> Prop} {f : Finsupp.{u2, u1} α M _inst_1}, (forall (x : α), (Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) x (Finsupp.support.{u2, u1} α M _inst_1 f)) -> (p x)) -> (Iff (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) (Finsupp.subtypeDomain.{u2, u1} α M _inst_1 p f) (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) (Finsupp.zero.{u2, u1} (Subtype.{succ u2} α p) M _inst_1)))) (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M _inst_1) f (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α M _inst_1) (Finsupp.zero.{u2, u1} α M _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_eq_zero_iff Finsupp.subtypeDomain_eq_zero_iffₓ'. -/
theorem subtypeDomain_eq_zero_iff {f : α →₀ M} (hf : ∀ x ∈ f.support, p x) :
    f.subtypeDomain p = 0 ↔ f = 0 :=
  subtypeDomain_eq_zero_iff'.trans
    ⟨fun H =>
      ext fun x => by
        classical exact if hx : p x then H x hx else not_mem_support_iff.1 <| mt (hf x) hx,
      fun H x _ => by simp [H]⟩
#align finsupp.subtype_domain_eq_zero_iff Finsupp.subtypeDomain_eq_zero_iff

/- warning: finsupp.prod_subtype_domain_index -> Finsupp.prod_subtypeDomain_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : Zero.{u2} M] {p : α -> Prop} [_inst_2 : CommMonoid.{u3} N] {v : Finsupp.{u1, u2} α M _inst_1} {h : α -> M -> N}, (forall (x : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x (Finsupp.support.{u1, u2} α M _inst_1 v)) -> (p x)) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} (Subtype.{succ u1} α p) M N _inst_1 _inst_2 (Finsupp.subtypeDomain.{u1, u2} α M _inst_1 p v) (fun (a : Subtype.{succ u1} α p) (b : M) => h ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} α p) α (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} α p) α (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} α p) α (coeBase.{succ u1, succ u1} (Subtype.{succ u1} α p) α (coeSubtype.{succ u1} α (fun (x : α) => p x))))) a) b)) (Finsupp.prod.{u1, u2, u3} α M N _inst_1 _inst_2 v h))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {N : Type.{u3}} [_inst_1 : Zero.{u1} M] {p : α -> Prop} [_inst_2 : CommMonoid.{u3} N] {v : Finsupp.{u2, u1} α M _inst_1} {h : α -> M -> N}, (forall (x : α), (Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) x (Finsupp.support.{u2, u1} α M _inst_1 v)) -> (p x)) -> (Eq.{succ u3} N (Finsupp.prod.{u2, u1, u3} (Subtype.{succ u2} α p) M N _inst_1 _inst_2 (Finsupp.subtypeDomain.{u2, u1} α M _inst_1 p v) (fun (a : Subtype.{succ u2} α p) (b : M) => h (Subtype.val.{succ u2} α p a) b)) (Finsupp.prod.{u2, u1, u3} α M N _inst_1 _inst_2 v h))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_subtype_domain_index Finsupp.prod_subtypeDomain_indexₓ'. -/
@[to_additive]
theorem prod_subtypeDomain_index [CommMonoid N] {v : α →₀ M} {h : α → M → N}
    (hp : ∀ x ∈ v.support, p x) : ((v.subtypeDomain p).Prod fun a b => h a b) = v.Prod h :=
  prod_bij (fun p _ => p.val) (fun _ => by classical exact mem_subtype.1) (fun _ _ => rfl)
    (fun _ _ _ _ => Subtype.eq) fun b hb => ⟨⟨b, hp b hb⟩, by classical exact mem_subtype.2 hb, rfl⟩
#align finsupp.prod_subtype_domain_index Finsupp.prod_subtypeDomain_index
#align finsupp.sum_subtype_domain_index Finsupp.sum_subtypeDomain_index

end Zero

section AddZeroClass

variable [AddZeroClass M] {p : α → Prop} {v v' : α →₀ M}

/- warning: finsupp.subtype_domain_add -> Finsupp.subtypeDomain_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M] {p : α -> Prop} {v : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)} {v' : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.subtypeDomain.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1) p (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.hasAdd.{u1, u2} α M _inst_1)) v v')) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.hasAdd.{u1, u2} (Subtype.{succ u1} α p) M _inst_1)) (Finsupp.subtypeDomain.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1) p v) (Finsupp.subtypeDomain.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1) p v'))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddZeroClass.{u1} M] {p : α -> Prop} {v : Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)} {v' : Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.subtypeDomain.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1) p (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (instHAdd.{max u2 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.add.{u2, u1} α M _inst_1)) v v')) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M (AddZeroClass.toZero.{u1} M _inst_1)) (instHAdd.{max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.add.{u2, u1} (Subtype.{succ u2} α p) M _inst_1)) (Finsupp.subtypeDomain.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1) p v) (Finsupp.subtypeDomain.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1) p v'))
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_add Finsupp.subtypeDomain_addₓ'. -/
@[simp]
theorem subtypeDomain_add {v v' : α →₀ M} :
    (v + v').subtypeDomain p = v.subtypeDomain p + v'.subtypeDomain p :=
  ext fun _ => rfl
#align finsupp.subtype_domain_add Finsupp.subtypeDomain_add

/- warning: finsupp.subtype_domain_add_monoid_hom -> Finsupp.subtypeDomainAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M] {p : α -> Prop}, AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.addZeroClass.{u1, u2} α M _inst_1) (Finsupp.addZeroClass.{u1, u2} (Subtype.{succ u1} α p) M _inst_1)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M] {p : α -> Prop}, AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} (Subtype.{succ u1} α p) M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.addZeroClass.{u1, u2} α M _inst_1) (Finsupp.addZeroClass.{u1, u2} (Subtype.{succ u1} α p) M _inst_1)
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_add_monoid_hom Finsupp.subtypeDomainAddMonoidHomₓ'. -/
/-- `subtype_domain` but as an `add_monoid_hom`. -/
def subtypeDomainAddMonoidHom : (α →₀ M) →+ Subtype p →₀ M
    where
  toFun := subtypeDomain p
  map_zero' := subtypeDomain_zero
  map_add' _ _ := subtypeDomain_add
#align finsupp.subtype_domain_add_monoid_hom Finsupp.subtypeDomainAddMonoidHom

/- warning: finsupp.filter_add_hom -> Finsupp.filterAddHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M], (α -> Prop) -> (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.addZeroClass.{u1, u2} α M _inst_1) (Finsupp.addZeroClass.{u1, u2} α M _inst_1))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M], (α -> Prop) -> (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.addZeroClass.{u1, u2} α M _inst_1) (Finsupp.addZeroClass.{u1, u2} α M _inst_1))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_add_hom Finsupp.filterAddHomₓ'. -/
/-- `finsupp.filter` as an `add_monoid_hom`. -/
def filterAddHom (p : α → Prop) : (α →₀ M) →+ α →₀ M
    where
  toFun := filter p
  map_zero' := filter_zero p
  map_add' f g := coeFn_injective <| Set.indicator_add { x | p x } f g
#align finsupp.filter_add_hom Finsupp.filterAddHom

/- warning: finsupp.filter_add -> Finsupp.filter_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M] {p : α -> Prop} {v : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)} {v' : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1) p (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.hasAdd.{u1, u2} α M _inst_1)) v v')) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.hasAdd.{u1, u2} α M _inst_1)) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1) p v) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_1) p v'))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddZeroClass.{u1} M] {p : α -> Prop} {v : Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)} {v' : Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.filter.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1) p (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (instHAdd.{max u2 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.add.{u2, u1} α M _inst_1)) v v')) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (instHAdd.{max u2 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1)) (Finsupp.add.{u2, u1} α M _inst_1)) (Finsupp.filter.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1) p v) (Finsupp.filter.{u2, u1} α M (AddZeroClass.toZero.{u1} M _inst_1) p v'))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_add Finsupp.filter_addₓ'. -/
@[simp]
theorem filter_add {v v' : α →₀ M} : (v + v').filterₓ p = v.filterₓ p + v'.filterₓ p :=
  (filterAddHom p).map_add v v'
#align finsupp.filter_add Finsupp.filter_add

end AddZeroClass

section CommMonoid

variable [AddCommMonoid M] {p : α → Prop}

/- warning: finsupp.subtype_domain_sum -> Finsupp.subtypeDomain_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {p : α -> Prop} {s : Finset.{u2} ι} {h : ι -> (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))}, Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.subtypeDomain.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) p (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_1) s (fun (c : ι) => h c))) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) ι (Finsupp.addCommMonoid.{u1, u3} (Subtype.{succ u1} α p) M _inst_1) s (fun (c : ι) => Finsupp.subtypeDomain.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) p (h c)))
but is expected to have type
  forall {α : Type.{u2}} {ι : Type.{u3}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] {p : α -> Prop} {s : Finset.{u3} ι} {h : ι -> (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.subtypeDomain.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) p (Finset.sum.{max u2 u1, u3} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) ι (Finsupp.addCommMonoid.{u2, u1} α M _inst_1) s (fun (c : ι) => h c))) (Finset.sum.{max u2 u1, u3} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) ι (Finsupp.addCommMonoid.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) s (fun (c : ι) => Finsupp.subtypeDomain.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) p (h c)))
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_sum Finsupp.subtypeDomain_sumₓ'. -/
theorem subtypeDomain_sum {s : Finset ι} {h : ι → α →₀ M} :
    (∑ c in s, h c).subtypeDomain p = ∑ c in s, (h c).subtypeDomain p :=
  (subtypeDomainAddMonoidHom : _ →+ Subtype p →₀ M).map_sum _ s
#align finsupp.subtype_domain_sum Finsupp.subtypeDomain_sum

/- warning: finsupp.subtype_domain_finsupp_sum -> Finsupp.subtypeDomain_finsupp_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] {p : α -> Prop} [_inst_2 : Zero.{u4} N] {s : Finsupp.{u2, u4} β N _inst_2} {h : β -> N -> (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))}, Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.subtypeDomain.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) p (Finsupp.sum.{u2, u4, max u1 u3} β N (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α M _inst_1) s h)) (Finsupp.sum.{u2, u4, max u1 u3} β N (Finsupp.{u1, u3} (Subtype.{succ u1} α p) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} (Subtype.{succ u1} α p) M _inst_1) s (fun (c : β) (d : N) => Finsupp.subtypeDomain.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) p (h c d)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {M : Type.{u1}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u1} M] {p : α -> Prop} [_inst_2 : Zero.{u4} N] {s : Finsupp.{u3, u4} β N _inst_2} {h : β -> N -> (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.subtypeDomain.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) p (Finsupp.sum.{u3, u4, max u2 u1} β N (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u2, u1} α M _inst_1) s h)) (Finsupp.sum.{u3, u4, max u2 u1} β N (Finsupp.{u2, u1} (Subtype.{succ u2} α p) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u2, u1} (Subtype.{succ u2} α p) M _inst_1) s (fun (c : β) (d : N) => Finsupp.subtypeDomain.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) p (h c d)))
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_finsupp_sum Finsupp.subtypeDomain_finsupp_sumₓ'. -/
theorem subtypeDomain_finsupp_sum [Zero N] {s : β →₀ N} {h : β → N → α →₀ M} :
    (s.Sum h).subtypeDomain p = s.Sum fun c d => (h c d).subtypeDomain p :=
  subtypeDomain_sum
#align finsupp.subtype_domain_finsupp_sum Finsupp.subtypeDomain_finsupp_sum

/- warning: finsupp.filter_sum -> Finsupp.filter_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {p : α -> Prop} (s : Finset.{u2} ι) (f : ι -> (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.filter.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) p (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_1) s (fun (a : ι) => f a))) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_1) s (fun (a : ι) => Finsupp.filter.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) p (f a)))
but is expected to have type
  forall {α : Type.{u2}} {ι : Type.{u3}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] {p : α -> Prop} (s : Finset.{u3} ι) (f : ι -> (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.filter.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) p (Finset.sum.{max u2 u1, u3} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) ι (Finsupp.addCommMonoid.{u2, u1} α M _inst_1) s (fun (a : ι) => f a))) (Finset.sum.{max u1 u2, u3} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) ι (Finsupp.addCommMonoid.{u2, u1} α M _inst_1) s (fun (a : ι) => Finsupp.filter.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) p (f a)))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_sum Finsupp.filter_sumₓ'. -/
theorem filter_sum (s : Finset ι) (f : ι → α →₀ M) :
    (∑ a in s, f a).filterₓ p = ∑ a in s, filter p (f a) :=
  (filterAddHom p : (α →₀ M) →+ _).map_sum f s
#align finsupp.filter_sum Finsupp.filter_sum

/- warning: finsupp.filter_eq_sum -> Finsupp.filter_eq_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] (p : α -> Prop) [D : DecidablePred.{succ u1} α p] (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) p f) (Finset.sum.{max u1 u2, u1} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) α (Finsupp.addCommMonoid.{u1, u2} α M _inst_1) (Finset.filter.{u1} α p (fun (a : α) => D a) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) f)) (fun (i : α) => Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) i (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) f i)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] (p : α -> Prop) [D : DecidablePred.{succ u2} α p] (f : Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.filter.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) p f) (Finset.sum.{max u1 u2, u2} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) α (Finsupp.addCommMonoid.{u2, u1} α M _inst_1) (Finset.filter.{u2} α p (fun (a : α) => D a) (Finsupp.support.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) f)) (fun (i : α) => Finsupp.single.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) i (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) f i)))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_eq_sum Finsupp.filter_eq_sumₓ'. -/
theorem filter_eq_sum (p : α → Prop) [D : DecidablePred p] (f : α →₀ M) :
    f.filterₓ p = ∑ i in f.support.filterₓ p, single i (f i) :=
  (f.filterₓ p).sum_single.symm.trans <|
    Finset.sum_congr (by rw [Subsingleton.elim D] <;> rfl) fun x hx => by
      rw [filter_apply_pos _ _ (mem_filter.1 hx).2]
#align finsupp.filter_eq_sum Finsupp.filter_eq_sum

end CommMonoid

section Group

variable [AddGroup G] {p : α → Prop} {v v' : α →₀ G}

/- warning: finsupp.subtype_domain_neg -> Finsupp.subtypeDomain_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : AddGroup.{u2} G] {p : α -> Prop} {v : Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.subtypeDomain.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasNeg.{u1, u2} α G (SubNegZeroMonoid.toNegZeroClass.{u2} G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) v)) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasNeg.{u1, u2} (Subtype.{succ u1} α p) G (SubNegZeroMonoid.toNegZeroClass.{u2} G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) (Finsupp.subtypeDomain.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p v))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : AddGroup.{u1} G] {p : α -> Prop} {v : Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.subtypeDomain.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) v)) (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instNegFinsuppToZero.{u2, u1} (Subtype.{succ u2} α p) G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) (Finsupp.subtypeDomain.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p v))
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_neg Finsupp.subtypeDomain_negₓ'. -/
@[simp]
theorem subtypeDomain_neg : (-v).subtypeDomain p = -v.subtypeDomain p :=
  ext fun _ => rfl
#align finsupp.subtype_domain_neg Finsupp.subtypeDomain_neg

/- warning: finsupp.subtype_domain_sub -> Finsupp.subtypeDomain_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : AddGroup.{u2} G] {p : α -> Prop} {v : Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))} {v' : Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.subtypeDomain.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasSub.{u1, u2} α G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) v v')) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} (Subtype.{succ u1} α p) G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} (Subtype.{succ u1} α p) G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} (Subtype.{succ u1} α p) G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasSub.{u1, u2} (Subtype.{succ u1} α p) G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) (Finsupp.subtypeDomain.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p v) (Finsupp.subtypeDomain.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p v'))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : AddGroup.{u1} G] {p : α -> Prop} {v : Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))} {v' : Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.subtypeDomain.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) v v')) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} (Subtype.{succ u2} α p) G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} (Subtype.{succ u2} α p) G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} (Subtype.{succ u2} α p) G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} (Subtype.{succ u2} α p) G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) (Finsupp.subtypeDomain.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p v) (Finsupp.subtypeDomain.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p v'))
Case conversion may be inaccurate. Consider using '#align finsupp.subtype_domain_sub Finsupp.subtypeDomain_subₓ'. -/
@[simp]
theorem subtypeDomain_sub : (v - v').subtypeDomain p = v.subtypeDomain p - v'.subtypeDomain p :=
  ext fun _ => rfl
#align finsupp.subtype_domain_sub Finsupp.subtypeDomain_sub

/- warning: finsupp.single_neg -> Finsupp.single_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : AddGroup.{u2} G] (a : α) (b : G), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.single.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a (Neg.neg.{u2} G (SubNegMonoid.toHasNeg.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)) b)) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasNeg.{u1, u2} α G (SubNegZeroMonoid.toNegZeroClass.{u2} G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) (Finsupp.single.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a b))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : AddGroup.{u1} G] (a : α) (b : G), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.single.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a (Neg.neg.{u1} G (NegZeroClass.toNeg.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) b)) (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) (Finsupp.single.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a b))
Case conversion may be inaccurate. Consider using '#align finsupp.single_neg Finsupp.single_negₓ'. -/
@[simp]
theorem single_neg (a : α) (b : G) : single a (-b) = -single a b :=
  (singleAddHom a : G →+ _).map_neg b
#align finsupp.single_neg Finsupp.single_neg

/- warning: finsupp.single_sub -> Finsupp.single_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : AddGroup.{u2} G] (a : α) (b₁ : G) (b₂ : G), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.single.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a (HSub.hSub.{u2, u2, u2} G G G (instHSub.{u2} G (SubNegMonoid.toHasSub.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))) b₁ b₂)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasSub.{u1, u2} α G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) (Finsupp.single.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a b₁) (Finsupp.single.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a b₂))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : AddGroup.{u1} G] (a : α) (b₁ : G) (b₂ : G), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.single.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a (HSub.hSub.{u1, u1, u1} G G G (instHSub.{u1} G (SubNegMonoid.toSub.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_1))) b₁ b₂)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) (Finsupp.single.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a b₁) (Finsupp.single.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a b₂))
Case conversion may be inaccurate. Consider using '#align finsupp.single_sub Finsupp.single_subₓ'. -/
@[simp]
theorem single_sub (a : α) (b₁ b₂ : G) : single a (b₁ - b₂) = single a b₁ - single a b₂ :=
  (singleAddHom a : G →+ _).map_sub b₁ b₂
#align finsupp.single_sub Finsupp.single_sub

/- warning: finsupp.erase_neg -> Finsupp.erase_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : AddGroup.{u2} G] (a : α) (f : Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.erase.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasNeg.{u1, u2} α G (SubNegZeroMonoid.toNegZeroClass.{u2} G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) f)) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasNeg.{u1, u2} α G (SubNegZeroMonoid.toNegZeroClass.{u2} G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) (Finsupp.erase.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a f))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : AddGroup.{u1} G] (a : α) (f : Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.erase.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) f)) (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) (Finsupp.erase.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a f))
Case conversion may be inaccurate. Consider using '#align finsupp.erase_neg Finsupp.erase_negₓ'. -/
@[simp]
theorem erase_neg (a : α) (f : α →₀ G) : erase a (-f) = -erase a f :=
  (eraseAddHom a : (_ →₀ G) →+ _).map_neg f
#align finsupp.erase_neg Finsupp.erase_neg

/- warning: finsupp.erase_sub -> Finsupp.erase_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : AddGroup.{u2} G] (a : α) (f₁ : Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (f₂ : Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.erase.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasSub.{u1, u2} α G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) f₁ f₂)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasSub.{u1, u2} α G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) (Finsupp.erase.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a f₁) (Finsupp.erase.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) a f₂))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : AddGroup.{u1} G] (a : α) (f₁ : Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (f₂ : Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.erase.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) f₁ f₂)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) (Finsupp.erase.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a f₁) (Finsupp.erase.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) a f₂))
Case conversion may be inaccurate. Consider using '#align finsupp.erase_sub Finsupp.erase_subₓ'. -/
@[simp]
theorem erase_sub (a : α) (f₁ f₂ : α →₀ G) : erase a (f₁ - f₂) = erase a f₁ - erase a f₂ :=
  (eraseAddHom a : (_ →₀ G) →+ _).map_sub f₁ f₂
#align finsupp.erase_sub Finsupp.erase_sub

/- warning: finsupp.filter_neg -> Finsupp.filter_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : AddGroup.{u2} G] (p : α -> Prop) (f : Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.filter.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasNeg.{u1, u2} α G (SubNegZeroMonoid.toNegZeroClass.{u2} G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) f)) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasNeg.{u1, u2} α G (SubNegZeroMonoid.toNegZeroClass.{u2} G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) (Finsupp.filter.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p f))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : AddGroup.{u1} G] (p : α -> Prop) (f : Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.filter.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) f)) (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) (Finsupp.filter.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p f))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_neg Finsupp.filter_negₓ'. -/
@[simp]
theorem filter_neg (p : α → Prop) (f : α →₀ G) : filter p (-f) = -filter p f :=
  (filterAddHom p : (_ →₀ G) →+ _).map_neg f
#align finsupp.filter_neg Finsupp.filter_neg

/- warning: finsupp.filter_sub -> Finsupp.filter_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : AddGroup.{u2} G] (p : α -> Prop) (f₁ : Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (f₂ : Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.filter.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasSub.{u1, u2} α G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) f₁ f₂)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1))))) (Finsupp.hasSub.{u1, u2} α G (SubtractionMonoid.toSubNegZeroMonoid.{u2} G (AddGroup.toSubtractionMonoid.{u2} G _inst_1)))) (Finsupp.filter.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p f₁) (Finsupp.filter.{u1, u2} α G (AddZeroClass.toHasZero.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G _inst_1)))) p f₂))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : AddGroup.{u1} G] (p : α -> Prop) (f₁ : Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (f₂ : Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.filter.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) f₁ f₂)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) (Finsupp.filter.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p f₁) (Finsupp.filter.{u2, u1} α G (NegZeroClass.toZero.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_1)))) p f₂))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_sub Finsupp.filter_subₓ'. -/
@[simp]
theorem filter_sub (p : α → Prop) (f₁ f₂ : α →₀ G) :
    filter p (f₁ - f₂) = filter p f₁ - filter p f₂ :=
  (filterAddHom p : (_ →₀ G) →+ _).map_sub f₁ f₂
#align finsupp.filter_sub Finsupp.filter_sub

end Group

end SubtypeDomain

/- warning: finsupp.mem_support_multiset_sum -> Finsupp.mem_support_multiset_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] {s : Multiset.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))} (a : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Multiset.sum.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_1) s))) -> (Exists.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (fun (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) => Exists.{0} (Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Multiset.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))) (Multiset.hasMem.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))) f s) (fun (H : Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Multiset.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))) (Multiset.hasMem.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))) f s) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) f))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M] {s : Multiset.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))} (a : α), (Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) a (Finsupp.support.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) (Multiset.sum.{max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_1) s))) -> (Exists.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (fun (f : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) => And (Membership.mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Multiset.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Multiset.instMembershipMultiset.{max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) f s) (Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) a (Finsupp.support.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) f))))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_support_multiset_sum Finsupp.mem_support_multiset_sumₓ'. -/
theorem mem_support_multiset_sum [AddCommMonoid M] {s : Multiset (α →₀ M)} (a : α) :
    a ∈ s.Sum.support → ∃ f ∈ s, a ∈ (f : α →₀ M).support :=
  Multiset.induction_on s False.elim
    (by
      intro f s ih ha
      by_cases a ∈ f.support
      · exact ⟨f, Multiset.mem_cons_self _ _, h⟩
      · simp only [Multiset.sum_cons, mem_support_iff, add_apply, not_mem_support_iff.1 h,
          zero_add] at ha
        rcases ih (mem_support_iff.2 ha) with ⟨f', h₀, h₁⟩
        exact ⟨f', Multiset.mem_cons_of_mem h₀, h₁⟩)
#align finsupp.mem_support_multiset_sum Finsupp.mem_support_multiset_sum

/- warning: finsupp.mem_support_finset_sum -> Finsupp.mem_support_finset_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {s : Finset.{u2} ι} {h : ι -> (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))} (a : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_1) s (fun (c : ι) => h c)))) -> (Exists.{succ u2} ι (fun (c : ι) => Exists.{0} (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) c s) (fun (H : Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) c s) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (h c)))))
but is expected to have type
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] {s : Finset.{u2} ι} {h : ι -> (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))} (a : α), (Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) a (Finsupp.support.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_1) s (fun (c : ι) => h c)))) -> (Exists.{succ u2} ι (fun (c : ι) => And (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) c s) (Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) a (Finsupp.support.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (h c)))))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_support_finset_sum Finsupp.mem_support_finset_sumₓ'. -/
theorem mem_support_finset_sum [AddCommMonoid M] {s : Finset ι} {h : ι → α →₀ M} (a : α)
    (ha : a ∈ (∑ c in s, h c).support) : ∃ c ∈ s, a ∈ (h c).support :=
  let ⟨f, hf, hfa⟩ := mem_support_multiset_sum a ha
  let ⟨c, hc, Eq⟩ := Multiset.mem_map.1 hf
  ⟨c, hc, Eq.symm ▸ hfa⟩
#align finsupp.mem_support_finset_sum Finsupp.mem_support_finset_sum

/-! ### Declarations about `curry` and `uncurry` -/


section CurryUncurry

variable [AddCommMonoid M] [AddCommMonoid N]

/- warning: finsupp.curry -> Finsupp.curry is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (Finsupp.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) -> (Finsupp.{u1, max u2 u3} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (Finsupp.{max u2 u1, u3} (Prod.{u1, u2} α β) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) -> (Finsupp.{u1, max u3 u2} α (Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.zero.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.curry Finsupp.curryₓ'. -/
/-- Given a finitely supported function `f` from a product type `α × β` to `γ`,
`curry f` is the "curried" finitely supported function from `α` to the type of
finitely supported functions from `β` to `γ`. -/
protected def curry (f : α × β →₀ M) : α →₀ β →₀ M :=
  f.Sum fun p c => single p.1 (single p.2 c)
#align finsupp.curry Finsupp.curry

/- warning: finsupp.curry_apply -> Finsupp.curry_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (f : Finsupp.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (x : α) (y : β), Eq.{succ u3} M (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (_x : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => β -> M) (Finsupp.hasCoeToFun.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (coeFn.{max (succ u1) (succ (max u2 u3)), max (succ u1) (succ (max u2 u3))} (Finsupp.{u1, max u2 u3} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))) (fun (_x : Finsupp.{u1, max u2 u3} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))) => α -> (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))) (Finsupp.hasCoeToFun.{u1, max u2 u3} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))) (Finsupp.curry.{u1, u2, u3} α β M _inst_1 f) x) y) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (fun (_x : Finsupp.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => (Prod.{u1, u2} α β) -> M) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) f (Prod.mk.{u1, u2} α β x y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] (f : Finsupp.{max u3 u2, u1} (Prod.{u2, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (x : α) (y : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) y) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (FunLike.coe.{max (succ u2) (succ (max u3 u1)), succ u2, succ (max u3 u1)} (Finsupp.{u2, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) _x) (Finsupp.funLike.{u2, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))) (Finsupp.curry.{u2, u3, u1} α β M _inst_1 f) x) y) (FunLike.coe.{max (succ (max u2 u3)) (succ u1), succ (max u2 u3), succ u1} (Finsupp.{max u2 u3, u1} (Prod.{u2, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Prod.{u2, u3} α β) (fun (_x : Prod.{u2, u3} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Prod.{u2, u3} α β) => M) _x) (Finsupp.funLike.{max u2 u3, u1} (Prod.{u2, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) f (Prod.mk.{u2, u3} α β x y))
Case conversion may be inaccurate. Consider using '#align finsupp.curry_apply Finsupp.curry_applyₓ'. -/
@[simp]
theorem curry_apply (f : α × β →₀ M) (x : α) (y : β) : f.curry x y = f (x, y) := by
  classical
    have : ∀ b : α × β, single b.fst (single b.snd (f b)) x y = if b = (x, y) then f b else 0 :=
      by
      rintro ⟨b₁, b₂⟩
      simp [single_apply, ite_apply, Prod.ext_iff, ite_and]
      split_ifs <;> simp [single_apply, *]
    rw [Finsupp.curry, sum_apply, sum_apply, Finsupp.sum, Finset.sum_eq_single, this, if_pos rfl]
    · intro b hb b_ne
      rw [this b, if_neg b_ne]
    · intro hxy
      rw [this (x, y), if_pos rfl, not_mem_support_iff.mp hxy]
#align finsupp.curry_apply Finsupp.curry_apply

/- warning: finsupp.sum_curry_index -> Finsupp.sum_curry_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : AddCommMonoid.{u4} N] (f : Finsupp.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (g : α -> β -> M -> N), (forall (a : α) (b : β), Eq.{succ u4} N (g a b (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))))) (OfNat.ofNat.{u4} N 0 (OfNat.mk.{u4} N 0 (Zero.zero.{u4} N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))))))) -> (forall (a : α) (b : β) (c₀ : M) (c₁ : M), Eq.{succ u4} N (g a b (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) c₀ c₁)) (HAdd.hAdd.{u4, u4, u4} N N N (instHAdd.{u4} N (AddZeroClass.toHasAdd.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (g a b c₀) (g a b c₁))) -> (Eq.{succ u4} N (Finsupp.sum.{u1, max u2 u3, u4} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) N (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) _inst_2 (Finsupp.curry.{u1, u2, u3} α β M _inst_1 f) (fun (a : α) (f : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) => Finsupp.sum.{u2, u3, u4} β M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) _inst_2 f (g a))) (Finsupp.sum.{max u1 u2, u3, u4} (Prod.{u1, u2} α β) M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) _inst_2 f (fun (p : Prod.{u1, u2} α β) (c : M) => g (Prod.fst.{u1, u2} α β p) (Prod.snd.{u1, u2} α β p) c)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u4}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : AddCommMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u1} N] (f : Finsupp.{max u4 u3, u2} (Prod.{u3, u4} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (g : α -> β -> M -> N), (forall (a : α) (b : β), Eq.{succ u1} N (g a b (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))) (OfNat.ofNat.{u1} N 0 (Zero.toOfNat0.{u1} N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_2))))) -> (forall (a : α) (b : β) (c₀ : M) (c₁ : M), Eq.{succ u1} N (g a b (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) c₀ c₁)) (HAdd.hAdd.{u1, u1, u1} N N N (instHAdd.{u1} N (AddZeroClass.toAdd.{u1} N (AddMonoid.toAddZeroClass.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_2)))) (g a b c₀) (g a b c₁))) -> (Eq.{succ u1} N (Finsupp.sum.{u3, max u4 u2, u1} α (Finsupp.{u4, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) N (Finsupp.zero.{u4, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) _inst_2 (Finsupp.curry.{u3, u4, u2} α β M _inst_1 f) (fun (a : α) (f : Finsupp.{u4, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) => Finsupp.sum.{u4, u2, u1} β M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) _inst_2 f (g a))) (Finsupp.sum.{max u3 u4, u2, u1} (Prod.{u3, u4} α β) M N (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) _inst_2 f (fun (p : Prod.{u3, u4} α β) (c : M) => g (Prod.fst.{u3, u4} α β p) (Prod.snd.{u3, u4} α β p) c)))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_curry_index Finsupp.sum_curry_indexₓ'. -/
theorem sum_curry_index (f : α × β →₀ M) (g : α → β → M → N) (hg₀ : ∀ a b, g a b 0 = 0)
    (hg₁ : ∀ a b c₀ c₁, g a b (c₀ + c₁) = g a b c₀ + g a b c₁) :
    (f.curry.Sum fun a f => f.Sum (g a)) = f.Sum fun p c => g p.1 p.2 c :=
  by
  rw [Finsupp.curry]
  trans
  ·
    exact
      sum_sum_index (fun a => sum_zero_index) fun a b₀ b₁ =>
        sum_add_index' (fun a => hg₀ _ _) fun c d₀ d₁ => hg₁ _ _ _ _
  congr ; funext p c
  trans
  · exact sum_single_index sum_zero_index
  exact sum_single_index (hg₀ _ _)
#align finsupp.sum_curry_index Finsupp.sum_curry_index

/- warning: finsupp.uncurry -> Finsupp.uncurry is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (Finsupp.{u1, max u2 u3} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))) -> (Finsupp.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (Finsupp.{u1, max u3 u2} α (Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.zero.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) -> (Finsupp.{max u2 u1, u3} (Prod.{u1, u2} α β) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))
Case conversion may be inaccurate. Consider using '#align finsupp.uncurry Finsupp.uncurryₓ'. -/
/-- Given a finitely supported function `f` from `α` to the type of
finitely supported functions from `β` to `M`,
`uncurry f` is the "uncurried" finitely supported function from `α × β` to `M`. -/
protected def uncurry (f : α →₀ β →₀ M) : α × β →₀ M :=
  f.Sum fun a g => g.Sum fun b c => single (a, b) c
#align finsupp.uncurry Finsupp.uncurry

/- warning: finsupp.finsupp_prod_equiv -> Finsupp.finsuppProdEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], Equiv.{max (succ (max u1 u2)) (succ u3), max (succ u1) (succ (max u2 u3))} (Finsupp.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u1, max u2 u3} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], Equiv.{max (succ u3) (succ (max u2 u1)), max (succ (max u3 u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Prod.{u1, u2} α β) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, max u3 u2} α (Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.zero.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.finsupp_prod_equiv Finsupp.finsuppProdEquivₓ'. -/
/-- `finsupp_prod_equiv` defines the `equiv` between `((α × β) →₀ M)` and `(α →₀ (β →₀ M))` given by
currying and uncurrying. -/
def finsuppProdEquiv : (α × β →₀ M) ≃ (α →₀ β →₀ M)
    where
  toFun := Finsupp.curry
  invFun := Finsupp.uncurry
  left_inv f := by
    rw [Finsupp.uncurry, sum_curry_index]
    · simp_rw [Prod.mk.eta, sum_single]
    · intros
      apply single_zero
    · intros
      apply single_add
  right_inv f := by
    simp only [Finsupp.curry, Finsupp.uncurry, sum_sum_index, sum_zero_index, sum_add_index,
      sum_single_index, single_zero, single_add, eq_self_iff_true, forall_true_iff,
      forall₃_true_iff, Prod.mk.eta, (single_sum _ _ _).symm, sum_single]
#align finsupp.finsupp_prod_equiv Finsupp.finsuppProdEquiv

/- warning: finsupp.filter_curry -> Finsupp.filter_curry is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (f : Finsupp.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (p : α -> Prop), Eq.{max (succ u1) (succ (max u2 u3))} (Finsupp.{u1, max u2 u3} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))) (Finsupp.curry.{u1, u2, u3} α β M _inst_1 (Finsupp.filter.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (fun (a : Prod.{u1, u2} α β) => p (Prod.fst.{u1, u2} α β a)) f)) (Finsupp.filter.{u1, max u2 u3} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) p (Finsupp.curry.{u1, u2, u3} α β M _inst_1 f))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] (f : Finsupp.{max u3 u2, u1} (Prod.{u2, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (p : α -> Prop), Eq.{max (max (succ u2) (succ u3)) (succ u1)} (Finsupp.{u2, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)))) (Finsupp.curry.{u2, u3, u1} α β M _inst_1 (Finsupp.filter.{max u2 u3, u1} (Prod.{u2, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) (fun (a : Prod.{u2, u3} α β) => p (Prod.fst.{u2, u3} α β a)) f)) (Finsupp.filter.{u2, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) p (Finsupp.curry.{u2, u3, u1} α β M _inst_1 f))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_curry Finsupp.filter_curryₓ'. -/
theorem filter_curry (f : α × β →₀ M) (p : α → Prop) :
    (f.filterₓ fun a : α × β => p a.1).curry = f.curry.filterₓ p := by
  classical
    rw [Finsupp.curry, Finsupp.curry, Finsupp.sum, Finsupp.sum, filter_sum, support_filter,
      sum_filter]
    refine' Finset.sum_congr rfl _
    rintro ⟨a₁, a₂⟩ ha
    dsimp only
    split_ifs
    · rw [filter_apply_pos, filter_single_of_pos] <;> exact h
    · rwa [filter_single_of_neg]
#align finsupp.filter_curry Finsupp.filter_curry

/- warning: finsupp.support_curry -> Finsupp.support_curry is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] [_inst_3 : DecidableEq.{succ u1} α] (f : Finsupp.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))), HasSubset.Subset.{u1} (Finset.{u1} α) (Finset.hasSubset.{u1} α) (Finsupp.support.{u1, max u2 u3} α (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.curry.{u1, u2, u3} α β M _inst_1 f)) (Finset.image.{max u1 u2, u1} (Prod.{u1, u2} α β) α (fun (a : α) (b : α) => _inst_3 a b) (Prod.fst.{u1, u2} α β) (Finsupp.support.{max u1 u2, u3} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) f))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {M : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} M] [_inst_3 : DecidableEq.{succ u3} α] (f : Finsupp.{max u2 u3, u1} (Prod.{u3, u2} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))), HasSubset.Subset.{u3} (Finset.{u3} α) (Finset.instHasSubsetFinset.{u3} α) (Finsupp.support.{u3, max u2 u1} α (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.zero.{u2, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1))) (Finsupp.curry.{u3, u2, u1} α β M _inst_1 f)) (Finset.image.{max u2 u3, u3} (Prod.{u3, u2} α β) α (fun (a : α) (b : α) => _inst_3 a b) (Prod.fst.{u3, u2} α β) (Finsupp.support.{max u3 u2, u1} (Prod.{u3, u2} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_1)) f))
Case conversion may be inaccurate. Consider using '#align finsupp.support_curry Finsupp.support_curryₓ'. -/
theorem support_curry [DecidableEq α] (f : α × β →₀ M) :
    f.curry.support ⊆ f.support.image Prod.fst :=
  by
  rw [← Finset.bunionᵢ_singleton]
  refine' Finset.Subset.trans support_sum _
  refine' Finset.bunionᵢ_mono fun a _ => support_single_subset
#align finsupp.support_curry Finsupp.support_curry

end CurryUncurry

/-! ### Declarations about finitely supported functions whose support is a `sum` type -/


section Sum

#print Finsupp.sumElim /-
/-- `finsupp.sum_elim f g` maps `inl x` to `f x` and `inr y` to `g y`. -/
def sumElim {α β γ : Type _} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) : Sum α β →₀ γ :=
  onFinset
    (by
      haveI := Classical.decEq α <;> haveI := Classical.decEq β <;>
        exact f.support.map ⟨_, Sum.inl_injective⟩ ∪ g.support.map ⟨_, Sum.inr_injective⟩)
    (Sum.elim f g) fun ab h => by
    cases' ab with a b <;> simp only [Sum.elim_inl, Sum.elim_inr] at h <;> simpa
#align finsupp.sum_elim Finsupp.sumElim
-/

/- warning: finsupp.coe_sum_elim -> Finsupp.coe_sumElim is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Zero.{u3} γ] (f : Finsupp.{u1, u3} α γ _inst_1) (g : Finsupp.{u2, u3} β γ _inst_1), Eq.{max (succ (max u1 u2)) (succ u3)} ((Sum.{u1, u2} α β) -> γ) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) => (Sum.{u1, u2} α β) -> γ) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Finsupp.sumElim.{u1, u2, u3} α β γ _inst_1 f g)) (Sum.elim.{u1, u2, succ u3} α β γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α γ _inst_1) (fun (_x : Finsupp.{u1, u3} α γ _inst_1) => α -> γ) (Finsupp.hasCoeToFun.{u1, u3} α γ _inst_1) f) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β γ _inst_1) (fun (_x : Finsupp.{u2, u3} β γ _inst_1) => β -> γ) (Finsupp.hasCoeToFun.{u2, u3} β γ _inst_1) g))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Zero.{u1} γ] (f : Finsupp.{u3, u1} α γ _inst_1) (g : Finsupp.{u2, u1} β γ _inst_1), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (forall (ᾰ : Sum.{u3, u2} α β), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) ᾰ) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Finsupp.sumElim.{u3, u2, u1} α β γ _inst_1 f g)) (Sum.elim.{u3, u2, succ u1} α β γ (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α γ _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => γ) _x) (Finsupp.funLike.{u3, u1} α γ _inst_1) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β γ _inst_1) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => γ) _x) (Finsupp.funLike.{u2, u1} β γ _inst_1) g))
Case conversion may be inaccurate. Consider using '#align finsupp.coe_sum_elim Finsupp.coe_sumElimₓ'. -/
@[simp]
theorem coe_sumElim {α β γ : Type _} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) :
    ⇑(sumElim f g) = Sum.elim f g :=
  rfl
#align finsupp.coe_sum_elim Finsupp.coe_sumElim

/- warning: finsupp.sum_elim_apply -> Finsupp.sumElim_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Zero.{u3} γ] (f : Finsupp.{u1, u3} α γ _inst_1) (g : Finsupp.{u2, u3} β γ _inst_1) (x : Sum.{u1, u2} α β), Eq.{succ u3} γ (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) => (Sum.{u1, u2} α β) -> γ) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Finsupp.sumElim.{u1, u2, u3} α β γ _inst_1 f g) x) (Sum.elim.{u1, u2, succ u3} α β γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α γ _inst_1) (fun (_x : Finsupp.{u1, u3} α γ _inst_1) => α -> γ) (Finsupp.hasCoeToFun.{u1, u3} α γ _inst_1) f) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β γ _inst_1) (fun (_x : Finsupp.{u2, u3} β γ _inst_1) => β -> γ) (Finsupp.hasCoeToFun.{u2, u3} β γ _inst_1) g) x)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Zero.{u1} γ] (f : Finsupp.{u3, u1} α γ _inst_1) (g : Finsupp.{u2, u1} β γ _inst_1) (x : Sum.{u3, u2} α β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) x) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Finsupp.sumElim.{u3, u2, u1} α β γ _inst_1 f g) x) (Sum.elim.{u3, u2, succ u1} α β γ (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α γ _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => γ) _x) (Finsupp.funLike.{u3, u1} α γ _inst_1) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β γ _inst_1) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => γ) _x) (Finsupp.funLike.{u2, u1} β γ _inst_1) g) x)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_elim_apply Finsupp.sumElim_applyₓ'. -/
theorem sumElim_apply {α β γ : Type _} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) (x : Sum α β) :
    sumElim f g x = Sum.elim f g x :=
  rfl
#align finsupp.sum_elim_apply Finsupp.sumElim_apply

/- warning: finsupp.sum_elim_inl -> Finsupp.sumElim_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Zero.{u3} γ] (f : Finsupp.{u1, u3} α γ _inst_1) (g : Finsupp.{u2, u3} β γ _inst_1) (x : α), Eq.{succ u3} γ (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) => (Sum.{u1, u2} α β) -> γ) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Finsupp.sumElim.{u1, u2, u3} α β γ _inst_1 f g) (Sum.inl.{u1, u2} α β x)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α γ _inst_1) (fun (_x : Finsupp.{u1, u3} α γ _inst_1) => α -> γ) (Finsupp.hasCoeToFun.{u1, u3} α γ _inst_1) f x)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Zero.{u1} γ] (f : Finsupp.{u3, u1} α γ _inst_1) (g : Finsupp.{u2, u1} β γ _inst_1) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) (Sum.inl.{u3, u2} α β x)) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Finsupp.sumElim.{u3, u2, u1} α β γ _inst_1 f g) (Sum.inl.{u3, u2} α β x)) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α γ _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => γ) _x) (Finsupp.funLike.{u3, u1} α γ _inst_1) f x)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_elim_inl Finsupp.sumElim_inlₓ'. -/
theorem sumElim_inl {α β γ : Type _} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) (x : α) :
    sumElim f g (Sum.inl x) = f x :=
  rfl
#align finsupp.sum_elim_inl Finsupp.sumElim_inl

/- warning: finsupp.sum_elim_inr -> Finsupp.sumElim_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Zero.{u3} γ] (f : Finsupp.{u1, u3} α γ _inst_1) (g : Finsupp.{u2, u3} β γ _inst_1) (x : β), Eq.{succ u3} γ (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) => (Sum.{u1, u2} α β) -> γ) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Finsupp.sumElim.{u1, u2, u3} α β γ _inst_1 f g) (Sum.inr.{u1, u2} α β x)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β γ _inst_1) (fun (_x : Finsupp.{u2, u3} β γ _inst_1) => β -> γ) (Finsupp.hasCoeToFun.{u2, u3} β γ _inst_1) g x)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Zero.{u1} γ] (f : Finsupp.{u3, u1} α γ _inst_1) (g : Finsupp.{u2, u1} β γ _inst_1) (x : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) (Sum.inr.{u3, u2} α β x)) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Finsupp.sumElim.{u3, u2, u1} α β γ _inst_1 f g) (Sum.inr.{u3, u2} α β x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β γ _inst_1) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => γ) _x) (Finsupp.funLike.{u2, u1} β γ _inst_1) g x)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_elim_inr Finsupp.sumElim_inrₓ'. -/
theorem sumElim_inr {α β γ : Type _} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) (x : β) :
    sumElim f g (Sum.inr x) = g x :=
  rfl
#align finsupp.sum_elim_inr Finsupp.sumElim_inr

#print Finsupp.sumFinsuppEquivProdFinsupp /-
/-- The equivalence between `(α ⊕ β) →₀ γ` and `(α →₀ γ) × (β →₀ γ)`.

This is the `finsupp` version of `equiv.sum_arrow_equiv_prod_arrow`. -/
@[simps apply symm_apply]
def sumFinsuppEquivProdFinsupp {α β γ : Type _} [Zero γ] : (Sum α β →₀ γ) ≃ (α →₀ γ) × (β →₀ γ)
    where
  toFun f :=
    ⟨f.comapDomain Sum.inl (Sum.inl_injective.InjOn _),
      f.comapDomain Sum.inr (Sum.inr_injective.InjOn _)⟩
  invFun fg := sumElim fg.1 fg.2
  left_inv f := by
    ext ab
    cases' ab with a b <;> simp
  right_inv fg := by ext <;> simp
#align finsupp.sum_finsupp_equiv_prod_finsupp Finsupp.sumFinsuppEquivProdFinsupp
-/

/- warning: finsupp.fst_sum_finsupp_equiv_prod_finsupp -> Finsupp.fst_sumFinsuppEquivProdFinsupp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Zero.{u3} γ] (f : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (x : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α γ _inst_1) (fun (_x : Finsupp.{u1, u3} α γ _inst_1) => α -> γ) (Finsupp.hasCoeToFun.{u1, u3} α γ _inst_1) (Prod.fst.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u3)) (succ (max u2 u3))) (max (succ (max u1 u3)) (succ (max u2 u3))) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u3)) (succ (max u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u3)) (succ (max u2 u3))} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u3)) (succ (max u2 u3))} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1))) => (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) -> (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u3)) (succ (max u2 u3))} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1))) (Finsupp.sumFinsuppEquivProdFinsupp.{u1, u2, u3} α β γ _inst_1) f)) x) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) => (Sum.{u1, u2} α β) -> γ) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) f (Sum.inl.{u1, u2} α β x))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Zero.{u1} γ] (f : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => γ) x) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α γ _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => γ) _x) (Finsupp.funLike.{u3, u1} α γ _inst_1) (Prod.fst.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Equiv.{max (succ u1) (succ (max u2 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) => Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) _x) (Equiv.instFunLikeEquiv.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1))) (Finsupp.sumFinsuppEquivProdFinsupp.{u3, u2, u1} α β γ _inst_1) f)) x) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) f (Sum.inl.{u3, u2} α β x))
Case conversion may be inaccurate. Consider using '#align finsupp.fst_sum_finsupp_equiv_prod_finsupp Finsupp.fst_sumFinsuppEquivProdFinsuppₓ'. -/
theorem fst_sumFinsuppEquivProdFinsupp {α β γ : Type _} [Zero γ] (f : Sum α β →₀ γ) (x : α) :
    (sumFinsuppEquivProdFinsupp f).1 x = f (Sum.inl x) :=
  rfl
#align finsupp.fst_sum_finsupp_equiv_prod_finsupp Finsupp.fst_sumFinsuppEquivProdFinsupp

/- warning: finsupp.snd_sum_finsupp_equiv_prod_finsupp -> Finsupp.snd_sumFinsuppEquivProdFinsupp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Zero.{u3} γ] (f : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (y : β), Eq.{succ u3} γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β γ _inst_1) (fun (_x : Finsupp.{u2, u3} β γ _inst_1) => β -> γ) (Finsupp.hasCoeToFun.{u2, u3} β γ _inst_1) (Prod.snd.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u3)) (succ (max u2 u3))) (max (succ (max u1 u3)) (succ (max u2 u3))) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u3)) (succ (max u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u3)) (succ (max u2 u3))} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u3)) (succ (max u2 u3))} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1))) => (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) -> (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u3)) (succ (max u2 u3))} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1))) (Finsupp.sumFinsuppEquivProdFinsupp.{u1, u2, u3} α β γ _inst_1) f)) y) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) => (Sum.{u1, u2} α β) -> γ) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) f (Sum.inr.{u1, u2} α β y))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Zero.{u1} γ] (f : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (y : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => γ) y) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β γ _inst_1) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => γ) _x) (Finsupp.funLike.{u2, u1} β γ _inst_1) (Prod.snd.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Equiv.{max (succ u1) (succ (max u2 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) => Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) _x) (Equiv.instFunLikeEquiv.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1))) (Finsupp.sumFinsuppEquivProdFinsupp.{u3, u2, u1} α β γ _inst_1) f)) y) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) f (Sum.inr.{u3, u2} α β y))
Case conversion may be inaccurate. Consider using '#align finsupp.snd_sum_finsupp_equiv_prod_finsupp Finsupp.snd_sumFinsuppEquivProdFinsuppₓ'. -/
theorem snd_sumFinsuppEquivProdFinsupp {α β γ : Type _} [Zero γ] (f : Sum α β →₀ γ) (y : β) :
    (sumFinsuppEquivProdFinsupp f).2 y = f (Sum.inr y) :=
  rfl
#align finsupp.snd_sum_finsupp_equiv_prod_finsupp Finsupp.snd_sumFinsuppEquivProdFinsupp

/- warning: finsupp.sum_finsupp_equiv_prod_finsupp_symm_inl -> Finsupp.sumFinsuppEquivProdFinsupp_symm_inl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Zero.{u3} γ] (fg : Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (x : α), Eq.{succ u3} γ (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) => (Sum.{u1, u2} α β) -> γ) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (coeFn.{max 1 (max (max (succ (max u1 u3)) (succ (max u2 u3))) (succ (max u1 u2)) (succ u3)) (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u3)) (succ (max u2 u3)), max (max (succ (max u1 u3)) (succ (max u2 u3))) (succ (max u1 u2)) (succ u3)} (Equiv.{max (succ (max u1 u3)) (succ (max u2 u3)), max (succ (max u1 u2)) (succ u3)} (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1)) (fun (_x : Equiv.{max (succ (max u1 u3)) (succ (max u2 u3)), max (succ (max u1 u2)) (succ u3)} (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1)) => (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) -> (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1)) (Equiv.hasCoeToFun.{max (succ (max u1 u3)) (succ (max u2 u3)), max (succ (max u1 u2)) (succ u3)} (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1)) (Equiv.symm.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u3)) (succ (max u2 u3))} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (Finsupp.sumFinsuppEquivProdFinsupp.{u1, u2, u3} α β γ _inst_1)) fg) (Sum.inl.{u1, u2} α β x)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α γ _inst_1) (fun (_x : Finsupp.{u1, u3} α γ _inst_1) => α -> γ) (Finsupp.hasCoeToFun.{u1, u3} α γ _inst_1) (Prod.fst.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1) fg) x)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Zero.{u1} γ] (fg : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) (Sum.inl.{u3, u2} α β x)) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Equiv.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (fun (_x : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) => Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) _x) (Equiv.instFunLikeEquiv.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1)) (Equiv.symm.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (Finsupp.sumFinsuppEquivProdFinsupp.{u3, u2, u1} α β γ _inst_1)) fg) (Sum.inl.{u3, u2} α β x)) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α γ _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => γ) _x) (Finsupp.funLike.{u3, u1} α γ _inst_1) (Prod.fst.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1) fg) x)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_finsupp_equiv_prod_finsupp_symm_inl Finsupp.sumFinsuppEquivProdFinsupp_symm_inlₓ'. -/
theorem sumFinsuppEquivProdFinsupp_symm_inl {α β γ : Type _} [Zero γ] (fg : (α →₀ γ) × (β →₀ γ))
    (x : α) : (sumFinsuppEquivProdFinsupp.symm fg) (Sum.inl x) = fg.1 x :=
  rfl
#align finsupp.sum_finsupp_equiv_prod_finsupp_symm_inl Finsupp.sumFinsuppEquivProdFinsupp_symm_inl

/- warning: finsupp.sum_finsupp_equiv_prod_finsupp_symm_inr -> Finsupp.sumFinsuppEquivProdFinsupp_symm_inr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Zero.{u3} γ] (fg : Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (y : β), Eq.{succ u3} γ (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (fun (_x : Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) => (Sum.{u1, u2} α β) -> γ) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (coeFn.{max 1 (max (max (succ (max u1 u3)) (succ (max u2 u3))) (succ (max u1 u2)) (succ u3)) (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u3)) (succ (max u2 u3)), max (max (succ (max u1 u3)) (succ (max u2 u3))) (succ (max u1 u2)) (succ u3)} (Equiv.{max (succ (max u1 u3)) (succ (max u2 u3)), max (succ (max u1 u2)) (succ u3)} (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1)) (fun (_x : Equiv.{max (succ (max u1 u3)) (succ (max u2 u3)), max (succ (max u1 u2)) (succ u3)} (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1)) => (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) -> (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1)) (Equiv.hasCoeToFun.{max (succ (max u1 u3)) (succ (max u2 u3)), max (succ (max u1 u2)) (succ u3)} (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1)) (Equiv.symm.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u3)) (succ (max u2 u3))} (Finsupp.{max u1 u2, u3} (Sum.{u1, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1)) (Finsupp.sumFinsuppEquivProdFinsupp.{u1, u2, u3} α β γ _inst_1)) fg) (Sum.inr.{u1, u2} α β y)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} β γ _inst_1) (fun (_x : Finsupp.{u2, u3} β γ _inst_1) => β -> γ) (Finsupp.hasCoeToFun.{u2, u3} β γ _inst_1) (Prod.snd.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α γ _inst_1) (Finsupp.{u2, u3} β γ _inst_1) fg) y)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Zero.{u1} γ] (fg : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (y : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) (Sum.inr.{u3, u2} α β y)) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => γ) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) γ _inst_1) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Equiv.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (fun (_x : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) => Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) _x) (Equiv.instFunLikeEquiv.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1)) (Equiv.symm.{max (max (succ u1) (succ u2)) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) γ _inst_1) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1)) (Finsupp.sumFinsuppEquivProdFinsupp.{u3, u2, u1} α β γ _inst_1)) fg) (Sum.inr.{u3, u2} α β y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β γ _inst_1) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => γ) _x) (Finsupp.funLike.{u2, u1} β γ _inst_1) (Prod.snd.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α γ _inst_1) (Finsupp.{u2, u1} β γ _inst_1) fg) y)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_finsupp_equiv_prod_finsupp_symm_inr Finsupp.sumFinsuppEquivProdFinsupp_symm_inrₓ'. -/
theorem sumFinsuppEquivProdFinsupp_symm_inr {α β γ : Type _} [Zero γ] (fg : (α →₀ γ) × (β →₀ γ))
    (y : β) : (sumFinsuppEquivProdFinsupp.symm fg) (Sum.inr y) = fg.2 y :=
  rfl
#align finsupp.sum_finsupp_equiv_prod_finsupp_symm_inr Finsupp.sumFinsuppEquivProdFinsupp_symm_inr

variable [AddMonoid M]

/- warning: finsupp.sum_finsupp_add_equiv_prod_finsupp -> Finsupp.sumFinsuppAddEquivProdFinsupp is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u2}} {β : Type.{u3}}, AddEquiv.{max (max u2 u3) u1, max (max u2 u1) u3 u1} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u2}} {β : Type.{u3}}, AddEquiv.{max u1 u3 u2, max (max u1 u3) u1 u2} (Finsupp.{max u3 u2, u1} (Sum.{u2, u3} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u2, max u1 u3} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u2, max u1 u3} (Finsupp.{u2, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_finsupp_add_equiv_prod_finsupp Finsupp.sumFinsuppAddEquivProdFinsuppₓ'. -/
/-- The additive equivalence between `(α ⊕ β) →₀ M` and `(α →₀ M) × (β →₀ M)`.

This is the `finsupp` version of `equiv.sum_arrow_equiv_prod_arrow`. -/
@[simps apply symm_apply]
def sumFinsuppAddEquivProdFinsupp {α β : Type _} : (Sum α β →₀ M) ≃+ (α →₀ M) × (β →₀ M) :=
  { sumFinsuppEquivProdFinsupp with
    map_add' := by
      intros
      ext <;>
        simp only [Equiv.toFun_as_coe, Prod.fst_add, Prod.snd_add, add_apply,
          snd_sum_finsupp_equiv_prod_finsupp, fst_sum_finsupp_equiv_prod_finsupp] }
#align finsupp.sum_finsupp_add_equiv_prod_finsupp Finsupp.sumFinsuppAddEquivProdFinsupp

/- warning: finsupp.fst_sum_finsupp_add_equiv_prod_finsupp -> Finsupp.fst_sumFinsuppAddEquivProdFinsupp is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u2}} {β : Type.{u3}} (f : Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (x : α), Eq.{succ u1} M (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => α -> M) (Finsupp.hasCoeToFun.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.fst.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (coeFn.{max (succ (max (max u2 u3) u1)) (succ (max (max u2 u1) u3 u1)), max (succ (max (max u2 u3) u1)) (succ (max (max u2 u1) u3 u1))} (AddEquiv.{max (max u2 u3) u1, max (max u2 u1) u3 u1} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (fun (_x : AddEquiv.{max (max u2 u3) u1, max (max u2 u1) u3 u1} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) => (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) -> (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) (AddEquiv.hasCoeToFun.{max (max u2 u3) u1, max (max u2 u1) u3 u1} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.sumFinsuppAddEquivProdFinsupp.{u1, u2, u3} M _inst_1 α β) f)) x) (coeFn.{max (succ (max u2 u3)) (succ u1), max (succ (max u2 u3)) (succ u1)} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => (Sum.{u2, u3} α β) -> M) (Finsupp.hasCoeToFun.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) f (Sum.inl.{u2, u3} α β x))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u3}} {β : Type.{u2}} (f : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.fst.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1)} (AddEquiv.{max u1 u2 u3, max (max u1 u2) u1 u3} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (fun (_x : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) => Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) _x) (AddHomClass.toFunLike.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max u1 u2 u3, max (max u1 u2) u1 u3} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (AddZeroClass.toAdd.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1))) (AddZeroClass.toAdd.{max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1)))) (AddMonoidHomClass.toAddHomClass.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max u1 u2 u3, max (max u1 u2) u1 u3} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1)) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1))) (AddEquivClass.instAddMonoidHomClass.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max u1 u2 u3, max (max u1 u2) u1 u3} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1)) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))))) (Finsupp.sumFinsuppAddEquivProdFinsupp.{u1, u3, u2} M _inst_1 α β) f)) x) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => M) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) f (Sum.inl.{u3, u2} α β x))
Case conversion may be inaccurate. Consider using '#align finsupp.fst_sum_finsupp_add_equiv_prod_finsupp Finsupp.fst_sumFinsuppAddEquivProdFinsuppₓ'. -/
theorem fst_sumFinsuppAddEquivProdFinsupp {α β : Type _} (f : Sum α β →₀ M) (x : α) :
    (sumFinsuppAddEquivProdFinsupp f).1 x = f (Sum.inl x) :=
  rfl
#align finsupp.fst_sum_finsupp_add_equiv_prod_finsupp Finsupp.fst_sumFinsuppAddEquivProdFinsupp

/- warning: finsupp.snd_sum_finsupp_add_equiv_prod_finsupp -> Finsupp.snd_sumFinsuppAddEquivProdFinsupp is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u2}} {β : Type.{u3}} (f : Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (y : β), Eq.{succ u1} M (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => β -> M) (Finsupp.hasCoeToFun.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.snd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (coeFn.{max (succ (max (max u2 u3) u1)) (succ (max (max u2 u1) u3 u1)), max (succ (max (max u2 u3) u1)) (succ (max (max u2 u1) u3 u1))} (AddEquiv.{max (max u2 u3) u1, max (max u2 u1) u3 u1} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (fun (_x : AddEquiv.{max (max u2 u3) u1, max (max u2 u1) u3 u1} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) => (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) -> (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) (AddEquiv.hasCoeToFun.{max (max u2 u3) u1, max (max u2 u1) u3 u1} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.sumFinsuppAddEquivProdFinsupp.{u1, u2, u3} M _inst_1 α β) f)) y) (coeFn.{max (succ (max u2 u3)) (succ u1), max (succ (max u2 u3)) (succ u1)} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => (Sum.{u2, u3} α β) -> M) (Finsupp.hasCoeToFun.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) f (Sum.inr.{u2, u3} α β y))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u3}} {β : Type.{u2}} (f : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (y : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) y) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.snd.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1)} (AddEquiv.{max u1 u2 u3, max (max u1 u2) u1 u3} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (fun (_x : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) => Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) _x) (AddHomClass.toFunLike.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max u1 u2 u3, max (max u1 u2) u1 u3} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (AddZeroClass.toAdd.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1))) (AddZeroClass.toAdd.{max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1)))) (AddMonoidHomClass.toAddHomClass.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max u1 u2 u3, max (max u1 u2) u1 u3} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1)) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1))) (AddEquivClass.instAddMonoidHomClass.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max u1 u2 u3, max (max u1 u2) u1 u3} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1)) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))))) (Finsupp.sumFinsuppAddEquivProdFinsupp.{u1, u3, u2} M _inst_1 α β) f)) y) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => M) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) f (Sum.inr.{u3, u2} α β y))
Case conversion may be inaccurate. Consider using '#align finsupp.snd_sum_finsupp_add_equiv_prod_finsupp Finsupp.snd_sumFinsuppAddEquivProdFinsuppₓ'. -/
theorem snd_sumFinsuppAddEquivProdFinsupp {α β : Type _} (f : Sum α β →₀ M) (y : β) :
    (sumFinsuppAddEquivProdFinsupp f).2 y = f (Sum.inr y) :=
  rfl
#align finsupp.snd_sum_finsupp_add_equiv_prod_finsupp Finsupp.snd_sumFinsuppAddEquivProdFinsupp

/- warning: finsupp.sum_finsupp_add_equiv_prod_finsupp_symm_inl -> Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inl is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u2}} {β : Type.{u3}} (fg : Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (x : α), Eq.{succ u1} M (coeFn.{max (succ (max u2 u3)) (succ u1), max (succ (max u2 u3)) (succ u1)} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => (Sum.{u2, u3} α β) -> M) (Finsupp.hasCoeToFun.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (coeFn.{max (succ (max (max u2 u1) u3 u1)) (succ (max (max u2 u3) u1)), max (succ (max (max u2 u1) u3 u1)) (succ (max (max u2 u3) u1))} (AddEquiv.{max (max u2 u1) u3 u1, max (max u2 u3) u1} (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : AddEquiv.{max (max u2 u1) u3 u1, max (max u2 u3) u1} (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) -> (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (AddEquiv.hasCoeToFun.{max (max u2 u1) u3 u1, max (max u2 u3) u1} (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (AddEquiv.symm.{max (max u2 u3) u1, max (max u2 u1) u3 u1} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.sumFinsuppAddEquivProdFinsupp.{u1, u2, u3} M _inst_1 α β)) fg) (Sum.inl.{u2, u3} α β x)) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => α -> M) (Finsupp.hasCoeToFun.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.fst.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) fg) x)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u3}} {β : Type.{u2}} (fg : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => M) (Sum.inl.{u3, u2} α β x)) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => M) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1)} (AddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (fun (_x : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) => Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) _x) (AddHomClass.toFunLike.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (AddZeroClass.toAdd.{max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1)))) (AddZeroClass.toAdd.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1))) (AddMonoidHomClass.toAddHomClass.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1))) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1)) (AddEquivClass.instAddMonoidHomClass.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1))) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1)) (AddEquiv.instAddEquivClassAddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))))) (AddEquiv.symm.{max (max u2 u3) u1, max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.sumFinsuppAddEquivProdFinsupp.{u1, u3, u2} M _inst_1 α β)) fg) (Sum.inl.{u3, u2} α β x)) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.fst.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) fg) x)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_finsupp_add_equiv_prod_finsupp_symm_inl Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inlₓ'. -/
theorem sumFinsuppAddEquivProdFinsupp_symm_inl {α β : Type _} (fg : (α →₀ M) × (β →₀ M)) (x : α) :
    (sumFinsuppAddEquivProdFinsupp.symm fg) (Sum.inl x) = fg.1 x :=
  rfl
#align finsupp.sum_finsupp_add_equiv_prod_finsupp_symm_inl Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inl

/- warning: finsupp.sum_finsupp_add_equiv_prod_finsupp_symm_inr -> Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inr is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u2}} {β : Type.{u3}} (fg : Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (y : β), Eq.{succ u1} M (coeFn.{max (succ (max u2 u3)) (succ u1), max (succ (max u2 u3)) (succ u1)} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => (Sum.{u2, u3} α β) -> M) (Finsupp.hasCoeToFun.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (coeFn.{max (succ (max (max u2 u1) u3 u1)) (succ (max (max u2 u3) u1)), max (succ (max (max u2 u1) u3 u1)) (succ (max (max u2 u3) u1))} (AddEquiv.{max (max u2 u1) u3 u1, max (max u2 u3) u1} (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : AddEquiv.{max (max u2 u1) u3 u1, max (max u2 u3) u1} (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) -> (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (AddEquiv.hasCoeToFun.{max (max u2 u1) u3 u1, max (max u2 u3) u1} (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (AddEquiv.symm.{max (max u2 u3) u1, max (max u2 u1) u3 u1} (Finsupp.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (Finsupp.hasAdd.{max u2 u3, u1} (Sum.{u2, u3} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.hasAdd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.hasAdd.{u2, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.hasAdd.{u3, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.sumFinsuppAddEquivProdFinsupp.{u1, u2, u3} M _inst_1 α β)) fg) (Sum.inr.{u2, u3} α β y)) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (fun (_x : Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) => β -> M) (Finsupp.hasCoeToFun.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.snd.{max u2 u1, max u3 u1} (Finsupp.{u2, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.{u3, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) fg) y)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] {α : Type.{u3}} {β : Type.{u2}} (fg : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (y : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => M) (Sum.inr.{u3, u2} α β y)) (FunLike.coe.{max (succ (max u3 u2)) (succ u1), succ (max u3 u2), succ u1} (Finsupp.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Sum.{u3, u2} α β) (fun (_x : Sum.{u3, u2} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u3, u2} α β) => M) _x) (Finsupp.funLike.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1)} (AddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (fun (_x : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) => Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) _x) (AddHomClass.toFunLike.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (AddZeroClass.toAdd.{max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1)))) (AddZeroClass.toAdd.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1))) (AddMonoidHomClass.toAddHomClass.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1))) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1)) (AddEquivClass.instAddMonoidHomClass.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddZeroClassSum.{max u3 u1, max u2 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u3, u1} α M _inst_1)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{u2, u1} β M _inst_1))) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.addMonoid.{max u2 u3, u1} (Sum.{u3, u2} α β) M _inst_1)) (AddEquiv.instAddEquivClassAddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))))) (AddEquiv.symm.{max (max u2 u3) u1, max (max u2 u3) u1} (Finsupp.{max u2 u3, u1} (Sum.{u3, u2} α β) M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1))) (Finsupp.add.{max u3 u2, u1} (Sum.{u3, u2} α β) M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Prod.instAddSum.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.add.{u3, u1} α M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (Finsupp.add.{u2, u1} β M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Finsupp.sumFinsuppAddEquivProdFinsupp.{u1, u3, u2} M _inst_1 α β)) fg) (Sum.inr.{u3, u2} α β y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) (Prod.snd.{max u1 u3, max u1 u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M _inst_1)) (Finsupp.{u2, u1} β M (AddMonoid.toZero.{u1} M _inst_1)) fg) y)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_finsupp_add_equiv_prod_finsupp_symm_inr Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inrₓ'. -/
theorem sumFinsuppAddEquivProdFinsupp_symm_inr {α β : Type _} (fg : (α →₀ M) × (β →₀ M)) (y : β) :
    (sumFinsuppAddEquivProdFinsupp.symm fg) (Sum.inr y) = fg.2 y :=
  rfl
#align finsupp.sum_finsupp_add_equiv_prod_finsupp_symm_inr Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inr

end Sum

/-! ### Declarations about scalar multiplication -/


section

variable [Zero M] [MonoidWithZero R] [MulActionWithZero R M]

/- warning: finsupp.single_smul -> Finsupp.single_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Zero.{u2} M] [_inst_2 : MonoidWithZero.{u3} R] [_inst_3 : MulActionWithZero.{u3, u2} R M _inst_2 _inst_1] (a : α) (b : α) (f : α -> M) (r : R), Eq.{succ u2} M (SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M _inst_1 (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R _inst_2))) _inst_1 (MulActionWithZero.toSMulWithZero.{u3, u2} R M _inst_2 _inst_1 _inst_3))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R _inst_2)))) (fun (_x : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R _inst_2)))) => α -> R) (Finsupp.hasCoeToFun.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R _inst_2)))) (Finsupp.single.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R _inst_2))) a r) b) (f a)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_1) (fun (_x : Finsupp.{u1, u2} α M _inst_1) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M _inst_1) (Finsupp.single.{u1, u2} α M _inst_1 a (SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M _inst_1 (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R _inst_2))) _inst_1 (MulActionWithZero.toSMulWithZero.{u3, u2} R M _inst_2 _inst_1 _inst_3))) r (f b))) b)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {R : Type.{u2}} [_inst_1 : Zero.{u3} M] [_inst_2 : MonoidWithZero.{u2} R] [_inst_3 : MulActionWithZero.{u2, u3} R M _inst_2 _inst_1] (a : α) (b : α) (f : α -> M) (r : R), Eq.{succ u3} M (HSMul.hSMul.{u2, u3, u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) b) M M (instHSMul.{u2, u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) b) M (SMulZeroClass.toSMul.{u2, u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) b) M _inst_1 (SMulWithZero.toSMulZeroClass.{u2, u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) b) M (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) b) _inst_2) _inst_1 (MulActionWithZero.toSMulWithZero.{u2, u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) b) M _inst_2 _inst_1 _inst_3)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) _x) (Finsupp.funLike.{u1, u2} α R (MonoidWithZero.toZero.{u2} R _inst_2)) (Finsupp.single.{u1, u2} α R (MonoidWithZero.toZero.{u2} R _inst_2) a r) b) (f a)) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α M _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u3} α M _inst_1) (Finsupp.single.{u1, u3} α M _inst_1 a (HSMul.hSMul.{u2, u3, u3} R M M (instHSMul.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M _inst_1 (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R _inst_2) _inst_1 (MulActionWithZero.toSMulWithZero.{u2, u3} R M _inst_2 _inst_1 _inst_3)))) r (f b))) b)
Case conversion may be inaccurate. Consider using '#align finsupp.single_smul Finsupp.single_smulₓ'. -/
@[simp]
theorem single_smul (a b : α) (f : α → M) (r : R) : single a r b • f a = single a (r • f b) b := by
  by_cases a = b <;> simp [h]
#align finsupp.single_smul Finsupp.single_smul

end

section

variable [Monoid G] [MulAction G α] [AddCommMonoid M]

/- warning: finsupp.comap_has_smul -> Finsupp.comapSMul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Monoid.{u3} G] [_inst_2 : MulAction.{u3, u1} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M], SMul.{u3, max u1 u2} G (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Monoid.{u3} G] [_inst_2 : MulAction.{u3, u1} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M], SMul.{u3, max u2 u1} G (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))
Case conversion may be inaccurate. Consider using '#align finsupp.comap_has_smul Finsupp.comapSMulₓ'. -/
/-- Scalar multiplication acting on the domain.

This is not an instance as it would conflict with the action on the range.
See the `instance_diamonds` test for examples of such conflicts. -/
def comapSMul : SMul G (α →₀ M) where smul g := mapDomain ((· • ·) g)
#align finsupp.comap_has_smul Finsupp.comapSMul

attribute [local instance] comap_has_smul

/- warning: finsupp.comap_smul_def -> Finsupp.comapSMul_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Monoid.{u3} G] [_inst_2 : MulAction.{u3, u1} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M] (g : G) (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))), Eq.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (SMul.smul.{u3, max u1 u2} G (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.comapSMul.{u1, u2, u3} α M G _inst_1 _inst_2 _inst_3) g f) (Finsupp.mapDomain.{u1, u1, u2} α α M _inst_3 (SMul.smul.{u3, u1} G α (MulAction.toHasSmul.{u3, u1} G α _inst_1 _inst_2) g) f)
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {G : Type.{u1}} [_inst_1 : Monoid.{u1} G] [_inst_2 : MulAction.{u1, u3} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M] (g : G) (f : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))), Eq.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} G (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (instHSMul.{u1, max u3 u2} G (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.comapSMul.{u3, u2, u1} α M G _inst_1 _inst_2 _inst_3)) g f) (Finsupp.mapDomain.{u3, u3, u2} α α M _inst_3 ((fun (x._@.Mathlib.Data.Finsupp.Basic._hyg.14296 : G) (x._@.Mathlib.Data.Finsupp.Basic._hyg.14298 : α) => HSMul.hSMul.{u1, u3, u3} G α α (instHSMul.{u1, u3} G α (MulAction.toSMul.{u1, u3} G α _inst_1 _inst_2)) x._@.Mathlib.Data.Finsupp.Basic._hyg.14296 x._@.Mathlib.Data.Finsupp.Basic._hyg.14298) g) f)
Case conversion may be inaccurate. Consider using '#align finsupp.comap_smul_def Finsupp.comapSMul_defₓ'. -/
theorem comapSMul_def (g : G) (f : α →₀ M) : g • f = mapDomain ((· • ·) g) f :=
  rfl
#align finsupp.comap_smul_def Finsupp.comapSMul_def

/- warning: finsupp.comap_smul_single -> Finsupp.comapSMul_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Monoid.{u3} G] [_inst_2 : MulAction.{u3, u1} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M] (g : G) (a : α) (b : M), Eq.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (SMul.smul.{u3, max u1 u2} G (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.comapSMul.{u1, u2, u3} α M G _inst_1 _inst_2 _inst_3) g (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) a b)) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMul.smul.{u3, u1} G α (MulAction.toHasSmul.{u3, u1} G α _inst_1 _inst_2) g a) b)
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {G : Type.{u1}} [_inst_1 : Monoid.{u1} G] [_inst_2 : MulAction.{u1, u3} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M] (g : G) (a : α) (b : M), Eq.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (HSMul.hSMul.{u1, max u2 u3, max u3 u2} G (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (instHSMul.{u1, max u3 u2} G (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.comapSMul.{u3, u2, u1} α M G _inst_1 _inst_2 _inst_3)) g (Finsupp.single.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) a b)) (Finsupp.single.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (HSMul.hSMul.{u1, u3, u3} G α α (instHSMul.{u1, u3} G α (MulAction.toSMul.{u1, u3} G α _inst_1 _inst_2)) g a) b)
Case conversion may be inaccurate. Consider using '#align finsupp.comap_smul_single Finsupp.comapSMul_singleₓ'. -/
@[simp]
theorem comapSMul_single (g : G) (a : α) (b : M) : g • single a b = single (g • a) b :=
  mapDomain_single
#align finsupp.comap_smul_single Finsupp.comapSMul_single

/- warning: finsupp.comap_mul_action -> Finsupp.comapMulAction is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Monoid.{u3} G] [_inst_2 : MulAction.{u3, u1} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M], MulAction.{u3, max u1 u2} G (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Monoid.{u3} G] [_inst_2 : MulAction.{u3, u1} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M], MulAction.{u3, max u2 u1} G (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1
Case conversion may be inaccurate. Consider using '#align finsupp.comap_mul_action Finsupp.comapMulActionₓ'. -/
/-- `finsupp.comap_has_smul` is multiplicative -/
def comapMulAction : MulAction G (α →₀ M)
    where
  one_smul f := by rw [comap_smul_def, one_smul_eq_id, map_domain_id]
  mul_smul g g' f := by
    rw [comap_smul_def, comap_smul_def, comap_smul_def, ← comp_smul_left, map_domain_comp]
#align finsupp.comap_mul_action Finsupp.comapMulAction

attribute [local instance] comap_mul_action

/- warning: finsupp.comap_distrib_mul_action -> Finsupp.comapDistribMulAction is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Monoid.{u3} G] [_inst_2 : MulAction.{u3, u1} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M], DistribMulAction.{u3, max u1 u2} G (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Monoid.{u3} G] [_inst_2 : MulAction.{u3, u1} G α _inst_1] [_inst_3 : AddCommMonoid.{u2} M], DistribMulAction.{u3, max u2 u1} G (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))
Case conversion may be inaccurate. Consider using '#align finsupp.comap_distrib_mul_action Finsupp.comapDistribMulActionₓ'. -/
/-- `finsupp.comap_has_smul` is distributive -/
def comapDistribMulAction : DistribMulAction G (α →₀ M)
    where
  smul_zero g := by
    ext
    dsimp [(· • ·)]
    simp
  smul_add g f f' := by
    ext
    dsimp [(· • ·)]
    simp [map_domain_add]
#align finsupp.comap_distrib_mul_action Finsupp.comapDistribMulAction

end

section

variable [Group G] [MulAction G α] [AddCommMonoid M]

attribute [local instance] comap_has_smul comap_mul_action comap_distrib_mul_action

/- warning: finsupp.comap_smul_apply -> Finsupp.comapSMul_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_1 : Group.{u3} G] [_inst_2 : MulAction.{u3, u1} G α (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1))] [_inst_3 : AddCommMonoid.{u2} M] (g : G) (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (a : α), Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (SMul.smul.{u3, max u1 u2} G (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.comapSMul.{u1, u2, u3} α M G (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)) _inst_2 _inst_3) g f) a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) f (SMul.smul.{u3, u1} G α (MulAction.toHasSmul.{u3, u1} G α (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)) _inst_2) (Inv.inv.{u3} G (DivInvMonoid.toHasInv.{u3} G (Group.toDivInvMonoid.{u3} G _inst_1)) g) a))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] [_inst_2 : MulAction.{u1, u3} G α (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))] [_inst_3 : AddCommMonoid.{u2} M] (g : G) (f : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} G (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (instHSMul.{u1, max u3 u2} G (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.comapSMul.{u3, u2, u1} α M G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) _inst_2 _inst_3)) g f) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) f (HSMul.hSMul.{u1, u3, u3} G α α (instHSMul.{u1, u3} G α (MulAction.toSMul.{u1, u3} G α (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) _inst_2)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) g) a))
Case conversion may be inaccurate. Consider using '#align finsupp.comap_smul_apply Finsupp.comapSMul_applyₓ'. -/
/-- When `G` is a group, `finsupp.comap_has_smul` acts by precomposition with the action of `g⁻¹`.
-/
@[simp]
theorem comapSMul_apply (g : G) (f : α →₀ M) (a : α) : (g • f) a = f (g⁻¹ • a) :=
  by
  conv_lhs => rw [← smul_inv_smul g a]
  exact map_domain_apply (MulAction.injective g) _ (g⁻¹ • a)
#align finsupp.comap_smul_apply Finsupp.comapSMul_apply

end

section

instance [Zero M] [SMulZeroClass R M] : SMulZeroClass R (α →₀ M)
    where
  smul a v := v.mapRange ((· • ·) a) (smul_zero _)
  smul_zero a := by
    ext
    apply smul_zero

/-!
Throughout this section, some `monoid` and `semiring` arguments are specified with `{}` instead of
`[]`. See note [implicit instance arguments].
-/


/- warning: finsupp.coe_smul -> Finsupp.coe_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribSMul.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1)] (b : R) (v : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))), Eq.{succ (max u1 u2)} (α -> M) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMul.smul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u3} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_2))) b v)) (SMul.smul.{u3, max u1 u2} R (α -> M) (Function.hasSMul.{u1, u3, u2} α R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_2))) b (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) v))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {R : Type.{u2}} [_inst_1 : AddMonoid.{u3} M] [_inst_2 : DistribSMul.{u2, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1)] (b : R) (v : Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)), Eq.{max (succ u1) (succ u3)} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) ᾰ) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (HSMul.hSMul.{u2, max u1 u3, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (instHSMul.{u2, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (SMulZeroClass.toSMul.{u2, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.zero.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u3, u2} α M R (AddMonoid.toZero.{u3} M _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) _inst_2)))) b v)) (HSMul.hSMul.{u2, max u1 u3, max u1 u3} R (forall (a : α), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (forall (ᾰ : α), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) ᾰ) (instHSMul.{u2, max u1 u3} R (forall (a : α), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (Pi.instSMul.{u1, u3, u2} α R (fun (a : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (fun (i : α) => SMulZeroClass.toSMul.{u2, u3} R ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) i) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) i) _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} R ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) i) (AddMonoid.toAddZeroClass.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) i) _inst_1) _inst_2)))) b (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) v))
Case conversion may be inaccurate. Consider using '#align finsupp.coe_smul Finsupp.coe_smulₓ'. -/
@[simp]
theorem coe_smul [AddMonoid M] [DistribSMul R M] (b : R) (v : α →₀ M) : ⇑(b • v) = b • v :=
  rfl
#align finsupp.coe_smul Finsupp.coe_smul

/- warning: finsupp.smul_apply -> Finsupp.smul_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribSMul.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1)] (b : R) (v : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (a : α), Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMul.smul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u3} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_2))) b v) a) (SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_2)) b (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) => α -> M) (Finsupp.hasCoeToFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) v a))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {R : Type.{u2}} [_inst_1 : AddMonoid.{u3} M] [_inst_2 : DistribSMul.{u2, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1)] (b : R) (v : Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (a : α), Eq.{succ u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (HSMul.hSMul.{u2, max u1 u3, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (instHSMul.{u2, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (SMulZeroClass.toSMul.{u2, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.zero.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u3, u2} α M R (AddMonoid.toZero.{u3} M _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) _inst_2)))) b v) a) (HSMul.hSMul.{u2, u3, u3} R ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (instHSMul.{u2, u3} R ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (SMulZeroClass.toSMul.{u2, u3} R ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} R ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) (AddMonoid.toAddZeroClass.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) a) _inst_1) _inst_2))) b (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) v a))
Case conversion may be inaccurate. Consider using '#align finsupp.smul_apply Finsupp.smul_applyₓ'. -/
theorem smul_apply [AddMonoid M] [DistribSMul R M] (b : R) (v : α →₀ M) (a : α) :
    (b • v) a = b • v a :=
  rfl
#align finsupp.smul_apply Finsupp.smul_apply

/- warning: is_smul_regular.finsupp -> IsSMulRegular.finsupp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribSMul.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1)] {k : R}, (IsSMulRegular.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_2)) k) -> (IsSMulRegular.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u3} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_2))) k)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {R : Type.{u2}} [_inst_1 : AddMonoid.{u3} M] [_inst_2 : DistribSMul.{u2, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1)] {k : R}, (IsSMulRegular.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) _inst_2)) k) -> (IsSMulRegular.{u2, max u3 u1} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (SMulZeroClass.toSMul.{u2, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.zero.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u3, u2} α M R (AddMonoid.toZero.{u3} M _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) _inst_2))) k)
Case conversion may be inaccurate. Consider using '#align is_smul_regular.finsupp IsSMulRegular.finsuppₓ'. -/
theorem IsSMulRegular.finsupp [AddMonoid M] [DistribSMul R M] {k : R} (hk : IsSMulRegular M k) :
    IsSMulRegular (α →₀ M) k := fun _ _ h => ext fun i => hk (congr_fun h i)
#align is_smul_regular.finsupp IsSMulRegular.finsupp

instance [Nonempty α] [AddMonoid M] [DistribSMul R M] [FaithfulSMul R M] : FaithfulSMul R (α →₀ M)
    where eq_of_smul_eq_smul r₁ r₂ h :=
    let ⟨a⟩ := ‹Nonempty α›
    eq_of_smul_eq_smul fun m : M => by simpa using congr_fun (h (single a m)) a

variable (α M)

instance [AddZeroClass M] [DistribSMul R M] : DistribSMul R (α →₀ M)
    where
  smul := (· • ·)
  smul_add a x y := ext fun _ => smul_add _ _ _
  smul_zero x := ext fun _ => smul_zero _

instance [Monoid R] [AddMonoid M] [DistribMulAction R M] : DistribMulAction R (α →₀ M) :=
  { Finsupp.distribSMul _ _ with
    smul := (· • ·)
    one_smul := fun x => ext fun _ => one_smul _ _
    mul_smul := fun r s x => ext fun _ => mul_smul _ _ _ }

instance [Monoid R] [Monoid S] [AddMonoid M] [DistribMulAction R M] [DistribMulAction S M]
    [SMul R S] [IsScalarTower R S M] : IsScalarTower R S (α →₀ M)
    where smul_assoc r s a := ext fun _ => smul_assoc _ _ _

instance [Monoid R] [Monoid S] [AddMonoid M] [DistribMulAction R M] [DistribMulAction S M]
    [SMulCommClass R S M] : SMulCommClass R S (α →₀ M)
    where smul_comm r s a := ext fun _ => smul_comm _ _ _

instance [Monoid R] [AddMonoid M] [DistribMulAction R M] [DistribMulAction Rᵐᵒᵖ M]
    [IsCentralScalar R M] : IsCentralScalar R (α →₀ M)
    where op_smul_eq_smul r a := ext fun _ => op_smul_eq_smul _ _

instance [Semiring R] [AddCommMonoid M] [Module R M] : Module R (α →₀ M) :=
  { Finsupp.distribMulAction α M with
    smul := (· • ·)
    zero_smul := fun x => ext fun _ => zero_smul _ _
    add_smul := fun a x y => ext fun _ => add_smul _ _ _ }

variable {α M} {R}

/- warning: finsupp.support_smul -> Finsupp.support_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} {_x : Monoid.{u3} R} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribMulAction.{u3, u2} R M _x _inst_1] {b : R} {g : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))}, HasSubset.Subset.{u1} (Finset.{u1} α) (Finset.hasSubset.{u1} α) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (SMul.smul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u3} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2)))) b g)) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) g)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} {_x : Monoid.{u3} R} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribMulAction.{u3, u2} R M _x _inst_1] {b : R} {g : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)}, HasSubset.Subset.{u1} (Finset.{u1} α) (Finset.instHasSubsetFinset.{u1} α) (Finsupp.support.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (instHSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.zero.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u3} α M R (AddMonoid.toZero.{u2} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2))))) b g)) (Finsupp.support.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1) g)
Case conversion may be inaccurate. Consider using '#align finsupp.support_smul Finsupp.support_smulₓ'. -/
theorem support_smul {_ : Monoid R} [AddMonoid M] [DistribMulAction R M] {b : R} {g : α →₀ M} :
    (b • g).support ⊆ g.support := fun a =>
  by
  simp only [smul_apply, mem_support_iff, Ne.def]
  exact mt fun h => h.symm ▸ smul_zero _
#align finsupp.support_smul Finsupp.support_smul

/- warning: finsupp.support_smul_eq -> Finsupp.support_smul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_4 : NoZeroSMulDivisors.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3))))] {b : R}, (Ne.{succ u3} R b (OfNat.ofNat.{u3} R 0 (OfNat.mk.{u3} R 0 (Zero.zero.{u3} R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))))) -> (forall {g : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))}, Eq.{succ u1} (Finset.{u1} α) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMul.smul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (SMulZeroClass.toHasSmul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.smulZeroClass.{u1, u2, u3} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3))))) b g)) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) g))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_4 : NoZeroSMulDivisors.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3))))] {b : R}, (Ne.{succ u3} R b (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))))) -> (forall {g : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))}, Eq.{succ u1} (Finset.{u1} α) (Finsupp.support.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (instHSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulZeroClass.toSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.zero.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u3} α M R (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u2} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_2 _inst_3)))))) b g)) (Finsupp.support.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) g))
Case conversion may be inaccurate. Consider using '#align finsupp.support_smul_eq Finsupp.support_smul_eqₓ'. -/
@[simp]
theorem support_smul_eq [Semiring R] [AddCommMonoid M] [Module R M] [NoZeroSMulDivisors R M] {b : R}
    (hb : b ≠ 0) {g : α →₀ M} : (b • g).support = g.support :=
  Finset.ext fun a => by simp [Finsupp.smul_apply, hb]
#align finsupp.support_smul_eq Finsupp.support_smul_eq

section

variable {p : α → Prop}

/- warning: finsupp.filter_smul -> Finsupp.filter_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} {p : α -> Prop} {_x : Monoid.{u3} R} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribMulAction.{u3, u2} R M _x _inst_1] {b : R} {v : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) p (SMul.smul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u3} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2)))) b v)) (SMul.smul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u3} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2)))) b (Finsupp.filter.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) p v))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} {p : α -> Prop} {_x : Monoid.{u3} R} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribMulAction.{u3, u2} R M _x _inst_1] {b : R} {v : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.filter.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1) p (HSMul.hSMul.{u3, max u1 u2, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (instHSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.zero.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u3} α M R (AddMonoid.toZero.{u2} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2))))) b v)) (HSMul.hSMul.{u3, max u2 u1, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (instHSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.zero.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u3} α M R (AddMonoid.toZero.{u2} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2))))) b (Finsupp.filter.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1) p v))
Case conversion may be inaccurate. Consider using '#align finsupp.filter_smul Finsupp.filter_smulₓ'. -/
@[simp]
theorem filter_smul {_ : Monoid R} [AddMonoid M] [DistribMulAction R M] {b : R} {v : α →₀ M} :
    (b • v).filterₓ p = b • v.filterₓ p :=
  coeFn_injective <| Set.indicator_const_smul { x | p x } b v
#align finsupp.filter_smul Finsupp.filter_smul

end

/- warning: finsupp.map_domain_smul -> Finsupp.mapDomain_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {R : Type.{u4}} {_x : Monoid.{u4} R} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : DistribMulAction.{u4, u3} R M _x (AddCommMonoid.toAddMonoid.{u3} M _inst_1)] {f : α -> β} (b : R) (v : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))), Eq.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f (SMul.smul.{u4, max u1 u3} R (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (SMulZeroClass.toHasSmul.{u4, max u1 u3} R (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.smulZeroClass.{u1, u3, u4} α M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (DistribMulAction.toDistribSMul.{u4, u3} R M _x (AddCommMonoid.toAddMonoid.{u3} M _inst_1) _inst_2)))) b v)) (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (DistribMulAction.toDistribSMul.{u4, u3} R M _x (AddCommMonoid.toAddMonoid.{u3} M _inst_1) _inst_2)))) b (Finsupp.mapDomain.{u1, u2, u3} α β M _inst_1 f v))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {M : Type.{u3}} {R : Type.{u4}} {_x : Monoid.{u4} R} [_inst_1 : AddCommMonoid.{u3} M] [_inst_2 : DistribMulAction.{u4, u3} R M _x (AddCommMonoid.toAddMonoid.{u3} M _inst_1)] {f : α -> β} (b : R) (v : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.mapDomain.{u2, u1, u3} α β M _inst_1 f (HSMul.hSMul.{u4, max u2 u3, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (instHSMul.{u4, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (SMulZeroClass.toSMul.{u4, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.zero.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.instSMulZeroClassFinsuppZero.{u2, u3, u4} α M R (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (DistribSMul.toSMulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (DistribMulAction.toDistribSMul.{u4, u3} R M _x (AddCommMonoid.toAddMonoid.{u3} M _inst_1) _inst_2))))) b v)) (HSMul.hSMul.{u4, max u3 u1, max u1 u3} R (Finsupp.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (instHSMul.{u4, max u1 u3} R (Finsupp.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (SMulZeroClass.toSMul.{u4, max u1 u3} R (Finsupp.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.zero.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u3, u4} β M R (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (DistribSMul.toSMulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)) (DistribMulAction.toDistribSMul.{u4, u3} R M _x (AddCommMonoid.toAddMonoid.{u3} M _inst_1) _inst_2))))) b (Finsupp.mapDomain.{u2, u1, u3} α β M _inst_1 f v))
Case conversion may be inaccurate. Consider using '#align finsupp.map_domain_smul Finsupp.mapDomain_smulₓ'. -/
theorem mapDomain_smul {_ : Monoid R} [AddCommMonoid M] [DistribMulAction R M] {f : α → β} (b : R)
    (v : α →₀ M) : mapDomain f (b • v) = b • mapDomain f v :=
  mapDomain_mapRange _ _ _ _ (smul_add b)
#align finsupp.map_domain_smul Finsupp.mapDomain_smul

/- warning: finsupp.smul_single -> Finsupp.smul_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} {_x : Monoid.{u3} R} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribMulAction.{u3, u2} R M _x _inst_1] (c : R) (a : α) (b : M), Eq.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMul.smul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u3} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2)))) c (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) a b)) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) a (SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2))) c b))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} {_x : Monoid.{u3} R} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribMulAction.{u3, u2} R M _x _inst_1] (c : R) (a : α) (b : M), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (HSMul.hSMul.{u3, max u2 u1, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (instHSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.zero.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u3} α M R (AddMonoid.toZero.{u2} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2))))) c (Finsupp.single.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1) a b)) (Finsupp.single.{u1, u2} α M (AddMonoid.toZero.{u2} M _inst_1) a (HSMul.hSMul.{u3, u2, u2} R M M (instHSMul.{u3, u2} R M (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u2} R M _x _inst_1 _inst_2)))) c b))
Case conversion may be inaccurate. Consider using '#align finsupp.smul_single Finsupp.smul_singleₓ'. -/
@[simp]
theorem smul_single {_ : Monoid R} [AddMonoid M] [DistribMulAction R M] (c : R) (a : α) (b : M) :
    c • Finsupp.single a b = Finsupp.single a (c • b) :=
  mapRange_single
#align finsupp.smul_single Finsupp.smul_single

/- warning: finsupp.smul_single' -> Finsupp.smul_single' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {_x : Semiring.{u2} R} (c : R) (a : α) (b : R), Eq.{succ (max u1 u2)} (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x))))) (SMul.smul.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x))))) (SMulZeroClass.toHasSmul.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x))))) (Finsupp.hasZero.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x))))) (Finsupp.smulZeroClass.{u1, u2, u2} α R R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x)))) (SMulWithZero.toSmulZeroClass.{u2, u2} R R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x)))) (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x)))) (MulZeroClass.toSMulWithZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x))))))) c (Finsupp.single.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x)))) a b)) (Finsupp.single.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x)))) a (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x))))) c b))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} {_x : Semiring.{u2} R} (c : R) (a : α) (b : R), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x))) (HSMul.hSMul.{u2, max u2 u1, max u1 u2} R (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x))) (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x))) (instHSMul.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x))) (SMulZeroClass.toSMul.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x))) (Finsupp.zero.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x))) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u2} α R R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x)) (SMulWithZero.toSMulZeroClass.{u2, u2} R R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x)) (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x)) (MulZeroClass.toSMulWithZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x)))))))) c (Finsupp.single.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x)) a b)) (Finsupp.single.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _x)) a (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _x)))) c b))
Case conversion may be inaccurate. Consider using '#align finsupp.smul_single' Finsupp.smul_single'ₓ'. -/
@[simp]
theorem smul_single' {_ : Semiring R} (c : R) (a : α) (b : R) :
    c • Finsupp.single a b = Finsupp.single a (c * b) :=
  smul_single _ _ _
#align finsupp.smul_single' Finsupp.smul_single'

/- warning: finsupp.map_range_smul -> Finsupp.mapRange_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} {_x : Monoid.{u4} R} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribMulAction.{u4, u2} R M _x _inst_1] [_inst_3 : AddMonoid.{u3} N] [_inst_4 : DistribMulAction.{u4, u3} R N _x _inst_3] {f : M -> N} {hf : Eq.{succ u3} N (f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)))))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3)))))} (c : R) (v : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))), (forall (x : M), Eq.{succ u3} N (f (SMul.smul.{u4, u2} R M (SMulZeroClass.toHasSmul.{u4, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u2} R M _x _inst_1 _inst_2))) c x)) (SMul.smul.{u4, u3} R N (SMulZeroClass.toHasSmul.{u4, u3} R N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3)) (DistribSMul.toSmulZeroClass.{u4, u3} R N (AddMonoid.toAddZeroClass.{u3} N _inst_3) (DistribMulAction.toDistribSMul.{u4, u3} R N _x _inst_3 _inst_4))) c (f x))) -> (Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Finsupp.mapRange.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3)) f hf (SMul.smul.{u4, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u4} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u2} R M _x _inst_1 _inst_2)))) c v)) (SMul.smul.{u4, max u1 u3} R (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (SMulZeroClass.toHasSmul.{u4, max u1 u3} R (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Finsupp.hasZero.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Finsupp.smulZeroClass.{u1, u3, u4} α N R (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3)) (DistribSMul.toSmulZeroClass.{u4, u3} R N (AddMonoid.toAddZeroClass.{u3} N _inst_3) (DistribMulAction.toDistribSMul.{u4, u3} R N _x _inst_3 _inst_4)))) c (Finsupp.mapRange.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3)) f hf v)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} {R : Type.{u4}} {_x : Monoid.{u4} R} [_inst_1 : AddMonoid.{u3} M] [_inst_2 : DistribMulAction.{u4, u3} R M _x _inst_1] [_inst_3 : AddMonoid.{u2} N] [_inst_4 : DistribMulAction.{u4, u2} R N _x _inst_3] {f : M -> N} {hf : Eq.{succ u2} N (f (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M _inst_1)))) (OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N (AddMonoid.toZero.{u2} N _inst_3)))} (c : R) (v : Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)), (forall (x : M), Eq.{succ u2} N (f (HSMul.hSMul.{u4, u3, u3} R M M (instHSMul.{u4, u3} R M (SMulZeroClass.toSMul.{u4, u3} R M (AddMonoid.toZero.{u3} M _inst_1) (DistribSMul.toSMulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _x _inst_1 _inst_2)))) c x)) (HSMul.hSMul.{u4, u2, u2} R N N (instHSMul.{u4, u2} R N (SMulZeroClass.toSMul.{u4, u2} R N (AddMonoid.toZero.{u2} N _inst_3) (DistribSMul.toSMulZeroClass.{u4, u2} R N (AddMonoid.toAddZeroClass.{u2} N _inst_3) (DistribMulAction.toDistribSMul.{u4, u2} R N _x _inst_3 _inst_4)))) c (f x))) -> (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N _inst_3)) (Finsupp.mapRange.{u1, u3, u2} α M N (AddMonoid.toZero.{u3} M _inst_1) (AddMonoid.toZero.{u2} N _inst_3) f hf (HSMul.hSMul.{u4, max u1 u3, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (instHSMul.{u4, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (SMulZeroClass.toSMul.{u4, max u1 u3} R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.zero.{u1, u3} α M (AddMonoid.toZero.{u3} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u3, u4} α M R (AddMonoid.toZero.{u3} M _inst_1) (DistribSMul.toSMulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _x _inst_1 _inst_2))))) c v)) (HSMul.hSMul.{u4, max u2 u1, max u1 u2} R (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N _inst_3)) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N _inst_3)) (instHSMul.{u4, max u1 u2} R (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N _inst_3)) (SMulZeroClass.toSMul.{u4, max u1 u2} R (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N _inst_3)) (Finsupp.zero.{u1, u2} α N (AddMonoid.toZero.{u2} N _inst_3)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u4} α N R (AddMonoid.toZero.{u2} N _inst_3) (DistribSMul.toSMulZeroClass.{u4, u2} R N (AddMonoid.toAddZeroClass.{u2} N _inst_3) (DistribMulAction.toDistribSMul.{u4, u2} R N _x _inst_3 _inst_4))))) c (Finsupp.mapRange.{u1, u3, u2} α M N (AddMonoid.toZero.{u3} M _inst_1) (AddMonoid.toZero.{u2} N _inst_3) f hf v)))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range_smul Finsupp.mapRange_smulₓ'. -/
theorem mapRange_smul {_ : Monoid R} [AddMonoid M] [DistribMulAction R M] [AddMonoid N]
    [DistribMulAction R N] {f : M → N} {hf : f 0 = 0} (c : R) (v : α →₀ M)
    (hsmul : ∀ x, f (c • x) = c • f x) : mapRange f hf (c • v) = c • mapRange f hf v :=
  by
  erw [← map_range_comp]
  have : f ∘ (· • ·) c = (· • ·) c ∘ f := funext hsmul
  simp_rw [this]
  apply map_range_comp
  rw [Function.comp_apply, smul_zero, hf]
#align finsupp.map_range_smul Finsupp.mapRange_smul

/- warning: finsupp.smul_single_one -> Finsupp.smul_single_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] (a : α) (b : R), Eq.{succ (max u1 u2)} (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (SMul.smul.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (SMulZeroClass.toHasSmul.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.hasZero.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.smulZeroClass.{u1, u2, u2} α R R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (SMulWithZero.toSmulZeroClass.{u2, u2} R R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (MulZeroClass.toSMulWithZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) b (Finsupp.single.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) a (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))))) (Finsupp.single.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) a b)
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] (a : α) (b : R), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (HSMul.hSMul.{u2, max u2 u1, max u1 u2} R (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (instHSMul.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (SMulZeroClass.toSMul.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.zero.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u2} α R R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (SMulWithZero.toSMulZeroClass.{u2, u2} R R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (MulZeroClass.toSMulWithZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))))) b (Finsupp.single.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) a (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1))))) (Finsupp.single.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) a b)
Case conversion may be inaccurate. Consider using '#align finsupp.smul_single_one Finsupp.smul_single_oneₓ'. -/
theorem smul_single_one [Semiring R] (a : α) (b : R) : b • single a 1 = single a b := by
  rw [smul_single, smul_eq_mul, mul_one]
#align finsupp.smul_single_one Finsupp.smul_single_one

/- warning: finsupp.comap_domain_smul -> Finsupp.comapDomain_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {R : Type.{u4}} [_inst_1 : AddMonoid.{u3} M] [_inst_2 : Monoid.{u4} R] [_inst_3 : DistribMulAction.{u4, u3} R M _inst_2 _inst_1] {f : α -> β} (r : R) (v : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (hfv : Set.InjOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) v)))) (hfrv : optParam.{0} (Set.InjOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r v))))) (Set.InjOn.mono.{u1, u2} α β (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r v)))) (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) v))) f (Set.preimage_mono.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r v))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) v)) (Iff.mpr (HasSubset.Subset.{u2} (Set.{u2} β) (Set.hasSubset.{u2} β) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r v))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) v))) (HasSubset.Subset.{u2} (Finset.{u2} β) (Finset.hasSubset.{u2} β) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r v)) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) v)) (Finset.coe_subset.{u2} β (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r v)) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) v)) (Finsupp.support_smul.{u2, u3, u4} β M R _inst_2 _inst_1 _inst_3 r v))) hfv)), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) f (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r v) hfrv) (SMul.smul.{u4, max u1 u3} R (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u1 u3} R (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u1, u3, u4} α M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) f v hfv))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u4}} {R : Type.{u3}} [_inst_1 : AddMonoid.{u4} M] [_inst_2 : Monoid.{u3} R] [_inst_3 : DistribMulAction.{u3, u4} R M _inst_2 _inst_1] {f : α -> β} (r : R) (v : Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (hfv : Set.InjOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) v)))) (hfrv : optParam.{0} (Set.InjOn.{u1, u2} α β f (Set.preimage.{u1, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) (HSMul.hSMul.{u3, max u2 u4, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u2, u4, u3} β M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r v))))) (Set.InjOn.mono.{u2, u1} α β (Set.preimage.{u1, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) (HSMul.hSMul.{u3, max u2 u4, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u2, u4, u3} β M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r v)))) (Set.preimage.{u1, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) v))) f (Set.preimage_mono.{u1, u2} α β f (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) (HSMul.hSMul.{u3, max u2 u4, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u2, u4, u3} β M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r v))) (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) v)) (Iff.mpr (HasSubset.Subset.{u2} (Set.{u2} β) (Set.instHasSubsetSet.{u2} β) (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) (HSMul.hSMul.{u3, max u2 u4, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u2, u4, u3} β M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r v))) (Finset.toSet.{u2} β (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) v))) (HasSubset.Subset.{u2} (Finset.{u2} β) (Finset.instHasSubsetFinset.{u2} β) (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) (HSMul.hSMul.{u3, max u2 u4, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u2, u4, u3} β M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r v)) (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) v)) (Finset.coe_subset.{u2} β (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) (HSMul.hSMul.{u3, max u2 u4, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u2, u4, u3} β M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r v)) (Finsupp.support.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1) v)) (Finsupp.support_smul.{u2, u4, u3} β M R _inst_2 _inst_1 _inst_3 r v))) hfv)), Eq.{max (succ u1) (succ u4)} (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.comapDomain.{u1, u2, u4} α β M (AddMonoid.toZero.{u4} M _inst_1) f (HSMul.hSMul.{u3, max u2 u4, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u2, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u2, u4, u3} β M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r v) hfrv) (HSMul.hSMul.{u3, max u4 u1, max u1 u4} R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u1 u4} R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u1 u4} R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u4, u3} α M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r (Finsupp.comapDomain.{u1, u2, u4} α β M (AddMonoid.toZero.{u4} M _inst_1) f v hfv))
Case conversion may be inaccurate. Consider using '#align finsupp.comap_domain_smul Finsupp.comapDomain_smulₓ'. -/
theorem comapDomain_smul [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : α → β} (r : R)
    (v : β →₀ M) (hfv : Set.InjOn f (f ⁻¹' ↑v.support))
    (hfrv : Set.InjOn f (f ⁻¹' ↑(r • v).support) :=
      hfv.mono <| Set.preimage_mono <| Finset.coe_subset.mpr support_smul) :
    comapDomain f (r • v) hfrv = r • comapDomain f v hfv :=
  by
  ext
  rfl
#align finsupp.comap_domain_smul Finsupp.comapDomain_smul

/- warning: finsupp.comap_domain_smul_of_injective -> Finsupp.comapDomain_smul_of_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {R : Type.{u4}} [_inst_1 : AddMonoid.{u3} M] [_inst_2 : Monoid.{u4} R] [_inst_3 : DistribMulAction.{u4, u3} R M _inst_2 _inst_1] {f : α -> β} (hf : Function.Injective.{succ u1, succ u2} α β f) (r : R) (v : Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) f (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r v) (Function.Injective.injOn.{u1, u2} α β f hf (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (SMul.smul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u2 u3} R (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u2, u3, u4} β M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r v)))))) (SMul.smul.{u4, max u1 u3} R (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u1 u3} R (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.hasZero.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1))) (Finsupp.smulZeroClass.{u1, u3, u4} α M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_1) (DistribMulAction.toDistribSMul.{u4, u3} R M _inst_2 _inst_1 _inst_3)))) r (Finsupp.comapDomain.{u1, u2, u3} α β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) f v (Function.Injective.injOn.{u1, u2} α β f hf (Set.preimage.{u1, u2} α β f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} β) (Set.{u2} β) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} β) (Set.{u2} β) (Finset.Set.hasCoeT.{u2} β))) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_1)) v))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {M : Type.{u4}} {R : Type.{u3}} [_inst_1 : AddMonoid.{u4} M] [_inst_2 : Monoid.{u3} R] [_inst_3 : DistribMulAction.{u3, u4} R M _inst_2 _inst_1] {f : α -> β} (hf : Function.Injective.{succ u2, succ u1} α β f) (r : R) (v : Finsupp.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)), Eq.{max (succ u2) (succ u4)} (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.comapDomain.{u2, u1, u4} α β M (AddMonoid.toZero.{u4} M _inst_1) f (HSMul.hSMul.{u3, max u1 u4, max u1 u4} R (Finsupp.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u1 u4} R (Finsupp.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u1 u4} R (Finsupp.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u4, u3} β M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r v) (Function.Injective.injOn.{u1, u2} α β f hf (Set.preimage.{u2, u1} α β f (Finset.toSet.{u1} β (Finsupp.support.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1) (HSMul.hSMul.{u3, max u1 u4, max u1 u4} R (Finsupp.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u1 u4} R (Finsupp.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u1 u4} R (Finsupp.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u4, u3} β M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r v)))))) (HSMul.hSMul.{u3, max u4 u2, max u2 u4} R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u2 u4} R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u2, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u2, u4, u3} α M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) (DistribMulAction.toDistribSMul.{u3, u4} R M _inst_2 _inst_1 _inst_3))))) r (Finsupp.comapDomain.{u2, u1, u4} α β M (AddMonoid.toZero.{u4} M _inst_1) f v (Function.Injective.injOn.{u1, u2} α β f hf (Set.preimage.{u2, u1} α β f (Finset.toSet.{u1} β (Finsupp.support.{u1, u4} β M (AddMonoid.toZero.{u4} M _inst_1) v))))))
Case conversion may be inaccurate. Consider using '#align finsupp.comap_domain_smul_of_injective Finsupp.comapDomain_smul_of_injectiveₓ'. -/
/-- A version of `finsupp.comap_domain_smul` that's easier to use. -/
theorem comapDomain_smul_of_injective [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : α → β}
    (hf : Function.Injective f) (r : R) (v : β →₀ M) :
    comapDomain f (r • v) (hf.InjOn _) = r • comapDomain f v (hf.InjOn _) :=
  comapDomain_smul _ _ _ _
#align finsupp.comap_domain_smul_of_injective Finsupp.comapDomain_smul_of_injective

end

/- warning: finsupp.sum_smul_index -> Finsupp.sum_smul_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] {g : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))} {b : R} {h : α -> R -> M}, (forall (i : α), Eq.{succ u2} M (h i (OfNat.ofNat.{u3} R 0 (OfNat.mk.{u3} R 0 (Zero.zero.{u3} R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) -> (Eq.{succ u2} M (Finsupp.sum.{u1, u3, u2} α R M (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_2 (SMul.smul.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (SMulZeroClass.toHasSmul.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Finsupp.hasZero.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Finsupp.smulZeroClass.{u1, u3, u3} α R R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (SMulWithZero.toSmulZeroClass.{u3, u3} R R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (MulZeroClass.toSMulWithZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) b g) h) (Finsupp.sum.{u1, u3, u2} α R M (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_2 g (fun (i : α) (a : R) => h i (HMul.hMul.{u3, u3, u3} R R R (instHMul.{u3} R (Distrib.toHasMul.{u3} R (NonUnitalNonAssocSemiring.toDistrib.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) b a))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] {g : Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))} {b : R} {h : α -> R -> M}, (forall (i : α), Eq.{succ u2} M (h i (OfNat.ofNat.{u3} R 0 (Zero.toOfNat0.{u3} R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))))) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) -> (Eq.{succ u2} M (Finsupp.sum.{u1, u3, u2} α R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) _inst_2 (HSMul.hSMul.{u3, max u1 u3, max u1 u3} R (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (instHSMul.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (SMulZeroClass.toSMul.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.zero.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u3, u3} α R R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (SMulWithZero.toSMulZeroClass.{u3, u3} R R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (MulZeroClass.toSMulWithZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))))) b g) h) (Finsupp.sum.{u1, u3, u2} α R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) _inst_2 g (fun (i : α) (a : R) => h i (HMul.hMul.{u3, u3, u3} R R R (instHMul.{u3} R (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) b a))))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_smul_index Finsupp.sum_smul_indexₓ'. -/
theorem sum_smul_index [Semiring R] [AddCommMonoid M] {g : α →₀ R} {b : R} {h : α → R → M}
    (h0 : ∀ i, h i 0 = 0) : (b • g).Sum h = g.Sum fun i a => h i (b * a) :=
  Finsupp.sum_mapRange_index h0
#align finsupp.sum_smul_index Finsupp.sum_smul_index

/- warning: finsupp.sum_smul_index' -> Finsupp.sum_smul_index' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : DistribSMul.{u4, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1)] [_inst_3 : AddCommMonoid.{u3} N] {g : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))} {b : R} {h : α -> M -> N}, (forall (i : α), Eq.{succ u3} N (h i (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)))))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_3))))))) -> (Eq.{succ u3} N (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) _inst_3 (SMul.smul.{u4, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u4} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_2))) b g) h) (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) _inst_3 g (fun (i : α) (c : M) => h i (SMul.smul.{u4, u2} R M (SMulZeroClass.toHasSmul.{u4, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_2)) b c))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {N : Type.{u2}} {R : Type.{u3}} [_inst_1 : AddMonoid.{u4} M] [_inst_2 : DistribSMul.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1)] [_inst_3 : AddCommMonoid.{u2} N] {g : Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)} {b : R} {h : α -> M -> N}, (forall (i : α), Eq.{succ u2} N (h i (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M (AddMonoid.toZero.{u4} M _inst_1)))) (OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_3))))) -> (Eq.{succ u2} N (Finsupp.sum.{u1, u4, u2} α M N (AddMonoid.toZero.{u4} M _inst_1) _inst_3 (HSMul.hSMul.{u3, max u1 u4, max u1 u4} R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u3, max u1 u4} R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u3, max u1 u4} R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u4, u3} α M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) _inst_2)))) b g) h) (Finsupp.sum.{u1, u4, u2} α M N (AddMonoid.toZero.{u4} M _inst_1) _inst_3 g (fun (i : α) (c : M) => h i (HSMul.hSMul.{u3, u4, u4} R M M (instHSMul.{u3, u4} R M (SMulZeroClass.toSMul.{u3, u4} R M (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u3, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) _inst_2))) b c))))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_smul_index' Finsupp.sum_smul_index'ₓ'. -/
theorem sum_smul_index' [AddMonoid M] [DistribSMul R M] [AddCommMonoid N] {g : α →₀ M} {b : R}
    {h : α → M → N} (h0 : ∀ i, h i 0 = 0) : (b • g).Sum h = g.Sum fun i c => h i (b • c) :=
  Finsupp.sum_mapRange_index h0
#align finsupp.sum_smul_index' Finsupp.sum_smul_index'

/- warning: finsupp.sum_smul_index_add_monoid_hom -> Finsupp.sum_smul_index_addMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : AddMonoid.{u2} M] [_inst_2 : AddCommMonoid.{u3} N] [_inst_3 : DistribSMul.{u4, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1)] {g : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))} {b : R} {h : α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))}, Eq.{succ u3} N (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) _inst_2 (SMul.smul.{u4, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (SMulZeroClass.toHasSmul.{u4, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.hasZero.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1))) (Finsupp.smulZeroClass.{u1, u2, u4} α M R (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_3))) b g) (fun (a : α) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (fun (_x : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (h a))) (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) _inst_2 g (fun (i : α) (c : M) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (fun (_x : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (h i) (SMul.smul.{u4, u2} R M (SMulZeroClass.toHasSmul.{u4, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M _inst_1)) (DistribSMul.toSmulZeroClass.{u4, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_1) _inst_3)) b c)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} {R : Type.{u2}} [_inst_1 : AddMonoid.{u4} M] [_inst_2 : AddCommMonoid.{u3} N] [_inst_3 : DistribSMul.{u2, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1)] {g : Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)} {b : R} {h : α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)))}, Eq.{succ u3} N (Finsupp.sum.{u1, u4, u3} α M N (AddMonoid.toZero.{u4} M _inst_1) _inst_2 (HSMul.hSMul.{u2, max u1 u4, max u1 u4} R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (instHSMul.{u2, max u1 u4} R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (SMulZeroClass.toSMul.{u2, max u1 u4} R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.zero.{u1, u4} α M (AddMonoid.toZero.{u4} M _inst_1)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u4, u2} α M R (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u2, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) _inst_3)))) b g) (fun (a : α) => FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => N) _x) (AddHomClass.toFunLike.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M N (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M _inst_1)) (AddZeroClass.toAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) (AddMonoidHom.addMonoidHomClass.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))) (h a))) (Finsupp.sum.{u1, u4, u3} α M N (AddMonoid.toZero.{u4} M _inst_1) _inst_2 g (fun (i : α) (c : M) => FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : M) => N) _x) (AddHomClass.toFunLike.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M N (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M _inst_1)) (AddZeroClass.toAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) (AddMonoidHomClass.toAddHomClass.{max u4 u3, u4, u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))) M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2)) (AddMonoidHom.addMonoidHomClass.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M _inst_1) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_2))))) (h i) (HSMul.hSMul.{u2, u4, u4} R M M (instHSMul.{u2, u4} R M (SMulZeroClass.toSMul.{u2, u4} R M (AddMonoid.toZero.{u4} M _inst_1) (DistribSMul.toSMulZeroClass.{u2, u4} R M (AddMonoid.toAddZeroClass.{u4} M _inst_1) _inst_3))) b c)))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_smul_index_add_monoid_hom Finsupp.sum_smul_index_addMonoidHomₓ'. -/
/-- A version of `finsupp.sum_smul_index'` for bundled additive maps. -/
theorem sum_smul_index_addMonoidHom [AddMonoid M] [AddCommMonoid N] [DistribSMul R M] {g : α →₀ M}
    {b : R} {h : α → M →+ N} : ((b • g).Sum fun a => h a) = g.Sum fun i c => h i (b • c) :=
  sum_mapRange_index fun i => (h i).map_zero
#align finsupp.sum_smul_index_add_monoid_hom Finsupp.sum_smul_index_addMonoidHom

instance [Semiring R] [AddCommMonoid M] [Module R M] {ι : Type _} [NoZeroSMulDivisors R M] :
    NoZeroSMulDivisors R (ι →₀ M) :=
  ⟨fun c f h =>
    or_iff_not_imp_left.mpr fun hc =>
      Finsupp.ext fun i => (smul_eq_zero.mp (Finsupp.ext_iff.mp h i)).resolve_left hc⟩

section DistribMulActionHom

variable [Semiring R]

variable [AddCommMonoid M] [AddCommMonoid N] [DistribMulAction R M] [DistribMulAction R N]

/- warning: finsupp.distrib_mul_action_hom.single -> Finsupp.DistribMulActionHom.single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : DistribMulAction.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2)], α -> (DistribMulActionHom.{u3, u2, max u1 u2} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4 (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u3} α M R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : DistribMulAction.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2)], α -> (DistribMulActionHom.{u3, u2, max u2 u1} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4 (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u3} α M R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.distrib_mul_action_hom.single Finsupp.DistribMulActionHom.singleₓ'. -/
/-- `finsupp.single` as a `distrib_mul_action_hom`.

See also `finsupp.lsingle` for the version as a linear map. -/
def DistribMulActionHom.single (a : α) : M →+[R] α →₀ M :=
  { singleAddHom a with
    map_smul' := fun k m => by
      simp only [AddMonoidHom.toFun_eq_coe, single_add_hom_apply, smul_single] }
#align finsupp.distrib_mul_action_hom.single Finsupp.DistribMulActionHom.single

/- warning: finsupp.distrib_mul_action_hom_ext -> Finsupp.distribMulActionHom_ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} N] [_inst_4 : DistribMulAction.{u4, u2} R M (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_5 : DistribMulAction.{u4, u3} R N (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} N _inst_3)] {f : DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5} {g : DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5}, (forall (a : α) (m : M), Eq.{succ u3} N (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5) (fun (_x : DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) -> N) ([anonymous].{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5) f (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) a m)) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5) (fun (_x : DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) -> N) ([anonymous].{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5) g (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) a m))) -> (Eq.{max (succ (max u1 u2)) (succ u3)} (DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5) f g)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u3}} {N : Type.{u1}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : AddCommMonoid.{u1} N] [_inst_4 : DistribMulAction.{u4, u3} R M (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_5 : DistribMulAction.{u4, u1} R N (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} N _inst_3)] {f : DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5} {g : DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5}, (forall (a : α) (m : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) => N) (Finsupp.single.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) a m)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u3), succ u1} (DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (fun (_x : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) => N) _x) (SMulHomClass.toFunLike.{max (max u2 u3) u1, u4, max u2 u3, u1} (DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5) R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) N (SMulZeroClass.toSMul.{u4, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (AddMonoid.toZero.{max u2 u3} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSMulZeroClass.{u4, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (AddMonoid.toAddZeroClass.{max u2 u3} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribMulAction.toDistribSMul.{u4, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4)))) (SMulZeroClass.toSMul.{u4, u1} R N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_3)) (DistribSMul.toSMulZeroClass.{u4, u1} R N (AddMonoid.toAddZeroClass.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_3)) (DistribMulAction.toDistribSMul.{u4, u1} R N (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5))) (DistribMulActionHomClass.toSMulHomClass.{max (max u2 u3) u1, u4, max u2 u3, u1} (DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5) R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) N (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (AddCommMonoid.toAddMonoid.{u1} N _inst_3) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) _inst_5 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u4, max u2 u3, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5))) f (Finsupp.single.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) a m)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u3), succ u1} (DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (fun (_x : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) => N) _x) (SMulHomClass.toFunLike.{max (max u2 u3) u1, u4, max u2 u3, u1} (DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5) R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) N (SMulZeroClass.toSMul.{u4, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (AddMonoid.toZero.{max u2 u3} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribSMul.toSMulZeroClass.{u4, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (AddMonoid.toAddZeroClass.{max u2 u3} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (DistribMulAction.toDistribSMul.{u4, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4)))) (SMulZeroClass.toSMul.{u4, u1} R N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_3)) (DistribSMul.toSMulZeroClass.{u4, u1} R N (AddMonoid.toAddZeroClass.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_3)) (DistribMulAction.toDistribSMul.{u4, u1} R N (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5))) (DistribMulActionHomClass.toSMulHomClass.{max (max u2 u3) u1, u4, max u2 u3, u1} (DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5) R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) N (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (AddCommMonoid.toAddMonoid.{u1} N _inst_3) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) _inst_5 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u4, max u2 u3, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5))) g (Finsupp.single.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) a m))) -> (Eq.{max (max (succ u2) (succ u3)) (succ u1)} (DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5) f g)
Case conversion may be inaccurate. Consider using '#align finsupp.distrib_mul_action_hom_ext Finsupp.distribMulActionHom_extₓ'. -/
theorem distribMulActionHom_ext {f g : (α →₀ M) →+[R] N}
    (h : ∀ (a : α) (m : M), f (single a m) = g (single a m)) : f = g :=
  DistribMulActionHom.toAddMonoidHom_injective <| addHom_ext h
#align finsupp.distrib_mul_action_hom_ext Finsupp.distribMulActionHom_ext

/- warning: finsupp.distrib_mul_action_hom_ext' -> Finsupp.distribMulActionHom_ext' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} N] [_inst_4 : DistribMulAction.{u4, u2} R M (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2)] [_inst_5 : DistribMulAction.{u4, u3} R N (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} N _inst_3)] {f : DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5} {g : DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5}, (forall (a : α), Eq.{max (succ u2) (succ u3)} (DistribMulActionHom.{u4, u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4 N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5) (DistribMulActionHom.comp.{u4, u2, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4 (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5 f (Finsupp.DistribMulActionHom.single.{u1, u2, u4} α M R _inst_1 _inst_2 _inst_4 a)) (DistribMulActionHom.comp.{u4, u2, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4 (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5 g (Finsupp.DistribMulActionHom.single.{u1, u2, u4} α M R _inst_1 _inst_2 _inst_4 a))) -> (Eq.{max (succ (max u1 u2)) (succ u3)} (DistribMulActionHom.{u4, max u1 u2, u3} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Finsupp.addMonoid.{u1, u2} α M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Finsupp.distribMulAction.{u1, u2, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u3} N _inst_3) _inst_5) f g)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u3}} {N : Type.{u1}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : AddCommMonoid.{u1} N] [_inst_4 : DistribMulAction.{u4, u3} R M (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2)] [_inst_5 : DistribMulAction.{u4, u1} R N (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} N _inst_3)] {f : DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5} {g : DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5}, (forall (a : α), Eq.{max (succ u3) (succ u1)} (DistribMulActionHom.{u4, u3, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4 N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5) (DistribMulActionHom.comp.{u4, u3, max u2 u3, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4 (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5 f (Finsupp.DistribMulActionHom.single.{u2, u3, u4} α M R _inst_1 _inst_2 _inst_4 a)) (DistribMulActionHom.comp.{u4, u3, max u2 u3, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) M (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4 (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5 g (Finsupp.DistribMulActionHom.single.{u2, u3, u4} α M R _inst_1 _inst_2 _inst_4 a))) -> (Eq.{max (max (succ u2) (succ u3)) (succ u1)} (DistribMulActionHom.{u4, max u3 u2, u1} R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Finsupp.addMonoid.{u2, u3} α M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (Finsupp.distribMulAction.{u2, u3, u4} α M R (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) _inst_4) N (AddCommMonoid.toAddMonoid.{u1} N _inst_3) _inst_5) f g)
Case conversion may be inaccurate. Consider using '#align finsupp.distrib_mul_action_hom_ext' Finsupp.distribMulActionHom_ext'ₓ'. -/
/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem distribMulActionHom_ext' {f g : (α →₀ M) →+[R] N}
    (h : ∀ a : α, f.comp (DistribMulActionHom.single a) = g.comp (DistribMulActionHom.single a)) :
    f = g :=
  distribMulActionHom_ext fun a => DistribMulActionHom.congr_fun (h a)
#align finsupp.distrib_mul_action_hom_ext' Finsupp.distribMulActionHom_ext'

end DistribMulActionHom

section

variable [Zero R]

#print Finsupp.uniqueOfRight /-
/-- The `finsupp` version of `pi.unique`. -/
instance uniqueOfRight [Subsingleton R] : Unique (α →₀ R) :=
  FunLike.coe_injective.unique
#align finsupp.unique_of_right Finsupp.uniqueOfRight
-/

#print Finsupp.uniqueOfLeft /-
/-- The `finsupp` version of `pi.unique_of_is_empty`. -/
instance uniqueOfLeft [IsEmpty α] : Unique (α →₀ R) :=
  FunLike.coe_injective.unique
#align finsupp.unique_of_left Finsupp.uniqueOfLeft
-/

end

/- warning: finsupp.restrict_support_equiv -> Finsupp.restrictSupportEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (s : Set.{u1} α) (M : Type.{u2}) [_inst_1 : AddCommMonoid.{u2} M], Equiv.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Subtype.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (fun (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) => HasSubset.Subset.{u1} (Set.{u1} α) (Set.hasSubset.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) f)) s)) (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} (s : Set.{u1} α) (M : Type.{u2}) [_inst_1 : AddCommMonoid.{u2} M], Equiv.{max 1 (succ u1) (succ u2), max (succ u2) (succ u1)} (Subtype.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (fun (f : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) => HasSubset.Subset.{u1} (Set.{u1} α) (Set.instHasSubsetSet.{u1} α) (Finset.toSet.{u1} α (Finsupp.support.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)) f)) s)) (Finsupp.{u1, u2} (Set.Elem.{u1} α s) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))
Case conversion may be inaccurate. Consider using '#align finsupp.restrict_support_equiv Finsupp.restrictSupportEquivₓ'. -/
/-- Given an `add_comm_monoid M` and `s : set α`, `restrict_support_equiv s M` is the `equiv`
between the subtype of finitely supported functions with support contained in `s` and
the type of finitely supported functions from `s`. -/
def restrictSupportEquiv (s : Set α) (M : Type _) [AddCommMonoid M] :
    { f : α →₀ M // ↑f.support ⊆ s } ≃ (s →₀ M)
    where
  toFun f := subtypeDomain (fun x => x ∈ s) f.1
  invFun f :=
    ⟨f.mapDomain Subtype.val, by
      classical
        refine' Set.Subset.trans (Finset.coe_subset.2 map_domain_support) _
        rw [Finset.coe_image, Set.image_subset_iff]
        exact fun x hx => x.2⟩
  left_inv := by
    rintro ⟨f, hf⟩
    apply Subtype.eq
    ext a
    dsimp only
    refine' by_cases (fun h : a ∈ Set.range (Subtype.val : s → α) => _) fun h => _
    · rcases h with ⟨x, rfl⟩
      rw [map_domain_apply Subtype.val_injective, subtype_domain_apply]
    · convert map_domain_notin_range _ _ h
      rw [← not_mem_support_iff]
      refine' mt _ h
      exact fun ha => ⟨⟨a, hf ha⟩, rfl⟩
  right_inv f := by
    ext ⟨a, ha⟩
    dsimp only
    rw [subtype_domain_apply, map_domain_apply Subtype.val_injective]
#align finsupp.restrict_support_equiv Finsupp.restrictSupportEquiv

/- warning: finsupp.dom_congr -> Finsupp.domCongr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (Equiv.{succ u1, succ u2} α β) -> (AddEquiv.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasAdd.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.hasAdd.{u2, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M], (Equiv.{succ u1, succ u2} α β) -> (AddEquiv.{max u3 u1, max u3 u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u2, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.add.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.add.{u2, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.dom_congr Finsupp.domCongrₓ'. -/
/-- Given `add_comm_monoid M` and `e : α ≃ β`, `dom_congr e` is the corresponding `equiv` between
`α →₀ M` and `β →₀ M`.

This is `finsupp.equiv_congr_left` as an `add_equiv`. -/
@[simps apply]
protected def domCongr [AddCommMonoid M] (e : α ≃ β) : (α →₀ M) ≃+ (β →₀ M)
    where
  toFun := equivMapDomain e
  invFun := equivMapDomain e.symm
  left_inv v := by
    simp only [← equiv_map_domain_trans, Equiv.self_trans_symm]
    exact equiv_map_domain_refl _
  right_inv := by
    intro v
    simp only [← equiv_map_domain_trans, Equiv.symm_trans_self]
    exact equiv_map_domain_refl _
  map_add' a b := by simp only [equiv_map_domain_eq_map_domain] <;> exact map_domain_add
#align finsupp.dom_congr Finsupp.domCongr

/- warning: finsupp.dom_congr_refl -> Finsupp.domCongr_refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M], Eq.{succ (max u1 u2)} (AddEquiv.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.domCongr.{u1, u1, u2} α α M _inst_1 (Equiv.refl.{succ u1} α)) (AddEquiv.refl.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.hasAdd.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddCommMonoid.{u2} M], Eq.{max (succ u1) (succ u2)} (AddEquiv.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.add.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.add.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1)))) (Finsupp.domCongr.{u1, u1, u2} α α M _inst_1 (Equiv.refl.{succ u1} α)) (AddEquiv.refl.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))) (Finsupp.add.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.dom_congr_refl Finsupp.domCongr_reflₓ'. -/
@[simp]
theorem domCongr_refl [AddCommMonoid M] :
    Finsupp.domCongr (Equiv.refl α) = AddEquiv.refl (α →₀ M) :=
  AddEquiv.ext fun _ => equivMapDomain_refl _
#align finsupp.dom_congr_refl Finsupp.domCongr_refl

/- warning: finsupp.dom_congr_symm -> Finsupp.domCongr_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (e : Equiv.{succ u1, succ u2} α β), Eq.{max (succ (max u2 u3)) (succ (max u1 u3))} (AddEquiv.{max u2 u3, max u1 u3} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasAdd.{u2, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.hasAdd.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (AddEquiv.symm.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (Finsupp.hasAdd.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.hasAdd.{u2, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.domCongr.{u1, u2, u3} α β M _inst_1 e)) (Finsupp.domCongr.{u2, u1, u3} β α M _inst_1 (Equiv.symm.{succ u1, succ u2} α β e))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {M : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} M] (e : Equiv.{succ u2, succ u1} α β), Eq.{max (max (succ u2) (succ u1)) (succ u3)} (AddEquiv.{max u1 u3, max u2 u3} (Finsupp.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.add.{u1, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.add.{u2, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1)))) (AddEquiv.symm.{max u2 u3, max u1 u3} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.{u1, u3} β M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.add.{u2, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.add.{u1, u3} β M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_1))) (Finsupp.domCongr.{u2, u1, u3} α β M _inst_1 e)) (Finsupp.domCongr.{u1, u2, u3} β α M _inst_1 (Equiv.symm.{succ u2, succ u1} α β e))
Case conversion may be inaccurate. Consider using '#align finsupp.dom_congr_symm Finsupp.domCongr_symmₓ'. -/
@[simp]
theorem domCongr_symm [AddCommMonoid M] (e : α ≃ β) :
    (Finsupp.domCongr e).symm = (Finsupp.domCongr e.symm : (β →₀ M) ≃+ (α →₀ M)) :=
  AddEquiv.ext fun _ => rfl
#align finsupp.dom_congr_symm Finsupp.domCongr_symm

/- warning: finsupp.dom_congr_trans -> Finsupp.domCongr_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {M : Type.{u4}} [_inst_1 : AddCommMonoid.{u4} M] (e : Equiv.{succ u1, succ u2} α β) (f : Equiv.{succ u2, succ u3} β γ), Eq.{max (succ (max u1 u4)) (succ (max u3 u4))} (AddEquiv.{max u1 u4, max u3 u4} (Finsupp.{u1, u4} α M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.{u3, u4} γ M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.hasAdd.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.hasAdd.{u3, u4} γ M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (AddEquiv.trans.{max u1 u4, max u2 u4, max u3 u4} (Finsupp.{u1, u4} α M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.{u3, u4} γ M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (Finsupp.hasAdd.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.hasAdd.{u2, u4} β M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.hasAdd.{u3, u4} γ M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.domCongr.{u1, u2, u4} α β M _inst_1 e) (Finsupp.domCongr.{u2, u3, u4} β γ M _inst_1 f)) (Finsupp.domCongr.{u1, u3, u4} α γ M _inst_1 (Equiv.trans.{succ u1, succ u2, succ u3} α β γ e f))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} {M : Type.{u4}} [_inst_1 : AddCommMonoid.{u4} M] (e : Equiv.{succ u3, succ u2} α β) (f : Equiv.{succ u2, succ u1} β γ), Eq.{max (max (succ u3) (succ u1)) (succ u4)} (AddEquiv.{max u3 u4, max u4 u1} (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.{u1, u4} γ M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.add.{u3, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.add.{u1, u4} γ M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1)))) (AddEquiv.trans.{max u3 u4, max u2 u4, max u4 u1} (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.{u1, u4} γ M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.add.{u3, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.add.{u2, u4} β M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.add.{u1, u4} γ M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_1))) (Finsupp.domCongr.{u3, u2, u4} α β M _inst_1 e) (Finsupp.domCongr.{u2, u1, u4} β γ M _inst_1 f)) (Finsupp.domCongr.{u3, u1, u4} α γ M _inst_1 (Equiv.trans.{succ u3, succ u2, succ u1} α β γ e f))
Case conversion may be inaccurate. Consider using '#align finsupp.dom_congr_trans Finsupp.domCongr_transₓ'. -/
@[simp]
theorem domCongr_trans [AddCommMonoid M] (e : α ≃ β) (f : β ≃ γ) :
    (Finsupp.domCongr e).trans (Finsupp.domCongr f) =
      (Finsupp.domCongr (e.trans f) : (α →₀ M) ≃+ _) :=
  AddEquiv.ext fun _ => (equivMapDomain_trans _ _ _).symm
#align finsupp.dom_congr_trans Finsupp.domCongr_trans

end Finsupp

namespace Finsupp

/-! ### Declarations about sigma types -/


section Sigma

variable {αs : ι → Type _} [Zero M] (l : (Σi, αs i) →₀ M)

#print Finsupp.split /-
/-- Given `l`, a finitely supported function from the sigma type `Σ (i : ι), αs i` to `M` and
an index element `i : ι`, `split l i` is the `i`th component of `l`,
a finitely supported function from `as i` to `M`.

This is the `finsupp` version of `sigma.curry`.
-/
def split (i : ι) : αs i →₀ M :=
  l.comapDomain (Sigma.mk i) fun x1 x2 _ _ hx => heq_iff_eq.1 (Sigma.mk.inj hx).2
#align finsupp.split Finsupp.split
-/

/- warning: finsupp.split_apply -> Finsupp.split_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {αs : ι -> Type.{u3}} [_inst_1 : Zero.{u2} M] (l : Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => αs i)) M _inst_1) (i : ι) (x : αs i), Eq.{succ u2} M (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (Finsupp.{u3, u2} ((fun (i : ι) => αs i) i) M _inst_1) (fun (_x : Finsupp.{u3, u2} ((fun (i : ι) => αs i) i) M _inst_1) => (αs i) -> M) (Finsupp.hasCoeToFun.{u3, u2} ((fun (i : ι) => αs i) i) M _inst_1) (Finsupp.split.{u1, u2, u3} ι M (fun (i : ι) => αs i) _inst_1 l i) x) (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => αs i)) M _inst_1) (fun (_x : Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => αs i)) M _inst_1) => (Sigma.{u1, u3} ι (fun (i : ι) => αs i)) -> M) (Finsupp.hasCoeToFun.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => αs i)) M _inst_1) l (Sigma.mk.{u1, u3} ι (fun (i : ι) => αs i) i x))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u3}} {αs : ι -> Type.{u2}} [_inst_1 : Zero.{u3} M] (l : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => αs i)) M _inst_1) (i : ι) (x : αs i), Eq.{succ u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : αs i) => M) x) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Finsupp.{u2, u3} (αs i) M _inst_1) (αs i) (fun (_x : αs i) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : αs i) => M) _x) (Finsupp.funLike.{u2, u3} (αs i) M _inst_1) (Finsupp.split.{u1, u3, u2} ι M (fun (i : ι) => αs i) _inst_1 l i) x) (FunLike.coe.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2), succ u3} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => αs i)) M _inst_1) (Sigma.{u1, u2} ι (fun (i : ι) => αs i)) (fun (_x : Sigma.{u1, u2} ι (fun (i : ι) => αs i)) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sigma.{u1, u2} ι (fun (i : ι) => αs i)) => M) _x) (Finsupp.funLike.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => αs i)) M _inst_1) l (Sigma.mk.{u1, u2} ι (fun (i : ι) => αs i) i x))
Case conversion may be inaccurate. Consider using '#align finsupp.split_apply Finsupp.split_applyₓ'. -/
theorem split_apply (i : ι) (x : αs i) : split l i x = l ⟨i, x⟩ :=
  by
  dsimp only [split]
  rw [comap_domain_apply]
#align finsupp.split_apply Finsupp.split_apply

#print Finsupp.splitSupport /-
/-- Given `l`, a finitely supported function from the sigma type `Σ (i : ι), αs i` to `β`,
`split_support l` is the finset of indices in `ι` that appear in the support of `l`. -/
def splitSupport (l : (Σi, αs i) →₀ M) : Finset ι :=
  haveI := Classical.decEq ι
  l.support.image Sigma.fst
#align finsupp.split_support Finsupp.splitSupport
-/

/- warning: finsupp.mem_split_support_iff_nonzero -> Finsupp.mem_splitSupport_iff_nonzero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {αs : ι -> Type.{u3}} [_inst_1 : Zero.{u2} M] (l : Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => αs i)) M _inst_1) (i : ι), Iff (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i (Finsupp.splitSupport.{u1, u2, u3} ι M (fun (i : ι) => αs i) _inst_1 l)) (Ne.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} (αs i) M _inst_1) (Finsupp.split.{u1, u2, u3} ι M (fun (i : ι) => αs i) _inst_1 l i) (OfNat.ofNat.{max u3 u2} (Finsupp.{u3, u2} (αs i) M _inst_1) 0 (OfNat.mk.{max u3 u2} (Finsupp.{u3, u2} (αs i) M _inst_1) 0 (Zero.zero.{max u3 u2} (Finsupp.{u3, u2} (αs i) M _inst_1) (Finsupp.hasZero.{u3, u2} (αs i) M _inst_1)))))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {αs : ι -> Type.{u1}} [_inst_1 : Zero.{u2} M] (l : Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => αs i)) M _inst_1) (i : ι), Iff (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i (Finsupp.splitSupport.{u3, u2, u1} ι M (fun (i : ι) => αs i) _inst_1 l)) (Ne.{max (succ u2) (succ u1)} (Finsupp.{u1, u2} (αs i) M _inst_1) (Finsupp.split.{u3, u2, u1} ι M (fun (i : ι) => αs i) _inst_1 l i) (OfNat.ofNat.{max u2 u1} (Finsupp.{u1, u2} (αs i) M _inst_1) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u1, u2} (αs i) M _inst_1) (Finsupp.zero.{u1, u2} (αs i) M _inst_1))))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_split_support_iff_nonzero Finsupp.mem_splitSupport_iff_nonzeroₓ'. -/
theorem mem_splitSupport_iff_nonzero (i : ι) : i ∈ splitSupport l ↔ split l i ≠ 0 :=
  by
  rw [split_support, mem_image, Ne.def, ← support_eq_empty, ← Ne.def, ←
    Finset.nonempty_iff_ne_empty, split, comap_domain, Finset.Nonempty]
  simp only [exists_prop, Finset.mem_preimage, exists_and_right, exists_eq_right, mem_support_iff,
    Sigma.exists, Ne.def]
#align finsupp.mem_split_support_iff_nonzero Finsupp.mem_splitSupport_iff_nonzero

#print Finsupp.splitComp /-
/-- Given `l`, a finitely supported function from the sigma type `Σ i, αs i` to `β` and
an `ι`-indexed family `g` of functions from `(αs i →₀ β)` to `γ`, `split_comp` defines a
finitely supported function from the index type `ι` to `γ` given by composing `g i` with
`split l i`. -/
def splitComp [Zero N] (g : ∀ i, (αs i →₀ M) → N) (hg : ∀ i x, x = 0 ↔ g i x = 0) : ι →₀ N
    where
  support := splitSupport l
  toFun i := g i (split l i)
  mem_support_toFun := by
    intro i
    rw [mem_split_support_iff_nonzero, not_iff_not, hg]
#align finsupp.split_comp Finsupp.splitComp
-/

/- warning: finsupp.sigma_support -> Finsupp.sigma_support is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {αs : ι -> Type.{u3}} [_inst_1 : Zero.{u2} M] (l : Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => αs i)) M _inst_1), Eq.{succ (max u1 u3)} (Finset.{max u1 u3} (Sigma.{u1, u3} ι (fun (i : ι) => αs i))) (Finsupp.support.{max u1 u3, u2} (Sigma.{u1, u3} ι (fun (i : ι) => αs i)) M _inst_1 l) (Finset.sigma.{u1, u3} ι (fun (i : ι) => αs i) (Finsupp.splitSupport.{u1, u2, u3} ι M (fun (i : ι) => αs i) _inst_1 l) (fun (i : ι) => Finsupp.support.{u3, u2} (αs i) M _inst_1 (Finsupp.split.{u1, u2, u3} ι M (fun (i : ι) => αs i) _inst_1 l i)))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u1}} {αs : ι -> Type.{u2}} [_inst_1 : Zero.{u1} M] (l : Finsupp.{max u2 u3, u1} (Sigma.{u3, u2} ι (fun (i : ι) => αs i)) M _inst_1), Eq.{max (succ u3) (succ u2)} (Finset.{max u3 u2} (Sigma.{u3, u2} ι (fun (i : ι) => αs i))) (Finsupp.support.{max u3 u2, u1} (Sigma.{u3, u2} ι (fun (i : ι) => αs i)) M _inst_1 l) (Finset.sigma.{u3, u2} ι (fun (i : ι) => αs i) (Finsupp.splitSupport.{u3, u1, u2} ι M (fun (i : ι) => αs i) _inst_1 l) (fun (i : ι) => Finsupp.support.{u2, u1} (αs i) M _inst_1 (Finsupp.split.{u3, u1, u2} ι M (fun (i : ι) => αs i) _inst_1 l i)))
Case conversion may be inaccurate. Consider using '#align finsupp.sigma_support Finsupp.sigma_supportₓ'. -/
theorem sigma_support : l.support = l.splitSupport.Sigma fun i => (l.split i).support := by
  simp only [Finset.ext_iff, split_support, split, comap_domain, mem_image, mem_preimage,
      Sigma.forall, mem_sigma] <;>
    tauto
#align finsupp.sigma_support Finsupp.sigma_support

/- warning: finsupp.sigma_sum -> Finsupp.sigma_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {αs : ι -> Type.{u4}} [_inst_1 : Zero.{u2} M] (l : Finsupp.{max u1 u4, u2} (Sigma.{u1, u4} ι (fun (i : ι) => αs i)) M _inst_1) [_inst_2 : AddCommMonoid.{u3} N] (f : (Sigma.{u1, u4} ι (fun (i : ι) => αs i)) -> M -> N), Eq.{succ u3} N (Finsupp.sum.{max u1 u4, u2, u3} (Sigma.{u1, u4} ι (fun (i : ι) => αs i)) M N _inst_1 _inst_2 l f) (Finset.sum.{u3, u1} N ι _inst_2 (Finsupp.splitSupport.{u1, u2, u4} ι M (fun (i : ι) => αs i) _inst_1 l) (fun (i : ι) => Finsupp.sum.{u4, u2, u3} (αs i) M N _inst_1 _inst_2 (Finsupp.split.{u1, u2, u4} ι M (fun (i : ι) => αs i) _inst_1 l i) (fun (a : αs i) (b : M) => f (Sigma.mk.{u1, u4} ι (fun (i : ι) => αs i) i a) b)))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u1}} {N : Type.{u4}} {αs : ι -> Type.{u2}} [_inst_1 : Zero.{u1} M] (l : Finsupp.{max u2 u3, u1} (Sigma.{u3, u2} ι (fun (i : ι) => αs i)) M _inst_1) [_inst_2 : AddCommMonoid.{u4} N] (f : (Sigma.{u3, u2} ι (fun (i : ι) => αs i)) -> M -> N), Eq.{succ u4} N (Finsupp.sum.{max u3 u2, u1, u4} (Sigma.{u3, u2} ι (fun (i : ι) => αs i)) M N _inst_1 _inst_2 l f) (Finset.sum.{u4, u3} N ι _inst_2 (Finsupp.splitSupport.{u3, u1, u2} ι M (fun (i : ι) => αs i) _inst_1 l) (fun (i : ι) => Finsupp.sum.{u2, u1, u4} (αs i) M N _inst_1 _inst_2 (Finsupp.split.{u3, u1, u2} ι M (fun (i : ι) => αs i) _inst_1 l i) (fun (a : αs i) (b : M) => f (Sigma.mk.{u3, u2} ι (fun (i : ι) => αs i) i a) b)))
Case conversion may be inaccurate. Consider using '#align finsupp.sigma_sum Finsupp.sigma_sumₓ'. -/
theorem sigma_sum [AddCommMonoid N] (f : (Σi : ι, αs i) → M → N) :
    l.Sum f = ∑ i in splitSupport l, (split l i).Sum fun (a : αs i) b => f ⟨i, a⟩ b := by
  simp only [Sum, sigma_support, sum_sigma, split_apply]
#align finsupp.sigma_sum Finsupp.sigma_sum

variable {η : Type _} [Fintype η] {ιs : η → Type _} [Zero α]

#print Finsupp.sigmaFinsuppEquivPiFinsupp /-
/-- On a `fintype η`, `finsupp.split` is an equivalence between `(Σ (j : η), ιs j) →₀ α`
and `Π j, (ιs j →₀ α)`.

This is the `finsupp` version of `equiv.Pi_curry`. -/
noncomputable def sigmaFinsuppEquivPiFinsupp : ((Σj, ιs j) →₀ α) ≃ ∀ j, ιs j →₀ α
    where
  toFun := split
  invFun f :=
    onFinset (Finset.univ.Sigma fun j => (f j).support) (fun ji => f ji.1 ji.2) fun g hg =>
      Finset.mem_sigma.mpr ⟨Finset.mem_univ _, mem_support_iff.mpr hg⟩
  left_inv f := by
    ext
    simp [split]
  right_inv f := by
    ext
    simp [split]
#align finsupp.sigma_finsupp_equiv_pi_finsupp Finsupp.sigmaFinsuppEquivPiFinsupp
-/

#print Finsupp.sigmaFinsuppEquivPiFinsupp_apply /-
@[simp]
theorem sigmaFinsuppEquivPiFinsupp_apply (f : (Σj, ιs j) →₀ α) (j i) :
    sigmaFinsuppEquivPiFinsupp f j i = f ⟨j, i⟩ :=
  rfl
#align finsupp.sigma_finsupp_equiv_pi_finsupp_apply Finsupp.sigmaFinsuppEquivPiFinsupp_apply
-/

/- warning: finsupp.sigma_finsupp_add_equiv_pi_finsupp -> Finsupp.sigmaFinsuppAddEquivPiFinsupp is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} [_inst_2 : Fintype.{u1} η] {α : Type.{u2}} {ιs : η -> Type.{u3}} [_inst_4 : AddMonoid.{u2} α], AddEquiv.{max (max u1 u3) u2, max u1 u3 u2} (Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (forall (j : η), Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (Finsupp.hasAdd.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (fun (i : η) => Finsupp.hasAdd.{u3, u2} (ιs i) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)))
but is expected to have type
  forall {η : Type.{u1}} [_inst_2 : Fintype.{u1} η] {α : Type.{u2}} {ιs : η -> Type.{u3}} [_inst_4 : AddMonoid.{u2} α], AddEquiv.{max u2 u3 u1, max (max u1 u2) u3} (Finsupp.{max u3 u1, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u2} α _inst_4)) (forall (j : η), Finsupp.{u3, u2} (ιs j) α (AddMonoid.toZero.{u2} α _inst_4)) (Finsupp.add.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)) (Pi.instAdd.{u1, max u2 u3} η (fun (j : η) => Finsupp.{u3, u2} (ιs j) α (AddMonoid.toZero.{u2} α _inst_4)) (fun (i : η) => Finsupp.add.{u3, u2} (ιs i) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)))
Case conversion may be inaccurate. Consider using '#align finsupp.sigma_finsupp_add_equiv_pi_finsupp Finsupp.sigmaFinsuppAddEquivPiFinsuppₓ'. -/
/-- On a `fintype η`, `finsupp.split` is an additive equivalence between
`(Σ (j : η), ιs j) →₀ α` and `Π j, (ιs j →₀ α)`.

This is the `add_equiv` version of `finsupp.sigma_finsupp_equiv_pi_finsupp`.
-/
noncomputable def sigmaFinsuppAddEquivPiFinsupp {α : Type _} {ιs : η → Type _} [AddMonoid α] :
    ((Σj, ιs j) →₀ α) ≃+ ∀ j, ιs j →₀ α :=
  { sigmaFinsuppEquivPiFinsupp with
    map_add' := fun f g => by
      ext
      simp }
#align finsupp.sigma_finsupp_add_equiv_pi_finsupp Finsupp.sigmaFinsuppAddEquivPiFinsupp

/- warning: finsupp.sigma_finsupp_add_equiv_pi_finsupp_apply -> Finsupp.sigmaFinsuppAddEquivPiFinsupp_apply is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} [_inst_2 : Fintype.{u1} η] {α : Type.{u2}} {ιs : η -> Type.{u3}} [_inst_4 : AddMonoid.{u2} α] (f : Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (j : η) (i : ιs j), Eq.{succ u2} α (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (fun (_x : Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) => (ιs j) -> α) (Finsupp.hasCoeToFun.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (coeFn.{max (succ (max (max u1 u3) u2)) (succ (max u1 u3 u2)), max (succ (max (max u1 u3) u2)) (succ (max u1 u3 u2))} (AddEquiv.{max (max u1 u3) u2, max u1 u3 u2} (Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (forall (j : η), Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (Finsupp.hasAdd.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (fun (i : η) => Finsupp.hasAdd.{u3, u2} (ιs i) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)))) (fun (_x : AddEquiv.{max (max u1 u3) u2, max u1 u3 u2} (Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (forall (j : η), Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (Finsupp.hasAdd.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (fun (i : η) => Finsupp.hasAdd.{u3, u2} (ιs i) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)))) => (Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) -> (forall (j : η), Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4)))) (AddEquiv.hasCoeToFun.{max (max u1 u3) u2, max u1 u3 u2} (Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (forall (j : η), Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (Finsupp.hasAdd.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u3, u2} (ιs j) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (fun (i : η) => Finsupp.hasAdd.{u3, u2} (ιs i) α (AddMonoid.toAddZeroClass.{u2} α _inst_4)))) (Finsupp.sigmaFinsuppAddEquivPiFinsupp.{u1, u2, u3} η _inst_2 α (fun (j : η) => ιs j) _inst_4) f j) i) (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) (fun (_x : Finsupp.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) => (Sigma.{u1, u3} η (fun (j : η) => ιs j)) -> α) (Finsupp.hasCoeToFun.{max u1 u3, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_4))) f (Sigma.mk.{u1, u3} η (fun (j : η) => ιs j) j i))
but is expected to have type
  forall {η : Type.{u1}} [_inst_2 : Fintype.{u1} η] {α : Type.{u3}} {ιs : η -> Type.{u2}} [_inst_4 : AddMonoid.{u3} α] (f : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) (j : η) (i : ιs j), Eq.{succ u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ιs j) => α) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (ιs j) (fun (_x : ιs j) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ιs j) => α) _x) (Finsupp.funLike.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1)} (AddEquiv.{max u3 u2 u1, max (max u1 u3) u2} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) (forall (j : η), Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (Finsupp.add.{max u1 u2, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (fun (i : η) => Finsupp.add.{u2, u3} (ιs i) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)))) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) (fun (_x : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) => forall (j : η), Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) _x) (AddHomClass.toFunLike.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max u3 u2 u1, max (max u1 u3) u2} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) (forall (j : η), Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (Finsupp.add.{max u1 u2, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (fun (i : η) => Finsupp.add.{u2, u3} (ιs i) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)))) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) (forall (j : η), Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (Finsupp.add.{max u1 u2, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (fun (i : η) => Finsupp.add.{u2, u3} (ιs i) α (AddMonoid.toAddZeroClass.{u3} α _inst_4))) (AddEquivClass.instAddHomClass.{max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} (AddEquiv.{max u3 u2 u1, max (max u1 u3) u2} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) (forall (j : η), Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (Finsupp.add.{max u1 u2, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (fun (i : η) => Finsupp.add.{u2, u3} (ιs i) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)))) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) (forall (j : η), Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (Finsupp.add.{max u1 u2, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (fun (i : η) => Finsupp.add.{u2, u3} (ιs i) α (AddMonoid.toAddZeroClass.{u3} α _inst_4))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u2 u3) u1, max (max u2 u3) u1} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) (forall (j : η), Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (Finsupp.add.{max u1 u2, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)) (Pi.instAdd.{u1, max u3 u2} η (fun (j : η) => Finsupp.{u2, u3} (ιs j) α (AddMonoid.toZero.{u3} α _inst_4)) (fun (i : η) => Finsupp.add.{u2, u3} (ιs i) α (AddMonoid.toAddZeroClass.{u3} α _inst_4)))))) (Finsupp.sigmaFinsuppAddEquivPiFinsupp.{u1, u3, u2} η _inst_2 α (fun (j : η) => ιs j) _inst_4) f j) i) (FunLike.coe.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2), succ u3} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) (Sigma.{u1, u2} η (fun (j : η) => ιs j)) (fun (_x : Sigma.{u1, u2} η (fun (j : η) => ιs j)) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sigma.{u1, u2} η (fun (j : η) => ιs j)) => α) _x) (Finsupp.funLike.{max u1 u2, u3} (Sigma.{u1, u2} η (fun (j : η) => ιs j)) α (AddMonoid.toZero.{u3} α _inst_4)) f (Sigma.mk.{u1, u2} η (fun (j : η) => ιs j) j i))
Case conversion may be inaccurate. Consider using '#align finsupp.sigma_finsupp_add_equiv_pi_finsupp_apply Finsupp.sigmaFinsuppAddEquivPiFinsupp_applyₓ'. -/
@[simp]
theorem sigmaFinsuppAddEquivPiFinsupp_apply {α : Type _} {ιs : η → Type _} [AddMonoid α]
    (f : (Σj, ιs j) →₀ α) (j i) : sigmaFinsuppAddEquivPiFinsupp f j i = f ⟨j, i⟩ :=
  rfl
#align finsupp.sigma_finsupp_add_equiv_pi_finsupp_apply Finsupp.sigmaFinsuppAddEquivPiFinsupp_apply

end Sigma

/-! ### Meta declarations -/


/-- Stringify a `finsupp` as a sequence of `finsupp.single` terms.

Note this is `meta` as it has to choose some order for the terms. -/
unsafe instance (ι α : Type _) [Zero α] [Repr ι] [Repr α] : Repr (ι →₀ α)
    where repr f :=
    if f.support.card = 0 then "0"
    else
      " + ".intercalate <|
        f.support.val.unquot.map fun i => "finsupp.single " ++ repr i ++ " " ++ repr (f i)

end Finsupp

