/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module data.finsupp.to_dfinsupp
! leanprover-community/mathlib commit bd9851ca476957ea4549eb19b40e7b5ade9428cc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Module.Equiv
import Mathbin.Data.Dfinsupp.Basic
import Mathbin.Data.Finsupp.Basic

/-!
# Conversion between `finsupp` and homogenous `dfinsupp`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This module provides conversions between `finsupp` and `dfinsupp`.
It is in its own file since neither `finsupp` or `dfinsupp` depend on each other.

## Main definitions

* "identity" maps between `finsupp` and `dfinsupp`:
  * `finsupp.to_dfinsupp : (ι →₀ M) → (Π₀ i : ι, M)`
  * `dfinsupp.to_finsupp : (Π₀ i : ι, M) → (ι →₀ M)`
  * Bundled equiv versions of the above:
    * `finsupp_equiv_dfinsupp : (ι →₀ M) ≃ (Π₀ i : ι, M)`
    * `finsupp_add_equiv_dfinsupp : (ι →₀ M) ≃+ (Π₀ i : ι, M)`
    * `finsupp_lequiv_dfinsupp R : (ι →₀ M) ≃ₗ[R] (Π₀ i : ι, M)`
* stronger versions of `finsupp.split`:
  * `sigma_finsupp_equiv_dfinsupp : ((Σ i, η i) →₀ N) ≃ (Π₀ i, (η i →₀ N))`
  * `sigma_finsupp_add_equiv_dfinsupp : ((Σ i, η i) →₀ N) ≃+ (Π₀ i, (η i →₀ N))`
  * `sigma_finsupp_lequiv_dfinsupp : ((Σ i, η i) →₀ N) ≃ₗ[R] (Π₀ i, (η i →₀ N))`

## Theorems

The defining features of these operations is that they preserve the function and support:

* `finsupp.to_dfinsupp_coe`
* `finsupp.to_dfinsupp_support`
* `dfinsupp.to_finsupp_coe`
* `dfinsupp.to_finsupp_support`

and therefore map `finsupp.single` to `dfinsupp.single` and vice versa:

* `finsupp.to_dfinsupp_single`
* `dfinsupp.to_finsupp_single`

as well as preserving arithmetic operations.

For the bundled equivalences, we provide lemmas that they reduce to `finsupp.to_dfinsupp`:

* `finsupp_add_equiv_dfinsupp_apply`
* `finsupp_lequiv_dfinsupp_apply`
* `finsupp_add_equiv_dfinsupp_symm_apply`
* `finsupp_lequiv_dfinsupp_symm_apply`

## Implementation notes

We provide `dfinsupp.to_finsupp` and `finsupp_equiv_dfinsupp` computably by adding
`[decidable_eq ι]` and `[Π m : M, decidable (m ≠ 0)]` arguments. To aid with definitional unfolding,
these arguments are also present on the `noncomputable` equivs.
-/


variable {ι : Type _} {R : Type _} {M : Type _}

/-! ### Basic definitions and lemmas -/


section Defs

#print Finsupp.toDfinsupp /-
/-- Interpret a `finsupp` as a homogenous `dfinsupp`. -/
def Finsupp.toDfinsupp [Zero M] (f : ι →₀ M) : Π₀ i : ι, M
    where
  toFun := f
  support' :=
    Trunc.mk
      ⟨f.support.1, fun i => (Classical.em (f i = 0)).symm.imp_left Finsupp.mem_support_iff.mpr⟩
#align finsupp.to_dfinsupp Finsupp.toDfinsupp
-/

#print Finsupp.toDfinsupp_coe /-
@[simp]
theorem Finsupp.toDfinsupp_coe [Zero M] (f : ι →₀ M) : ⇑f.toDfinsupp = f :=
  rfl
#align finsupp.to_dfinsupp_coe Finsupp.toDfinsupp_coe
-/

section

variable [DecidableEq ι] [Zero M]

/- warning: finsupp.to_dfinsupp_single -> Finsupp.toDfinsupp_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Zero.{u2} M] (i : ι) (m : M), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)) (Finsupp.toDfinsupp.{u1, u2} ι M _inst_2 (Finsupp.single.{u1, u2} ι M _inst_2 i m)) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => M) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2) i m)
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : Zero.{u1} M] (i : ι) (m : M), Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)) (Finsupp.toDfinsupp.{u2, u1} ι M _inst_2 (Finsupp.single.{u2, u1} ι M _inst_2 i m)) (Dfinsupp.single.{u2, u1} ι (fun (i : ι) => M) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2) i m)
Case conversion may be inaccurate. Consider using '#align finsupp.to_dfinsupp_single Finsupp.toDfinsupp_singleₓ'. -/
@[simp]
theorem Finsupp.toDfinsupp_single (i : ι) (m : M) :
    (Finsupp.single i m).toDfinsupp = Dfinsupp.single i m :=
  by
  ext
  simp [Finsupp.single_apply, Dfinsupp.single_apply]
#align finsupp.to_dfinsupp_single Finsupp.toDfinsupp_single

variable [∀ m : M, Decidable (m ≠ 0)]

/- warning: to_dfinsupp_support -> toDfinsupp_support is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Zero.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_2))))] (f : Finsupp.{u1, u2} ι M _inst_2), Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => M) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2) (fun (i : ι) (x : M) => _inst_3 x) (Finsupp.toDfinsupp.{u1, u2} ι M _inst_2 f)) (Finsupp.support.{u1, u2} ι M _inst_2 f)
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : Zero.{u1} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_2)))] (f : Finsupp.{u2, u1} ι M _inst_2), Eq.{succ u2} (Finset.{u2} ι) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => M) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2) (fun (i : ι) (x : M) => _inst_3 x) (Finsupp.toDfinsupp.{u2, u1} ι M _inst_2 f)) (Finsupp.support.{u2, u1} ι M _inst_2 f)
Case conversion may be inaccurate. Consider using '#align to_dfinsupp_support toDfinsupp_supportₓ'. -/
@[simp]
theorem toDfinsupp_support (f : ι →₀ M) : f.toDfinsupp.support = f.support :=
  by
  ext
  simp
#align to_dfinsupp_support toDfinsupp_support

#print Dfinsupp.toFinsupp /-
/-- Interpret a homogenous `dfinsupp` as a `finsupp`.

Note that the elaborator has a lot of trouble with this definition - it is often necessary to
write `(dfinsupp.to_finsupp f : ι →₀ M)` instead of `f.to_finsupp`, as for some unknown reason
using dot notation or omitting the type ascription prevents the type being resolved correctly. -/
def Dfinsupp.toFinsupp (f : Π₀ i : ι, M) : ι →₀ M :=
  ⟨f.support, f, fun i => by simp only [Dfinsupp.mem_support_iff]⟩
#align dfinsupp.to_finsupp Dfinsupp.toFinsupp
-/

/- warning: dfinsupp.to_finsupp_coe -> Dfinsupp.toFinsupp_coe is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Zero.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_2))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)), Eq.{max (succ u1) (succ u2)} (ι -> M) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M _inst_2) (fun (_x : Finsupp.{u1, u2} ι M _inst_2) => ι -> M) (Finsupp.hasCoeToFun.{u1, u2} ι M _inst_2) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f)) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)) (fun (_x : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)) => ι -> M) (Dfinsupp.hasCoeToFun.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)) f)
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : Zero.{u1} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_2)))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : ι), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => M) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι M _inst_2) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => M) _x) (Finsupp.funLike.{u2, u1} ι M _inst_2) (Dfinsupp.toFinsupp.{u2, u1} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Dfinsupp.{u2, u1} ι (fun (i : ι) => (fun (_i : ι) => M) i) (fun (i : ι) => (fun (i : ι) => _inst_2) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (_i : ι) => M) i) _x) (Dfinsupp.funLike.{u2, u1} ι (fun (i : ι) => (fun (_i : ι) => M) i) (fun (i : ι) => (fun (i : ι) => _inst_2) i)) f)
Case conversion may be inaccurate. Consider using '#align dfinsupp.to_finsupp_coe Dfinsupp.toFinsupp_coeₓ'. -/
@[simp]
theorem Dfinsupp.toFinsupp_coe (f : Π₀ i : ι, M) : ⇑f.toFinsupp = f :=
  rfl
#align dfinsupp.to_finsupp_coe Dfinsupp.toFinsupp_coe

/- warning: dfinsupp.to_finsupp_support -> Dfinsupp.toFinsupp_support is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Zero.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_2))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)), Eq.{succ u1} (Finset.{u1} ι) (Finsupp.support.{u1, u2} ι M _inst_2 (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => M) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2) (fun (i : ι) (x : M) => _inst_3 x) f)
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : Zero.{u1} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_2)))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)), Eq.{succ u2} (Finset.{u2} ι) (Finsupp.support.{u2, u1} ι M _inst_2 (Dfinsupp.toFinsupp.{u2, u1} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f)) (Dfinsupp.support.{u2, u1} ι (fun (i : ι) => M) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2) (fun (i : ι) (x : M) => _inst_3 x) f)
Case conversion may be inaccurate. Consider using '#align dfinsupp.to_finsupp_support Dfinsupp.toFinsupp_supportₓ'. -/
@[simp]
theorem Dfinsupp.toFinsupp_support (f : Π₀ i : ι, M) : f.toFinsupp.support = f.support :=
  by
  ext
  simp
#align dfinsupp.to_finsupp_support Dfinsupp.toFinsupp_support

/- warning: dfinsupp.to_finsupp_single -> Dfinsupp.toFinsupp_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Zero.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_2))))] (i : ι) (m : M), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M _inst_2) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (Dfinsupp.single.{u1, u2} ι (fun (i : ι) => M) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2) i m)) (Finsupp.single.{u1, u2} ι M _inst_2 i m)
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : Zero.{u1} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_2)))] (i : ι) (m : M), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} ι M _inst_2) (Dfinsupp.toFinsupp.{u2, u1} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (Dfinsupp.single.{u2, u1} ι (fun (i : ι) => M) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => _inst_2) i m)) (Finsupp.single.{u2, u1} ι M _inst_2 i m)
Case conversion may be inaccurate. Consider using '#align dfinsupp.to_finsupp_single Dfinsupp.toFinsupp_singleₓ'. -/
@[simp]
theorem Dfinsupp.toFinsupp_single (i : ι) (m : M) :
    (Dfinsupp.single i m : Π₀ i : ι, M).toFinsupp = Finsupp.single i m :=
  by
  ext
  simp [Finsupp.single_apply, Dfinsupp.single_apply]
#align dfinsupp.to_finsupp_single Dfinsupp.toFinsupp_single

/- warning: finsupp.to_dfinsupp_to_finsupp -> Finsupp.toDfinsupp_toFinsupp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Zero.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_2))))] (f : Finsupp.{u1, u2} ι M _inst_2), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M _inst_2) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (Finsupp.toDfinsupp.{u1, u2} ι M _inst_2 f)) f
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : Zero.{u1} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_2)))] (f : Finsupp.{u2, u1} ι M _inst_2), Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} ι M _inst_2) (Dfinsupp.toFinsupp.{u2, u1} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) (Finsupp.toDfinsupp.{u2, u1} ι M _inst_2 f)) f
Case conversion may be inaccurate. Consider using '#align finsupp.to_dfinsupp_to_finsupp Finsupp.toDfinsupp_toFinsuppₓ'. -/
@[simp]
theorem Finsupp.toDfinsupp_toFinsupp (f : ι →₀ M) : f.toDfinsupp.toFinsupp = f :=
  Finsupp.coeFn_injective rfl
#align finsupp.to_dfinsupp_to_finsupp Finsupp.toDfinsupp_toFinsupp

/- warning: dfinsupp.to_finsupp_to_dfinsupp -> Dfinsupp.toFinsupp_toDfinsupp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Zero.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_2))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)) (Finsupp.toDfinsupp.{u1, u2} ι M _inst_2 (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f)) f
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : Zero.{u1} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M _inst_2)))] (f : Dfinsupp.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)), Eq.{max (succ u2) (succ u1)} (Dfinsupp.{u2, u1} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)) (Finsupp.toDfinsupp.{u2, u1} ι M _inst_2 (Dfinsupp.toFinsupp.{u2, u1} ι M (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 (fun (m : M) => _inst_3 m) f)) f
Case conversion may be inaccurate. Consider using '#align dfinsupp.to_finsupp_to_dfinsupp Dfinsupp.toFinsupp_toDfinsuppₓ'. -/
@[simp]
theorem Dfinsupp.toFinsupp_toDfinsupp (f : Π₀ i : ι, M) : f.toFinsupp.toDfinsupp = f :=
  Dfinsupp.coeFn_injective rfl
#align dfinsupp.to_finsupp_to_dfinsupp Dfinsupp.toFinsupp_toDfinsupp

end

end Defs

/-! ### Lemmas about arithmetic operations -/


section Lemmas

namespace Finsupp

#print Finsupp.toDfinsupp_zero /-
@[simp]
theorem toDfinsupp_zero [Zero M] : (0 : ι →₀ M).toDfinsupp = 0 :=
  Dfinsupp.coeFn_injective rfl
#align finsupp.to_dfinsupp_zero Finsupp.toDfinsupp_zero
-/

/- warning: finsupp.to_dfinsupp_add -> Finsupp.toDfinsupp_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M] (f : Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_1)) (g : Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_1)), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_1) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_1)) (Finsupp.hasAdd.{u1, u2} ι M _inst_1)) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_1)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_1)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_1)) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_1))) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_1) f) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_1) g))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddZeroClass.{u2} M] (f : Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_1)) (g : Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_1)), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_1) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_1)) (Finsupp.add.{u1, u2} ι M _inst_1)) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} M _inst_1)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} M _inst_1)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} M _inst_1)) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} M _inst_1)) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_1))) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_1) f) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_1) g))
Case conversion may be inaccurate. Consider using '#align finsupp.to_dfinsupp_add Finsupp.toDfinsupp_addₓ'. -/
@[simp]
theorem toDfinsupp_add [AddZeroClass M] (f g : ι →₀ M) :
    (f + g).toDfinsupp = f.toDfinsupp + g.toDfinsupp :=
  Dfinsupp.coeFn_injective rfl
#align finsupp.to_dfinsupp_add Finsupp.toDfinsupp_add

/- warning: finsupp.to_dfinsupp_neg -> Finsupp.toDfinsupp_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddGroup.{u2} M] (f : Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1)))) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Finsupp.hasNeg.{u1, u2} ι M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1)))) f)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_1)) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1)))) f))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddGroup.{u2} M] (f : Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Finsupp.toDfinsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1)))) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Finsupp.instNegFinsuppToZero.{u1, u2} ι M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1)))) f)) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_1)) (Finsupp.toDfinsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1)))) f))
Case conversion may be inaccurate. Consider using '#align finsupp.to_dfinsupp_neg Finsupp.toDfinsupp_negₓ'. -/
@[simp]
theorem toDfinsupp_neg [AddGroup M] (f : ι →₀ M) : (-f).toDfinsupp = -f.toDfinsupp :=
  Dfinsupp.coeFn_injective rfl
#align finsupp.to_dfinsupp_neg Finsupp.toDfinsupp_neg

/- warning: finsupp.to_dfinsupp_sub -> Finsupp.toDfinsupp_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddGroup.{u2} M] (f : Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (g : Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))), Eq.{succ (max u1 u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1)))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Finsupp.hasSub.{u1, u2} ι M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1)))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_1))) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1)))) f) (Finsupp.toDfinsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_1)))) g))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : AddGroup.{u2} M] (f : Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (g : Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Finsupp.toDfinsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1)))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u1, u2} ι M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1)))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_1))) (Finsupp.toDfinsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1)))) f) (Finsupp.toDfinsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_1)))) g))
Case conversion may be inaccurate. Consider using '#align finsupp.to_dfinsupp_sub Finsupp.toDfinsupp_subₓ'. -/
@[simp]
theorem toDfinsupp_sub [AddGroup M] (f g : ι →₀ M) :
    (f - g).toDfinsupp = f.toDfinsupp - g.toDfinsupp :=
  Dfinsupp.coeFn_injective rfl
#align finsupp.to_dfinsupp_sub Finsupp.toDfinsupp_sub

/- warning: finsupp.to_dfinsupp_smul -> Finsupp.toDfinsupp_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Monoid.{u2} R] [_inst_2 : AddMonoid.{u3} M] [_inst_3 : DistribMulAction.{u2, u3} R M _inst_1 _inst_2] (r : R) (f : Finsupp.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_2))), Eq.{succ (max u1 u3)} (Dfinsupp.{u1, u3} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_2))) (Finsupp.toDfinsupp.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_2)) (SMul.smul.{u2, max u1 u3} R (Finsupp.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_2))) (SMulZeroClass.toHasSmul.{u2, max u1 u3} R (Finsupp.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_2))) (Finsupp.hasZero.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_2))) (Finsupp.smulZeroClass.{u1, u3, u2} ι M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_2)) (DistribSMul.toSmulZeroClass.{u2, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_2) (DistribMulAction.toDistribSMul.{u2, u3} R M _inst_1 _inst_2 _inst_3)))) r f)) (SMul.smul.{u2, max u1 u3} R (Dfinsupp.{u1, u3} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_2))) (Dfinsupp.hasSmul.{u1, u3, u2} ι R (fun (i : ι) => M) _inst_1 (fun (i : ι) => _inst_2) (fun (i : ι) => _inst_3)) r (Finsupp.toDfinsupp.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_2)) f))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Monoid.{u3} R] [_inst_2 : AddMonoid.{u2} M] [_inst_3 : DistribMulAction.{u3, u2} R M _inst_1 _inst_2] (r : R) (f : Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_2)), Eq.{max (succ u1) (succ u2)} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddMonoid.toZero.{u2} M _inst_2)) (Finsupp.toDfinsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_2) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} R (Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_2)) (Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_2)) (instHSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_2)) (SMulZeroClass.toSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_2)) (Finsupp.zero.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_2)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u3} ι M R (AddMonoid.toZero.{u2} M _inst_2) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_2) (DistribMulAction.toDistribSMul.{u3, u2} R M _inst_1 _inst_2 _inst_3))))) r f)) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} R (Dfinsupp.{u1, u2} ι (fun (_i : ι) => M) (fun (i : ι) => AddMonoid.toZero.{u2} M _inst_2)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddMonoid.toZero.{u2} M _inst_2)) (instHSMul.{u3, max u1 u2} R (Dfinsupp.{u1, u2} ι (fun (_i : ι) => M) (fun (i : ι) => AddMonoid.toZero.{u2} M _inst_2)) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι R (fun (_i : ι) => M) _inst_1 (fun (i : ι) => _inst_2) (fun (i : ι) => _inst_3))) r (Finsupp.toDfinsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_2) f))
Case conversion may be inaccurate. Consider using '#align finsupp.to_dfinsupp_smul Finsupp.toDfinsupp_smulₓ'. -/
@[simp]
theorem toDfinsupp_smul [Monoid R] [AddMonoid M] [DistribMulAction R M] (r : R) (f : ι →₀ M) :
    (r • f).toDfinsupp = r • f.toDfinsupp :=
  Dfinsupp.coeFn_injective rfl
#align finsupp.to_dfinsupp_smul Finsupp.toDfinsupp_smul

end Finsupp

namespace Dfinsupp

variable [DecidableEq ι]

#print Dfinsupp.toFinsupp_zero /-
@[simp]
theorem toFinsupp_zero [Zero M] [∀ m : M, Decidable (m ≠ 0)] : toFinsupp 0 = (0 : ι →₀ M) :=
  Finsupp.coeFn_injective rfl
#align dfinsupp.to_finsupp_zero Dfinsupp.toFinsupp_zero
-/

/- warning: dfinsupp.to_finsupp_add -> Dfinsupp.toFinsupp_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddZeroClass.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M _inst_2)))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => M) i) _inst_2)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => M) i) _inst_2)), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_2)) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u2} M _inst_2) (fun (m : M) => _inst_3 m) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_2)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_2)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_2)) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_2)) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_2)) (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_2)) (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_2)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_2)) (Finsupp.hasAdd.{u1, u2} ι M _inst_2)) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u2} M _inst_2) (fun (m : M) => _inst_3 m) f) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u2} M _inst_2) (fun (m : M) => _inst_3 m) g))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddZeroClass.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddZeroClass.toZero.{u2} M _inst_2))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => M) i) _inst_2)) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => M) i) _inst_2)), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_2)) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toZero.{u2} M _inst_2) (fun (m : M) => _inst_3 m) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) _inst_2)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) _inst_2)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) _inst_2)) (instHAdd.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) _inst_2)) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2))) f g)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_2)) (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_2)) (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_2)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_2)) (Finsupp.add.{u1, u2} ι M _inst_2)) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toZero.{u2} M _inst_2) (fun (m : M) => _inst_3 m) f) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toZero.{u2} M _inst_2) (fun (m : M) => _inst_3 m) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.to_finsupp_add Dfinsupp.toFinsupp_addₓ'. -/
@[simp]
theorem toFinsupp_add [AddZeroClass M] [∀ m : M, Decidable (m ≠ 0)] (f g : Π₀ i : ι, M) :
    (toFinsupp (f + g) : ι →₀ M) = toFinsupp f + toFinsupp g :=
  Finsupp.coeFn_injective <| Dfinsupp.coe_add _ _
#align dfinsupp.to_finsupp_add Dfinsupp.toFinsupp_add

/- warning: dfinsupp.to_finsupp_neg -> Dfinsupp.toFinsupp_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddGroup.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => M) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => M) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => M) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => M) i) _inst_2))))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Dfinsupp.hasNeg.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)) f)) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Finsupp.hasNeg.{u1, u2} ι M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) f))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddGroup.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => M) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => M) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => M) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => M) i) _inst_2))))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2))))) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) (Neg.neg.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (_i : ι) => M) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (_i : ι) => M) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (_i : ι) => M) i) _inst_2))))) (Dfinsupp.instNegDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2)) f)) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2))))) (Finsupp.instNegFinsuppToZero.{u1, u2} ι M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.to_finsupp_neg Dfinsupp.toFinsupp_negₓ'. -/
@[simp]
theorem toFinsupp_neg [AddGroup M] [∀ m : M, Decidable (m ≠ 0)] (f : Π₀ i : ι, M) :
    (toFinsupp (-f) : ι →₀ M) = -toFinsupp f :=
  Finsupp.coeFn_injective <| Dfinsupp.coe_neg _
#align dfinsupp.to_finsupp_neg Dfinsupp.toFinsupp_neg

/- warning: dfinsupp.to_finsupp_sub -> Dfinsupp.toFinsupp_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddGroup.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => M) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => M) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => M) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => M) i) _inst_2))))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => M) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => M) i) (SubNegMonoid.toAddMonoid.{u2} ((fun (i : ι) => M) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => M) i) _inst_2))))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Dfinsupp.hasSub.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2))))) (Finsupp.hasSub.{u1, u2} ι M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) f) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) g))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddGroup.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))))))] (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => M) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => M) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => M) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => M) i) _inst_2))))) (g : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (i : ι) => M) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (i : ι) => M) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (i : ι) => M) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (i : ι) => M) i) _inst_2))))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2))))) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (_i : ι) => M) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (_i : ι) => M) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (_i : ι) => M) i) _inst_2))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (_i : ι) => M) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (_i : ι) => M) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (_i : ι) => M) i) _inst_2))))) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (_i : ι) => M) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (_i : ι) => M) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (_i : ι) => M) i) _inst_2))))) (instHSub.{max u1 u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => NegZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (_i : ι) => M) i) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (_i : ι) => M) i) (AddGroup.toSubtractionMonoid.{u2} ((fun (_i : ι) => M) i) _inst_2))))) (Dfinsupp.instSubDfinsuppToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoid.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2))) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2))))) (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2))))) (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} ι M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u1, u2} ι M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) f) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (AddGroup.toSubtractionMonoid.{u2} M _inst_2)))) (fun (m : M) => _inst_3 m) g))
Case conversion may be inaccurate. Consider using '#align dfinsupp.to_finsupp_sub Dfinsupp.toFinsupp_subₓ'. -/
@[simp]
theorem toFinsupp_sub [AddGroup M] [∀ m : M, Decidable (m ≠ 0)] (f g : Π₀ i : ι, M) :
    (toFinsupp (f - g) : ι →₀ M) = toFinsupp f - toFinsupp g :=
  Finsupp.coeFn_injective <| Dfinsupp.coe_sub _ _
#align dfinsupp.to_finsupp_sub Dfinsupp.toFinsupp_sub

/- warning: dfinsupp.to_finsupp_smul -> Dfinsupp.toFinsupp_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Monoid.{u2} R] [_inst_3 : AddMonoid.{u3} M] [_inst_4 : DistribMulAction.{u2, u3} R M _inst_2 _inst_3] [_inst_5 : forall (m : M), Decidable (Ne.{succ u3} M m (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_3))))))] (r : R) (f : Dfinsupp.{u1, u3} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => M) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => M) i) _inst_3))), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_3))) (Dfinsupp.toFinsupp.{u1, u3} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_3)) (fun (m : M) => _inst_5 m) (SMul.smul.{u2, max u1 u3} R (Dfinsupp.{u1, u3} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_3))) (Dfinsupp.hasSmul.{u1, u3, u2} ι R (fun (i : ι) => M) _inst_2 (fun (i : ι) => _inst_3) (fun (i : ι) => _inst_4)) r f)) (SMul.smul.{u2, max u1 u3} R (Finsupp.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_3))) (SMulZeroClass.toHasSmul.{u2, max u1 u3} R (Finsupp.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_3))) (Finsupp.hasZero.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_3))) (Finsupp.smulZeroClass.{u1, u3, u2} ι M R (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_3)) (DistribSMul.toSmulZeroClass.{u2, u3} R M (AddMonoid.toAddZeroClass.{u3} M _inst_3) (DistribMulAction.toDistribSMul.{u2, u3} R M _inst_2 _inst_3 _inst_4)))) r (Dfinsupp.toFinsupp.{u1, u3} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M _inst_3)) (fun (m : M) => _inst_5 m) f))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Monoid.{u3} R] [_inst_3 : AddMonoid.{u2} M] [_inst_4 : DistribMulAction.{u3, u2} R M _inst_2 _inst_3] [_inst_5 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M _inst_3))))] (r : R) (f : Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => M) i) _inst_3)), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_3)) (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddMonoid.toZero.{u2} M _inst_3) (fun (m : M) => _inst_5 m) (HSMul.hSMul.{u3, max u1 u2, max u1 u2} R (Dfinsupp.{u1, u2} ι (fun (_i : ι) => M) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (_i : ι) => M) i) _inst_3)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (_i : ι) => M) i) _inst_3)) (instHSMul.{u3, max u1 u2} R (Dfinsupp.{u1, u2} ι (fun (_i : ι) => M) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (_i : ι) => M) i) _inst_3)) (Dfinsupp.instSMulDfinsuppToZero.{u1, u2, u3} ι R (fun (_i : ι) => M) _inst_2 (fun (i : ι) => _inst_3) (fun (i : ι) => _inst_4))) r f)) (HSMul.hSMul.{u3, max u2 u1, max u1 u2} R (Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_3)) (Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_3)) (instHSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_3)) (SMulZeroClass.toSMul.{u3, max u1 u2} R (Finsupp.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_3)) (Finsupp.zero.{u1, u2} ι M (AddMonoid.toZero.{u2} M _inst_3)) (Finsupp.instSMulZeroClassFinsuppZero.{u1, u2, u3} ι M R (AddMonoid.toZero.{u2} M _inst_3) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M _inst_3) (DistribMulAction.toDistribSMul.{u3, u2} R M _inst_2 _inst_3 _inst_4))))) r (Dfinsupp.toFinsupp.{u1, u2} ι M (fun (a : ι) (b : ι) => _inst_1 a b) (AddMonoid.toZero.{u2} M _inst_3) (fun (m : M) => _inst_5 m) f))
Case conversion may be inaccurate. Consider using '#align dfinsupp.to_finsupp_smul Dfinsupp.toFinsupp_smulₓ'. -/
@[simp]
theorem toFinsupp_smul [Monoid R] [AddMonoid M] [DistribMulAction R M] [∀ m : M, Decidable (m ≠ 0)]
    (r : R) (f : Π₀ i : ι, M) : (toFinsupp (r • f) : ι →₀ M) = r • toFinsupp f :=
  Finsupp.coeFn_injective <| Dfinsupp.coe_smul _ _
#align dfinsupp.to_finsupp_smul Dfinsupp.toFinsupp_smul

end Dfinsupp

end Lemmas

/-! ### Bundled `equiv`s -/


section Equivs

#print finsuppEquivDfinsupp /-
/-- `finsupp.to_dfinsupp` and `dfinsupp.to_finsupp` together form an equiv. -/
@[simps (config := { fullyApplied := false })]
def finsuppEquivDfinsupp [DecidableEq ι] [Zero M] [∀ m : M, Decidable (m ≠ 0)] :
    (ι →₀ M) ≃ Π₀ i : ι, M where
  toFun := Finsupp.toDfinsupp
  invFun := Dfinsupp.toFinsupp
  left_inv := Finsupp.toDfinsupp_toFinsupp
  right_inv := Dfinsupp.toFinsupp_toDfinsupp
#align finsupp_equiv_dfinsupp finsuppEquivDfinsupp
-/

/- warning: finsupp_add_equiv_dfinsupp -> finsuppAddEquivDfinsupp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddZeroClass.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M _inst_2)))))], AddEquiv.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι M (AddZeroClass.toHasZero.{u2} M _inst_2)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u2} M _inst_2)) (Finsupp.hasAdd.{u1, u2} ι M _inst_2) (Dfinsupp.hasAdd.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddZeroClass.{u2} M] [_inst_3 : forall (m : M), Decidable (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddZeroClass.toZero.{u2} M _inst_2))))], AddEquiv.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} ι M (AddZeroClass.toZero.{u2} M _inst_2)) (Dfinsupp.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toZero.{u2} ((fun (_i : ι) => M) i) _inst_2)) (Finsupp.add.{u1, u2} ι M _inst_2) (Dfinsupp.instAddDfinsuppToZero.{u1, u2} ι (fun (i : ι) => M) (fun (i : ι) => _inst_2))
Case conversion may be inaccurate. Consider using '#align finsupp_add_equiv_dfinsupp finsuppAddEquivDfinsuppₓ'. -/
/-- The additive version of `finsupp.to_finsupp`. Note that this is `noncomputable` because
`finsupp.has_add` is noncomputable. -/
@[simps (config := { fullyApplied := false })]
def finsuppAddEquivDfinsupp [DecidableEq ι] [AddZeroClass M] [∀ m : M, Decidable (m ≠ 0)] :
    (ι →₀ M) ≃+ Π₀ i : ι, M :=
  { finsuppEquivDfinsupp with
    toFun := Finsupp.toDfinsupp
    invFun := Dfinsupp.toFinsupp
    map_add' := Finsupp.toDfinsupp_add }
#align finsupp_add_equiv_dfinsupp finsuppAddEquivDfinsupp

variable (R)

/- warning: finsupp_lequiv_dfinsupp -> finsuppLequivDfinsupp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (R : Type.{u2}) {M : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : forall (m : M), Decidable (Ne.{succ u3} M m (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))))))] [_inst_5 : Module.{u2, u3} R M _inst_2 _inst_3], LinearEquiv.{u2, u2, max u1 u3, max u1 u3} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (Finsupp.{u1, u3} ι M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => M) (fun (i : ι) => AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u3} ι M _inst_3) (Dfinsupp.addCommMonoid.{u1, u3} ι (fun (i : ι) => M) (fun (i : ι) => _inst_3)) (Finsupp.module.{u1, u3, u2} ι M R _inst_2 _inst_3 _inst_5) (Dfinsupp.module.{u1, u3, u2} ι R (fun (i : ι) => M) _inst_2 (fun (i : ι) => _inst_3) (fun (i : ι) => _inst_5))
but is expected to have type
  forall {ι : Type.{u1}} (R : Type.{u2}) {M : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : forall (m : M), Decidable (Ne.{succ u3} M m (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)))))] [_inst_5 : Module.{u2, u3} R M _inst_2 _inst_3], LinearEquiv.{u2, u2, max u3 u1, max u3 u1} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (Finsupp.{u1, u3} ι M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Dfinsupp.{u1, u3} ι (fun (i : ι) => M) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (_i : ι) => M) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (_i : ι) => M) i) _inst_3))) (Finsupp.addCommMonoid.{u1, u3} ι M _inst_3) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u3} ι (fun (i : ι) => M) (fun (i : ι) => _inst_3)) (Finsupp.instModuleFinsuppToZeroToAddMonoidAddCommMonoid.{u1, u3, u2} ι M R _inst_2 _inst_3 _inst_5) (Dfinsupp.instModuleDfinsuppToZeroToAddMonoidInstAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, u3, u2} ι R (fun (i : ι) => M) _inst_2 (fun (i : ι) => _inst_3) (fun (i : ι) => _inst_5))
Case conversion may be inaccurate. Consider using '#align finsupp_lequiv_dfinsupp finsuppLequivDfinsuppₓ'. -/
/-- The additive version of `finsupp.to_finsupp`. Note that this is `noncomputable` because
`finsupp.has_add` is noncomputable. -/
@[simps (config := { fullyApplied := false })]
def finsuppLequivDfinsupp [DecidableEq ι] [Semiring R] [AddCommMonoid M]
    [∀ m : M, Decidable (m ≠ 0)] [Module R M] : (ι →₀ M) ≃ₗ[R] Π₀ i : ι, M :=
  { finsuppEquivDfinsupp with
    toFun := Finsupp.toDfinsupp
    invFun := Dfinsupp.toFinsupp
    map_smul' := Finsupp.toDfinsupp_smul
    map_add' := Finsupp.toDfinsupp_add }
#align finsupp_lequiv_dfinsupp finsuppLequivDfinsupp

section Sigma

/-! ### Stronger versions of `finsupp.split` -/
noncomputable section

variable {η : ι → Type _} {N : Type _} [Semiring R]

open Finsupp

#print sigmaFinsuppEquivDfinsupp /-
/-- `finsupp.split` is an equivalence between `(Σ i, η i) →₀ N` and `Π₀ i, (η i →₀ N)`. -/
def sigmaFinsuppEquivDfinsupp [Zero N] : ((Σi, η i) →₀ N) ≃ Π₀ i, η i →₀ N
    where
  toFun f :=
    ⟨split f,
      Trunc.mk
        ⟨(splitSupport f : Finset ι).val, fun i =>
          by
          rw [← Finset.mem_def, mem_split_support_iff_nonzero]
          exact (em _).symm⟩⟩
  invFun f := by
    haveI := Classical.decEq ι
    haveI := fun i => Classical.decEq (η i →₀ N)
    refine'
      on_finset (Finset.sigma f.support fun j => (f j).support) (fun ji => f ji.1 ji.2) fun g hg =>
        finset.mem_sigma.mpr ⟨_, mem_support_iff.mpr hg⟩
    simp only [Ne.def, Dfinsupp.mem_support_toFun]
    intro h
    rw [h] at hg
    simpa using hg
  left_inv f := by
    ext
    simp [split]
  right_inv f := by
    ext
    simp [split]
#align sigma_finsupp_equiv_dfinsupp sigmaFinsuppEquivDfinsupp
-/

/- warning: sigma_finsupp_equiv_dfinsupp_apply -> sigmaFinsuppEquivDfinsupp_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} [_inst_2 : Zero.{u3} N] (f : Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2), Eq.{max (succ u1) (succ u2) (succ u3)} ((fun (_x : Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) => forall (i : ι), Finsupp.{u2, u3} (η i) N _inst_2) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))) (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2))) => (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) -> (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N _inst_2) f)) (coeFn.{succ (max u1 u2 u3), max (succ u1) (succ (max u2 u3))} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) (fun (_x : Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) => forall (i : ι), Finsupp.{u2, u3} (η i) N _inst_2) (Dfinsupp.hasCoeToFun.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))) (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2))) => (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) -> (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N _inst_2) f)) (Finsupp.split.{u1, u3, u2} ι N (fun (i : ι) => η i) _inst_2 f)
but is expected to have type
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} [_inst_2 : Zero.{u3} N] (f : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2), Eq.{max (max (succ u1) (succ u2)) (succ u3)} (forall (a : ι), (fun (i : ι) => (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) i) a) (FunLike.coe.{max (succ u1) (succ (max u2 u3)), succ u1, succ (max u2 u3)} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) i) (fun (i : ι) => (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N _inst_2) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) i) _x) (Dfinsupp.funLike.{u1, max u2 u3} ι (fun (i : ι) => (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) i) (fun (i : ι) => (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N _inst_2) i)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Equiv.{max (succ u3) (succ (max u2 u1)), max (succ (max u3 u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N _inst_2))) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (fun (_x : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N _inst_2)) _x) (Equiv.instFunLikeEquiv.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N _inst_2))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N _inst_2) f)) (Finsupp.split.{u1, u3, u2} ι N (fun (i : ι) => η i) _inst_2 f)
Case conversion may be inaccurate. Consider using '#align sigma_finsupp_equiv_dfinsupp_apply sigmaFinsuppEquivDfinsupp_applyₓ'. -/
@[simp]
theorem sigmaFinsuppEquivDfinsupp_apply [Zero N] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDfinsupp f : ∀ i, η i →₀ N) = Finsupp.split f :=
  rfl
#align sigma_finsupp_equiv_dfinsupp_apply sigmaFinsuppEquivDfinsupp_apply

/- warning: sigma_finsupp_equiv_dfinsupp_symm_apply -> sigmaFinsuppEquivDfinsupp_symm_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} [_inst_2 : Zero.{u3} N] (f : Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) (s : Sigma.{u1, u2} ι (fun (i : ι) => η i)), Eq.{succ u3} N (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (fun (_x : Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) => (Sigma.{u1, u2} ι (fun (i : ι) => η i)) -> N) (Finsupp.hasCoeToFun.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (coeFn.{max 1 (max (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3)) (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3)), max (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3)} (Equiv.{succ (max u1 u2 u3), max (succ (max u1 u2)) (succ u3)} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2)) (fun (_x : Equiv.{succ (max u1 u2 u3), max (succ (max u1 u2)) (succ u3)} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2)) => (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) -> (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2)) (Equiv.hasCoeToFun.{succ (max u1 u2 u3), max (succ (max u1 u2)) (succ u3)} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2)) (Equiv.symm.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N _inst_2)) f) s) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} (η (Sigma.fst.{u1, u2} ι (fun (i : ι) => η i) s)) N _inst_2) (fun (_x : Finsupp.{u2, u3} (η (Sigma.fst.{u1, u2} ι (fun (i : ι) => η i) s)) N _inst_2) => (η (Sigma.fst.{u1, u2} ι (fun (i : ι) => η i) s)) -> N) (Finsupp.hasCoeToFun.{u2, u3} (η (Sigma.fst.{u1, u2} ι (fun (i : ι) => η i) s)) N _inst_2) (coeFn.{succ (max u1 u2 u3), max (succ u1) (succ (max u2 u3))} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) (fun (_x : Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) => forall (i : ι), Finsupp.{u2, u3} (η i) N _inst_2) (Dfinsupp.hasCoeToFun.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_2)) f (Sigma.fst.{u1, u2} ι (fun (i : ι) => η i) s)) (Sigma.snd.{u1, u2} ι (fun (i : ι) => η i) s))
but is expected to have type
  forall {ι : Type.{u2}} {η : ι -> Type.{u1}} {N : Type.{u3}} [_inst_2 : Zero.{u3} N] (f : Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u1, u3} (η i) N _inst_2)) (s : Sigma.{u2, u1} ι (fun (i : ι) => η i)), Eq.{succ u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sigma.{u2, u1} ι (fun (i : ι) => η i)) => N) s) (FunLike.coe.{max (succ (max u2 u1)) (succ u3), succ (max u2 u1), succ u3} (Finsupp.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => η i)) N _inst_2) (Sigma.{u2, u1} ι (fun (i : ι) => η i)) (fun (_x : Sigma.{u2, u1} ι (fun (i : ι) => η i)) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sigma.{u2, u1} ι (fun (i : ι) => η i)) => N) _x) (Finsupp.funLike.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => η i)) N _inst_2) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (max (succ u3) (succ u1)) (succ u2), max (max (succ u3) (succ u1)) (succ u2)} (Equiv.{max (max (succ u3) (succ u1)) (succ u2), max (max (succ u3) (succ u1)) (succ u2)} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u1, u3} (η i) N _inst_2)) (Finsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => η i)) N _inst_2)) (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u1, u3} (η i) N _inst_2)) (fun (_x : Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u1, u3} (η i) N _inst_2)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u1, u3} (η i) N _inst_2)) => Finsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => η i)) N _inst_2) _x) (Equiv.instFunLikeEquiv.{max (max (succ u3) (succ u1)) (succ u2), max (max (succ u3) (succ u1)) (succ u2)} (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u1, u3} (η i) N _inst_2)) (Finsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => η i)) N _inst_2)) (Equiv.symm.{max (max (succ u3) (succ u1)) (succ u2), max (max (succ u3) (succ u1)) (succ u2)} (Finsupp.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.{u2, max u3 u1} ι (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) (fun (i : ι) => Finsupp.zero.{u1, u3} (η i) N _inst_2)) (sigmaFinsuppEquivDfinsupp.{u2, u1, u3} ι (fun (i : ι) => η i) N _inst_2)) f) s) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} (η (Sigma.fst.{u2, u1} ι (fun (i : ι) => η i) s)) N _inst_2) (η (Sigma.fst.{u2, u1} ι (fun (i : ι) => η i) s)) (fun (_x : η (Sigma.fst.{u2, u1} ι (fun (i : ι) => η i) s)) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : η (Sigma.fst.{u2, u1} ι (fun (i : ι) => η i) s)) => N) _x) (Finsupp.funLike.{u1, u3} (η (Sigma.fst.{u2, u1} ι (fun (i : ι) => η i) s)) N _inst_2) (FunLike.coe.{max (succ u2) (succ (max u1 u3)), succ u2, succ (max u1 u3)} (Dfinsupp.{u2, max u1 u3} ι (fun (i : ι) => (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) i) (fun (i : ι) => (fun (i : ι) => Finsupp.zero.{u1, u3} (η i) N _inst_2) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) i) _x) (Dfinsupp.funLike.{u2, max u1 u3} ι (fun (i : ι) => (fun (i : ι) => Finsupp.{u1, u3} (η i) N _inst_2) i) (fun (i : ι) => (fun (i : ι) => Finsupp.zero.{u1, u3} (η i) N _inst_2) i)) f (Sigma.fst.{u2, u1} ι (fun (i : ι) => η i) s)) (Sigma.snd.{u2, u1} ι (fun (i : ι) => η i) s))
Case conversion may be inaccurate. Consider using '#align sigma_finsupp_equiv_dfinsupp_symm_apply sigmaFinsuppEquivDfinsupp_symm_applyₓ'. -/
@[simp]
theorem sigmaFinsuppEquivDfinsupp_symm_apply [Zero N] (f : Π₀ i, η i →₀ N) (s : Σi, η i) :
    (sigmaFinsuppEquivDfinsupp.symm f : (Σi, η i) →₀ N) s = f s.1 s.2 :=
  rfl
#align sigma_finsupp_equiv_dfinsupp_symm_apply sigmaFinsuppEquivDfinsupp_symm_apply

/- warning: sigma_finsupp_equiv_dfinsupp_support -> sigmaFinsuppEquivDfinsupp_support is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : Zero.{u3} N] [_inst_4 : forall (i : ι) (x : Finsupp.{u2, u3} (η i) N _inst_3), Decidable (Ne.{max (succ u2) (succ u3)} (Finsupp.{u2, u3} (η i) N _inst_3) x (OfNat.ofNat.{max u2 u3} (Finsupp.{u2, u3} (η i) N _inst_3) 0 (OfNat.mk.{max u2 u3} (Finsupp.{u2, u3} (η i) N _inst_3) 0 (Zero.zero.{max u2 u3} (Finsupp.{u2, u3} (η i) N _inst_3) (Finsupp.hasZero.{u2, u3} (η i) N _inst_3)))))] (f : Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3), Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3) (fun (i : ι) (x : Finsupp.{u2, u3} (η i) N _inst_3) => _inst_4 i x) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))) (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3))) => (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3) -> (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N _inst_3) f)) (Finsupp.splitSupport.{u1, u3, u2} ι N (fun (i : ι) => η i) _inst_3 f)
but is expected to have type
  forall {ι : Type.{u3}} {η : ι -> Type.{u1}} {N : Type.{u2}} [_inst_2 : DecidableEq.{succ u3} ι] [_inst_3 : Zero.{u2} N] [_inst_4 : forall (i : ι) (x : Finsupp.{u1, u2} (η i) N _inst_3), Decidable (Ne.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} (η i) N _inst_3) x (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} (η i) N _inst_3) 0 (Zero.toOfNat0.{max u1 u2} (Finsupp.{u1, u2} (η i) N _inst_3) (Finsupp.zero.{u1, u2} (η i) N _inst_3))))] (f : Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3), Eq.{succ u3} (Finset.{u3} ι) (Dfinsupp.support.{u3, max u1 u2} ι (fun (i : ι) => Finsupp.{u1, u2} (η i) N _inst_3) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => Finsupp.zero.{u1, u2} (η i) N _inst_3) (fun (i : ι) (x : Finsupp.{u1, u2} (η i) N _inst_3) => _inst_4 i x) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), max (max (succ u2) (succ u1)) (succ u3), max (max (succ u2) (succ u1)) (succ u3)} (Equiv.{max (succ u2) (succ (max u1 u3)), max (succ (max u2 u1)) (succ u3)} (Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u3, max u2 u1} ι (fun (i : ι) => Finsupp.{u1, u2} (η i) N _inst_3) (fun (i : ι) => Finsupp.zero.{u1, u2} (η i) N _inst_3))) (Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) (fun (_x : Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) => Dfinsupp.{u3, max u2 u1} ι (fun (i : ι) => Finsupp.{u1, u2} (η i) N _inst_3) (fun (i : ι) => Finsupp.zero.{u1, u2} (η i) N _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (max (succ u2) (succ u1)) (succ u3), max (max (succ u2) (succ u1)) (succ u3)} (Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u3, max u2 u1} ι (fun (i : ι) => Finsupp.{u1, u2} (η i) N _inst_3) (fun (i : ι) => Finsupp.zero.{u1, u2} (η i) N _inst_3))) (sigmaFinsuppEquivDfinsupp.{u3, u1, u2} ι (fun (i : ι) => η i) N _inst_3) f)) (Finsupp.splitSupport.{u3, u2, u1} ι N (fun (i : ι) => η i) _inst_3 f)
Case conversion may be inaccurate. Consider using '#align sigma_finsupp_equiv_dfinsupp_support sigmaFinsuppEquivDfinsupp_supportₓ'. -/
@[simp]
theorem sigmaFinsuppEquivDfinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDfinsupp f).support = Finsupp.splitSupport f :=
  by
  ext
  rw [Dfinsupp.mem_support_toFun]
  exact (Finsupp.mem_splitSupport_iff_nonzero _ _).symm
#align sigma_finsupp_equiv_dfinsupp_support sigmaFinsuppEquivDfinsupp_support

/- warning: sigma_finsupp_equiv_dfinsupp_single -> sigmaFinsuppEquivDfinsupp_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} [_inst_2 : DecidableEq.{succ u1} ι] [_inst_3 : Zero.{u3} N] (a : Sigma.{u1, u2} ι (fun (i : ι) => η i)) (n : N), Eq.{succ (max u1 u2 u3)} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3)) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))) (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3))) => (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3) -> (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N _inst_3) (Finsupp.single.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3 a n)) (Dfinsupp.single.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N _inst_3) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N _inst_3) (Sigma.fst.{u1, u2} ι (fun (i : ι) => η i) a) (Finsupp.single.{u2, u3} (η (Sigma.fst.{u1, u2} ι (fun (i : ι) => η i) a)) N _inst_3 (Sigma.snd.{u1, u2} ι (fun (i : ι) => η i) a) n))
but is expected to have type
  forall {ι : Type.{u3}} {η : ι -> Type.{u1}} {N : Type.{u2}} [_inst_2 : DecidableEq.{succ u3} ι] [_inst_3 : Zero.{u2} N] (a : Sigma.{u3, u1} ι (fun (i : ι) => η i)) (n : N), Eq.{max (max (succ u3) (succ u1)) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) => Dfinsupp.{u3, max u2 u1} ι (fun (i : ι) => Finsupp.{u1, u2} (η i) N _inst_3) (fun (i : ι) => Finsupp.zero.{u1, u2} (η i) N _inst_3)) (Finsupp.single.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3 a n)) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), max (max (succ u2) (succ u1)) (succ u3), max (max (succ u2) (succ u1)) (succ u3)} (Equiv.{max (succ u2) (succ (max u1 u3)), max (succ (max u2 u1)) (succ u3)} (Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u3, max u2 u1} ι (fun (i : ι) => Finsupp.{u1, u2} (η i) N _inst_3) (fun (i : ι) => Finsupp.zero.{u1, u2} (η i) N _inst_3))) (Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) (fun (_x : Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) => Dfinsupp.{u3, max u2 u1} ι (fun (i : ι) => Finsupp.{u1, u2} (η i) N _inst_3) (fun (i : ι) => Finsupp.zero.{u1, u2} (η i) N _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (max (succ u2) (succ u1)) (succ u3), max (max (succ u2) (succ u1)) (succ u3)} (Finsupp.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3) (Dfinsupp.{u3, max u2 u1} ι (fun (i : ι) => Finsupp.{u1, u2} (η i) N _inst_3) (fun (i : ι) => Finsupp.zero.{u1, u2} (η i) N _inst_3))) (sigmaFinsuppEquivDfinsupp.{u3, u1, u2} ι (fun (i : ι) => η i) N _inst_3) (Finsupp.single.{max u1 u3, u2} (Sigma.{u3, u1} ι (fun (i : ι) => η i)) N _inst_3 a n)) (Dfinsupp.single.{u3, max u2 u1} ι (fun (i : ι) => Finsupp.{u1, u2} (η i) N _inst_3) (fun (a : ι) (b : ι) => _inst_2 a b) (fun (i : ι) => Finsupp.zero.{u1, u2} (η i) N _inst_3) (Sigma.fst.{u3, u1} ι (fun (i : ι) => η i) a) (Finsupp.single.{u1, u2} (η (Sigma.fst.{u3, u1} ι (fun (i : ι) => η i) a)) N _inst_3 (Sigma.snd.{u3, u1} ι (fun (i : ι) => η i) a) n))
Case conversion may be inaccurate. Consider using '#align sigma_finsupp_equiv_dfinsupp_single sigmaFinsuppEquivDfinsupp_singleₓ'. -/
@[simp]
theorem sigmaFinsuppEquivDfinsupp_single [DecidableEq ι] [Zero N] (a : Σi, η i) (n : N) :
    sigmaFinsuppEquivDfinsupp (Finsupp.single a n) =
      @Dfinsupp.single _ (fun i => η i →₀ N) _ _ a.1 (Finsupp.single a.2 n) :=
  by
  obtain ⟨i, a⟩ := a
  ext (j b)
  by_cases h : i = j
  · subst h
    classical simp [split_apply, Finsupp.single_apply]
  suffices Finsupp.single (⟨i, a⟩ : Σi, η i) n ⟨j, b⟩ = 0 by simp [split_apply, dif_neg h, this]
  have H : (⟨i, a⟩ : Σi, η i) ≠ ⟨j, b⟩ := by simp [h]
  classical rw [Finsupp.single_apply, if_neg H]
#align sigma_finsupp_equiv_dfinsupp_single sigmaFinsuppEquivDfinsupp_single

-- Without this Lean fails to find the `add_zero_class` instance on `Π₀ i, (η i →₀ N)`.
attribute [-instance] Finsupp.hasZero

/- warning: sigma_finsupp_equiv_dfinsupp_add -> sigmaFinsuppEquivDfinsupp_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} [_inst_2 : AddZeroClass.{u3} N] (f : Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (g : Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)), Eq.{succ (max u1 u2 u3)} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2))) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))) (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) => (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) -> (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (HAdd.hAdd.{max (max u1 u2) u3, max (max u1 u2) u3, max (max u1 u2) u3} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (instHAdd.{max (max u1 u2) u3} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Finsupp.hasAdd.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2)) f g)) (HAdd.hAdd.{max u1 u2 u3, max u1 u2 u3, max u1 u2 u3} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => AddZeroClass.toHasZero.{max u2 u3} ((fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) i) (Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => AddZeroClass.toHasZero.{max u2 u3} ((fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) i) (Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => AddZeroClass.toHasZero.{max u2 u3} ((fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) i) (Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))) (instHAdd.{max u1 u2 u3} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => AddZeroClass.toHasZero.{max u2 u3} ((fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) i) (Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))) (Dfinsupp.hasAdd.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))) (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) => (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) -> (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) f) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))) (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) => (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) -> (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) g))
but is expected to have type
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} [_inst_2 : AddZeroClass.{u3} N] (f : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (g : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)), Eq.{max (max (succ u1) (succ u2)) (succ u3)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2))) (HAdd.hAdd.{max (max u1 u2) u3, max (max u1 u2) u3, max (max u1 u2) u3} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (instHAdd.{max (max u1 u2) u3} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Finsupp.add.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2)) f g)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Equiv.{max (succ u3) (succ (max u2 u1)), max (succ (max u3 u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)))) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (_x : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2))) _x) (Equiv.instFunLikeEquiv.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (HAdd.hAdd.{max (max u1 u2) u3, max (max u1 u2) u3, max (max u1 u2) u3} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (instHAdd.{max (max u1 u2) u3} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Finsupp.add.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2)) f g)) (HAdd.hAdd.{max (max u1 u2) u3, max (max u1 u2) u3, max (max u1 u2) u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2))) f) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2))) g) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2))) f) (instHAdd.{max (max u1 u2) u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2))) f) (Dfinsupp.instAddDfinsuppToZero.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Equiv.{max (succ u3) (succ (max u2 u1)), max (succ (max u3 u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)))) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (_x : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2))) _x) (Equiv.instFunLikeEquiv.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddZeroClass.toZero.{u3} N _inst_2)) f) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Equiv.{max (succ u3) (succ (max u2 u1)), max (succ (max u3 u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)))) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (_x : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2))) _x) (Equiv.instFunLikeEquiv.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddZeroClass.toZero.{u3} N _inst_2)) g))
Case conversion may be inaccurate. Consider using '#align sigma_finsupp_equiv_dfinsupp_add sigmaFinsuppEquivDfinsupp_addₓ'. -/
@[simp]
theorem sigmaFinsuppEquivDfinsupp_add [AddZeroClass N] (f g : (Σi, η i) →₀ N) :
    sigmaFinsuppEquivDfinsupp (f + g) =
      (sigmaFinsuppEquivDfinsupp f + sigmaFinsuppEquivDfinsupp g : Π₀ i : ι, η i →₀ N) :=
  by
  ext
  rfl
#align sigma_finsupp_equiv_dfinsupp_add sigmaFinsuppEquivDfinsupp_add

/- warning: sigma_finsupp_add_equiv_dfinsupp -> sigmaFinsuppAddEquivDfinsupp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} [_inst_2 : AddZeroClass.{u3} N], AddEquiv.{max (max u1 u2) u3, max u1 u2 u3} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => AddZeroClass.toHasZero.{max u2 u3} (Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))) (Finsupp.hasAdd.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.hasAdd.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))
but is expected to have type
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} [_inst_2 : AddZeroClass.{u3} N], AddEquiv.{max u3 u2 u1, max (max u3 u2) u1} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toZero.{u3} N _inst_2)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => AddZeroClass.toZero.{max u2 u3} ((fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) i) (Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))) (Finsupp.add.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.instAddDfinsuppToZero.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toZero.{u3} N _inst_2)) (fun (i : ι) => Finsupp.addZeroClass.{u2, u3} (η i) N _inst_2))
Case conversion may be inaccurate. Consider using '#align sigma_finsupp_add_equiv_dfinsupp sigmaFinsuppAddEquivDfinsuppₓ'. -/
/-- `finsupp.split` is an additive equivalence between `(Σ i, η i) →₀ N` and `Π₀ i, (η i →₀ N)`. -/
@[simps]
def sigmaFinsuppAddEquivDfinsupp [AddZeroClass N] : ((Σi, η i) →₀ N) ≃+ Π₀ i, η i →₀ N :=
  { sigmaFinsuppEquivDfinsupp with
    toFun := sigmaFinsuppEquivDfinsupp
    invFun := sigmaFinsuppEquivDfinsupp.symm
    map_add' := sigmaFinsuppEquivDfinsupp_add }
#align sigma_finsupp_add_equiv_dfinsupp sigmaFinsuppAddEquivDfinsupp

attribute [-instance] Finsupp.addZeroClass

/- warning: sigma_finsupp_equiv_dfinsupp_smul -> sigmaFinsuppEquivDfinsupp_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_2 : Monoid.{u4} R] [_inst_3 : AddMonoid.{u3} N] [_inst_4 : DistribMulAction.{u4, u3} R N _inst_2 _inst_3] (r : R) (f : Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))), Eq.{succ (max u1 u2 u3)} (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3)))) (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))) (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))))) => (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) -> (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (SMul.smul.{u4, max (max u1 u2) u3} R (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (SMulZeroClass.toHasSmul.{u4, max (max u1 u2) u3} R (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Finsupp.hasZero.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Finsupp.smulZeroClass.{max u1 u2, u3, u4} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N R (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3)) (DistribSMul.toSmulZeroClass.{u4, u3} R N (AddMonoid.toAddZeroClass.{u3} N _inst_3) (DistribMulAction.toDistribSMul.{u4, u3} R N _inst_2 _inst_3 _inst_4)))) r f)) (SMul.smul.{u4, max u1 u2 u3} R (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => AddZeroClass.toHasZero.{max u2 u3} (Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u3} (Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Finsupp.addMonoid.{u2, u3} (η i) N _inst_3)))) (MulAction.toHasSmul.{u4, max u1 u2 u3} R (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => AddZeroClass.toHasZero.{max u2 u3} (Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u3} (Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Finsupp.addMonoid.{u2, u3} (η i) N _inst_3)))) _inst_2 (DistribMulAction.toMulAction.{u4, max u1 u2 u3} R (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => AddZeroClass.toHasZero.{max u2 u3} (Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u3} (Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Finsupp.addMonoid.{u2, u3} (η i) N _inst_3)))) _inst_2 (Dfinsupp.addMonoid.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.addMonoid.{u2, u3} (η i) N _inst_3)) (Dfinsupp.distribMulAction.{u1, max u2 u3, u4} ι R (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) _inst_2 (fun (i : ι) => Finsupp.addMonoid.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.distribMulAction.{u2, u3, u4} (η i) N R _inst_2 _inst_3 _inst_4)))) r (coeFn.{max 1 (max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))) (succ (max u1 u2 u3)) (succ (max u1 u2)) (succ u3), max (max (succ (max u1 u2)) (succ u3)) (succ (max u1 u2 u3))} (Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))))) (fun (_x : Equiv.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))))) => (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) -> (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))))) (Equiv.hasCoeToFun.{max (succ (max u1 u2)) (succ u3), succ (max u1 u2 u3)} (Finsupp.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (Dfinsupp.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) (fun (i : ι) => Finsupp.hasZero.{u2, u3} (η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N _inst_3))) f))
but is expected to have type
  forall {ι : Type.{u1}} {η : ι -> Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_2 : Monoid.{u4} R] [_inst_3 : AddMonoid.{u3} N] [_inst_4 : DistribMulAction.{u4, u3} R N _inst_2 _inst_3] (r : R) (f : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)), Eq.{max (max (succ u1) (succ u2)) (succ u3)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3))) (HSMul.hSMul.{u4, max (max u1 u2) u3, max (max u1 u2) u3} R (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (instHSMul.{u4, max (max u1 u2) u3} R (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (SMulZeroClass.toSMul.{u4, max (max u1 u2) u3} R (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (AddMonoid.toZero.{max (max u1 u2) u3} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (Finsupp.addMonoid.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3)) (Finsupp.instSMulZeroClassFinsuppZero.{max u1 u2, u3, u4} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N R (AddMonoid.toZero.{u3} N _inst_3) (DistribSMul.toSMulZeroClass.{u4, u3} R N (AddMonoid.toAddZeroClass.{u3} N _inst_3) (DistribMulAction.toDistribSMul.{u4, u3} R N _inst_2 _inst_3 _inst_4))))) r f)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Equiv.{max (succ u3) (succ (max u2 u1)), max (succ (max u3 u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)))) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (_x : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3))) _x) (Equiv.instFunLikeEquiv.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddMonoid.toZero.{u3} N _inst_3)) (HSMul.hSMul.{u4, max (max u1 u2) u3, max (max u1 u2) u3} R (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (instHSMul.{u4, max (max u1 u2) u3} R (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (SMulZeroClass.toSMul.{u4, max (max u1 u2) u3} R (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (AddMonoid.toZero.{max (max u1 u2) u3} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (Finsupp.addMonoid.{max u1 u2, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N _inst_3)) (Finsupp.instSMulZeroClassFinsuppZero.{max u1 u2, u3, u4} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N R (AddMonoid.toZero.{u3} N _inst_3) (DistribSMul.toSMulZeroClass.{u4, u3} R N (AddMonoid.toAddZeroClass.{u3} N _inst_3) (DistribMulAction.toDistribSMul.{u4, u3} R N _inst_2 _inst_3 _inst_4))))) r f)) (SMul.smul.{u4, max (max u3 u2) u1} R (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => AddMonoid.toZero.{max u2 u3} ((fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) i) (Finsupp.addMonoid.{u2, u3} (η i) N _inst_3))) (MulAction.toSMul.{u4, max (max u1 u2) u3} R (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => AddMonoid.toZero.{max u2 u3} ((fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) i) (Finsupp.addMonoid.{u2, u3} (η i) N _inst_3))) _inst_2 (DistribMulAction.toMulAction.{u4, max (max u1 u2) u3} R (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => AddMonoid.toZero.{max u2 u3} ((fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) i) (Finsupp.addMonoid.{u2, u3} (η i) N _inst_3))) _inst_2 (Dfinsupp.instAddMonoidDfinsuppToZero.{u1, max u2 u3} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => Finsupp.addMonoid.{u2, u3} (η i) N _inst_3)) (Dfinsupp.distribMulAction.{u1, max u2 u3, u4} ι R (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) _inst_2 (fun (i : ι) => Finsupp.addMonoid.{u2, u3} (η i) N _inst_3) (fun (i : ι) => Finsupp.distribMulAction.{u2, u3, u4} (η i) N R _inst_2 _inst_3 _inst_4)))) r (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Equiv.{max (succ u3) (succ (max u2 u1)), max (succ (max u3 u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)))) (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (_x : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) => Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3))) _x) (Equiv.instFunLikeEquiv.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Finsupp.{max u2 u1, u3} (Sigma.{u1, u2} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u3} N _inst_3)) (Dfinsupp.{u1, max u3 u2} ι (fun (i : ι) => Finsupp.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)) (fun (i : ι) => Finsupp.zero.{u2, u3} (η i) N (AddMonoid.toZero.{u3} N _inst_3)))) (sigmaFinsuppEquivDfinsupp.{u1, u2, u3} ι (fun (i : ι) => η i) N (AddMonoid.toZero.{u3} N _inst_3)) f))
Case conversion may be inaccurate. Consider using '#align sigma_finsupp_equiv_dfinsupp_smul sigmaFinsuppEquivDfinsupp_smulₓ'. -/
--tofix: r • (sigma_finsupp_equiv_dfinsupp f) doesn't work.
@[simp]
theorem sigmaFinsuppEquivDfinsupp_smul {R} [Monoid R] [AddMonoid N] [DistribMulAction R N] (r : R)
    (f : (Σi, η i) →₀ N) :
    sigmaFinsuppEquivDfinsupp (r • f) =
      @SMul.smul R (Π₀ i, η i →₀ N) MulAction.toHasSmul r (sigmaFinsuppEquivDfinsupp f) :=
  by
  ext
  rfl
#align sigma_finsupp_equiv_dfinsupp_smul sigmaFinsuppEquivDfinsupp_smul

attribute [-instance] Finsupp.addMonoid

/- warning: sigma_finsupp_lequiv_dfinsupp -> sigmaFinsuppLequivDfinsupp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (R : Type.{u2}) {η : ι -> Type.{u3}} {N : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u4} N] [_inst_3 : Module.{u2, u4} R N _inst_1 _inst_2], LinearEquiv.{u2, u2, max (max u1 u3) u4, max u1 u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u1 u3, u4} (Sigma.{u1, u3} ι (fun (i : ι) => η i)) N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (Dfinsupp.{u1, max u3 u4} ι (fun (i : ι) => Finsupp.{u3, u4} (η i) N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (fun (i : ι) => AddZeroClass.toHasZero.{max u3 u4} (Finsupp.{u3, u4} (η i) N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (AddMonoid.toAddZeroClass.{max u3 u4} (Finsupp.{u3, u4} (η i) N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (AddCommMonoid.toAddMonoid.{max u3 u4} (Finsupp.{u3, u4} (η i) N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (Finsupp.addCommMonoid.{u3, u4} (η i) N _inst_2))))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.addCommMonoid.{u1, max u3 u4} ι (fun (i : ι) => Finsupp.{u3, u4} (η i) N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) (fun (i : ι) => Finsupp.addCommMonoid.{u3, u4} (η i) N _inst_2)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} ι (fun (i : ι) => η i)) N R _inst_1 _inst_2 _inst_3) (Dfinsupp.module.{u1, max u3 u4, u2} ι R (fun (i : ι) => Finsupp.{u3, u4} (η i) N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2)))) _inst_1 (fun (i : ι) => Finsupp.addCommMonoid.{u3, u4} (η i) N _inst_2) (fun (i : ι) => Finsupp.module.{u3, u4, u2} (η i) N R _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {ι : Type.{u1}} (R : Type.{u2}) {η : ι -> Type.{u3}} {N : Type.{u4}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u4} N] [_inst_3 : Module.{u2, u4} R N _inst_1 _inst_2], LinearEquiv.{u2, u2, max u4 u3 u1, max (max u4 u3) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} ι (fun (i : ι) => η i)) N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (Dfinsupp.{u1, max u4 u3} ι (fun (i : ι) => Finsupp.{u3, u4} (η i) N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (fun (i : ι) => AddMonoid.toZero.{max u3 u4} ((fun (i : ι) => Finsupp.{u3, u4} (η i) N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) i) (AddCommMonoid.toAddMonoid.{max u3 u4} ((fun (i : ι) => Finsupp.{u3, u4} (η i) N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) i) (Finsupp.addCommMonoid.{u3, u4} (η i) N _inst_2)))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} ι (fun (i : ι) => η i)) N _inst_2) (Dfinsupp.instAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, max u3 u4} ι (fun (i : ι) => Finsupp.{u3, u4} (η i) N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) (fun (i : ι) => Finsupp.addCommMonoid.{u3, u4} (η i) N _inst_2)) (Finsupp.instModuleFinsuppToZeroToAddMonoidAddCommMonoid.{max u1 u3, u4, u2} (Sigma.{u1, u3} ι (fun (i : ι) => η i)) N R _inst_1 _inst_2 _inst_3) (Dfinsupp.instModuleDfinsuppToZeroToAddMonoidInstAddCommMonoidDfinsuppToZeroToAddMonoid.{u1, max u3 u4, u2} ι R (fun (i : ι) => Finsupp.{u3, u4} (η i) N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_2))) _inst_1 (fun (i : ι) => Finsupp.addCommMonoid.{u3, u4} (η i) N _inst_2) (fun (i : ι) => Finsupp.instModuleFinsuppToZeroToAddMonoidAddCommMonoid.{u3, u4, u2} (η i) N R _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align sigma_finsupp_lequiv_dfinsupp sigmaFinsuppLequivDfinsuppₓ'. -/
/-- `finsupp.split` is a linear equivalence between `(Σ i, η i) →₀ N` and `Π₀ i, (η i →₀ N)`. -/
@[simps]
def sigmaFinsuppLequivDfinsupp [AddCommMonoid N] [Module R N] :
    ((Σi, η i) →₀ N) ≃ₗ[R] Π₀ i, η i →₀ N :=
  { sigmaFinsuppAddEquivDfinsupp with map_smul' := sigmaFinsuppEquivDfinsupp_smul }
#align sigma_finsupp_lequiv_dfinsupp sigmaFinsuppLequivDfinsupp

end Sigma

end Equivs

