/-
Copyright (c) 2022 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa

! This file was ported from Lean 3 source module data.finsupp.ne_locus
! leanprover-community/mathlib commit 2705404e701abc6b3127da906f40bae062a169c9
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Finsupp.Defs

/-!
# Locus of unequal values of finitely supported functions

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Let `α N` be two Types, assume that `N` has a `0` and let `f g : α →₀ N` be finitely supported
functions.

## Main definition

* `finsupp.ne_locus f g : finset α`, the finite subset of `α` where `f` and `g` differ.

In the case in which `N` is an additive group, `finsupp.ne_locus f g` coincides with
`finsupp.support (f - g)`.
-/


variable {α M N P : Type _}

namespace Finsupp

variable [DecidableEq α]

section NHasZero

variable [DecidableEq N] [Zero N] (f g : α →₀ N)

#print Finsupp.neLocus /-
/-- Given two finitely supported functions `f g : α →₀ N`, `finsupp.ne_locus f g` is the `finset`
where `f` and `g` differ. This generalizes `(f - g).support` to situations without subtraction. -/
def neLocus (f g : α →₀ N) : Finset α :=
  (f.support ∪ g.support).filterₓ fun x => f x ≠ g x
#align finsupp.ne_locus Finsupp.neLocus
-/

/- warning: finsupp.mem_ne_locus -> Finsupp.mem_neLocus is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : Zero.{u2} N] {f : Finsupp.{u1, u2} α N _inst_3} {g : Finsupp.{u1, u2} α N _inst_3} {a : α}, Iff (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g)) (Ne.{succ u2} N (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N _inst_3) (fun (_x : Finsupp.{u1, u2} α N _inst_3) => α -> N) (Finsupp.hasCoeToFun.{u1, u2} α N _inst_3) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N _inst_3) (fun (_x : Finsupp.{u1, u2} α N _inst_3) => α -> N) (Finsupp.hasCoeToFun.{u1, u2} α N _inst_3) g a))
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : Zero.{u1} N] {f : Finsupp.{u2, u1} α N _inst_3} {g : Finsupp.{u2, u1} α N _inst_3} {a : α}, Iff (Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) a (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g)) (Ne.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α N _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u2, u1} α N _inst_3) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α N _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u2, u1} α N _inst_3) g a))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_ne_locus Finsupp.mem_neLocusₓ'. -/
@[simp]
theorem mem_neLocus {f g : α →₀ N} {a : α} : a ∈ f.neLocus g ↔ f a ≠ g a := by
  simpa only [ne_locus, Finset.mem_filter, Finset.mem_union, mem_support_iff,
    and_iff_right_iff_imp] using Ne.ne_or_ne _
#align finsupp.mem_ne_locus Finsupp.mem_neLocus

/- warning: finsupp.not_mem_ne_locus -> Finsupp.not_mem_neLocus is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : Zero.{u2} N] {f : Finsupp.{u1, u2} α N _inst_3} {g : Finsupp.{u1, u2} α N _inst_3} {a : α}, Iff (Not (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g))) (Eq.{succ u2} N (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N _inst_3) (fun (_x : Finsupp.{u1, u2} α N _inst_3) => α -> N) (Finsupp.hasCoeToFun.{u1, u2} α N _inst_3) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N _inst_3) (fun (_x : Finsupp.{u1, u2} α N _inst_3) => α -> N) (Finsupp.hasCoeToFun.{u1, u2} α N _inst_3) g a))
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : Zero.{u1} N] {f : Finsupp.{u2, u1} α N _inst_3} {g : Finsupp.{u2, u1} α N _inst_3} {a : α}, Iff (Not (Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) a (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g))) (Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α N _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u2, u1} α N _inst_3) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α N _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u2, u1} α N _inst_3) g a))
Case conversion may be inaccurate. Consider using '#align finsupp.not_mem_ne_locus Finsupp.not_mem_neLocusₓ'. -/
theorem not_mem_neLocus {f g : α →₀ N} {a : α} : a ∉ f.neLocus g ↔ f a = g a :=
  mem_neLocus.Not.trans not_ne_iff
#align finsupp.not_mem_ne_locus Finsupp.not_mem_neLocus

/- warning: finsupp.coe_ne_locus -> Finsupp.coe_neLocus is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : Zero.{u2} N] (f : Finsupp.{u1, u2} α N _inst_3) (g : Finsupp.{u1, u2} α N _inst_3), Eq.{succ u1} (Set.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g)) (setOf.{u1} α (fun (x : α) => Ne.{succ u2} N (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N _inst_3) (fun (_x : Finsupp.{u1, u2} α N _inst_3) => α -> N) (Finsupp.hasCoeToFun.{u1, u2} α N _inst_3) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N _inst_3) (fun (_x : Finsupp.{u1, u2} α N _inst_3) => α -> N) (Finsupp.hasCoeToFun.{u1, u2} α N _inst_3) g x)))
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : Zero.{u1} N] (f : Finsupp.{u2, u1} α N _inst_3) (g : Finsupp.{u2, u1} α N _inst_3), Eq.{succ u2} (Set.{u2} α) (Finset.toSet.{u2} α (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g)) (setOf.{u2} α (fun (x : α) => Ne.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α N _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u2, u1} α N _inst_3) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α N _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u2, u1} α N _inst_3) g x)))
Case conversion may be inaccurate. Consider using '#align finsupp.coe_ne_locus Finsupp.coe_neLocusₓ'. -/
@[simp]
theorem coe_neLocus : ↑(f.neLocus g) = { x | f x ≠ g x } :=
  by
  ext
  exact mem_ne_locus
#align finsupp.coe_ne_locus Finsupp.coe_neLocus

/- warning: finsupp.ne_locus_eq_empty -> Finsupp.neLocus_eq_empty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : Zero.{u2} N] {f : Finsupp.{u1, u2} α N _inst_3} {g : Finsupp.{u1, u2} α N _inst_3}, Iff (Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g) (EmptyCollection.emptyCollection.{u1} (Finset.{u1} α) (Finset.hasEmptyc.{u1} α))) (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N _inst_3) f g)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : Zero.{u1} N] {f : Finsupp.{u2, u1} α N _inst_3} {g : Finsupp.{u2, u1} α N _inst_3}, Iff (Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g) (EmptyCollection.emptyCollection.{u2} (Finset.{u2} α) (Finset.instEmptyCollectionFinset.{u2} α))) (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α N _inst_3) f g)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_eq_empty Finsupp.neLocus_eq_emptyₓ'. -/
@[simp]
theorem neLocus_eq_empty {f g : α →₀ N} : f.neLocus g = ∅ ↔ f = g :=
  ⟨fun h =>
    ext fun a =>
      Classical.not_not.mp (mem_neLocus.Not.mp (Finset.eq_empty_iff_forall_not_mem.mp h a)),
    fun h => h ▸ by simp only [ne_locus, Ne.def, eq_self_iff_true, not_true, Finset.filter_False]⟩
#align finsupp.ne_locus_eq_empty Finsupp.neLocus_eq_empty

/- warning: finsupp.nonempty_ne_locus_iff -> Finsupp.nonempty_neLocus_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : Zero.{u2} N] {f : Finsupp.{u1, u2} α N _inst_3} {g : Finsupp.{u1, u2} α N _inst_3}, Iff (Finset.Nonempty.{u1} α (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g)) (Ne.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N _inst_3) f g)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : Zero.{u1} N] {f : Finsupp.{u2, u1} α N _inst_3} {g : Finsupp.{u2, u1} α N _inst_3}, Iff (Finset.Nonempty.{u2} α (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g)) (Ne.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} α N _inst_3) f g)
Case conversion may be inaccurate. Consider using '#align finsupp.nonempty_ne_locus_iff Finsupp.nonempty_neLocus_iffₓ'. -/
@[simp]
theorem nonempty_neLocus_iff {f g : α →₀ N} : (f.neLocus g).Nonempty ↔ f ≠ g :=
  Finset.nonempty_iff_ne_empty.trans neLocus_eq_empty.Not
#align finsupp.nonempty_ne_locus_iff Finsupp.nonempty_neLocus_iff

/- warning: finsupp.ne_locus_comm -> Finsupp.neLocus_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : Zero.{u2} N] (f : Finsupp.{u1, u2} α N _inst_3) (g : Finsupp.{u1, u2} α N _inst_3), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 g f)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : Zero.{u1} N] (f : Finsupp.{u2, u1} α N _inst_3) (g : Finsupp.{u2, u1} α N _inst_3), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f g) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 g f)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_comm Finsupp.neLocus_commₓ'. -/
theorem neLocus_comm : f.neLocus g = g.neLocus f := by
  simp_rw [ne_locus, Finset.union_comm, ne_comm]
#align finsupp.ne_locus_comm Finsupp.neLocus_comm

/- warning: finsupp.ne_locus_zero_right -> Finsupp.neLocus_zero_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : Zero.{u2} N] (f : Finsupp.{u1, u2} α N _inst_3), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α N _inst_3) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α N _inst_3) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α N _inst_3) (Finsupp.hasZero.{u1, u2} α N _inst_3))))) (Finsupp.support.{u1, u2} α N _inst_3 f)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : Zero.{u1} N] (f : Finsupp.{u2, u1} α N _inst_3), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 f (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α N _inst_3) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α N _inst_3) (Finsupp.hasZero.{u2, u1} α N _inst_3)))) (Finsupp.support.{u2, u1} α N _inst_3 f)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_zero_right Finsupp.neLocus_zero_rightₓ'. -/
@[simp]
theorem neLocus_zero_right : f.neLocus 0 = f.support :=
  by
  ext
  rw [mem_ne_locus, mem_support_iff, coe_zero, Pi.zero_apply]
#align finsupp.ne_locus_zero_right Finsupp.neLocus_zero_right

/- warning: finsupp.ne_locus_zero_left -> Finsupp.neLocus_zero_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : Zero.{u2} N] (f : Finsupp.{u1, u2} α N _inst_3), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α N _inst_3) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α N _inst_3) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α N _inst_3) (Finsupp.hasZero.{u1, u2} α N _inst_3)))) f) (Finsupp.support.{u1, u2} α N _inst_3 f)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : Zero.{u1} N] (f : Finsupp.{u2, u1} α N _inst_3), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_3 (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α N _inst_3) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α N _inst_3) (Finsupp.hasZero.{u2, u1} α N _inst_3))) f) (Finsupp.support.{u2, u1} α N _inst_3 f)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_zero_left Finsupp.neLocus_zero_leftₓ'. -/
@[simp]
theorem neLocus_zero_left : (0 : α →₀ N).neLocus f = f.support :=
  (neLocus_comm _ _).trans (neLocus_zero_right _)
#align finsupp.ne_locus_zero_left Finsupp.neLocus_zero_left

end NHasZero

section NeLocusAndMaps

#print Finsupp.subset_mapRange_neLocus /-
theorem subset_mapRange_neLocus [DecidableEq N] [Zero N] [DecidableEq M] [Zero M] (f g : α →₀ N)
    {F : N → M} (F0 : F 0 = 0) : (f.mapRange F F0).neLocus (g.mapRange F F0) ⊆ f.neLocus g :=
  fun x => by simpa only [mem_ne_locus, map_range_apply, not_imp_not] using congr_arg F
#align finsupp.subset_map_range_ne_locus Finsupp.subset_mapRange_neLocus
-/

/- warning: finsupp.zip_with_ne_locus_eq_left -> Finsupp.zipWith_neLocus_eq_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u3} N] [_inst_3 : Zero.{u2} M] [_inst_4 : DecidableEq.{succ u4} P] [_inst_5 : Zero.{u4} P] [_inst_6 : Zero.{u3} N] {F : M -> N -> P} (F0 : Eq.{succ u4} P (F (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_3))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_6)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_5)))) (f : Finsupp.{u1, u2} α M _inst_3) (g₁ : Finsupp.{u1, u3} α N _inst_6) (g₂ : Finsupp.{u1, u3} α N _inst_6), (forall (f : M), Function.Injective.{succ u3, succ u4} N P (fun (g : N) => F f g)) -> (Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u4} α P (fun (a : α) (b : α) => _inst_1 a b) (fun (a : P) (b : P) => _inst_4 a b) _inst_5 (Finsupp.zipWith.{u1, u2, u3, u4} α M N P _inst_3 _inst_6 _inst_5 F F0 f g₁) (Finsupp.zipWith.{u1, u2, u3, u4} α M N P _inst_3 _inst_6 _inst_5 F F0 f g₂)) (Finsupp.neLocus.{u1, u3} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_6 g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u4} N] [_inst_3 : Zero.{u3} M] [_inst_4 : DecidableEq.{succ u2} P] [_inst_5 : Zero.{u2} P] [_inst_6 : Zero.{u4} N] {F : M -> N -> P} (F0 : Eq.{succ u2} P (F (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M _inst_3)) (OfNat.ofNat.{u4} N 0 (Zero.toOfNat0.{u4} N _inst_6))) (OfNat.ofNat.{u2} P 0 (Zero.toOfNat0.{u2} P _inst_5))) (f : Finsupp.{u1, u3} α M _inst_3) (g₁ : Finsupp.{u1, u4} α N _inst_6) (g₂ : Finsupp.{u1, u4} α N _inst_6), (forall (f : M), Function.Injective.{succ u4, succ u2} N P (fun (g : N) => F f g)) -> (Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α P (fun (a : α) (b : α) => _inst_1 a b) (fun (a : P) (b : P) => _inst_4 a b) _inst_5 (Finsupp.zipWith.{u1, u3, u4, u2} α M N P _inst_3 _inst_6 _inst_5 F F0 f g₁) (Finsupp.zipWith.{u1, u3, u4, u2} α M N P _inst_3 _inst_6 _inst_5 F F0 f g₂)) (Finsupp.neLocus.{u1, u4} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) _inst_6 g₁ g₂))
Case conversion may be inaccurate. Consider using '#align finsupp.zip_with_ne_locus_eq_left Finsupp.zipWith_neLocus_eq_leftₓ'. -/
theorem zipWith_neLocus_eq_left [DecidableEq N] [Zero M] [DecidableEq P] [Zero P] [Zero N]
    {F : M → N → P} (F0 : F 0 0 = 0) (f : α →₀ M) (g₁ g₂ : α →₀ N)
    (hF : ∀ f, Function.Injective fun g => F f g) :
    (zipWith F F0 f g₁).neLocus (zipWith F F0 f g₂) = g₁.neLocus g₂ :=
  by
  ext
  simpa only [mem_ne_locus] using (hF _).ne_iff
#align finsupp.zip_with_ne_locus_eq_left Finsupp.zipWith_neLocus_eq_left

/- warning: finsupp.zip_with_ne_locus_eq_right -> Finsupp.zipWith_neLocus_eq_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} M] [_inst_3 : Zero.{u2} M] [_inst_4 : DecidableEq.{succ u4} P] [_inst_5 : Zero.{u4} P] [_inst_6 : Zero.{u3} N] {F : M -> N -> P} (F0 : Eq.{succ u4} P (F (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_3))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N _inst_6)))) (OfNat.ofNat.{u4} P 0 (OfNat.mk.{u4} P 0 (Zero.zero.{u4} P _inst_5)))) (f₁ : Finsupp.{u1, u2} α M _inst_3) (f₂ : Finsupp.{u1, u2} α M _inst_3) (g : Finsupp.{u1, u3} α N _inst_6), (forall (g : N), Function.Injective.{succ u2, succ u4} M P (fun (f : M) => F f g)) -> (Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u4} α P (fun (a : α) (b : α) => _inst_1 a b) (fun (a : P) (b : P) => _inst_4 a b) _inst_5 (Finsupp.zipWith.{u1, u2, u3, u4} α M N P _inst_3 _inst_6 _inst_5 F F0 f₁ g) (Finsupp.zipWith.{u1, u2, u3, u4} α M N P _inst_3 _inst_6 _inst_5 F F0 f₂ g)) (Finsupp.neLocus.{u1, u2} α M (fun (a : α) (b : α) => _inst_1 a b) (fun (a : M) (b : M) => _inst_2 a b) _inst_3 f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {N : Type.{u2}} {P : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u4} M] [_inst_3 : Zero.{u4} M] [_inst_4 : DecidableEq.{succ u3} P] [_inst_5 : Zero.{u3} P] [_inst_6 : Zero.{u2} N] {F : M -> N -> P} (F0 : Eq.{succ u3} P (F (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M _inst_3)) (OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N _inst_6))) (OfNat.ofNat.{u3} P 0 (Zero.toOfNat0.{u3} P _inst_5))) (f₁ : Finsupp.{u1, u4} α M _inst_3) (f₂ : Finsupp.{u1, u4} α M _inst_3) (g : Finsupp.{u1, u2} α N _inst_6), (forall (g : N), Function.Injective.{succ u4, succ u3} M P (fun (f : M) => F f g)) -> (Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u3} α P (fun (a : α) (b : α) => _inst_1 a b) (fun (a : P) (b : P) => _inst_4 a b) _inst_5 (Finsupp.zipWith.{u1, u4, u2, u3} α M N P _inst_3 _inst_6 _inst_5 F F0 f₁ g) (Finsupp.zipWith.{u1, u4, u2, u3} α M N P _inst_3 _inst_6 _inst_5 F F0 f₂ g)) (Finsupp.neLocus.{u1, u4} α M (fun (a : α) (b : α) => _inst_1 a b) (fun (a : M) (b : M) => _inst_2 a b) _inst_3 f₁ f₂))
Case conversion may be inaccurate. Consider using '#align finsupp.zip_with_ne_locus_eq_right Finsupp.zipWith_neLocus_eq_rightₓ'. -/
theorem zipWith_neLocus_eq_right [DecidableEq M] [Zero M] [DecidableEq P] [Zero P] [Zero N]
    {F : M → N → P} (F0 : F 0 0 = 0) (f₁ f₂ : α →₀ M) (g : α →₀ N)
    (hF : ∀ g, Function.Injective fun f => F f g) :
    (zipWith F F0 f₁ g).neLocus (zipWith F F0 f₂ g) = f₁.neLocus f₂ :=
  by
  ext
  simpa only [mem_ne_locus] using (hF _).ne_iff
#align finsupp.zip_with_ne_locus_eq_right Finsupp.zipWith_neLocus_eq_right

#print Finsupp.mapRange_neLocus_eq /-
theorem mapRange_neLocus_eq [DecidableEq N] [DecidableEq M] [Zero M] [Zero N] (f g : α →₀ N)
    {F : N → M} (F0 : F 0 = 0) (hF : Function.Injective F) :
    (f.mapRange F F0).neLocus (g.mapRange F F0) = f.neLocus g :=
  by
  ext
  simpa only [mem_ne_locus] using hF.ne_iff
#align finsupp.map_range_ne_locus_eq Finsupp.mapRange_neLocus_eq
-/

end NeLocusAndMaps

variable [DecidableEq N]

/- warning: finsupp.ne_locus_add_left -> Finsupp.neLocus_add_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddLeftCancelMonoid.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (h : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.hasAdd.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) f g) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.hasAdd.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) f h)) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3))) g h)
but is expected to have type
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddLeftCancelMonoid.{u2} N] (f : Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (g : Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (h : Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddLeftCancelMonoid.toZero.{u2} N _inst_3) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.instAddFinsuppToZero.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) f g) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddLeftCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.instAddFinsuppToZero.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddLeftCancelMonoid.toAddMonoid.{u2} N _inst_3)))) f h)) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddLeftCancelMonoid.toZero.{u2} N _inst_3) g h)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_add_left Finsupp.neLocus_add_leftₓ'. -/
@[simp]
theorem neLocus_add_left [AddLeftCancelMonoid N] (f g h : α →₀ N) :
    (f + g).neLocus (f + h) = g.neLocus h :=
  zipWith_neLocus_eq_left _ _ _ _ add_right_injective
#align finsupp.ne_locus_add_left Finsupp.neLocus_add_left

/- warning: finsupp.ne_locus_add_right -> Finsupp.neLocus_add_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddRightCancelMonoid.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (h : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.hasAdd.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) f h) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) (Finsupp.hasAdd.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) g h)) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3))) f g)
but is expected to have type
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddRightCancelMonoid.{u2} N] (f : Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (g : Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (h : Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddRightCancelMonoid.toZero.{u2} N _inst_3) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.instAddFinsuppToZero.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) f h) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddRightCancelMonoid.toZero.{u2} N _inst_3)) (Finsupp.instAddFinsuppToZero.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (AddRightCancelMonoid.toAddMonoid.{u2} N _inst_3)))) g h)) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddRightCancelMonoid.toZero.{u2} N _inst_3) f g)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_add_right Finsupp.neLocus_add_rightₓ'. -/
@[simp]
theorem neLocus_add_right [AddRightCancelMonoid N] (f g h : α →₀ N) :
    (f + h).neLocus (g + h) = f.neLocus g :=
  zipWith_neLocus_eq_right _ _ _ _ add_left_injective
#align finsupp.ne_locus_add_right Finsupp.neLocus_add_right

section AddGroup

variable [AddGroup N] (f f₁ f₂ g g₁ g₂ : α →₀ N)

/- warning: finsupp.ne_locus_neg_neg -> Finsupp.neLocus_neg_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddGroup.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasNeg.{u1, u2} α N (SubNegZeroMonoid.toNegZeroClass.{u2} N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) f) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasNeg.{u1, u2} α N (SubNegZeroMonoid.toNegZeroClass.{u2} N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) g)) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) f g)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : AddGroup.{u1} N] (f : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f) (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) g)) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f g)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_neg_neg Finsupp.neLocus_neg_negₓ'. -/
@[simp]
theorem neLocus_neg_neg : neLocus (-f) (-g) = f.neLocus g :=
  mapRange_neLocus_eq _ _ neg_zero neg_injective
#align finsupp.ne_locus_neg_neg Finsupp.neLocus_neg_neg

/- warning: finsupp.ne_locus_neg -> Finsupp.neLocus_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddGroup.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasNeg.{u1, u2} α N (SubNegZeroMonoid.toNegZeroClass.{u2} N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) f) g) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) f (Neg.neg.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasNeg.{u1, u2} α N (SubNegZeroMonoid.toNegZeroClass.{u2} N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) g))
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : AddGroup.{u1} N] (f : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f) g) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f (Neg.neg.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instNegFinsuppToZero.{u2, u1} α N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) g))
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_neg Finsupp.neLocus_negₓ'. -/
theorem neLocus_neg : neLocus (-f) g = f.neLocus (-g) := by rw [← ne_locus_neg_neg, neg_neg]
#align finsupp.ne_locus_neg Finsupp.neLocus_neg

/- warning: finsupp.ne_locus_eq_support_sub -> Finsupp.neLocus_eq_support_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddGroup.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) f g) (Finsupp.support.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasSub.{u1, u2} α N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) f g))
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : AddGroup.{u1} N] (f : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f g) (Finsupp.support.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f g))
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_eq_support_sub Finsupp.neLocus_eq_support_subₓ'. -/
theorem neLocus_eq_support_sub : f.neLocus g = (f - g).support := by
  rw [← ne_locus_add_right _ _ (-g), add_right_neg, ne_locus_zero_right, sub_eq_add_neg]
#align finsupp.ne_locus_eq_support_sub Finsupp.neLocus_eq_support_sub

/- warning: finsupp.ne_locus_sub_left -> Finsupp.neLocus_sub_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddGroup.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g₁ : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g₂ : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasSub.{u1, u2} α N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) f g₁) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasSub.{u1, u2} α N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) f g₂)) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) g₁ g₂)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : AddGroup.{u1} N] (f : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g₁ : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g₂ : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f g₁) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f g₂)) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) g₁ g₂)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_sub_left Finsupp.neLocus_sub_leftₓ'. -/
@[simp]
theorem neLocus_sub_left : neLocus (f - g₁) (f - g₂) = neLocus g₁ g₂ := by
  simp only [sub_eq_add_neg, ne_locus_add_left, ne_locus_neg_neg]
#align finsupp.ne_locus_sub_left Finsupp.neLocus_sub_left

/- warning: finsupp.ne_locus_sub_right -> Finsupp.neLocus_sub_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddGroup.{u2} N] (f₁ : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (f₂ : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasSub.{u1, u2} α N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) f₁ g) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasSub.{u1, u2} α N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) f₂ g)) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) f₁ f₂)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : AddGroup.{u1} N] (f₁ : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (f₂ : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f₁ g) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f₂ g)) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f₁ f₂)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_sub_right Finsupp.neLocus_sub_rightₓ'. -/
@[simp]
theorem neLocus_sub_right : neLocus (f₁ - g) (f₂ - g) = neLocus f₁ f₂ := by
  simpa only [sub_eq_add_neg] using ne_locus_add_right _ _ _
#align finsupp.ne_locus_sub_right Finsupp.neLocus_sub_right

/- warning: finsupp.ne_locus_self_add_right -> Finsupp.neLocus_self_add_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddGroup.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) f (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasAdd.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) f g)) (Finsupp.support.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) g)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : AddGroup.{u1} N] (f : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (instHAdd.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instAddFinsuppToZero.{u2, u1} α N (AddMonoid.toAddZeroClass.{u1} N (SubNegMonoid.toAddMonoid.{u1} N (AddGroup.toSubNegMonoid.{u1} N _inst_3))))) f g)) (Finsupp.support.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) g)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_self_add_right Finsupp.neLocus_self_add_rightₓ'. -/
@[simp]
theorem neLocus_self_add_right : neLocus f (f + g) = g.support := by
  rw [← ne_locus_zero_left, ← ne_locus_add_left f 0 g, add_zero]
#align finsupp.ne_locus_self_add_right Finsupp.neLocus_self_add_right

/- warning: finsupp.ne_locus_self_add_left -> Finsupp.neLocus_self_add_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddGroup.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasAdd.{u1, u2} α N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) f g) f) (Finsupp.support.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) g)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : AddGroup.{u1} N] (f : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (instHAdd.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instAddFinsuppToZero.{u2, u1} α N (AddMonoid.toAddZeroClass.{u1} N (SubNegMonoid.toAddMonoid.{u1} N (AddGroup.toSubNegMonoid.{u1} N _inst_3))))) f g) f) (Finsupp.support.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) g)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_self_add_left Finsupp.neLocus_self_add_leftₓ'. -/
@[simp]
theorem neLocus_self_add_left : neLocus (f + g) f = g.support := by
  rw [ne_locus_comm, ne_locus_self_add_right]
#align finsupp.ne_locus_self_add_left Finsupp.neLocus_self_add_left

/- warning: finsupp.ne_locus_self_sub_right -> Finsupp.neLocus_self_sub_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddGroup.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) f (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasSub.{u1, u2} α N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) f g)) (Finsupp.support.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) g)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : AddGroup.{u1} N] (f : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f g)) (Finsupp.support.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) g)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_self_sub_right Finsupp.neLocus_self_sub_rightₓ'. -/
@[simp]
theorem neLocus_self_sub_right : neLocus f (f - g) = g.support := by
  rw [sub_eq_add_neg, ne_locus_self_add_right, support_neg]
#align finsupp.ne_locus_self_sub_right Finsupp.neLocus_self_sub_right

/- warning: finsupp.ne_locus_self_sub_left -> Finsupp.neLocus_self_sub_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} α] [_inst_2 : DecidableEq.{succ u2} N] [_inst_3 : AddGroup.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (g : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))), Eq.{succ u1} (Finset.{u1} α) (Finsupp.neLocus.{u1, u2} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3))))) (Finsupp.hasSub.{u1, u2} α N (SubtractionMonoid.toSubNegZeroMonoid.{u2} N (AddGroup.toSubtractionMonoid.{u2} N _inst_3)))) f g) f) (Finsupp.support.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (SubNegMonoid.toAddMonoid.{u2} N (AddGroup.toSubNegMonoid.{u2} N _inst_3)))) g)
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} α] [_inst_2 : DecidableEq.{succ u1} N] [_inst_3 : AddGroup.{u1} N] (f : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (g : Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))), Eq.{succ u2} (Finset.{u2} α) (Finsupp.neLocus.{u2, u1} α N (fun (a : α) (b : α) => _inst_1 a b) (fun (a : N) (b : N) => _inst_2 a b) (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3))))) (Finsupp.instSubFinsuppToZeroToNegZeroClass.{u2, u1} α N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) f g) f) (Finsupp.support.{u2, u1} α N (NegZeroClass.toZero.{u1} N (SubNegZeroMonoid.toNegZeroClass.{u1} N (SubtractionMonoid.toSubNegZeroMonoid.{u1} N (AddGroup.toSubtractionMonoid.{u1} N _inst_3)))) g)
Case conversion may be inaccurate. Consider using '#align finsupp.ne_locus_self_sub_left Finsupp.neLocus_self_sub_leftₓ'. -/
@[simp]
theorem neLocus_self_sub_left : neLocus (f - g) f = g.support := by
  rw [ne_locus_comm, ne_locus_self_sub_right]
#align finsupp.ne_locus_self_sub_left Finsupp.neLocus_self_sub_left

end AddGroup

end Finsupp

