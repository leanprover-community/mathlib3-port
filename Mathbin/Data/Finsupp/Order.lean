/-
Copyright (c) 2021 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Aaron Anderson

! This file was ported from Lean 3 source module data.finsupp.order
! leanprover-community/mathlib commit b363547b3113d350d053abdf2884e9850a56b205
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Finsupp.Defs

/-!
# Pointwise order on finitely supported functions

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file lifts order structures on `α` to `ι →₀ α`.

## Main declarations

* `finsupp.order_embedding_to_fun`: The order embedding from finitely supported functions to
  functions.
* `finsupp.order_iso_multiset`: The order isomorphism between `ℕ`-valued finitely supported
  functions and multisets.
-/


noncomputable section

open BigOperators

open Finset

variable {ι α : Type _}

namespace Finsupp

/-! ### Order structures -/


section Zero

variable [Zero α]

section LE

variable [LE α]

instance : LE (ι →₀ α) :=
  ⟨fun f g => ∀ i, f i ≤ g i⟩

/- warning: finsupp.le_def -> Finsupp.le_def is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : Zero.{u2} α] [_inst_2 : LE.{u2} α] {f : Finsupp.{u1, u2} ι α _inst_1} {g : Finsupp.{u1, u2} ι α _inst_1}, Iff (LE.le.{max u1 u2} (Finsupp.{u1, u2} ι α _inst_1) (Finsupp.hasLe.{u1, u2} ι α _inst_1 _inst_2) f g) (forall (i : ι), LE.le.{u2} α _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α _inst_1) (fun (_x : Finsupp.{u1, u2} ι α _inst_1) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α _inst_1) f i) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α _inst_1) (fun (_x : Finsupp.{u1, u2} ι α _inst_1) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α _inst_1) g i))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : Zero.{u1} α] [_inst_2 : LE.{u1} α] {f : Finsupp.{u2, u1} ι α _inst_1} {g : Finsupp.{u2, u1} ι α _inst_1}, Iff (LE.le.{max u2 u1} (Finsupp.{u2, u1} ι α _inst_1) (Finsupp.instLEFinsupp.{u2, u1} ι α _inst_1 _inst_2) f g) (forall (i : ι), LE.le.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α _inst_1) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α _inst_1) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α _inst_1) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α _inst_1) g i))
Case conversion may be inaccurate. Consider using '#align finsupp.le_def Finsupp.le_defₓ'. -/
theorem le_def {f g : ι →₀ α} : f ≤ g ↔ ∀ i, f i ≤ g i :=
  Iff.rfl
#align finsupp.le_def Finsupp.le_def

#print Finsupp.orderEmbeddingToFun /-
/-- The order on `finsupp`s over a partial order embeds into the order on functions -/
def orderEmbeddingToFun : (ι →₀ α) ↪o (ι → α)
    where
  toFun f := f
  inj' f g h :=
    Finsupp.ext fun i => by
      dsimp at h
      rw [h]
  map_rel_iff' a b := (@le_def _ _ _ _ a b).symm
#align finsupp.order_embedding_to_fun Finsupp.orderEmbeddingToFun
-/

/- warning: finsupp.order_embedding_to_fun_apply -> Finsupp.orderEmbeddingToFun_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : Zero.{u2} α] [_inst_2 : LE.{u2} α] {f : Finsupp.{u1, u2} ι α _inst_1} {i : ι}, Eq.{succ u2} α (coeFn.{succ (max u1 u2), succ (max u1 u2)} (OrderEmbedding.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α _inst_1) (ι -> α) (Finsupp.hasLe.{u1, u2} ι α _inst_1 _inst_2) (Pi.hasLe.{u1, u2} ι (fun (ᾰ : ι) => α) (fun (i : ι) => _inst_2))) (fun (_x : RelEmbedding.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α _inst_1) (ι -> α) (LE.le.{max u1 u2} (Finsupp.{u1, u2} ι α _inst_1) (Finsupp.hasLe.{u1, u2} ι α _inst_1 _inst_2)) (LE.le.{max u1 u2} (ι -> α) (Pi.hasLe.{u1, u2} ι (fun (ᾰ : ι) => α) (fun (i : ι) => _inst_2)))) => (Finsupp.{u1, u2} ι α _inst_1) -> ι -> α) (RelEmbedding.hasCoeToFun.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α _inst_1) (ι -> α) (LE.le.{max u1 u2} (Finsupp.{u1, u2} ι α _inst_1) (Finsupp.hasLe.{u1, u2} ι α _inst_1 _inst_2)) (LE.le.{max u1 u2} (ι -> α) (Pi.hasLe.{u1, u2} ι (fun (ᾰ : ι) => α) (fun (i : ι) => _inst_2)))) (Finsupp.orderEmbeddingToFun.{u1, u2} ι α _inst_1 _inst_2) f i) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α _inst_1) (fun (_x : Finsupp.{u1, u2} ι α _inst_1) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α _inst_1) f i)
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : Zero.{u1} α] [_inst_2 : LE.{u1} α] {f : Finsupp.{u2, u1} ι α _inst_1} {i : ι}, Eq.{succ u1} α (FunLike.coe.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Function.Embedding.{succ (max u1 u2), succ (max u1 u2)} (Finsupp.{u2, u1} ι α _inst_1) (ι -> α)) (Finsupp.{u2, u1} ι α _inst_1) (fun (_x : Finsupp.{u2, u1} ι α _inst_1) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Finsupp.{u2, u1} ι α _inst_1) => ι -> α) _x) (EmbeddingLike.toFunLike.{succ (max u1 u2), succ (max u1 u2), succ (max u1 u2)} (Function.Embedding.{succ (max u1 u2), succ (max u1 u2)} (Finsupp.{u2, u1} ι α _inst_1) (ι -> α)) (Finsupp.{u2, u1} ι α _inst_1) (ι -> α) (Function.instEmbeddingLikeEmbedding.{succ (max u1 u2), succ (max u1 u2)} (Finsupp.{u2, u1} ι α _inst_1) (ι -> α))) (RelEmbedding.toEmbedding.{max u1 u2, max u1 u2} (Finsupp.{u2, u1} ι α _inst_1) (ι -> α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Finsupp.{u2, u1} ι α _inst_1) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Finsupp.{u2, u1} ι α _inst_1) => LE.le.{max u1 u2} (Finsupp.{u2, u1} ι α _inst_1) (Finsupp.instLEFinsupp.{u2, u1} ι α _inst_1 _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : ι -> α) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : ι -> α) => LE.le.{max u2 u1} (ι -> α) (Pi.hasLe.{u2, u1} ι (fun (a._@.Mathlib.Data.Finsupp.Order._hyg.125 : ι) => α) (fun (i : ι) => _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (Finsupp.orderEmbeddingToFun.{u2, u1} ι α _inst_1 _inst_2)) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α _inst_1) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α _inst_1) f i)
Case conversion may be inaccurate. Consider using '#align finsupp.order_embedding_to_fun_apply Finsupp.orderEmbeddingToFun_applyₓ'. -/
@[simp]
theorem orderEmbeddingToFun_apply {f : ι →₀ α} {i : ι} : orderEmbeddingToFun f i = f i :=
  rfl
#align finsupp.order_embedding_to_fun_apply Finsupp.orderEmbeddingToFun_apply

end LE

section Preorder

variable [Preorder α]

instance : Preorder (ι →₀ α) :=
  { Finsupp.hasLe with
    le_refl := fun f i => le_rfl
    le_trans := fun f g h hfg hgh i => (hfg i).trans (hgh i) }

/- warning: finsupp.monotone_to_fun -> Finsupp.monotone_toFun is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : Zero.{u2} α] [_inst_2 : Preorder.{u2} α], Monotone.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α _inst_1) (ι -> α) (Finsupp.preorder.{u1, u2} ι α _inst_1 _inst_2) (Pi.preorder.{u1, u2} ι (fun (ᾰ : ι) => α) (fun (i : ι) => _inst_2)) (Finsupp.toFun.{u1, u2} ι α _inst_1)
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : Zero.{u1} α] [_inst_2 : Preorder.{u1} α], Monotone.{max u2 u1, max u2 u1} (Finsupp.{u2, u1} ι α _inst_1) (ι -> α) (Finsupp.preorder.{u2, u1} ι α _inst_1 _inst_2) (Pi.preorder.{u2, u1} ι (fun (ᾰ : ι) => α) (fun (i : ι) => _inst_2)) (Finsupp.toFun.{u2, u1} ι α _inst_1)
Case conversion may be inaccurate. Consider using '#align finsupp.monotone_to_fun Finsupp.monotone_toFunₓ'. -/
theorem monotone_toFun : Monotone (Finsupp.toFun : (ι →₀ α) → ι → α) := fun f g h a => le_def.1 h a
#align finsupp.monotone_to_fun Finsupp.monotone_toFun

end Preorder

instance [PartialOrder α] : PartialOrder (ι →₀ α) :=
  { Finsupp.preorder with le_antisymm := fun f g hfg hgf => ext fun i => (hfg i).antisymm (hgf i) }

instance [SemilatticeInf α] : SemilatticeInf (ι →₀ α) :=
  { Finsupp.partialOrder with
    inf := zipWith (· ⊓ ·) inf_idem
    inf_le_left := fun f g i => inf_le_left
    inf_le_right := fun f g i => inf_le_right
    le_inf := fun f g i h1 h2 s => le_inf (h1 s) (h2 s) }

#print Finsupp.inf_apply /-
@[simp]
theorem inf_apply [SemilatticeInf α] {i : ι} {f g : ι →₀ α} : (f ⊓ g) i = f i ⊓ g i :=
  rfl
#align finsupp.inf_apply Finsupp.inf_apply
-/

instance [SemilatticeSup α] : SemilatticeSup (ι →₀ α) :=
  { Finsupp.partialOrder with
    sup := zipWith (· ⊔ ·) sup_idem
    le_sup_left := fun f g i => le_sup_left
    le_sup_right := fun f g i => le_sup_right
    sup_le := fun f g h hf hg i => sup_le (hf i) (hg i) }

#print Finsupp.sup_apply /-
@[simp]
theorem sup_apply [SemilatticeSup α] {i : ι} {f g : ι →₀ α} : (f ⊔ g) i = f i ⊔ g i :=
  rfl
#align finsupp.sup_apply Finsupp.sup_apply
-/

#print Finsupp.lattice /-
instance lattice [Lattice α] : Lattice (ι →₀ α) :=
  { Finsupp.semilatticeInf, Finsupp.semilatticeSup with }
#align finsupp.lattice Finsupp.lattice
-/

end Zero

/-! ### Algebraic order structures -/


instance [OrderedAddCommMonoid α] : OrderedAddCommMonoid (ι →₀ α) :=
  { Finsupp.addCommMonoid, Finsupp.partialOrder with
    add_le_add_left := fun a b h c s => add_le_add_left (h s) (c s) }

instance [OrderedCancelAddCommMonoid α] : OrderedCancelAddCommMonoid (ι →₀ α) :=
  { Finsupp.orderedAddCommMonoid with
    le_of_add_le_add_left := fun f g i h s => le_of_add_le_add_left (h s) }

instance [OrderedAddCommMonoid α] [ContravariantClass α α (· + ·) (· ≤ ·)] :
    ContravariantClass (ι →₀ α) (ι →₀ α) (· + ·) (· ≤ ·) :=
  ⟨fun f g h H x => le_of_add_le_add_left <| H x⟩

section CanonicallyOrderedAddMonoid

variable [CanonicallyOrderedAddMonoid α]

instance : OrderBot (ι →₀ α) where
  bot := 0
  bot_le := by simp only [le_def, coe_zero, Pi.zero_apply, imp_true_iff, zero_le]

/- warning: finsupp.bot_eq_zero -> Finsupp.bot_eq_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α], Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Bot.bot.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (OrderBot.toHasBot.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasLe.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (Finsupp.orderBot.{u1, u2} ι α _inst_1))) (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasZero.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α], Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Bot.bot.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (OrderBot.toBot.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.instLEFinsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.orderBot.{u2, u1} ι α _inst_1))) (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.zero.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align finsupp.bot_eq_zero Finsupp.bot_eq_zeroₓ'. -/
protected theorem bot_eq_zero : (⊥ : ι →₀ α) = 0 :=
  rfl
#align finsupp.bot_eq_zero Finsupp.bot_eq_zero

/- warning: finsupp.add_eq_zero_iff -> Finsupp.add_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] (f : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (g : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))), Iff (Eq.{succ (max u1 u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasAdd.{u1, u2} ι α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) f g) (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasZero.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))))))) (And (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) f (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasZero.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))))))) (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) g (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasZero.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))))))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] (f : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (g : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))), Iff (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (instHAdd.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.add.{u2, u1} ι α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) f g) (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.zero.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))) (And (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) f (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.zero.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))) (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) g (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.zero.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align finsupp.add_eq_zero_iff Finsupp.add_eq_zero_iffₓ'. -/
@[simp]
theorem add_eq_zero_iff (f g : ι →₀ α) : f + g = 0 ↔ f = 0 ∧ g = 0 := by simp [ext_iff, forall_and]
#align finsupp.add_eq_zero_iff Finsupp.add_eq_zero_iff

/- warning: finsupp.le_iff' -> Finsupp.le_iff' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] (f : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (g : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) {s : Finset.{u1} ι}, (HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) f) s) -> (Iff (LE.le.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasLe.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) f g) (forall (i : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i s) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) f i) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) g i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] (f : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (g : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) {s : Finset.{u2} ι}, (HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) f) s) -> (Iff (LE.le.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.instLEFinsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) f g) (forall (i : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (LE.le.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) (OrderedAddCommMonoid.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) _inst_1)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) g i))))
Case conversion may be inaccurate. Consider using '#align finsupp.le_iff' Finsupp.le_iff'ₓ'. -/
theorem le_iff' (f g : ι →₀ α) {s : Finset ι} (hf : f.support ⊆ s) : f ≤ g ↔ ∀ i ∈ s, f i ≤ g i :=
  ⟨fun h s hs => h s, fun h s => by
    classical exact
        if H : s ∈ f.support then h s (hf H) else (not_mem_support_iff.1 H).symm ▸ zero_le (g s)⟩
#align finsupp.le_iff' Finsupp.le_iff'

/- warning: finsupp.le_iff -> Finsupp.le_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] (f : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (g : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))), Iff (LE.le.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasLe.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) f g) (forall (i : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) f)) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) f i) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) g i)))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] (f : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (g : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))), Iff (LE.le.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.instLEFinsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) f g) (forall (i : ι), (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) f)) -> (LE.le.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) (OrderedAddCommMonoid.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) i) _inst_1)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) f i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) g i)))
Case conversion may be inaccurate. Consider using '#align finsupp.le_iff Finsupp.le_iffₓ'. -/
theorem le_iff (f g : ι →₀ α) : f ≤ g ↔ ∀ i ∈ f.support, f i ≤ g i :=
  le_iff' f g <| Subset.refl _
#align finsupp.le_iff Finsupp.le_iff

/- warning: finsupp.decidable_le -> Finsupp.decidableLe is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] [_inst_2 : DecidableRel.{succ u2} α (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))], DecidableRel.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (LE.le.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasLe.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))))
but is expected to have type
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] [_inst_2 : DecidableRel.{succ u2} α (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))], DecidableRel.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddMonoid.toZero.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (LE.le.{max u2 u1} (Finsupp.{u1, u2} ι α (AddMonoid.toZero.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (Finsupp.instLEFinsupp.{u1, u2} ι α (AddMonoid.toZero.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finsupp.decidable_le Finsupp.decidableLeₓ'. -/
instance decidableLe [DecidableRel (@LE.le α _)] : DecidableRel (@LE.le (ι →₀ α) _) := fun f g =>
  decidable_of_iff _ (le_iff f g).symm
#align finsupp.decidable_le Finsupp.decidableLe

/- warning: finsupp.single_le_iff -> Finsupp.single_le_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] {i : ι} {x : α} {f : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))}, Iff (LE.le.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.hasLe.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (Finsupp.single.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) i x) f) (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) f i))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] {i : ι} {x : α} {f : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))}, Iff (LE.le.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.instLEFinsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.single.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) i x) f) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) x (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) f i))
Case conversion may be inaccurate. Consider using '#align finsupp.single_le_iff Finsupp.single_le_iffₓ'. -/
@[simp]
theorem single_le_iff {i : ι} {x : α} {f : ι →₀ α} : single i x ≤ f ↔ x ≤ f i :=
  (le_iff' _ _ support_single_subset).trans <| by simp
#align finsupp.single_le_iff Finsupp.single_le_iff

variable [Sub α] [OrderedSub α] {f g : ι →₀ α} {i : ι} {a b : α}

/- warning: finsupp.tsub -> Finsupp.tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] [_inst_2 : Sub.{u2} α] [_inst_3 : OrderedSub.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (AddZeroClass.toHasAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) _inst_2], Sub.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))))
but is expected to have type
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] [_inst_2 : Sub.{u2} α] [_inst_3 : OrderedSub.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) _inst_2], Sub.{max u2 u1} (Finsupp.{u1, u2} ι α (AddMonoid.toZero.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finsupp.tsub Finsupp.tsubₓ'. -/
/-- This is called `tsub` for truncated subtraction, to distinguish it with subtraction in an
additive group. -/
instance tsub : Sub (ι →₀ α) :=
  ⟨zipWith (fun m n => m - n) (tsub_self 0)⟩
#align finsupp.tsub Finsupp.tsub

instance : OrderedSub (ι →₀ α) :=
  ⟨fun n m k => forall_congr' fun x => tsub_le_iff_right⟩

instance : CanonicallyOrderedAddMonoid (ι →₀ α) :=
  { Finsupp.orderBot,
    Finsupp.orderedAddCommMonoid with
    exists_add_of_le := fun f g h => ⟨g - f, ext fun x => (add_tsub_cancel_of_le <| h x).symm⟩
    le_self_add := fun f g x => le_self_add }

/- warning: finsupp.coe_tsub -> Finsupp.coe_tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] [_inst_2 : Sub.{u2} α] [_inst_3 : OrderedSub.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (AddZeroClass.toHasAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) _inst_2] (f : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (g : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))), Eq.{succ (max u1 u2)} (ι -> α) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.tsub.{u1, u2} ι α _inst_1 _inst_2 _inst_3)) f g)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (ι -> α) (ι -> α) (ι -> α) (instHSub.{max u1 u2} (ι -> α) (Pi.instSub.{u1, u2} ι (fun (ᾰ : ι) => α) (fun (i : ι) => _inst_2))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (f : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (g : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : ι), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.tsub.{u2, u1} ι α _inst_1 _inst_2 _inst_3)) f g)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (forall (ᾰ : ι), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) ᾰ) (forall (ᾰ : ι), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) ᾰ) (forall (ᾰ : ι), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) ᾰ) (instHSub.{max u2 u1} (forall (ᾰ : ι), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) ᾰ) (Pi.instSub.{u2, u1} ι (fun (ᾰ : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) ᾰ) (fun (i : ι) => _inst_2))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) g))
Case conversion may be inaccurate. Consider using '#align finsupp.coe_tsub Finsupp.coe_tsubₓ'. -/
@[simp]
theorem coe_tsub (f g : ι →₀ α) : ⇑(f - g) = f - g :=
  rfl
#align finsupp.coe_tsub Finsupp.coe_tsub

/- warning: finsupp.tsub_apply -> Finsupp.tsub_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] [_inst_2 : Sub.{u2} α] [_inst_3 : OrderedSub.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (AddZeroClass.toHasAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) _inst_2] (f : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (g : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (a : ι), Eq.{succ u2} α (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.tsub.{u1, u2} ι α _inst_1 _inst_2 _inst_3)) f g) a) (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (fun (_x : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) => ι -> α) (Finsupp.hasCoeToFun.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) g a))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (f : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (g : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (a : ι), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.tsub.{u2, u1} ι α _inst_1 _inst_2 _inst_3)) f g) a) (HSub.hSub.{u1, u1, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) a) ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) a) ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) a) (instHSub.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) a) _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => α) _x) (Finsupp.funLike.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) g a))
Case conversion may be inaccurate. Consider using '#align finsupp.tsub_apply Finsupp.tsub_applyₓ'. -/
theorem tsub_apply (f g : ι →₀ α) (a : ι) : (f - g) a = f a - g a :=
  rfl
#align finsupp.tsub_apply Finsupp.tsub_apply

/- warning: finsupp.single_tsub -> Finsupp.single_tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] [_inst_2 : Sub.{u2} α] [_inst_3 : OrderedSub.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (AddZeroClass.toHasAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) _inst_2] {i : ι} {a : α} {b : α}, Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.single.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) i (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α _inst_2) a b)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.tsub.{u1, u2} ι α _inst_1 _inst_2 _inst_3)) (Finsupp.single.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) i a) (Finsupp.single.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) i b))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {i : ι} {a : α} {b : α}, Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.single.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) i (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.tsub.{u2, u1} ι α _inst_1 _inst_2 _inst_3)) (Finsupp.single.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) i a) (Finsupp.single.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) i b))
Case conversion may be inaccurate. Consider using '#align finsupp.single_tsub Finsupp.single_tsubₓ'. -/
@[simp]
theorem single_tsub : single i (a - b) = single i a - single i b :=
  by
  ext j
  obtain rfl | h := eq_or_ne i j
  · rw [tsub_apply, single_eq_same, single_eq_same, single_eq_same]
  · rw [tsub_apply, single_eq_of_ne h, single_eq_of_ne h, single_eq_of_ne h, tsub_self]
#align finsupp.single_tsub Finsupp.single_tsub

/- warning: finsupp.support_tsub -> Finsupp.support_tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] [_inst_2 : Sub.{u2} α] [_inst_3 : OrderedSub.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (AddZeroClass.toHasAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) _inst_2] {f1 : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))} {f2 : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))}, HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.tsub.{u1, u2} ι α _inst_1 _inst_2 _inst_3)) f1 f2)) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) f1)
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {f1 : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))} {f2 : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))}, HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.tsub.{u2, u1} ι α _inst_1 _inst_2 _inst_3)) f1 f2)) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) f1)
Case conversion may be inaccurate. Consider using '#align finsupp.support_tsub Finsupp.support_tsubₓ'. -/
theorem support_tsub {f1 f2 : ι →₀ α} : (f1 - f2).support ⊆ f1.support := by
  simp (config := { contextual := true }) only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,
    Ne.def, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]
#align finsupp.support_tsub Finsupp.support_tsub

/- warning: finsupp.subset_support_tsub -> Finsupp.subset_support_tsub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyOrderedAddMonoid.{u2} α] [_inst_2 : Sub.{u2} α] [_inst_3 : OrderedSub.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))) (AddZeroClass.toHasAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) _inst_2] [_inst_4 : DecidableEq.{succ u1} ι] {f1 : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))} {f2 : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))}, HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (SDiff.sdiff.{u1} (Finset.{u1} ι) (Finset.hasSdiff.{u1} ι (fun (a : ι) (b : ι) => _inst_4 a b)) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) f1) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) f2)) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1))))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (instHSub.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α _inst_1)))))) (Finsupp.tsub.{u1, u2} ι α _inst_1 _inst_2 _inst_3)) f1 f2))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] [_inst_4 : DecidableEq.{succ u2} ι] {f1 : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))} {f2 : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))}, HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (SDiff.sdiff.{u2} (Finset.{u2} ι) (Finset.instSDiffFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_4 a b)) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) f1) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) f2)) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (instHSub.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Finsupp.tsub.{u2, u1} ι α _inst_1 _inst_2 _inst_3)) f1 f2))
Case conversion may be inaccurate. Consider using '#align finsupp.subset_support_tsub Finsupp.subset_support_tsubₓ'. -/
theorem subset_support_tsub [DecidableEq ι] {f1 f2 : ι →₀ α} :
    f1.support \ f2.support ⊆ (f1 - f2).support := by
  simp (config := { contextual := true }) [subset_iff]
#align finsupp.subset_support_tsub Finsupp.subset_support_tsub

end CanonicallyOrderedAddMonoid

section CanonicallyLinearOrderedAddMonoid

variable [CanonicallyLinearOrderedAddMonoid α]

/- warning: finsupp.support_inf -> Finsupp.support_inf is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u2} α] [_inst_2 : DecidableEq.{succ u1} ι] (f : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))) (g : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))), Eq.{succ u1} (Finset.{u1} ι) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) (HasInf.inf.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))) (SemilatticeInf.toHasInf.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))) (Finsupp.semilatticeInf.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u2} α _inst_1))))) f g)) (Inter.inter.{u1} (Finset.{u1} ι) (Finset.hasInter.{u1} ι (fun (a : ι) (b : ι) => _inst_2 a b)) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) f) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : DecidableEq.{succ u2} ι] (f : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (g : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))), Eq.{succ u2} (Finset.{u2} ι) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HasInf.inf.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Lattice.toHasInf.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Finsupp.lattice.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1))))) f g)) (Inter.inter.{u2} (Finset.{u2} ι) (Finset.instInterFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_2 a b)) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) f) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) g))
Case conversion may be inaccurate. Consider using '#align finsupp.support_inf Finsupp.support_infₓ'. -/
@[simp]
theorem support_inf [DecidableEq ι] (f g : ι →₀ α) : (f ⊓ g).support = f.support ∩ g.support :=
  by
  ext
  simp only [inf_apply, mem_support_iff, Ne.def, Finset.mem_union, Finset.mem_filter,
    Finset.mem_inter]
  simp only [inf_eq_min, ← nonpos_iff_eq_zero, min_le_iff, not_or]
#align finsupp.support_inf Finsupp.support_inf

/- warning: finsupp.support_sup -> Finsupp.support_sup is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u2} α] [_inst_2 : DecidableEq.{succ u1} ι] (f : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))) (g : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))), Eq.{succ u1} (Finset.{u1} ι) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) (HasSup.sup.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))) (SemilatticeSup.toHasSup.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))) (Finsupp.semilatticeSup.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) (CanonicallyLinearOrderedAddMonoid.semilatticeSup.{u2} α _inst_1))) f g)) (Union.union.{u1} (Finset.{u1} ι) (Finset.hasUnion.{u1} ι (fun (a : ι) (b : ι) => _inst_2 a b)) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) f) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : DecidableEq.{succ u2} ι] (f : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (g : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))), Eq.{succ u2} (Finset.{u2} ι) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HasSup.sup.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (SemilatticeSup.toHasSup.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Finsupp.semilatticeSup.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1)))))) f g)) (Union.union.{u2} (Finset.{u2} ι) (Finset.instUnionFinset.{u2} ι (fun (a : ι) (b : ι) => _inst_2 a b)) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) f) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) g))
Case conversion may be inaccurate. Consider using '#align finsupp.support_sup Finsupp.support_supₓ'. -/
@[simp]
theorem support_sup [DecidableEq ι] (f g : ι →₀ α) : (f ⊔ g).support = f.support ∪ g.support :=
  by
  ext
  simp only [Finset.mem_union, mem_support_iff, sup_apply, Ne.def, ← bot_eq_zero]
  rw [_root_.sup_eq_bot_iff, not_and_or]
#align finsupp.support_sup Finsupp.support_sup

/- warning: finsupp.disjoint_iff -> Finsupp.disjoint_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u2} α] {f : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))} {g : Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))}, Iff (Disjoint.{max u1 u2} (Finsupp.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1))))))) (Finsupp.partialOrder.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) (OrderedAddCommMonoid.toPartialOrder.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))) (Finsupp.orderBot.{u1, u2} ι α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)) f g) (Disjoint.{u1} (Finset.{u1} ι) (Finset.partialOrder.{u1} ι) (Finset.orderBot.{u1} ι) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) f) (Finsupp.support.{u1, u2} ι α (AddZeroClass.toHasZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (OrderedAddCommMonoid.toAddCommMonoid.{u2} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u2} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u2} α _inst_1)))))) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] {f : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))} {g : Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))}, Iff (Disjoint.{max u2 u1} (Finsupp.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Finsupp.partialorder.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))) (Finsupp.orderBot.{u2, u1} ι α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)) f g) (Disjoint.{u2} (Finset.{u2} ι) (Finset.partialOrder.{u2} ι) (Finset.instOrderBotFinsetToLEToPreorderPartialOrder.{u2} ι) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) f) (Finsupp.support.{u2, u1} ι α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) g))
Case conversion may be inaccurate. Consider using '#align finsupp.disjoint_iff Finsupp.disjoint_iffₓ'. -/
theorem disjoint_iff {f g : ι →₀ α} : Disjoint f g ↔ Disjoint f.support g.support := by
  classical
    rw [disjoint_iff, disjoint_iff, Finsupp.bot_eq_zero, ← Finsupp.support_eq_empty,
      Finsupp.support_inf]
    rfl
#align finsupp.disjoint_iff Finsupp.disjoint_iff

end CanonicallyLinearOrderedAddMonoid

/-! ### Some lemmas about `ℕ` -/


section Nat

/- warning: finsupp.sub_single_one_add -> Finsupp.sub_single_one_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {a : ι} {u : Finsupp.{u1, 0} ι Nat Nat.hasZero} {u' : Finsupp.{u1, 0} ι Nat Nat.hasZero}, (Ne.{1} Nat (coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} ι Nat Nat.hasZero) => ι -> Nat) (Finsupp.hasCoeToFun.{u1, 0} ι Nat Nat.hasZero) u a) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Eq.{succ u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (HAdd.hAdd.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (instHAdd.{u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.hasAdd.{u1, 0} ι Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (HSub.hSub.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (instHSub.{u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.tsub.{u1, 0} ι Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring) Nat.hasSub Nat.hasOrderedSub)) u (Finsupp.single.{u1, 0} ι Nat Nat.hasZero a (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) u') (HSub.hSub.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (instHSub.{u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.tsub.{u1, 0} ι Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring) Nat.hasSub Nat.hasOrderedSub)) (HAdd.hAdd.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (instHAdd.{u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.hasAdd.{u1, 0} ι Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) u u') (Finsupp.single.{u1, 0} ι Nat Nat.hasZero a (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {ι : Type.{u1}} {a : ι} {u : Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)} {u' : Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)}, (Ne.{1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => Nat) a) (FunLike.coe.{succ u1, succ u1, 1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => Nat) _x) (Finsupp.funLike.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) u a) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => Nat) a) 0 (instOfNatNat 0))) -> (Eq.{succ u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (HAdd.hAdd.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (instHAdd.{u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.add.{u1, 0} ι Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (HSub.hSub.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (instHSub.{u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.tsub.{u1, 0} ι Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring) instSubNat Nat.instOrderedSubNatInstLENatInstAddNatInstSubNat)) u (Finsupp.single.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) a (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) u') (HSub.hSub.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (instHSub.{u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.tsub.{u1, 0} ι Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring) instSubNat Nat.instOrderedSubNatInstLENatInstAddNatInstSubNat)) (HAdd.hAdd.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (instHAdd.{u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.add.{u1, 0} ι Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) u u') (Finsupp.single.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) a (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))
Case conversion may be inaccurate. Consider using '#align finsupp.sub_single_one_add Finsupp.sub_single_one_addₓ'. -/
theorem sub_single_one_add {a : ι} {u u' : ι →₀ ℕ} (h : u a ≠ 0) :
    u - single a 1 + u' = u + u' - single a 1 :=
  tsub_add_eq_add_tsub <| single_le_iff.mpr <| Nat.one_le_iff_ne_zero.mpr h
#align finsupp.sub_single_one_add Finsupp.sub_single_one_add

/- warning: finsupp.add_sub_single_one -> Finsupp.add_sub_single_one is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {a : ι} {u : Finsupp.{u1, 0} ι Nat Nat.hasZero} {u' : Finsupp.{u1, 0} ι Nat Nat.hasZero}, (Ne.{1} Nat (coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} ι Nat Nat.hasZero) => ι -> Nat) (Finsupp.hasCoeToFun.{u1, 0} ι Nat Nat.hasZero) u' a) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Eq.{succ u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (HAdd.hAdd.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (instHAdd.{u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.hasAdd.{u1, 0} ι Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) u (HSub.hSub.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (instHSub.{u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.tsub.{u1, 0} ι Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring) Nat.hasSub Nat.hasOrderedSub)) u' (Finsupp.single.{u1, 0} ι Nat Nat.hasZero a (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HSub.hSub.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (instHSub.{u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.tsub.{u1, 0} ι Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring) Nat.hasSub Nat.hasOrderedSub)) (HAdd.hAdd.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.{u1, 0} ι Nat Nat.hasZero) (instHAdd.{u1} (Finsupp.{u1, 0} ι Nat Nat.hasZero) (Finsupp.hasAdd.{u1, 0} ι Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) u u') (Finsupp.single.{u1, 0} ι Nat Nat.hasZero a (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {ι : Type.{u1}} {a : ι} {u : Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)} {u' : Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)}, (Ne.{1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => Nat) a) (FunLike.coe.{succ u1, succ u1, 1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => Nat) _x) (Finsupp.funLike.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) u' a) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => Nat) a) 0 (instOfNatNat 0))) -> (Eq.{succ u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (HAdd.hAdd.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (instHAdd.{u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.add.{u1, 0} ι Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) u (HSub.hSub.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (instHSub.{u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.tsub.{u1, 0} ι Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring) instSubNat Nat.instOrderedSubNatInstLENatInstAddNatInstSubNat)) u' (Finsupp.single.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) a (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HSub.hSub.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (instHSub.{u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.tsub.{u1, 0} ι Nat (CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddMonoid.{0} Nat Nat.canonicallyOrderedCommSemiring) instSubNat Nat.instOrderedSubNatInstLENatInstAddNatInstSubNat)) (HAdd.hAdd.{u1, u1, u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (instHAdd.{u1} (Finsupp.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (Finsupp.add.{u1, 0} ι Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) u u') (Finsupp.single.{u1, 0} ι Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) a (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))
Case conversion may be inaccurate. Consider using '#align finsupp.add_sub_single_one Finsupp.add_sub_single_oneₓ'. -/
theorem add_sub_single_one {a : ι} {u u' : ι →₀ ℕ} (h : u' a ≠ 0) :
    u + (u' - single a 1) = u + u' - single a 1 :=
  (add_tsub_assoc_of_le (single_le_iff.mpr <| Nat.one_le_iff_ne_zero.mpr h) _).symm
#align finsupp.add_sub_single_one Finsupp.add_sub_single_one

end Nat

end Finsupp

