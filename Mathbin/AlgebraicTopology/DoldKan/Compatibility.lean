/-
Copyright (c) 2022 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathbin.CategoryTheory.Equivalence

#align_import algebraic_topology.dold_kan.compatibility from "leanprover-community/mathlib"@"18ee599842a5d17f189fe572f0ed8cb1d064d772"

/-!
> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
 Tools for compatibilities between Dold-Kan equivalences

The purpose of this file is to introduce tools which will enable the
construction of the Dold-Kan equivalence `simplicial_object C ‚âå chain_complex C ‚Ñï`
for a pseudoabelian category `C` from the equivalence
`karoubi (simplicial_object C) ‚âå karoubi (chain_complex C ‚Ñï)` and the two
equivalences `simplicial_object C ‚âÖ karoubi (simplicial_object C)` and
`chain_complex C ‚Ñï ‚âÖ karoubi (chain_complex C ‚Ñï)`.

It is certainly possible to get an equivalence `simplicial_object C ‚âå chain_complex C ‚Ñï`
using a compositions of the three equivalences above, but then neither the functor
nor the inverse would have good definitional properties. For example, it would be better
if the inverse functor of the equivalence was exactly the functor
`Œì‚ÇÄ : simplicial_object C ‚•§ chain_complex C ‚Ñï` which was constructed in `functor_gamma.lean`.

In this file, given four categories `A`, `A'`, `B`, `B'`, equivalences `eA : A ‚âÖ A'`,
`eB : B ‚âÖ B'`, `e' : A' ‚âÖ B'`, functors `F : A ‚•§ B'`, `G : B ‚•§ A` equipped with certain
compatibilities, we construct successive equivalences:
- `equivalence‚ÇÄ` from `A` to `B'`, which is the composition of `eA` and `e'`.
- `equivalence‚ÇÅ` from `A` to `B'`, with the same inverse functor as `equivalence‚ÇÄ`,
but whose functor is `F`.
- `equivalence‚ÇÇ` from `A` to `B`, which is the composition of `equivalence‚ÇÅ` and the
inverse of `eB`:
- `equivalence` from `A` to `B`, which has the same functor `F ‚ãô eB.inverse` as `equivalence‚ÇÇ`,
but whose inverse functor is `G`.

When extra assumptions are given, we shall also provide simplification lemmas for the
unit and counit isomorphisms of `equivalence`. (TODO)

-/


open CategoryTheory CategoryTheory.Category

namespace AlgebraicTopology

namespace DoldKan

namespace Compatibility

variable {A A' B B' : Type _} [Category A] [Category A'] [Category B] [Category B'] (eA : A ‚âå A')
  (eB : B ‚âå B') (e' : A' ‚âå B') {F : A ‚•§ B'} (hF : eA.Functor ‚ãô e'.Functor ‚âÖ F) {G : B ‚•§ A}
  (hG : eB.Functor ‚ãô e'.inverse ‚âÖ G ‚ãô eA.Functor)

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÄ /-
/-- A basic equivalence `A ‚âÖ B'` obtained by composing `eA : A ‚âÖ A'` and `e' : A' ‚âÖ B'`. -/
@[simps Functor inverse unit_iso_hom_app]
def equivalence‚ÇÄ : A ‚âå B' :=
  eA.trans e'
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÄ AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÄ
-/

variable {eA} {e'}

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅ /-
/-- An intermediate equivalence `A ‚âÖ B'` whose functor is `F` and whose inverse is
`e'.inverse ‚ãô eA.inverse`. -/
@[simps Functor]
def equivalence‚ÇÅ : A ‚âå B' :=
  letI : is_equivalence F :=
    is_equivalence.of_iso hF (is_equivalence.of_equivalence (equivalence‚ÇÄ eA e'))
  F.as_equivalence
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÅ AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅ
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅ_inverse /-
theorem equivalence‚ÇÅ_inverse : (equivalence‚ÇÅ hF).inverse = e'.inverse ‚ãô eA.inverse :=
  rfl
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÅ_inverse AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅ_inverse
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅCounitIso /-
/-- The counit isomorphism of the equivalence `equivalence‚ÇÅ` between `A` and `B'`. -/
@[simps]
def equivalence‚ÇÅCounitIso : (e'.inverse ‚ãô eA.inverse) ‚ãô F ‚âÖ ùü≠ B' :=
  calc
    (e'.inverse ‚ãô eA.inverse) ‚ãô F ‚âÖ (e'.inverse ‚ãô eA.inverse) ‚ãô eA.Functor ‚ãô e'.Functor :=
      isoWhiskerLeft _ hF.symm
    _ ‚âÖ e'.inverse ‚ãô (eA.inverse ‚ãô eA.Functor) ‚ãô e'.Functor := (Iso.refl _)
    _ ‚âÖ e'.inverse ‚ãô ùü≠ _ ‚ãô e'.Functor := (isoWhiskerLeft _ (isoWhiskerRight eA.counitIso _))
    _ ‚âÖ e'.inverse ‚ãô e'.Functor := (Iso.refl _)
    _ ‚âÖ ùü≠ B' := e'.counitIso
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÅ_counit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅCounitIso
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅCounitIso_eq /-
theorem equivalence‚ÇÅCounitIso_eq : (equivalence‚ÇÅ hF).counitIso = equivalence‚ÇÅCounitIso hF :=
  by
  ext Y
  dsimp [equivalence‚ÇÄ, equivalence‚ÇÅ, is_equivalence.inverse, is_equivalence.of_equivalence]
  simp only [equivalence‚ÇÅ_counit_iso_hom_app, CategoryTheory.Functor.map_id, comp_id]
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÅ_counit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅCounitIso_eq
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅUnitIso /-
/-- The unit isomorphism of the equivalence `equivalence‚ÇÅ` between `A` and `B'`. -/
@[simps]
def equivalence‚ÇÅUnitIso : ùü≠ A ‚âÖ F ‚ãô e'.inverse ‚ãô eA.inverse :=
  calc
    ùü≠ A ‚âÖ eA.Functor ‚ãô eA.inverse := eA.unitIso
    _ ‚âÖ eA.Functor ‚ãô ùü≠ A' ‚ãô eA.inverse := (Iso.refl _)
    _ ‚âÖ eA.Functor ‚ãô (e'.Functor ‚ãô e'.inverse) ‚ãô eA.inverse :=
      (isoWhiskerLeft _ (isoWhiskerRight e'.unitIso _))
    _ ‚âÖ (eA.Functor ‚ãô e'.Functor) ‚ãô e'.inverse ‚ãô eA.inverse := (Iso.refl _)
    _ ‚âÖ F ‚ãô e'.inverse ‚ãô eA.inverse := isoWhiskerRight hF _
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÅ_unit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅUnitIso
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅUnitIso_eq /-
theorem equivalence‚ÇÅUnitIso_eq : (equivalence‚ÇÅ hF).unitIso = equivalence‚ÇÅUnitIso hF :=
  by
  ext X
  dsimp [equivalence‚ÇÄ, equivalence‚ÇÅ, nat_iso.hcomp, is_equivalence.of_equivalence]
  simp only [id_comp, assoc, equivalence‚ÇÅ_unit_iso_hom_app]
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÅ_unit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅUnitIso_eq
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇ /-
/-- An intermediate equivalence `A ‚âÖ B` obtained as the composition of `equivalence‚ÇÅ` and
the inverse of `eB : B ‚âå B'`. -/
@[simps Functor]
def equivalence‚ÇÇ : A ‚âå B :=
  (equivalence‚ÇÅ hF).trans eB.symm
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÇ AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇ
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇ_inverse /-
theorem equivalence‚ÇÇ_inverse :
    (equivalence‚ÇÇ eB hF).inverse = eB.Functor ‚ãô e'.inverse ‚ãô eA.inverse :=
  rfl
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÇ_inverse AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇ_inverse
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇCounitIso /-
/-- The counit isomorphism of the equivalence `equivalence‚ÇÇ` between `A` and `B`. -/
@[simps]
def equivalence‚ÇÇCounitIso : (eB.Functor ‚ãô e'.inverse ‚ãô eA.inverse) ‚ãô F ‚ãô eB.inverse ‚âÖ ùü≠ B :=
  calc
    (eB.Functor ‚ãô e'.inverse ‚ãô eA.inverse) ‚ãô F ‚ãô eB.inverse ‚âÖ
        eB.Functor ‚ãô (e'.inverse ‚ãô eA.inverse ‚ãô F) ‚ãô eB.inverse :=
      Iso.refl _
    _ ‚âÖ eB.Functor ‚ãô ùü≠ _ ‚ãô eB.inverse :=
      (isoWhiskerLeft _ (isoWhiskerRight (equivalence‚ÇÅCounitIso hF) _))
    _ ‚âÖ eB.Functor ‚ãô eB.inverse := (Iso.refl _)
    _ ‚âÖ ùü≠ B := eB.unitIso.symm
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÇ_counit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇCounitIso
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇCounitIso_eq /-
theorem equivalence‚ÇÇCounitIso_eq : (equivalence‚ÇÇ eB hF).counitIso = equivalence‚ÇÇCounitIso eB hF :=
  by
  ext Y'
  dsimp [equivalence‚ÇÇ, iso.refl]
  simp only [equivalence‚ÇÅ_counit_iso_eq, equivalence‚ÇÇ_counit_iso_hom_app,
    equivalence‚ÇÅ_counit_iso_hom_app, functor.map_comp, assoc]
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÇ_counit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇCounitIso_eq
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇUnitIso /-
/-- The unit isomorphism of the equivalence `equivalence‚ÇÇ` between `A` and `B`. -/
@[simps]
def equivalence‚ÇÇUnitIso : ùü≠ A ‚âÖ (F ‚ãô eB.inverse) ‚ãô eB.Functor ‚ãô e'.inverse ‚ãô eA.inverse :=
  calc
    ùü≠ A ‚âÖ F ‚ãô e'.inverse ‚ãô eA.inverse := equivalence‚ÇÅUnitIso hF
    _ ‚âÖ F ‚ãô ùü≠ B' ‚ãô e'.inverse ‚ãô eA.inverse := (Iso.refl _)
    _ ‚âÖ F ‚ãô (eB.inverse ‚ãô eB.Functor) ‚ãô e'.inverse ‚ãô eA.inverse :=
      (isoWhiskerLeft _ (isoWhiskerRight eB.counitIso.symm _))
    _ ‚âÖ (F ‚ãô eB.inverse) ‚ãô eB.Functor ‚ãô e'.inverse ‚ãô eA.inverse := Iso.refl _
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÇ_unit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇUnitIso
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇUnitIso_eq /-
theorem equivalence‚ÇÇUnitIso_eq : (equivalence‚ÇÇ eB hF).unitIso = equivalence‚ÇÇUnitIso eB hF :=
  by
  ext X
  dsimp [equivalence‚ÇÇ]
  simpa only [equivalence‚ÇÇ_unit_iso_hom_app, equivalence‚ÇÅ_unit_iso_eq,
    equivalence‚ÇÅ_unit_iso_hom_app, assoc, nat_iso.cancel_nat_iso_hom_left]
#align algebraic_topology.dold_kan.compatibility.equivalence‚ÇÇ_unit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÇUnitIso_eq
-/

variable {eB}

#print AlgebraicTopology.DoldKan.Compatibility.equivalence /-
/-- The equivalence `A ‚âÖ B` whose functor is `F ‚ãô eB.inverse` and
whose inverse is `G : B ‚âÖ A`. -/
@[simps inverse]
def equivalence : A ‚âå B :=
  letI : is_equivalence G :=
    by
    refine' is_equivalence.of_iso _ (is_equivalence.of_equivalence (equivalence‚ÇÇ eB hF).symm)
    calc
      eB.functor ‚ãô e'.inverse ‚ãô eA.inverse ‚âÖ (eB.functor ‚ãô e'.inverse) ‚ãô eA.inverse := iso.refl _
      _ ‚âÖ (G ‚ãô eA.functor) ‚ãô eA.inverse := (iso_whisker_right hG _)
      _ ‚âÖ G ‚ãô ùü≠ A := (iso_whisker_left _ eA.unit_iso.symm)
      _ ‚âÖ G := functor.right_unitor G
  G.as_equivalence.symm
#align algebraic_topology.dold_kan.compatibility.equivalence AlgebraicTopology.DoldKan.Compatibility.equivalence
-/

#print AlgebraicTopology.DoldKan.Compatibility.equivalence_functor /-
theorem equivalence_functor : (equivalence hF hG).Functor = F ‚ãô eB.inverse :=
  rfl
#align algebraic_topology.dold_kan.compatibility.equivalence_functor AlgebraicTopology.DoldKan.Compatibility.equivalence_functor
-/

#print AlgebraicTopology.DoldKan.Compatibility.œÑ‚ÇÄ /-
/-- The isomorphism `eB.functor ‚ãô e'.inverse ‚ãô e'.functor ‚âÖ eB.functor` deduced
from the counit isomorphism of `e'`. -/
@[simps hom_app]
def œÑ‚ÇÄ : eB.Functor ‚ãô e'.inverse ‚ãô e'.Functor ‚âÖ eB.Functor :=
  calc
    eB.Functor ‚ãô e'.inverse ‚ãô e'.Functor ‚âÖ eB.Functor ‚ãô ùü≠ _ := isoWhiskerLeft _ e'.counitIso
    _ ‚âÖ eB.Functor := Functor.rightUnitor _
#align algebraic_topology.dold_kan.compatibility.œÑ‚ÇÄ AlgebraicTopology.DoldKan.Compatibility.œÑ‚ÇÄ
-/

#print AlgebraicTopology.DoldKan.Compatibility.œÑ‚ÇÅ /-
/-- The isomorphism `eB.functor ‚ãô e'.inverse ‚ãô e'.functor ‚âÖ eB.functor` deduced
from the isomorphisms `hF : eA.functor ‚ãô e'.functor ‚âÖ F`,
`hG : eB.functor ‚ãô e'.inverse ‚âÖ G ‚ãô eA.functor` and the datum of
an isomorphism `Œ∑ : G ‚ãô F ‚âÖ eB.functor`. -/
@[simps hom_app]
def œÑ‚ÇÅ (Œ∑ : G ‚ãô F ‚âÖ eB.Functor) : eB.Functor ‚ãô e'.inverse ‚ãô e'.Functor ‚âÖ eB.Functor :=
  calc
    eB.Functor ‚ãô e'.inverse ‚ãô e'.Functor ‚âÖ (eB.Functor ‚ãô e'.inverse) ‚ãô e'.Functor := Iso.refl _
    _ ‚âÖ (G ‚ãô eA.Functor) ‚ãô e'.Functor := (isoWhiskerRight hG _)
    _ ‚âÖ G ‚ãô eA.Functor ‚ãô e'.Functor := by rfl
    _ ‚âÖ G ‚ãô F := (isoWhiskerLeft _ hF)
    _ ‚âÖ eB.Functor := Œ∑
#align algebraic_topology.dold_kan.compatibility.œÑ‚ÇÅ AlgebraicTopology.DoldKan.Compatibility.œÑ‚ÇÅ
-/

variable (Œ∑ : G ‚ãô F ‚âÖ eB.Functor) (hŒ∑ : œÑ‚ÇÄ = œÑ‚ÇÅ hF hG Œ∑)

#print AlgebraicTopology.DoldKan.Compatibility.equivalenceCounitIso /-
/-- The counit isomorphism of `equivalence`. -/
@[simps]
def equivalenceCounitIso : G ‚ãô F ‚ãô eB.inverse ‚âÖ ùü≠ B :=
  calc
    G ‚ãô F ‚ãô eB.inverse ‚âÖ (G ‚ãô F) ‚ãô eB.inverse := Iso.refl _
    _ ‚âÖ eB.Functor ‚ãô eB.inverse := (isoWhiskerRight Œ∑ _)
    _ ‚âÖ ùü≠ B := eB.unitIso.symm
#align algebraic_topology.dold_kan.compatibility.equivalence_counit_iso AlgebraicTopology.DoldKan.Compatibility.equivalenceCounitIso
-/

variable {Œ∑ hF hG}

#print AlgebraicTopology.DoldKan.Compatibility.equivalenceCounitIso_eq /-
theorem equivalenceCounitIso_eq : (equivalence hF hG).counitIso = equivalenceCounitIso Œ∑ :=
  by
  ext1; apply nat_trans.ext; ext Y
  dsimp [Equivalence, equivalence_counit_iso, is_equivalence.of_equivalence]
  simp only [equivalence‚ÇÇ_counit_iso_eq eB hF]
  erw [nat_trans.id_app, nat_trans.id_app]
  dsimp [equivalence‚ÇÇ, equivalence‚ÇÅ]
  simp only [assoc, comp_id, F.map_id, id_comp, equivalence‚ÇÇ_counit_iso_hom_app, ‚Üê
    eB.inverse.map_comp_assoc, ‚Üê œÑ‚ÇÄ_hom_app, hŒ∑, œÑ‚ÇÅ_hom_app]
  erw [hF.inv.naturality_assoc]
  congr 2
  dsimp
  simp only [assoc, ‚Üê e'.functor.map_comp_assoc, eA.functor.map_comp, equivalence.fun_inv_map,
    iso.inv_hom_id_app_assoc, hG.inv_hom_id_app]
  dsimp
  rw [comp_id, eA.functor_unit_iso_comp, e'.functor.map_id, id_comp, hF.inv_hom_id_app_assoc]
#align algebraic_topology.dold_kan.compatibility.equivalence_counit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalenceCounitIso_eq
-/

variable (hF)

#print AlgebraicTopology.DoldKan.Compatibility.œÖ /-
/-- The isomorphism `eA.functor ‚âÖ F ‚ãô e'.inverse` deduced from the
unit isomorphism of `e'` and the isomorphism `hF : eA.functor ‚ãô e'.functor ‚âÖ F`. -/
@[simps]
def œÖ : eA.Functor ‚âÖ F ‚ãô e'.inverse :=
  calc
    eA.Functor ‚âÖ eA.Functor ‚ãô ùü≠ A' := (Functor.leftUnitor _).symm
    _ ‚âÖ eA.Functor ‚ãô e'.Functor ‚ãô e'.inverse := (isoWhiskerLeft _ e'.unitIso)
    _ ‚âÖ (eA.Functor ‚ãô e'.Functor) ‚ãô e'.inverse := (Iso.refl _)
    _ ‚âÖ F ‚ãô e'.inverse := isoWhiskerRight hF _
#align algebraic_topology.dold_kan.compatibility.œÖ AlgebraicTopology.DoldKan.Compatibility.œÖ
-/

variable (Œµ : eA.Functor ‚âÖ F ‚ãô e'.inverse) (hŒµ : œÖ hF = Œµ)

variable (hG)

#print AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso /-
/-- The unit isomorphism of `equivalence`. -/
@[simps]
def equivalenceUnitIso : ùü≠ A ‚âÖ (F ‚ãô eB.inverse) ‚ãô G :=
  calc
    ùü≠ A ‚âÖ eA.Functor ‚ãô eA.inverse := eA.unitIso
    _ ‚âÖ (F ‚ãô e'.inverse) ‚ãô eA.inverse := (isoWhiskerRight Œµ _)
    _ ‚âÖ F ‚ãô ùü≠ B' ‚ãô e'.inverse ‚ãô eA.inverse := (Iso.refl _)
    _ ‚âÖ F ‚ãô (eB.inverse ‚ãô eB.Functor) ‚ãô e'.inverse ‚ãô eA.inverse :=
      (isoWhiskerLeft _ (isoWhiskerRight eB.counitIso.symm _))
    _ ‚âÖ (F ‚ãô eB.inverse) ‚ãô (eB.Functor ‚ãô e'.inverse) ‚ãô eA.inverse := (Iso.refl _)
    _ ‚âÖ (F ‚ãô eB.inverse) ‚ãô (G ‚ãô eA.Functor) ‚ãô eA.inverse :=
      (isoWhiskerLeft _ (isoWhiskerRight hG _))
    _ ‚âÖ (F ‚ãô eB.inverse ‚ãô G) ‚ãô eA.Functor ‚ãô eA.inverse := (Iso.refl _)
    _ ‚âÖ (F ‚ãô eB.inverse ‚ãô G) ‚ãô ùü≠ A := (isoWhiskerLeft _ eA.unitIso.symm)
    _ ‚âÖ (F ‚ãô eB.inverse) ‚ãô G := Iso.refl _
#align algebraic_topology.dold_kan.compatibility.equivalence_unit_iso AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso
-/

variable {Œµ hF hG}

#print AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso_eq /-
theorem equivalenceUnitIso_eq : (equivalence hF hG).unitIso = equivalenceUnitIso hG Œµ :=
  by
  ext1; apply nat_trans.ext; ext X
  dsimp [Equivalence, iso.refl, nat_iso.hcomp, is_equivalence.inverse,
    is_equivalence.of_equivalence]
  erw [nat_trans.id_app, id_comp, G.map_id, comp_id, comp_id]
  simp only [equivalence‚ÇÇ_unit_iso_eq eB hF, equivalence‚ÇÇ_unit_iso_hom_app]
  dsimp [equivalence‚ÇÇ, equivalence‚ÇÅ]
  simp only [assoc, equivalence_unit_iso_hom_app, nat_iso.cancel_nat_iso_hom_left, ‚Üê
    eA.inverse.map_comp_assoc, ‚Üê hŒµ, œÖ_hom_app]
#align algebraic_topology.dold_kan.compatibility.equivalence_unit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso_eq
-/

end Compatibility

end DoldKan

end AlgebraicTopology

