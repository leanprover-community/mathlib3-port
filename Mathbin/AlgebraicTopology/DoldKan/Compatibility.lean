/-
Copyright (c) 2022 Joël Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joël Riou

! This file was ported from Lean 3 source module algebraic_topology.dold_kan.compatibility
! leanprover-community/mathlib commit 160f568dcf772b2477791c844fc605f2f91f73d1
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Equivalence

/-! Tools for compatibilities between Dold-Kan equivalences

The purpose of this file is to introduce tools which will enable the
construction of the Dold-Kan equivalence `simplicial_object C ≌ chain_complex C ℕ`
for a pseudoabelian category `C` from the equivalence
`karoubi (simplicial_object C) ≌ karoubi (chain_complex C ℕ)` and the two
equivalences `simplicial_object C ≅ karoubi (simplicial_object C)` and
`chain_complex C ℕ ≅ karoubi (chain_complex C ℕ)`.

It is certainly possible to get an equivalence `simplicial_object C ≌ chain_complex C ℕ`
using a compositions of the three equivalences above, but then neither the functor
nor the inverse would have good definitional properties. For example, it would be better
if the inverse functor of the equivalence was exactly the functor
`Γ₀ : simplicial_object C ⥤ chain_complex C ℕ` which was constructed in `functor_gamma.lean`.

In this file, given four categories `A`, `A'`, `B`, `B'`, equivalences `eA : A ≅ A'`,
`eB : B ≅ B'`, `e' : A' ≅ B'`, functors `F : A ⥤ B'`, `G : B ⥤ A` equipped with certain
compatibilities, we construct successive equivalences:
- `equivalence₀` from `A` to `B'`, which is the composition of `eA` and `e'`.
- `equivalence₁` from `A` to `B'`, with the same inverse functor as `equivalence₀`,
but whose functor is `F`.
- `equivalence₂` from `A` to `B`, which is the composition of `equivalence₁` and the
inverse of `eB`:
- `equivalence` from `A` to `B`, which has the same functor `F ⋙ eB.inverse` as `equivalence₂`,
but whose inverse functor is `G`.

When extra assumptions are given, we shall also provide simplification lemmas for the
unit and counit isomorphisms of `equivalence`. (TODO)

-/


open CategoryTheory CategoryTheory.Category

namespace AlgebraicTopology

namespace DoldKan

namespace Compatibility

variable {A A' B B' : Type _} [Category A] [Category A'] [Category B] [Category B'] (eA : A ≌ A')
  (eB : B ≌ B') (e' : A' ≌ B') {F : A ⥤ B'} (hF : eA.Functor ⋙ e'.Functor ≅ F) {G : B ⥤ A}
  (hG : eB.Functor ⋙ e'.inverse ≅ G ⋙ eA.Functor)

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₀ -> AlgebraicTopology.DoldKan.Compatibility.equivalence₀ is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'], (CategoryTheory.Equivalence.{u4, u5, u1, u2} A _inst_1 A' _inst_2) -> (CategoryTheory.Equivalence.{u5, u6, u2, u3} A' _inst_2 B' _inst_4) -> (CategoryTheory.Equivalence.{u4, u6, u1, u3} A _inst_1 B' _inst_4)
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'], (CategoryTheory.Equivalence.{u4, u5, u1, u2} A A' _inst_1 _inst_2) -> (CategoryTheory.Equivalence.{u5, u6, u2, u3} A' B' _inst_2 _inst_4) -> (CategoryTheory.Equivalence.{u4, u6, u1, u3} A B' _inst_1 _inst_4)
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₀ AlgebraicTopology.DoldKan.Compatibility.equivalence₀ₓ'. -/
/-- A basic equivalence `A ≅ B'` obtained by composing `eA : A ≅ A'` and `e' : A' ≅ B'`. -/
@[simps Functor inverse unit_iso_hom_app]
def equivalence₀ : A ≌ B' :=
  eA.trans e'
#align algebraic_topology.dold_kan.compatibility.equivalence₀ AlgebraicTopology.DoldKan.Compatibility.equivalence₀

include hF

variable {eA} {e'}

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₁ -> AlgebraicTopology.DoldKan.Compatibility.equivalence₁ is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'] {eA : CategoryTheory.Equivalence.{u4, u5, u1, u2} A _inst_1 A' _inst_2} {e' : CategoryTheory.Equivalence.{u5, u6, u2, u3} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u6, max u4 u6 u1 u3} (CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u5, u6, u1, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u5, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u5, u6, u2, u3} A' _inst_2 B' _inst_4 e')) F) -> (CategoryTheory.Equivalence.{u4, u6, u1, u3} A _inst_1 B' _inst_4)
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'] {eA : CategoryTheory.Equivalence.{u4, u5, u1, u2} A A' _inst_1 _inst_2} {e' : CategoryTheory.Equivalence.{u5, u6, u2, u3} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u6, max (max (max u3 u1) u6) u4} (CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u5, u6, u1, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u5, u1, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u5, u6, u2, u3} A' B' _inst_2 _inst_4 e')) F) -> (CategoryTheory.Equivalence.{u4, u6, u1, u3} A B' _inst_1 _inst_4)
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₁ AlgebraicTopology.DoldKan.Compatibility.equivalence₁ₓ'. -/
/-- An intermediate equivalence `A ≅ B'` whose functor is `F` and whose inverse is
`e'.inverse ⋙ eA.inverse`. -/
@[simps Functor]
def equivalence₁ : A ≌ B' :=
  letI : is_equivalence F :=
    is_equivalence.of_iso hF (is_equivalence.of_equivalence (equivalence₀ eA e'))
  F.as_equivalence
#align algebraic_topology.dold_kan.compatibility.equivalence₁ AlgebraicTopology.DoldKan.Compatibility.equivalence₁

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₁_inverse -> AlgebraicTopology.DoldKan.Compatibility.equivalence₁_inverse is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'] {eA : CategoryTheory.Equivalence.{u4, u5, u1, u2} A _inst_1 A' _inst_2} {e' : CategoryTheory.Equivalence.{u5, u6, u2, u3} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u1 u6, max u4 u6 u1 u3} (CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u5, u6, u1, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u5, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u5, u6, u2, u3} A' _inst_2 B' _inst_4 e')) F), Eq.{succ (max u6 u4 u3 u1)} (CategoryTheory.Functor.{u6, u4, u3, u1} B' _inst_4 A _inst_1) (CategoryTheory.Equivalence.inverse.{u4, u6, u1, u3} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (CategoryTheory.Functor.comp.{u6, u5, u4, u3, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u5, u6, u2, u3} A' _inst_2 B' _inst_4 e') (CategoryTheory.Equivalence.inverse.{u4, u5, u1, u2} A _inst_1 A' _inst_2 eA))
but is expected to have type
  forall {A : Type.{u6}} {A' : Type.{u2}} {B' : Type.{u5}} [_inst_1 : CategoryTheory.Category.{u4, u6} A] [_inst_2 : CategoryTheory.Category.{u1, u2} A'] [_inst_4 : CategoryTheory.Category.{u3, u5} B'] {eA : CategoryTheory.Equivalence.{u4, u1, u6, u2} A A' _inst_1 _inst_2} {e' : CategoryTheory.Equivalence.{u1, u3, u2, u5} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u4, u3, u6, u5} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u6 u3, max (max (max u5 u6) u3) u4} (CategoryTheory.Functor.{u4, u3, u6, u5} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u3, u6, u5} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u1, u3, u6, u2, u5} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u1, u6, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u5} A' B' _inst_2 _inst_4 e')) F), Eq.{max (max (max (succ u6) (succ u5)) (succ u4)) (succ u3)} (CategoryTheory.Functor.{u3, u4, u5, u6} B' _inst_4 A _inst_1) (CategoryTheory.Equivalence.inverse.{u4, u3, u6, u5} A B' _inst_1 _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u6, u2, u5, u4, u1, u3} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (CategoryTheory.Functor.comp.{u3, u1, u4, u5, u2, u6} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u5} A' B' _inst_2 _inst_4 e') (CategoryTheory.Equivalence.inverse.{u4, u1, u6, u2} A A' _inst_1 _inst_2 eA))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₁_inverse AlgebraicTopology.DoldKan.Compatibility.equivalence₁_inverseₓ'. -/
theorem equivalence₁_inverse : (equivalence₁ hF).inverse = e'.inverse ⋙ eA.inverse :=
  rfl
#align algebraic_topology.dold_kan.compatibility.equivalence₁_inverse AlgebraicTopology.DoldKan.Compatibility.equivalence₁_inverse

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₁_counit_iso -> AlgebraicTopology.DoldKan.Compatibility.equivalence₁CounitIso is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'] {eA : CategoryTheory.Equivalence.{u4, u5, u1, u2} A _inst_1 A' _inst_2} {e' : CategoryTheory.Equivalence.{u5, u6, u2, u3} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u6, max u4 u6 u1 u3} (CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u5, u6, u1, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u5, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u5, u6, u2, u3} A' _inst_2 B' _inst_4 e')) F) -> (CategoryTheory.Iso.{max u3 u6, max u6 u3} (CategoryTheory.Functor.{u6, u6, u3, u3} B' _inst_4 B' _inst_4) (CategoryTheory.Functor.category.{u6, u6, u3, u3} B' _inst_4 B' _inst_4) (CategoryTheory.Functor.comp.{u6, u4, u6, u3, u1, u3} B' _inst_4 A _inst_1 B' _inst_4 (CategoryTheory.Functor.comp.{u6, u5, u4, u3, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u5, u6, u2, u3} A' _inst_2 B' _inst_4 e') (CategoryTheory.Equivalence.inverse.{u4, u5, u1, u2} A _inst_1 A' _inst_2 eA)) F) (CategoryTheory.Functor.id.{u6, u3} B' _inst_4))
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'] {eA : CategoryTheory.Equivalence.{u4, u5, u1, u2} A A' _inst_1 _inst_2} {e' : CategoryTheory.Equivalence.{u5, u6, u2, u3} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u6, max (max (max u3 u1) u6) u4} (CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u5, u6, u1, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u5, u1, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u5, u6, u2, u3} A' B' _inst_2 _inst_4 e')) F) -> (CategoryTheory.Iso.{max u3 u6, max u3 u6} (CategoryTheory.Functor.{u6, u6, u3, u3} B' _inst_4 B' _inst_4) (CategoryTheory.Functor.category.{u6, u6, u3, u3} B' _inst_4 B' _inst_4) (CategoryTheory.Functor.comp.{u6, u4, u6, u3, u1, u3} B' _inst_4 A _inst_1 B' _inst_4 (CategoryTheory.Functor.comp.{u6, u5, u4, u3, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u5, u6, u2, u3} A' B' _inst_2 _inst_4 e') (CategoryTheory.Equivalence.inverse.{u4, u5, u1, u2} A A' _inst_1 _inst_2 eA)) F) (CategoryTheory.Functor.id.{u6, u3} B' _inst_4))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₁_counit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence₁CounitIsoₓ'. -/
/-- The counit isomorphism of the equivalence `equivalence₁` between `A` and `B'`. -/
@[simps]
def equivalence₁CounitIso : (e'.inverse ⋙ eA.inverse) ⋙ F ≅ 𝟭 B' :=
  calc
    (e'.inverse ⋙ eA.inverse) ⋙ F ≅ (e'.inverse ⋙ eA.inverse) ⋙ eA.Functor ⋙ e'.Functor :=
      isoWhiskerLeft _ hF.symm
    _ ≅ e'.inverse ⋙ (eA.inverse ⋙ eA.Functor) ⋙ e'.Functor := (Iso.refl _)
    _ ≅ e'.inverse ⋙ 𝟭 _ ⋙ e'.Functor := (isoWhiskerLeft _ (isoWhiskerRight eA.counitIso _))
    _ ≅ e'.inverse ⋙ e'.Functor := (Iso.refl _)
    _ ≅ 𝟭 B' := e'.counitIso
    
#align algebraic_topology.dold_kan.compatibility.equivalence₁_counit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence₁CounitIso

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₁_counit_iso_eq -> AlgebraicTopology.DoldKan.Compatibility.equivalence₁CounitIso_eq is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'] {eA : CategoryTheory.Equivalence.{u4, u5, u1, u2} A _inst_1 A' _inst_2} {e' : CategoryTheory.Equivalence.{u5, u6, u2, u3} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u1 u6, max u4 u6 u1 u3} (CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u5, u6, u1, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u5, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u5, u6, u2, u3} A' _inst_2 B' _inst_4 e')) F), Eq.{succ (max u3 u6)} (CategoryTheory.Iso.{max u3 u6, max u6 u3} (CategoryTheory.Functor.{u6, u6, u3, u3} B' _inst_4 B' _inst_4) (CategoryTheory.Functor.category.{u6, u6, u3, u3} B' _inst_4 B' _inst_4) (CategoryTheory.Functor.comp.{u6, u4, u6, u3, u1, u3} B' _inst_4 A _inst_1 B' _inst_4 (CategoryTheory.Equivalence.inverse.{u4, u6, u1, u3} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (CategoryTheory.Equivalence.functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF))) (CategoryTheory.Functor.id.{u6, u3} B' _inst_4)) (CategoryTheory.Equivalence.counitIso.{u4, u6, u1, u3} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (AlgebraicTopology.DoldKan.Compatibility.equivalence₁CounitIso.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' (CategoryTheory.Equivalence.functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) hF)
but is expected to have type
  forall {A : Type.{u3}} {A' : Type.{u2}} {B' : Type.{u6}} [_inst_1 : CategoryTheory.Category.{u4, u3} A] [_inst_2 : CategoryTheory.Category.{u1, u2} A'] [_inst_4 : CategoryTheory.Category.{u5, u6} B'] {eA : CategoryTheory.Equivalence.{u4, u1, u3, u2} A A' _inst_1 _inst_2} {e' : CategoryTheory.Equivalence.{u1, u5, u2, u6} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u4, u5, u3, u6} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u3 u5, max (max (max u6 u3) u5) u4} (CategoryTheory.Functor.{u4, u5, u3, u6} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u5, u3, u6} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u1, u5, u3, u2, u6} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u1, u3, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u1, u5, u2, u6} A' B' _inst_2 _inst_4 e')) F), Eq.{max (succ u6) (succ u5)} (CategoryTheory.Iso.{max u6 u5, max u6 u5} (CategoryTheory.Functor.{u5, u5, u6, u6} B' _inst_4 B' _inst_4) (CategoryTheory.Functor.category.{u5, u5, u6, u6} B' _inst_4 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u4, u5, u6, u3, u6} B' _inst_4 A _inst_1 B' _inst_4 (CategoryTheory.Equivalence.inverse.{u4, u5, u3, u6} A B' _inst_1 _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u3, u2, u6, u4, u1, u5} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (CategoryTheory.Equivalence.functor.{u4, u5, u3, u6} A B' _inst_1 _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u3, u2, u6, u4, u1, u5} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF))) (CategoryTheory.Functor.id.{u5, u6} B' _inst_4)) (CategoryTheory.Equivalence.counitIso.{u4, u5, u3, u6} A B' _inst_1 _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u3, u2, u6, u4, u1, u5} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (AlgebraicTopology.DoldKan.Compatibility.equivalence₁CounitIso.{u3, u2, u6, u4, u1, u5} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₁_counit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence₁CounitIso_eqₓ'. -/
theorem equivalence₁CounitIso_eq : (equivalence₁ hF).counitIso = equivalence₁CounitIso hF :=
  by
  ext Y
  dsimp [equivalence₀, equivalence₁, is_equivalence.inverse, is_equivalence.of_equivalence]
  simp only [equivalence₁_counit_iso_hom_app, CategoryTheory.Functor.map_id, comp_id]
#align algebraic_topology.dold_kan.compatibility.equivalence₁_counit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence₁CounitIso_eq

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₁_unit_iso -> AlgebraicTopology.DoldKan.Compatibility.equivalence₁UnitIso is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'] {eA : CategoryTheory.Equivalence.{u4, u5, u1, u2} A _inst_1 A' _inst_2} {e' : CategoryTheory.Equivalence.{u5, u6, u2, u3} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u6, max u4 u6 u1 u3} (CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u5, u6, u1, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u5, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u5, u6, u2, u3} A' _inst_2 B' _inst_4 e')) F) -> (CategoryTheory.Iso.{max u1 u4, max u4 u1} (CategoryTheory.Functor.{u4, u4, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.category.{u4, u4, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.id.{u4, u1} A _inst_1) (CategoryTheory.Functor.comp.{u4, u6, u4, u1, u3, u1} A _inst_1 B' _inst_4 A _inst_1 F (CategoryTheory.Functor.comp.{u6, u5, u4, u3, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u5, u6, u2, u3} A' _inst_2 B' _inst_4 e') (CategoryTheory.Equivalence.inverse.{u4, u5, u1, u2} A _inst_1 A' _inst_2 eA))))
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'] {eA : CategoryTheory.Equivalence.{u4, u5, u1, u2} A A' _inst_1 _inst_2} {e' : CategoryTheory.Equivalence.{u5, u6, u2, u3} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u6, max (max (max u3 u1) u6) u4} (CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u5, u6, u1, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u5, u1, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u5, u6, u2, u3} A' B' _inst_2 _inst_4 e')) F) -> (CategoryTheory.Iso.{max u1 u4, max u1 u4} (CategoryTheory.Functor.{u4, u4, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.category.{u4, u4, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.id.{u4, u1} A _inst_1) (CategoryTheory.Functor.comp.{u4, u6, u4, u1, u3, u1} A _inst_1 B' _inst_4 A _inst_1 F (CategoryTheory.Functor.comp.{u6, u5, u4, u3, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u5, u6, u2, u3} A' B' _inst_2 _inst_4 e') (CategoryTheory.Equivalence.inverse.{u4, u5, u1, u2} A A' _inst_1 _inst_2 eA))))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₁_unit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence₁UnitIsoₓ'. -/
/-- The unit isomorphism of the equivalence `equivalence₁` between `A` and `B'`. -/
@[simps]
def equivalence₁UnitIso : 𝟭 A ≅ F ⋙ e'.inverse ⋙ eA.inverse :=
  calc
    𝟭 A ≅ eA.Functor ⋙ eA.inverse := eA.unitIso
    _ ≅ eA.Functor ⋙ 𝟭 A' ⋙ eA.inverse := (Iso.refl _)
    _ ≅ eA.Functor ⋙ (e'.Functor ⋙ e'.inverse) ⋙ eA.inverse :=
      (isoWhiskerLeft _ (isoWhiskerRight e'.unitIso _))
    _ ≅ (eA.Functor ⋙ e'.Functor) ⋙ e'.inverse ⋙ eA.inverse := (Iso.refl _)
    _ ≅ F ⋙ e'.inverse ⋙ eA.inverse := isoWhiskerRight hF _
    
#align algebraic_topology.dold_kan.compatibility.equivalence₁_unit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence₁UnitIso

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₁_unit_iso_eq -> AlgebraicTopology.DoldKan.Compatibility.equivalence₁UnitIso_eq is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u4, u1} A] [_inst_2 : CategoryTheory.Category.{u5, u2} A'] [_inst_4 : CategoryTheory.Category.{u6, u3} B'] {eA : CategoryTheory.Equivalence.{u4, u5, u1, u2} A _inst_1 A' _inst_2} {e' : CategoryTheory.Equivalence.{u5, u6, u2, u3} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u1 u6, max u4 u6 u1 u3} (CategoryTheory.Functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u4, u6, u1, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u4, u5, u6, u1, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u4, u5, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u5, u6, u2, u3} A' _inst_2 B' _inst_4 e')) F), Eq.{succ (max u1 u4)} (CategoryTheory.Iso.{max u1 u4, max u4 u1} (CategoryTheory.Functor.{u4, u4, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.category.{u4, u4, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.id.{u4, u1} A _inst_1) (CategoryTheory.Functor.comp.{u4, u6, u4, u1, u3, u1} A _inst_1 B' _inst_4 A _inst_1 (CategoryTheory.Equivalence.functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (CategoryTheory.Equivalence.inverse.{u4, u6, u1, u3} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)))) (CategoryTheory.Equivalence.unitIso.{u4, u6, u1, u3} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (AlgebraicTopology.DoldKan.Compatibility.equivalence₁UnitIso.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' (CategoryTheory.Equivalence.functor.{u4, u6, u1, u3} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u3, u4, u5, u6} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) hF)
but is expected to have type
  forall {A : Type.{u6}} {A' : Type.{u2}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u5, u6} A] [_inst_2 : CategoryTheory.Category.{u1, u2} A'] [_inst_4 : CategoryTheory.Category.{u4, u3} B'] {eA : CategoryTheory.Equivalence.{u5, u1, u6, u2} A A' _inst_1 _inst_2} {e' : CategoryTheory.Equivalence.{u1, u4, u2, u3} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u5, u4, u6, u3} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u6 u4, max (max (max u3 u6) u4) u5} (CategoryTheory.Functor.{u5, u4, u6, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u4, u6, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u1, u4, u6, u2, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u1, u6, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u1, u4, u2, u3} A' B' _inst_2 _inst_4 e')) F), Eq.{max (succ u6) (succ u5)} (CategoryTheory.Iso.{max u6 u5, max u6 u5} (CategoryTheory.Functor.{u5, u5, u6, u6} A _inst_1 A _inst_1) (CategoryTheory.Functor.category.{u5, u5, u6, u6} A _inst_1 A _inst_1) (CategoryTheory.Functor.id.{u5, u6} A _inst_1) (CategoryTheory.Functor.comp.{u5, u4, u5, u6, u3, u6} A _inst_1 B' _inst_4 A _inst_1 (CategoryTheory.Equivalence.functor.{u5, u4, u6, u3} A B' _inst_1 _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u6, u2, u3, u5, u1, u4} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (CategoryTheory.Equivalence.inverse.{u5, u4, u6, u3} A B' _inst_1 _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u6, u2, u3, u5, u1, u4} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)))) (CategoryTheory.Equivalence.unitIso.{u5, u4, u6, u3} A B' _inst_1 _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u6, u2, u3, u5, u1, u4} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) (AlgebraicTopology.DoldKan.Compatibility.equivalence₁UnitIso.{u6, u2, u3, u5, u1, u4} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₁_unit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence₁UnitIso_eqₓ'. -/
theorem equivalence₁UnitIso_eq : (equivalence₁ hF).unitIso = equivalence₁UnitIso hF :=
  by
  ext X
  dsimp [equivalence₀, equivalence₁, nat_iso.hcomp, is_equivalence.of_equivalence]
  simp only [id_comp, assoc, equivalence₁_unit_iso_hom_app]
#align algebraic_topology.dold_kan.compatibility.equivalence₁_unit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence₁UnitIso_eq

include eB

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₂ -> AlgebraicTopology.DoldKan.Compatibility.equivalence₂ is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A _inst_1 A' _inst_2}, (CategoryTheory.Equivalence.{u7, u8, u3, u4} B _inst_3 B' _inst_4) -> (forall {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u8, max u5 u8 u1 u4} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) F) -> (CategoryTheory.Equivalence.{u5, u7, u1, u3} A _inst_1 B _inst_3))
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A A' _inst_1 _inst_2}, (CategoryTheory.Equivalence.{u7, u8, u3, u4} B B' _inst_3 _inst_4) -> (forall {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u8, max (max (max u4 u1) u8) u5} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' B' _inst_2 _inst_4 e')) F) -> (CategoryTheory.Equivalence.{u5, u7, u1, u3} A B _inst_1 _inst_3))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₂ AlgebraicTopology.DoldKan.Compatibility.equivalence₂ₓ'. -/
/-- An intermediate equivalence `A ≅ B` obtained as the composition of `equivalence₁` and
the inverse of `eB : B ≌ B'`. -/
@[simps Functor]
def equivalence₂ : A ≌ B :=
  (equivalence₁ hF).trans eB.symm
#align algebraic_topology.dold_kan.compatibility.equivalence₂ AlgebraicTopology.DoldKan.Compatibility.equivalence₂

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₂_inverse -> AlgebraicTopology.DoldKan.Compatibility.equivalence₂_inverse is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A _inst_1 A' _inst_2} (eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B _inst_3 B' _inst_4) {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u1 u8, max u5 u8 u1 u4} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) F), Eq.{succ (max u7 u5 u3 u1)} (CategoryTheory.Functor.{u7, u5, u3, u1} B _inst_3 A _inst_1) (CategoryTheory.Equivalence.inverse.{u5, u7, u1, u3} A _inst_1 B _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (CategoryTheory.Functor.comp.{u7, u8, u5, u3, u4, u1} B _inst_3 B' _inst_4 A _inst_1 (CategoryTheory.Equivalence.functor.{u7, u8, u3, u4} B _inst_3 B' _inst_4 eB) (CategoryTheory.Functor.comp.{u8, u6, u5, u4, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e') (CategoryTheory.Equivalence.inverse.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA)))
but is expected to have type
  forall {A : Type.{u8}} {A' : Type.{u4}} {B : Type.{u7}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u6, u8} A] [_inst_2 : CategoryTheory.Category.{u2, u4} A'] [_inst_3 : CategoryTheory.Category.{u5, u7} B] [_inst_4 : CategoryTheory.Category.{u1, u3} B'] {eA : CategoryTheory.Equivalence.{u6, u2, u8, u4} A A' _inst_1 _inst_2} (eB : CategoryTheory.Equivalence.{u5, u1, u7, u3} B B' _inst_3 _inst_4) {e' : CategoryTheory.Equivalence.{u2, u1, u4, u3} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u6, u1, u8, u3} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u8 u1, max (max (max u3 u8) u1) u6} (CategoryTheory.Functor.{u6, u1, u8, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u6, u1, u8, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u6, u2, u1, u8, u4, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u6, u2, u8, u4} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u2, u1, u4, u3} A' B' _inst_2 _inst_4 e')) F), Eq.{max (max (max (succ u8) (succ u7)) (succ u6)) (succ u5)} (CategoryTheory.Functor.{u5, u6, u7, u8} B _inst_3 A _inst_1) (CategoryTheory.Equivalence.inverse.{u6, u5, u8, u7} A B _inst_1 _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u8, u4, u7, u3, u6, u2, u5, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (CategoryTheory.Functor.comp.{u5, u1, u6, u7, u3, u8} B _inst_3 B' _inst_4 A _inst_1 (CategoryTheory.Equivalence.functor.{u5, u1, u7, u3} B B' _inst_3 _inst_4 eB) (CategoryTheory.Functor.comp.{u1, u2, u6, u3, u4, u8} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u2, u1, u4, u3} A' B' _inst_2 _inst_4 e') (CategoryTheory.Equivalence.inverse.{u6, u2, u8, u4} A A' _inst_1 _inst_2 eA)))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₂_inverse AlgebraicTopology.DoldKan.Compatibility.equivalence₂_inverseₓ'. -/
theorem equivalence₂_inverse :
    (equivalence₂ eB hF).inverse = eB.Functor ⋙ e'.inverse ⋙ eA.inverse :=
  rfl
#align algebraic_topology.dold_kan.compatibility.equivalence₂_inverse AlgebraicTopology.DoldKan.Compatibility.equivalence₂_inverse

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₂_counit_iso -> AlgebraicTopology.DoldKan.Compatibility.equivalence₂CounitIso is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A _inst_1 A' _inst_2} (eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B _inst_3 B' _inst_4) {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u8, max u5 u8 u1 u4} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) F) -> (CategoryTheory.Iso.{max u3 u7, max u7 u3} (CategoryTheory.Functor.{u7, u7, u3, u3} B _inst_3 B _inst_3) (CategoryTheory.Functor.category.{u7, u7, u3, u3} B _inst_3 B _inst_3) (CategoryTheory.Functor.comp.{u7, u5, u7, u3, u1, u3} B _inst_3 A _inst_1 B _inst_3 (CategoryTheory.Functor.comp.{u7, u8, u5, u3, u4, u1} B _inst_3 B' _inst_4 A _inst_1 (CategoryTheory.Equivalence.functor.{u7, u8, u3, u4} B _inst_3 B' _inst_4 eB) (CategoryTheory.Functor.comp.{u8, u6, u5, u4, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e') (CategoryTheory.Equivalence.inverse.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA))) (CategoryTheory.Functor.comp.{u5, u8, u7, u1, u4, u3} A _inst_1 B' _inst_4 B _inst_3 F (CategoryTheory.Equivalence.inverse.{u7, u8, u3, u4} B _inst_3 B' _inst_4 eB))) (CategoryTheory.Functor.id.{u7, u3} B _inst_3))
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A A' _inst_1 _inst_2} (eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B B' _inst_3 _inst_4) {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u8, max (max (max u4 u1) u8) u5} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' B' _inst_2 _inst_4 e')) F) -> (CategoryTheory.Iso.{max u3 u7, max u3 u7} (CategoryTheory.Functor.{u7, u7, u3, u3} B _inst_3 B _inst_3) (CategoryTheory.Functor.category.{u7, u7, u3, u3} B _inst_3 B _inst_3) (CategoryTheory.Functor.comp.{u7, u5, u7, u3, u1, u3} B _inst_3 A _inst_1 B _inst_3 (CategoryTheory.Functor.comp.{u7, u8, u5, u3, u4, u1} B _inst_3 B' _inst_4 A _inst_1 (CategoryTheory.Equivalence.functor.{u7, u8, u3, u4} B B' _inst_3 _inst_4 eB) (CategoryTheory.Functor.comp.{u8, u6, u5, u4, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u6, u8, u2, u4} A' B' _inst_2 _inst_4 e') (CategoryTheory.Equivalence.inverse.{u5, u6, u1, u2} A A' _inst_1 _inst_2 eA))) (CategoryTheory.Functor.comp.{u5, u8, u7, u1, u4, u3} A _inst_1 B' _inst_4 B _inst_3 F (CategoryTheory.Equivalence.inverse.{u7, u8, u3, u4} B B' _inst_3 _inst_4 eB))) (CategoryTheory.Functor.id.{u7, u3} B _inst_3))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₂_counit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence₂CounitIsoₓ'. -/
/-- The counit isomorphism of the equivalence `equivalence₂` between `A` and `B`. -/
@[simps]
def equivalence₂CounitIso : (eB.Functor ⋙ e'.inverse ⋙ eA.inverse) ⋙ F ⋙ eB.inverse ≅ 𝟭 B :=
  calc
    (eB.Functor ⋙ e'.inverse ⋙ eA.inverse) ⋙ F ⋙ eB.inverse ≅
        eB.Functor ⋙ (e'.inverse ⋙ eA.inverse ⋙ F) ⋙ eB.inverse :=
      Iso.refl _
    _ ≅ eB.Functor ⋙ 𝟭 _ ⋙ eB.inverse :=
      (isoWhiskerLeft _ (isoWhiskerRight (equivalence₁CounitIso hF) _))
    _ ≅ eB.Functor ⋙ eB.inverse := (Iso.refl _)
    _ ≅ 𝟭 B := eB.unitIso.symm
    
#align algebraic_topology.dold_kan.compatibility.equivalence₂_counit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence₂CounitIso

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₂_counit_iso_eq -> AlgebraicTopology.DoldKan.Compatibility.equivalence₂CounitIso_eq is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A _inst_1 A' _inst_2} (eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B _inst_3 B' _inst_4) {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u1 u8, max u5 u8 u1 u4} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) F), Eq.{succ (max u3 u7)} (CategoryTheory.Iso.{max u3 u7, max u7 u3} (CategoryTheory.Functor.{u7, u7, u3, u3} B _inst_3 B _inst_3) (CategoryTheory.Functor.category.{u7, u7, u3, u3} B _inst_3 B _inst_3) (CategoryTheory.Functor.comp.{u7, u5, u7, u3, u1, u3} B _inst_3 A _inst_1 B _inst_3 (CategoryTheory.Equivalence.inverse.{u5, u7, u1, u3} A _inst_1 B _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (CategoryTheory.Equivalence.functor.{u5, u7, u1, u3} A _inst_1 B _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF))) (CategoryTheory.Functor.id.{u7, u3} B _inst_3)) (CategoryTheory.Equivalence.counitIso.{u5, u7, u1, u3} A _inst_1 B _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (AlgebraicTopology.DoldKan.Compatibility.equivalence₂CounitIso.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' (CategoryTheory.Equivalence.functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u4, u5, u6, u8} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) hF)
but is expected to have type
  forall {A : Type.{u5}} {A' : Type.{u4}} {B : Type.{u8}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u6, u5} A] [_inst_2 : CategoryTheory.Category.{u2, u4} A'] [_inst_3 : CategoryTheory.Category.{u7, u8} B] [_inst_4 : CategoryTheory.Category.{u1, u3} B'] {eA : CategoryTheory.Equivalence.{u6, u2, u5, u4} A A' _inst_1 _inst_2} (eB : CategoryTheory.Equivalence.{u7, u1, u8, u3} B B' _inst_3 _inst_4) {e' : CategoryTheory.Equivalence.{u2, u1, u4, u3} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u6, u1, u5, u3} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u5 u1, max (max (max u3 u5) u1) u6} (CategoryTheory.Functor.{u6, u1, u5, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u6, u1, u5, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u6, u2, u1, u5, u4, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u6, u2, u5, u4} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u2, u1, u4, u3} A' B' _inst_2 _inst_4 e')) F), Eq.{max (succ u8) (succ u7)} (CategoryTheory.Iso.{max u8 u7, max u8 u7} (CategoryTheory.Functor.{u7, u7, u8, u8} B _inst_3 B _inst_3) (CategoryTheory.Functor.category.{u7, u7, u8, u8} B _inst_3 B _inst_3) (CategoryTheory.Functor.comp.{u7, u6, u7, u8, u5, u8} B _inst_3 A _inst_1 B _inst_3 (CategoryTheory.Equivalence.inverse.{u6, u7, u5, u8} A B _inst_1 _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u5, u4, u8, u3, u6, u2, u7, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (CategoryTheory.Equivalence.functor.{u6, u7, u5, u8} A B _inst_1 _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u5, u4, u8, u3, u6, u2, u7, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF))) (CategoryTheory.Functor.id.{u7, u8} B _inst_3)) (CategoryTheory.Equivalence.counitIso.{u6, u7, u5, u8} A B _inst_1 _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u5, u4, u8, u3, u6, u2, u7, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (AlgebraicTopology.DoldKan.Compatibility.equivalence₂CounitIso.{u5, u4, u8, u3, u6, u2, u7, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₂_counit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence₂CounitIso_eqₓ'. -/
theorem equivalence₂CounitIso_eq : (equivalence₂ eB hF).counitIso = equivalence₂CounitIso eB hF :=
  by
  ext Y'
  dsimp [equivalence₂, iso.refl]
  simp only [equivalence₁_counit_iso_eq, equivalence₂_counit_iso_hom_app,
    equivalence₁_counit_iso_hom_app, functor.map_comp, assoc]
#align algebraic_topology.dold_kan.compatibility.equivalence₂_counit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence₂CounitIso_eq

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₂_unit_iso -> AlgebraicTopology.DoldKan.Compatibility.equivalence₂UnitIso is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A _inst_1 A' _inst_2} (eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B _inst_3 B' _inst_4) {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u8, max u5 u8 u1 u4} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) F) -> (CategoryTheory.Iso.{max u1 u5, max u5 u1} (CategoryTheory.Functor.{u5, u5, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.category.{u5, u5, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.id.{u5, u1} A _inst_1) (CategoryTheory.Functor.comp.{u5, u7, u5, u1, u3, u1} A _inst_1 B _inst_3 A _inst_1 (CategoryTheory.Functor.comp.{u5, u8, u7, u1, u4, u3} A _inst_1 B' _inst_4 B _inst_3 F (CategoryTheory.Equivalence.inverse.{u7, u8, u3, u4} B _inst_3 B' _inst_4 eB)) (CategoryTheory.Functor.comp.{u7, u8, u5, u3, u4, u1} B _inst_3 B' _inst_4 A _inst_1 (CategoryTheory.Equivalence.functor.{u7, u8, u3, u4} B _inst_3 B' _inst_4 eB) (CategoryTheory.Functor.comp.{u8, u6, u5, u4, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e') (CategoryTheory.Equivalence.inverse.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA)))))
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A A' _inst_1 _inst_2} (eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B B' _inst_3 _inst_4) {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u8, max (max (max u4 u1) u8) u5} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' B' _inst_2 _inst_4 e')) F) -> (CategoryTheory.Iso.{max u1 u5, max u1 u5} (CategoryTheory.Functor.{u5, u5, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.category.{u5, u5, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.id.{u5, u1} A _inst_1) (CategoryTheory.Functor.comp.{u5, u7, u5, u1, u3, u1} A _inst_1 B _inst_3 A _inst_1 (CategoryTheory.Functor.comp.{u5, u8, u7, u1, u4, u3} A _inst_1 B' _inst_4 B _inst_3 F (CategoryTheory.Equivalence.inverse.{u7, u8, u3, u4} B B' _inst_3 _inst_4 eB)) (CategoryTheory.Functor.comp.{u7, u8, u5, u3, u4, u1} B _inst_3 B' _inst_4 A _inst_1 (CategoryTheory.Equivalence.functor.{u7, u8, u3, u4} B B' _inst_3 _inst_4 eB) (CategoryTheory.Functor.comp.{u8, u6, u5, u4, u2, u1} B' _inst_4 A' _inst_2 A _inst_1 (CategoryTheory.Equivalence.inverse.{u6, u8, u2, u4} A' B' _inst_2 _inst_4 e') (CategoryTheory.Equivalence.inverse.{u5, u6, u1, u2} A A' _inst_1 _inst_2 eA)))))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₂_unit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence₂UnitIsoₓ'. -/
/-- The unit isomorphism of the equivalence `equivalence₂` between `A` and `B`. -/
@[simps]
def equivalence₂UnitIso : 𝟭 A ≅ (F ⋙ eB.inverse) ⋙ eB.Functor ⋙ e'.inverse ⋙ eA.inverse :=
  calc
    𝟭 A ≅ F ⋙ e'.inverse ⋙ eA.inverse := equivalence₁UnitIso hF
    _ ≅ F ⋙ 𝟭 B' ⋙ e'.inverse ⋙ eA.inverse := (Iso.refl _)
    _ ≅ F ⋙ (eB.inverse ⋙ eB.Functor) ⋙ e'.inverse ⋙ eA.inverse :=
      (isoWhiskerLeft _ (isoWhiskerRight eB.counitIso.symm _))
    _ ≅ (F ⋙ eB.inverse) ⋙ eB.Functor ⋙ e'.inverse ⋙ eA.inverse := Iso.refl _
    
#align algebraic_topology.dold_kan.compatibility.equivalence₂_unit_iso AlgebraicTopology.DoldKan.Compatibility.equivalence₂UnitIso

/- warning: algebraic_topology.dold_kan.compatibility.equivalence₂_unit_iso_eq -> AlgebraicTopology.DoldKan.Compatibility.equivalence₂UnitIso_eq is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A _inst_1 A' _inst_2} (eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B _inst_3 B' _inst_4) {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u1 u8, max u5 u8 u1 u4} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) F), Eq.{succ (max u1 u5)} (CategoryTheory.Iso.{max u1 u5, max u5 u1} (CategoryTheory.Functor.{u5, u5, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.category.{u5, u5, u1, u1} A _inst_1 A _inst_1) (CategoryTheory.Functor.id.{u5, u1} A _inst_1) (CategoryTheory.Functor.comp.{u5, u7, u5, u1, u3, u1} A _inst_1 B _inst_3 A _inst_1 (CategoryTheory.Equivalence.functor.{u5, u7, u1, u3} A _inst_1 B _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (CategoryTheory.Equivalence.inverse.{u5, u7, u1, u3} A _inst_1 B _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)))) (CategoryTheory.Equivalence.unitIso.{u5, u7, u1, u3} A _inst_1 B _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (AlgebraicTopology.DoldKan.Compatibility.equivalence₂UnitIso.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' (CategoryTheory.Equivalence.functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4 (AlgebraicTopology.DoldKan.Compatibility.equivalence₁.{u1, u2, u4, u5, u6, u8} A A' B' _inst_1 _inst_2 _inst_4 eA e' F hF)) hF)
but is expected to have type
  forall {A : Type.{u8}} {A' : Type.{u4}} {B : Type.{u5}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u7, u8} A] [_inst_2 : CategoryTheory.Category.{u2, u4} A'] [_inst_3 : CategoryTheory.Category.{u6, u5} B] [_inst_4 : CategoryTheory.Category.{u1, u3} B'] {eA : CategoryTheory.Equivalence.{u7, u2, u8, u4} A A' _inst_1 _inst_2} (eB : CategoryTheory.Equivalence.{u6, u1, u5, u3} B B' _inst_3 _inst_4) {e' : CategoryTheory.Equivalence.{u2, u1, u4, u3} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u7, u1, u8, u3} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u8 u1, max (max (max u3 u8) u1) u7} (CategoryTheory.Functor.{u7, u1, u8, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u7, u1, u8, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u7, u2, u1, u8, u4, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u7, u2, u8, u4} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u2, u1, u4, u3} A' B' _inst_2 _inst_4 e')) F), Eq.{max (succ u8) (succ u7)} (CategoryTheory.Iso.{max u8 u7, max u8 u7} (CategoryTheory.Functor.{u7, u7, u8, u8} A _inst_1 A _inst_1) (CategoryTheory.Functor.category.{u7, u7, u8, u8} A _inst_1 A _inst_1) (CategoryTheory.Functor.id.{u7, u8} A _inst_1) (CategoryTheory.Functor.comp.{u7, u6, u7, u8, u5, u8} A _inst_1 B _inst_3 A _inst_1 (CategoryTheory.Equivalence.functor.{u7, u6, u8, u5} A B _inst_1 _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u8, u4, u5, u3, u7, u2, u6, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (CategoryTheory.Equivalence.inverse.{u7, u6, u8, u5} A B _inst_1 _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u8, u4, u5, u3, u7, u2, u6, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)))) (CategoryTheory.Equivalence.unitIso.{u7, u6, u8, u5} A B _inst_1 _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence₂.{u8, u4, u5, u3, u7, u2, u6, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)) (AlgebraicTopology.DoldKan.Compatibility.equivalence₂UnitIso.{u8, u4, u5, u3, u7, u2, u6, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF)
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence₂_unit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence₂UnitIso_eqₓ'. -/
theorem equivalence₂UnitIso_eq : (equivalence₂ eB hF).unitIso = equivalence₂UnitIso eB hF :=
  by
  ext X
  dsimp [equivalence₂]
  simpa only [equivalence₂_unit_iso_hom_app, equivalence₁_unit_iso_eq,
    equivalence₁_unit_iso_hom_app, assoc, nat_iso.cancel_nat_iso_hom_left]
#align algebraic_topology.dold_kan.compatibility.equivalence₂_unit_iso_eq AlgebraicTopology.DoldKan.Compatibility.equivalence₂UnitIso_eq

variable {eB}

include hG

/- warning: algebraic_topology.dold_kan.compatibility.equivalence -> AlgebraicTopology.DoldKan.Compatibility.equivalence is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A _inst_1 A' _inst_2} {eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B _inst_3 B' _inst_4} {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u8, max u5 u8 u1 u4} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) F) -> (forall {G : CategoryTheory.Functor.{u7, u5, u3, u1} B _inst_3 A _inst_1}, (CategoryTheory.Iso.{max u3 u6, max u7 u6 u3 u2} (CategoryTheory.Functor.{u7, u6, u3, u2} B _inst_3 A' _inst_2) (CategoryTheory.Functor.category.{u7, u6, u3, u2} B _inst_3 A' _inst_2) (CategoryTheory.Functor.comp.{u7, u8, u6, u3, u4, u2} B _inst_3 B' _inst_4 A' _inst_2 (CategoryTheory.Equivalence.functor.{u7, u8, u3, u4} B _inst_3 B' _inst_4 eB) (CategoryTheory.Equivalence.inverse.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) (CategoryTheory.Functor.comp.{u7, u5, u6, u3, u1, u2} B _inst_3 A _inst_1 A' _inst_2 G (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA))) -> (CategoryTheory.Equivalence.{u5, u7, u1, u3} A _inst_1 B _inst_3))
but is expected to have type
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A A' _inst_1 _inst_2} {eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B B' _inst_3 _inst_4} {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4}, (CategoryTheory.Iso.{max u1 u8, max (max (max u4 u1) u8) u5} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' B' _inst_2 _inst_4 e')) F) -> (forall {G : CategoryTheory.Functor.{u7, u5, u3, u1} B _inst_3 A _inst_1}, (CategoryTheory.Iso.{max u3 u6, max (max (max u2 u3) u6) u7} (CategoryTheory.Functor.{u7, u6, u3, u2} B _inst_3 A' _inst_2) (CategoryTheory.Functor.category.{u7, u6, u3, u2} B _inst_3 A' _inst_2) (CategoryTheory.Functor.comp.{u7, u8, u6, u3, u4, u2} B _inst_3 B' _inst_4 A' _inst_2 (CategoryTheory.Equivalence.functor.{u7, u8, u3, u4} B B' _inst_3 _inst_4 eB) (CategoryTheory.Equivalence.inverse.{u6, u8, u2, u4} A' B' _inst_2 _inst_4 e')) (CategoryTheory.Functor.comp.{u7, u5, u6, u3, u1, u2} B _inst_3 A _inst_1 A' _inst_2 G (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A A' _inst_1 _inst_2 eA))) -> (CategoryTheory.Equivalence.{u5, u7, u1, u3} A B _inst_1 _inst_3))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence AlgebraicTopology.DoldKan.Compatibility.equivalenceₓ'. -/
/-- The equivalence `A ≅ B` whose functor is `F ⋙ eB.inverse` and
whose inverse is `G : B ≅ A`. -/
@[simps inverse]
def equivalence : A ≌ B :=
  letI : is_equivalence G :=
    by
    refine' is_equivalence.of_iso _ (is_equivalence.of_equivalence (equivalence₂ eB hF).symm)
    calc
      eB.functor ⋙ e'.inverse ⋙ eA.inverse ≅ (eB.functor ⋙ e'.inverse) ⋙ eA.inverse := iso.refl _
      _ ≅ (G ⋙ eA.functor) ⋙ eA.inverse := (iso_whisker_right hG _)
      _ ≅ G ⋙ 𝟭 A := (iso_whisker_left _ eA.unit_iso.symm)
      _ ≅ G := functor.right_unitor G
      
  G.as_equivalence.symm
#align algebraic_topology.dold_kan.compatibility.equivalence AlgebraicTopology.DoldKan.Compatibility.equivalence

/- warning: algebraic_topology.dold_kan.compatibility.equivalence_functor -> AlgebraicTopology.DoldKan.Compatibility.equivalence_functor is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {A' : Type.{u2}} {B : Type.{u3}} {B' : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u5, u1} A] [_inst_2 : CategoryTheory.Category.{u6, u2} A'] [_inst_3 : CategoryTheory.Category.{u7, u3} B] [_inst_4 : CategoryTheory.Category.{u8, u4} B'] {eA : CategoryTheory.Equivalence.{u5, u6, u1, u2} A _inst_1 A' _inst_2} {eB : CategoryTheory.Equivalence.{u7, u8, u3, u4} B _inst_3 B' _inst_4} {e' : CategoryTheory.Equivalence.{u6, u8, u2, u4} A' _inst_2 B' _inst_4} {F : CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u1 u8, max u5 u8 u1 u4} (CategoryTheory.Functor.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u5, u8, u1, u4} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u5, u6, u8, u1, u2, u4} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA) (CategoryTheory.Equivalence.functor.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) F) {G : CategoryTheory.Functor.{u7, u5, u3, u1} B _inst_3 A _inst_1} (hG : CategoryTheory.Iso.{max u3 u6, max u7 u6 u3 u2} (CategoryTheory.Functor.{u7, u6, u3, u2} B _inst_3 A' _inst_2) (CategoryTheory.Functor.category.{u7, u6, u3, u2} B _inst_3 A' _inst_2) (CategoryTheory.Functor.comp.{u7, u8, u6, u3, u4, u2} B _inst_3 B' _inst_4 A' _inst_2 (CategoryTheory.Equivalence.functor.{u7, u8, u3, u4} B _inst_3 B' _inst_4 eB) (CategoryTheory.Equivalence.inverse.{u6, u8, u2, u4} A' _inst_2 B' _inst_4 e')) (CategoryTheory.Functor.comp.{u7, u5, u6, u3, u1, u2} B _inst_3 A _inst_1 A' _inst_2 G (CategoryTheory.Equivalence.functor.{u5, u6, u1, u2} A _inst_1 A' _inst_2 eA))), Eq.{succ (max u5 u7 u1 u3)} (CategoryTheory.Functor.{u5, u7, u1, u3} A _inst_1 B _inst_3) (CategoryTheory.Equivalence.functor.{u5, u7, u1, u3} A _inst_1 B _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence.{u1, u2, u3, u4, u5, u6, u7, u8} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF G hG)) (CategoryTheory.Functor.comp.{u5, u8, u7, u1, u4, u3} A _inst_1 B' _inst_4 B _inst_3 F (CategoryTheory.Equivalence.inverse.{u7, u8, u3, u4} B _inst_3 B' _inst_4 eB))
but is expected to have type
  forall {A : Type.{u8}} {A' : Type.{u4}} {B : Type.{u7}} {B' : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u6, u8} A] [_inst_2 : CategoryTheory.Category.{u2, u4} A'] [_inst_3 : CategoryTheory.Category.{u5, u7} B] [_inst_4 : CategoryTheory.Category.{u1, u3} B'] {eA : CategoryTheory.Equivalence.{u6, u2, u8, u4} A A' _inst_1 _inst_2} {eB : CategoryTheory.Equivalence.{u5, u1, u7, u3} B B' _inst_3 _inst_4} {e' : CategoryTheory.Equivalence.{u2, u1, u4, u3} A' B' _inst_2 _inst_4} {F : CategoryTheory.Functor.{u6, u1, u8, u3} A _inst_1 B' _inst_4} (hF : CategoryTheory.Iso.{max u8 u1, max (max (max u3 u8) u1) u6} (CategoryTheory.Functor.{u6, u1, u8, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.category.{u6, u1, u8, u3} A _inst_1 B' _inst_4) (CategoryTheory.Functor.comp.{u6, u2, u1, u8, u4, u3} A _inst_1 A' _inst_2 B' _inst_4 (CategoryTheory.Equivalence.functor.{u6, u2, u8, u4} A A' _inst_1 _inst_2 eA) (CategoryTheory.Equivalence.functor.{u2, u1, u4, u3} A' B' _inst_2 _inst_4 e')) F) {G : CategoryTheory.Functor.{u5, u6, u7, u8} B _inst_3 A _inst_1} (hG : CategoryTheory.Iso.{max u7 u2, max (max (max u4 u7) u2) u5} (CategoryTheory.Functor.{u5, u2, u7, u4} B _inst_3 A' _inst_2) (CategoryTheory.Functor.category.{u5, u2, u7, u4} B _inst_3 A' _inst_2) (CategoryTheory.Functor.comp.{u5, u1, u2, u7, u3, u4} B _inst_3 B' _inst_4 A' _inst_2 (CategoryTheory.Equivalence.functor.{u5, u1, u7, u3} B B' _inst_3 _inst_4 eB) (CategoryTheory.Equivalence.inverse.{u2, u1, u4, u3} A' B' _inst_2 _inst_4 e')) (CategoryTheory.Functor.comp.{u5, u6, u2, u7, u8, u4} B _inst_3 A _inst_1 A' _inst_2 G (CategoryTheory.Equivalence.functor.{u6, u2, u8, u4} A A' _inst_1 _inst_2 eA))), Eq.{max (max (max (succ u8) (succ u7)) (succ u6)) (succ u5)} (CategoryTheory.Functor.{u6, u5, u8, u7} A _inst_1 B _inst_3) (CategoryTheory.Equivalence.functor.{u6, u5, u8, u7} A B _inst_1 _inst_3 (AlgebraicTopology.DoldKan.Compatibility.equivalence.{u8, u4, u7, u3, u6, u2, u5, u1} A A' B B' _inst_1 _inst_2 _inst_3 _inst_4 eA eB e' F hF G hG)) (CategoryTheory.Functor.comp.{u6, u1, u5, u8, u3, u7} A _inst_1 B' _inst_4 B _inst_3 F (CategoryTheory.Equivalence.inverse.{u5, u1, u7, u3} B B' _inst_3 _inst_4 eB))
Case conversion may be inaccurate. Consider using '#align algebraic_topology.dold_kan.compatibility.equivalence_functor AlgebraicTopology.DoldKan.Compatibility.equivalence_functorₓ'. -/
theorem equivalence_functor : (equivalence hF hG).Functor = F ⋙ eB.inverse :=
  rfl
#align algebraic_topology.dold_kan.compatibility.equivalence_functor AlgebraicTopology.DoldKan.Compatibility.equivalence_functor

end Compatibility

end DoldKan

end AlgebraicTopology

