/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin

! This file was ported from Lean 3 source module algebraic_geometry.prime_spectrum.basic
! leanprover-community/mathlib commit a87d22575d946e1e156fc1edd1e1269600a8a282
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.PunitInstances
import Mathbin.LinearAlgebra.Finsupp
import Mathbin.RingTheory.Ideal.Over
import Mathbin.RingTheory.Ideal.Prod
import Mathbin.RingTheory.Localization.Away.Basic
import Mathbin.RingTheory.Nilpotent
import Mathbin.Topology.Sets.Closeds
import Mathbin.Topology.Sober

/-!
# Prime spectrum of a commutative ring

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The prime spectrum of a commutative ring is the type of all prime ideals.
It is naturally endowed with a topology: the Zariski topology.

(It is also naturally endowed with a sheaf of rings,
which is constructed in `algebraic_geometry.structure_sheaf`.)

## Main definitions

* `prime_spectrum R`: The prime spectrum of a commutative ring `R`,
  i.e., the set of all prime ideals of `R`.
* `zero_locus s`: The zero locus of a subset `s` of `R`
  is the subset of `prime_spectrum R` consisting of all prime ideals that contain `s`.
* `vanishing_ideal t`: The vanishing ideal of a subset `t` of `prime_spectrum R`
  is the intersection of points in `t` (viewed as prime ideals).

## Conventions

We denote subsets of rings with `s`, `s'`, etc...
whereas we denote subsets of prime spectra with `t`, `t'`, etc...

## Inspiration/contributors

The contents of this file draw inspiration from <https://github.com/ramonfmir/lean-scheme>
which has contributions from Ramon Fernandez Mir, Kevin Buzzard, Kenny Lau,
and Chris Hughes (on an earlier repository).
-/


noncomputable section

open Classical

universe u v

variable (R : Type u) (S : Type v) [CommRing R] [CommRing S]

#print PrimeSpectrum /-
/-- The prime spectrum of a commutative ring `R` is the type of all prime ideals of `R`.

It is naturally endowed with a topology (the Zariski topology),
and a sheaf of commutative rings (see `algebraic_geometry.structure_sheaf`).
It is a fundamental building block in algebraic geometry. -/
@[ext]
structure PrimeSpectrum where
  asIdeal : Ideal R
  IsPrime : as_ideal.IsPrime
#align prime_spectrum PrimeSpectrum
-/

attribute [instance] PrimeSpectrum.isPrime

namespace PrimeSpectrum

variable {R S}

instance [Nontrivial R] : Nonempty <| PrimeSpectrum R :=
  let ⟨I, hI⟩ := Ideal.exists_maximal R
  ⟨⟨I, hI.IsPrime⟩⟩

#print PrimeSpectrum.pUnit /-
/-- The prime spectrum of the zero ring is empty. -/
theorem pUnit (x : PrimeSpectrum PUnit) : False :=
  x.1.ne_top_iff_one.1 x.2.1 <| Subsingleton.elim (0 : PUnit) 1 ▸ x.1.zero_mem
#align prime_spectrum.punit PrimeSpectrum.pUnit
-/

variable (R S)

/- warning: prime_spectrum.prime_spectrum_prod_of_sum -> PrimeSpectrum.primeSpectrumProdOfSum is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S], (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) -> (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2))
but is expected to have type
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S], (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) -> (PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.prime_spectrum_prod_of_sum PrimeSpectrum.primeSpectrumProdOfSumₓ'. -/
/-- The map from the direct sum of prime spectra to the prime spectrum of a direct product. -/
@[simp]
def primeSpectrumProdOfSum : Sum (PrimeSpectrum R) (PrimeSpectrum S) → PrimeSpectrum (R × S)
  | Sum.inl ⟨I, hI⟩ => ⟨Ideal.prod I ⊤, Ideal.isPrime_ideal_prod_top⟩
  | Sum.inr ⟨J, hJ⟩ => ⟨Ideal.prod ⊤ J, Ideal.isPrime_ideal_prod_top'⟩
#align prime_spectrum.prime_spectrum_prod_of_sum PrimeSpectrum.primeSpectrumProdOfSum

/- warning: prime_spectrum.prime_spectrum_prod -> PrimeSpectrum.primeSpectrumProd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S], Equiv.{succ (max u1 u2), max (succ u1) (succ u2)} (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2)) (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2))
but is expected to have type
  forall (R : Type.{u1}) (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S], Equiv.{succ (max u2 u1), max (succ u2) (succ u1)} (PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2)) (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.prime_spectrum_prod PrimeSpectrum.primeSpectrumProdₓ'. -/
/-- The prime spectrum of `R × S` is in bijection with the disjoint unions of the prime spectrum of
`R` and the prime spectrum of `S`. -/
noncomputable def primeSpectrumProd :
    PrimeSpectrum (R × S) ≃ Sum (PrimeSpectrum R) (PrimeSpectrum S) :=
  Equiv.symm <|
    Equiv.ofBijective (primeSpectrumProdOfSum R S)
      (by
        constructor
        · rintro (⟨I, hI⟩ | ⟨J, hJ⟩) (⟨I', hI'⟩ | ⟨J', hJ'⟩) h <;>
            simp only [Ideal.prod.ext_iff, prime_spectrum_prod_of_sum] at h
          · simp only [h]
          · exact False.elim (hI.ne_top h.left)
          · exact False.elim (hJ.ne_top h.right)
          · simp only [h]
        · rintro ⟨I, hI⟩
          rcases(Ideal.ideal_prod_prime I).mp hI with (⟨p, ⟨hp, rfl⟩⟩ | ⟨p, ⟨hp, rfl⟩⟩)
          · exact ⟨Sum.inl ⟨p, hp⟩, rfl⟩
          · exact ⟨Sum.inr ⟨p, hp⟩, rfl⟩)
#align prime_spectrum.prime_spectrum_prod PrimeSpectrum.primeSpectrumProd

variable {R S}

/- warning: prime_spectrum.prime_spectrum_prod_symm_inl_as_ideal -> PrimeSpectrum.primeSpectrumProd_symm_inl_asIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (x : PrimeSpectrum.{u1} R _inst_1), Eq.{succ (max u1 u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Ring.toSemiring.{max u1 u2} (Prod.{u1, u2} R S) (CommRing.toRing.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2)))) (PrimeSpectrum.asIdeal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2))) => (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) -> (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2))) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2)) (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.primeSpectrumProd.{u1, u2} R S _inst_1 _inst_2)) (Sum.inl.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) x))) (Ideal.prod.{u1, u2} R S (CommRing.toRing.{u1} R _inst_1) (CommRing.toRing.{u2} S _inst_2) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Submodule.hasTop.{u2, u2} S S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (x : PrimeSpectrum.{u1} R _inst_1), Eq.{max (succ u1) (succ u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (CommSemiring.toSemiring.{max u1 u2} (Prod.{u1, u2} R S) (CommRing.toCommSemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2)))) (PrimeSpectrum.asIdeal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2))) (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (fun (_x : Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) => PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2)) (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.primeSpectrumProd.{u1, u2} R S _inst_1 _inst_2)) (Sum.inl.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) x))) (Ideal.prod.{u1, u2} R S (CommRing.toRing.{u1} R _inst_1) (CommRing.toRing.{u2} S _inst_2) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (Top.top.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Submodule.instTopSubmodule.{u2, u2} S S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.prime_spectrum_prod_symm_inl_as_ideal PrimeSpectrum.primeSpectrumProd_symm_inl_asIdealₓ'. -/
@[simp]
theorem primeSpectrumProd_symm_inl_asIdeal (x : PrimeSpectrum R) :
    ((primeSpectrumProd R S).symm <| Sum.inl x).asIdeal = Ideal.prod x.asIdeal ⊤ :=
  by
  cases x
  rfl
#align prime_spectrum.prime_spectrum_prod_symm_inl_as_ideal PrimeSpectrum.primeSpectrumProd_symm_inl_asIdeal

/- warning: prime_spectrum.prime_spectrum_prod_symm_inr_as_ideal -> PrimeSpectrum.primeSpectrumProd_symm_inr_asIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (x : PrimeSpectrum.{u2} S _inst_2), Eq.{succ (max u1 u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (Ring.toSemiring.{max u1 u2} (Prod.{u1, u2} R S) (CommRing.toRing.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2)))) (PrimeSpectrum.asIdeal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2))) => (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) -> (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2))) (Equiv.symm.{succ (max u1 u2), max (succ u1) (succ u2)} (PrimeSpectrum.{max u1 u2} (Prod.{u1, u2} R S) (Prod.commRing.{u1, u2} R S _inst_1 _inst_2)) (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.primeSpectrumProd.{u1, u2} R S _inst_1 _inst_2)) (Sum.inr.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) x))) (Ideal.prod.{u1, u2} R S (CommRing.toRing.{u1} R _inst_1) (CommRing.toRing.{u2} S _inst_2) (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (PrimeSpectrum.asIdeal.{u2} S _inst_2 x))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (x : PrimeSpectrum.{u2} S _inst_2), Eq.{max (succ u1) (succ u2)} (Ideal.{max u1 u2} (Prod.{u1, u2} R S) (CommSemiring.toSemiring.{max u1 u2} (Prod.{u1, u2} R S) (CommRing.toCommSemiring.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2)))) (PrimeSpectrum.asIdeal.{max u1 u2} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2))) (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (fun (_x : Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) => PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PrimeSpectrum.{max u2 u1} (Prod.{u1, u2} R S) (Prod.instCommRingProd.{u1, u2} R S _inst_1 _inst_2)) (Sum.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2)) (PrimeSpectrum.primeSpectrumProd.{u1, u2} R S _inst_1 _inst_2)) (Sum.inr.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) x))) (Ideal.prod.{u1, u2} R S (CommRing.toRing.{u1} R _inst_1) (CommRing.toRing.{u2} S _inst_2) (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.instTopSubmodule.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (PrimeSpectrum.asIdeal.{u2} S _inst_2 x))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.prime_spectrum_prod_symm_inr_as_ideal PrimeSpectrum.primeSpectrumProd_symm_inr_asIdealₓ'. -/
@[simp]
theorem primeSpectrumProd_symm_inr_asIdeal (x : PrimeSpectrum S) :
    ((primeSpectrumProd R S).symm <| Sum.inr x).asIdeal = Ideal.prod ⊤ x.asIdeal :=
  by
  cases x
  rfl
#align prime_spectrum.prime_spectrum_prod_symm_inr_as_ideal PrimeSpectrum.primeSpectrumProd_symm_inr_asIdeal

#print PrimeSpectrum.zeroLocus /-
/-- The zero locus of a set `s` of elements of a commutative ring `R` is the set of all prime ideals
of the ring that contain the set `s`.

An element `f` of `R` can be thought of as a dependent function on the prime spectrum of `R`.
At a point `x` (a prime ideal) the function (i.e., element) `f` takes values in the quotient ring
`R` modulo the prime ideal `x`. In this manner, `zero_locus s` is exactly the subset of
`prime_spectrum R` where all "functions" in `s` vanish simultaneously.
-/
def zeroLocus (s : Set R) : Set (PrimeSpectrum R) :=
  { x | s ⊆ x.asIdeal }
#align prime_spectrum.zero_locus PrimeSpectrum.zeroLocus
-/

#print PrimeSpectrum.mem_zeroLocus /-
@[simp]
theorem mem_zeroLocus (x : PrimeSpectrum R) (s : Set R) : x ∈ zeroLocus s ↔ s ⊆ x.asIdeal :=
  Iff.rfl
#align prime_spectrum.mem_zero_locus PrimeSpectrum.mem_zeroLocus
-/

#print PrimeSpectrum.zeroLocus_span /-
@[simp]
theorem zeroLocus_span (s : Set R) : zeroLocus (Ideal.span s : Set R) = zeroLocus s :=
  by
  ext x
  exact (Submodule.gi R R).gc s x.as_ideal
#align prime_spectrum.zero_locus_span PrimeSpectrum.zeroLocus_span
-/

#print PrimeSpectrum.vanishingIdeal /-
/-- The vanishing ideal of a set `t` of points of the prime spectrum of a commutative ring `R` is
the intersection of all the prime ideals in the set `t`.

An element `f` of `R` can be thought of as a dependent function on the prime spectrum of `R`.
At a point `x` (a prime ideal) the function (i.e., element) `f` takes values in the quotient ring
`R` modulo the prime ideal `x`. In this manner, `vanishing_ideal t` is exactly the ideal of `R`
consisting of all "functions" that vanish on all of `t`.
-/
def vanishingIdeal (t : Set (PrimeSpectrum R)) : Ideal R :=
  ⨅ (x : PrimeSpectrum R) (h : x ∈ t), x.asIdeal
#align prime_spectrum.vanishing_ideal PrimeSpectrum.vanishingIdeal
-/

#print PrimeSpectrum.coe_vanishingIdeal /-
theorem coe_vanishingIdeal (t : Set (PrimeSpectrum R)) :
    (vanishingIdeal t : Set R) = { f : R | ∀ x : PrimeSpectrum R, x ∈ t → f ∈ x.asIdeal } :=
  by
  ext f
  rw [vanishing_ideal, SetLike.mem_coe, Submodule.mem_iInf]
  apply forall_congr'; intro x
  rw [Submodule.mem_iInf]
#align prime_spectrum.coe_vanishing_ideal PrimeSpectrum.coe_vanishingIdeal
-/

#print PrimeSpectrum.mem_vanishingIdeal /-
theorem mem_vanishingIdeal (t : Set (PrimeSpectrum R)) (f : R) :
    f ∈ vanishingIdeal t ↔ ∀ x : PrimeSpectrum R, x ∈ t → f ∈ x.asIdeal := by
  rw [← SetLike.mem_coe, coe_vanishing_ideal, Set.mem_setOf_eq]
#align prime_spectrum.mem_vanishing_ideal PrimeSpectrum.mem_vanishingIdeal
-/

#print PrimeSpectrum.vanishingIdeal_singleton /-
@[simp]
theorem vanishingIdeal_singleton (x : PrimeSpectrum R) :
    vanishingIdeal ({x} : Set (PrimeSpectrum R)) = x.asIdeal := by simp [vanishing_ideal]
#align prime_spectrum.vanishing_ideal_singleton PrimeSpectrum.vanishingIdeal_singleton
-/

/- warning: prime_spectrum.subset_zero_locus_iff_le_vanishing_ideal -> PrimeSpectrum.subset_zeroLocus_iff_le_vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Iff (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasSubset.{u1} (PrimeSpectrum.{u1} R _inst_1)) t (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I))) (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))), Iff (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instHasSubsetSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) t (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I))) (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) I (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.subset_zero_locus_iff_le_vanishing_ideal PrimeSpectrum.subset_zeroLocus_iff_le_vanishingIdealₓ'. -/
theorem subset_zeroLocus_iff_le_vanishingIdeal (t : Set (PrimeSpectrum R)) (I : Ideal R) :
    t ⊆ zeroLocus I ↔ I ≤ vanishingIdeal t :=
  ⟨fun h f k => (mem_vanishingIdeal _ _).mpr fun x j => (mem_zeroLocus _ _).mpr (h j) k, fun h =>
    fun x j => (mem_zeroLocus _ _).mpr (le_trans h fun f h => ((mem_vanishingIdeal _ _).mp h) x j)⟩
#align prime_spectrum.subset_zero_locus_iff_le_vanishing_ideal PrimeSpectrum.subset_zeroLocus_iff_le_vanishingIdeal

section Gc

variable (R)

/- warning: prime_spectrum.gc -> PrimeSpectrum.gc is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommRing.{u1} R], GaloisConnection.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (OrderDual.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (OrderDual.preorder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.completeBooleanAlgebra.{u1} (PrimeSpectrum.{u1} R _inst_1))))))))) (fun (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) => PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I)) (fun (t : OrderDual.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1))) => PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : CommRing.{u1} R], GaloisConnection.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OrderDual.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) (OrderDual.preorder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instCompleteBooleanAlgebraSet.{u1} (PrimeSpectrum.{u1} R _inst_1))))))))) (fun (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) => PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I)) (fun (t : OrderDual.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1))) => PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t)
Case conversion may be inaccurate. Consider using '#align prime_spectrum.gc PrimeSpectrum.gcₓ'. -/
/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/
theorem gc :
    @GaloisConnection (Ideal R) (Set (PrimeSpectrum R))ᵒᵈ _ _ (fun I => zeroLocus I) fun t =>
      vanishingIdeal t :=
  fun I t => subset_zeroLocus_iff_le_vanishingIdeal t I
#align prime_spectrum.gc PrimeSpectrum.gc

/- warning: prime_spectrum.gc_set -> PrimeSpectrum.gc_set is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommRing.{u1} R], GaloisConnection.{u1, u1} (Set.{u1} R) (OrderDual.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Set.{u1} R) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} R) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} R) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} R) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} R) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} R) (Set.completeBooleanAlgebra.{u1} R))))))) (OrderDual.preorder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.completeBooleanAlgebra.{u1} (PrimeSpectrum.{u1} R _inst_1))))))))) (fun (s : Set.{u1} R) => PrimeSpectrum.zeroLocus.{u1} R _inst_1 s) (fun (t : OrderDual.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1))) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : CommRing.{u1} R], GaloisConnection.{u1, u1} (Set.{u1} R) (OrderDual.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Set.{u1} R) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} R) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} R) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} R) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} R) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} R) (Set.instCompleteBooleanAlgebraSet.{u1} R))))))) (OrderDual.preorder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instCompleteBooleanAlgebraSet.{u1} (PrimeSpectrum.{u1} R _inst_1))))))))) (fun (s : Set.{u1} R) => PrimeSpectrum.zeroLocus.{u1} R _inst_1 s) (fun (t : OrderDual.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1))) => SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.gc_set PrimeSpectrum.gc_setₓ'. -/
/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/
theorem gc_set :
    @GaloisConnection (Set R) (Set (PrimeSpectrum R))ᵒᵈ _ _ (fun s => zeroLocus s) fun t =>
      vanishingIdeal t :=
  by
  have ideal_gc : GaloisConnection Ideal.span coe := (Submodule.gi R R).gc
  simpa [zero_locus_span, Function.comp] using ideal_gc.compose (gc R)
#align prime_spectrum.gc_set PrimeSpectrum.gc_set

#print PrimeSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal /-
theorem subset_zeroLocus_iff_subset_vanishingIdeal (t : Set (PrimeSpectrum R)) (s : Set R) :
    t ⊆ zeroLocus s ↔ s ⊆ vanishingIdeal t :=
  (gc_set R) s t
#align prime_spectrum.subset_zero_locus_iff_subset_vanishing_ideal PrimeSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal
-/

end Gc

#print PrimeSpectrum.subset_vanishingIdeal_zeroLocus /-
theorem subset_vanishingIdeal_zeroLocus (s : Set R) : s ⊆ vanishingIdeal (zeroLocus s) :=
  (gc_set R).le_u_l s
#align prime_spectrum.subset_vanishing_ideal_zero_locus PrimeSpectrum.subset_vanishingIdeal_zeroLocus
-/

/- warning: prime_spectrum.le_vanishing_ideal_zero_locus -> PrimeSpectrum.le_vanishingIdeal_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))), LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) I (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.le_vanishing_ideal_zero_locus PrimeSpectrum.le_vanishingIdeal_zeroLocusₓ'. -/
theorem le_vanishingIdeal_zeroLocus (I : Ideal R) : I ≤ vanishingIdeal (zeroLocus I) :=
  (gc R).le_u_l I
#align prime_spectrum.le_vanishing_ideal_zero_locus PrimeSpectrum.le_vanishingIdeal_zeroLocus

#print PrimeSpectrum.vanishingIdeal_zeroLocus_eq_radical /-
@[simp]
theorem vanishingIdeal_zeroLocus_eq_radical (I : Ideal R) :
    vanishingIdeal (zeroLocus (I : Set R)) = I.radical :=
  Ideal.ext fun f =>
    by
    rw [mem_vanishing_ideal, Ideal.radical_eq_sInf, Submodule.mem_sInf]
    exact ⟨fun h x hx => h ⟨x, hx.2⟩ hx.1, fun h x hx => h x.1 ⟨hx, x.2⟩⟩
#align prime_spectrum.vanishing_ideal_zero_locus_eq_radical PrimeSpectrum.vanishingIdeal_zeroLocus_eq_radical
-/

#print PrimeSpectrum.zeroLocus_radical /-
@[simp]
theorem zeroLocus_radical (I : Ideal R) : zeroLocus (I.radical : Set R) = zeroLocus I :=
  vanishingIdeal_zeroLocus_eq_radical I ▸ (gc R).l_u_l_eq_l I
#align prime_spectrum.zero_locus_radical PrimeSpectrum.zeroLocus_radical
-/

#print PrimeSpectrum.subset_zeroLocus_vanishingIdeal /-
theorem subset_zeroLocus_vanishingIdeal (t : Set (PrimeSpectrum R)) :
    t ⊆ zeroLocus (vanishingIdeal t) :=
  (gc R).l_u_le t
#align prime_spectrum.subset_zero_locus_vanishing_ideal PrimeSpectrum.subset_zeroLocus_vanishingIdeal
-/

#print PrimeSpectrum.zeroLocus_anti_mono /-
theorem zeroLocus_anti_mono {s t : Set R} (h : s ⊆ t) : zeroLocus t ⊆ zeroLocus s :=
  (gc_set R).monotone_l h
#align prime_spectrum.zero_locus_anti_mono PrimeSpectrum.zeroLocus_anti_mono
-/

/- warning: prime_spectrum.zero_locus_anti_mono_ideal -> PrimeSpectrum.zeroLocus_anti_mono_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))} {t : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) s t) -> (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasSubset.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) t)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) s)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))} {t : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))}, (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) s t) -> (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instHasSubsetSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) t)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) s)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_anti_mono_ideal PrimeSpectrum.zeroLocus_anti_mono_idealₓ'. -/
theorem zeroLocus_anti_mono_ideal {s t : Ideal R} (h : s ≤ t) :
    zeroLocus (t : Set R) ⊆ zeroLocus (s : Set R) :=
  (gc R).monotone_l h
#align prime_spectrum.zero_locus_anti_mono_ideal PrimeSpectrum.zeroLocus_anti_mono_ideal

/- warning: prime_spectrum.vanishing_ideal_anti_mono -> PrimeSpectrum.vanishingIdeal_anti_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)} {t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)}, (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasSubset.{u1} (PrimeSpectrum.{u1} R _inst_1)) s t) -> (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 s))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)} {t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)}, (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instHasSubsetSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) s t) -> (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 s))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.vanishing_ideal_anti_mono PrimeSpectrum.vanishingIdeal_anti_monoₓ'. -/
theorem vanishingIdeal_anti_mono {s t : Set (PrimeSpectrum R)} (h : s ⊆ t) :
    vanishingIdeal t ≤ vanishingIdeal s :=
  (gc R).monotone_u h
#align prime_spectrum.vanishing_ideal_anti_mono PrimeSpectrum.vanishingIdeal_anti_mono

/- warning: prime_spectrum.zero_locus_subset_zero_locus_iff -> PrimeSpectrum.zeroLocus_subset_zeroLocus_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Iff (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasSubset.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) J))) (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) J (Ideal.radical.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) I))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))), Iff (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instHasSubsetSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) J))) (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) J (Ideal.radical.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) I))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_subset_zero_locus_iff PrimeSpectrum.zeroLocus_subset_zeroLocus_iffₓ'. -/
theorem zeroLocus_subset_zeroLocus_iff (I J : Ideal R) :
    zeroLocus (I : Set R) ⊆ zeroLocus (J : Set R) ↔ J ≤ I.radical :=
  ⟨fun h =>
    Ideal.radical_le_radical_iff.mp
      (vanishingIdeal_zeroLocus_eq_radical I ▸
        vanishingIdeal_zeroLocus_eq_radical J ▸ vanishingIdeal_anti_mono h),
    fun h => zeroLocus_radical I ▸ zeroLocus_anti_mono_ideal h⟩
#align prime_spectrum.zero_locus_subset_zero_locus_iff PrimeSpectrum.zeroLocus_subset_zeroLocus_iff

#print PrimeSpectrum.zeroLocus_subset_zeroLocus_singleton_iff /-
theorem zeroLocus_subset_zeroLocus_singleton_iff (f g : R) :
    zeroLocus ({f} : Set R) ⊆ zeroLocus {g} ↔ g ∈ (Ideal.span ({f} : Set R)).radical := by
  rw [← zero_locus_span {f}, ← zero_locus_span {g}, zero_locus_subset_zero_locus_iff, Ideal.span_le,
    Set.singleton_subset_iff, SetLike.mem_coe]
#align prime_spectrum.zero_locus_subset_zero_locus_singleton_iff PrimeSpectrum.zeroLocus_subset_zeroLocus_singleton_iff
-/

/- warning: prime_spectrum.zero_locus_bot -> PrimeSpectrum.zeroLocus_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Bot.bot.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasBot.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Set.univ.{u1} (PrimeSpectrum.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Bot.bot.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.instBotSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) (Set.univ.{u1} (PrimeSpectrum.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_bot PrimeSpectrum.zeroLocus_botₓ'. -/
theorem zeroLocus_bot : zeroLocus ((⊥ : Ideal R) : Set R) = Set.univ :=
  (gc R).l_bot
#align prime_spectrum.zero_locus_bot PrimeSpectrum.zeroLocus_bot

/- warning: prime_spectrum.zero_locus_singleton_zero -> PrimeSpectrum.zeroLocus_singleton_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))) (Set.univ.{u1} (PrimeSpectrum.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) (Set.univ.{u1} (PrimeSpectrum.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_singleton_zero PrimeSpectrum.zeroLocus_singleton_zeroₓ'. -/
@[simp]
theorem zeroLocus_singleton_zero : zeroLocus ({0} : Set R) = Set.univ :=
  zeroLocus_bot
#align prime_spectrum.zero_locus_singleton_zero PrimeSpectrum.zeroLocus_singleton_zero

#print PrimeSpectrum.zeroLocus_empty /-
@[simp]
theorem zeroLocus_empty : zeroLocus (∅ : Set R) = Set.univ :=
  (gc_set R).l_bot
#align prime_spectrum.zero_locus_empty PrimeSpectrum.zeroLocus_empty
-/

/- warning: prime_spectrum.vanishing_ideal_univ -> PrimeSpectrum.vanishingIdeal_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasEmptyc.{u1} (PrimeSpectrum.{u1} R _inst_1)))) (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instEmptyCollectionSet.{u1} (PrimeSpectrum.{u1} R _inst_1)))) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.vanishing_ideal_univ PrimeSpectrum.vanishingIdeal_univₓ'. -/
@[simp]
theorem vanishingIdeal_univ : vanishingIdeal (∅ : Set (PrimeSpectrum R)) = ⊤ := by
  simpa using (gc R).u_top
#align prime_spectrum.vanishing_ideal_univ PrimeSpectrum.vanishingIdeal_univ

/- warning: prime_spectrum.zero_locus_empty_of_one_mem -> PrimeSpectrum.zeroLocus_empty_of_one_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} R}, (Membership.Mem.{u1, u1} R (Set.{u1} R) (Set.hasMem.{u1} R) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) s) -> (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s) (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasEmptyc.{u1} (PrimeSpectrum.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} R}, (Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) s) -> (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s) (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instEmptyCollectionSet.{u1} (PrimeSpectrum.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_empty_of_one_mem PrimeSpectrum.zeroLocus_empty_of_one_memₓ'. -/
theorem zeroLocus_empty_of_one_mem {s : Set R} (h : (1 : R) ∈ s) : zeroLocus s = ∅ :=
  by
  rw [Set.eq_empty_iff_forall_not_mem]
  intro x hx
  rw [mem_zero_locus] at hx
  have x_prime : x.as_ideal.is_prime := by infer_instance
  have eq_top : x.as_ideal = ⊤ := by
    rw [Ideal.eq_top_iff_one]
    exact hx h
  apply x_prime.ne_top eq_top
#align prime_spectrum.zero_locus_empty_of_one_mem PrimeSpectrum.zeroLocus_empty_of_one_mem

/- warning: prime_spectrum.zero_locus_singleton_one -> PrimeSpectrum.zeroLocus_singleton_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasEmptyc.{u1} (PrimeSpectrum.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))) (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instEmptyCollectionSet.{u1} (PrimeSpectrum.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_singleton_one PrimeSpectrum.zeroLocus_singleton_oneₓ'. -/
@[simp]
theorem zeroLocus_singleton_one : zeroLocus ({1} : Set R) = ∅ :=
  zeroLocus_empty_of_one_mem (Set.mem_singleton (1 : R))
#align prime_spectrum.zero_locus_singleton_one PrimeSpectrum.zeroLocus_singleton_one

/- warning: prime_spectrum.zero_locus_empty_iff_eq_top -> PrimeSpectrum.zeroLocus_empty_iff_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))}, Iff (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasEmptyc.{u1} (PrimeSpectrum.{u1} R _inst_1)))) (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) I (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))}, Iff (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instEmptyCollectionSet.{u1} (PrimeSpectrum.{u1} R _inst_1)))) (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) I (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_empty_iff_eq_top PrimeSpectrum.zeroLocus_empty_iff_eq_topₓ'. -/
theorem zeroLocus_empty_iff_eq_top {I : Ideal R} : zeroLocus (I : Set R) = ∅ ↔ I = ⊤ :=
  by
  constructor
  · contrapose!
    intro h
    rcases Ideal.exists_le_maximal I h with ⟨M, hM, hIM⟩
    exact Set.Nonempty.ne_empty ⟨⟨M, hM.is_prime⟩, hIM⟩
  · rintro rfl
    apply zero_locus_empty_of_one_mem
    trivial
#align prime_spectrum.zero_locus_empty_iff_eq_top PrimeSpectrum.zeroLocus_empty_iff_eq_top

#print PrimeSpectrum.zeroLocus_univ /-
@[simp]
theorem zeroLocus_univ : zeroLocus (Set.univ : Set R) = ∅ :=
  zeroLocus_empty_of_one_mem (Set.mem_univ 1)
#align prime_spectrum.zero_locus_univ PrimeSpectrum.zeroLocus_univ
-/

/- warning: prime_spectrum.vanishing_ideal_eq_top_iff -> PrimeSpectrum.vanishingIdeal_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)}, Iff (Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 s) (Top.top.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasTop.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasEmptyc.{u1} (PrimeSpectrum.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)}, Iff (Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 s) (Top.top.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.instTopSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) s (EmptyCollection.emptyCollection.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instEmptyCollectionSet.{u1} (PrimeSpectrum.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.vanishing_ideal_eq_top_iff PrimeSpectrum.vanishingIdeal_eq_top_iffₓ'. -/
theorem vanishingIdeal_eq_top_iff {s : Set (PrimeSpectrum R)} : vanishingIdeal s = ⊤ ↔ s = ∅ := by
  rw [← top_le_iff, ← subset_zero_locus_iff_le_vanishing_ideal, Submodule.top_coe, zero_locus_univ,
    Set.subset_empty_iff]
#align prime_spectrum.vanishing_ideal_eq_top_iff PrimeSpectrum.vanishingIdeal_eq_top_iff

/- warning: prime_spectrum.zero_locus_sup -> PrimeSpectrum.zeroLocus_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Sup.sup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.idemSemiring.{u1, u1} R (CommRing.toCommSemiring.{u1} R _inst_1) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) I J))) (Inter.inter.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasInter.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ideal.instIdemCommSemiringIdealToSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I J))) (Inter.inter.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instInterSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) J)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_sup PrimeSpectrum.zeroLocus_supₓ'. -/
theorem zeroLocus_sup (I J : Ideal R) :
    zeroLocus ((I ⊔ J : Ideal R) : Set R) = zeroLocus I ∩ zeroLocus J :=
  (gc R).l_sup
#align prime_spectrum.zero_locus_sup PrimeSpectrum.zeroLocus_sup

/- warning: prime_spectrum.zero_locus_union -> PrimeSpectrum.zeroLocus_union is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (s : Set.{u1} R) (s' : Set.{u1} R), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Union.union.{u1} (Set.{u1} R) (Set.hasUnion.{u1} R) s s')) (Inter.inter.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasInter.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s'))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (s : Set.{u1} R) (s' : Set.{u1} R), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Union.union.{u1} (Set.{u1} R) (Set.instUnionSet.{u1} R) s s')) (Inter.inter.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instInterSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s'))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_union PrimeSpectrum.zeroLocus_unionₓ'. -/
theorem zeroLocus_union (s s' : Set R) : zeroLocus (s ∪ s') = zeroLocus s ∩ zeroLocus s' :=
  (gc_set R).l_sup
#align prime_spectrum.zero_locus_union PrimeSpectrum.zeroLocus_union

#print PrimeSpectrum.vanishingIdeal_union /-
theorem vanishingIdeal_union (t t' : Set (PrimeSpectrum R)) :
    vanishingIdeal (t ∪ t') = vanishingIdeal t ⊓ vanishingIdeal t' :=
  (gc R).u_inf
#align prime_spectrum.vanishing_ideal_union PrimeSpectrum.vanishingIdeal_union
-/

/- warning: prime_spectrum.zero_locus_supr -> PrimeSpectrum.zeroLocus_iSup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {ι : Sort.{u2}} (I : ι -> (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (iSup.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (ConditionallyCompleteLattice.toHasSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) ι (fun (i : ι) => I i)))) (Set.iInter.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) ι (fun (i : ι) => PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (I i))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {ι : Sort.{u1}} (I : ι -> (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))), Eq.{succ u2} (Set.{u2} (PrimeSpectrum.{u2} R _inst_1)) (PrimeSpectrum.zeroLocus.{u2} R _inst_1 (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (iSup.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (ConditionallyCompleteLattice.toSupSet.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Submodule.completeLattice.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) ι (fun (i : ι) => I i)))) (Set.iInter.{u2, u1} (PrimeSpectrum.{u2} R _inst_1) ι (fun (i : ι) => PrimeSpectrum.zeroLocus.{u2} R _inst_1 (SetLike.coe.{u2, u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) R (Submodule.setLike.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (I i))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_supr PrimeSpectrum.zeroLocus_iSupₓ'. -/
theorem zeroLocus_iSup {ι : Sort _} (I : ι → Ideal R) :
    zeroLocus ((⨆ i, I i : Ideal R) : Set R) = ⋂ i, zeroLocus (I i) :=
  (gc R).l_iSup
#align prime_spectrum.zero_locus_supr PrimeSpectrum.zeroLocus_iSup

/- warning: prime_spectrum.zero_locus_Union -> PrimeSpectrum.zeroLocus_iUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {ι : Sort.{u2}} (s : ι -> (Set.{u1} R)), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Set.iUnion.{u1, u2} R ι (fun (i : ι) => s i))) (Set.iInter.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) ι (fun (i : ι) => PrimeSpectrum.zeroLocus.{u1} R _inst_1 (s i)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {ι : Sort.{u1}} (s : ι -> (Set.{u2} R)), Eq.{succ u2} (Set.{u2} (PrimeSpectrum.{u2} R _inst_1)) (PrimeSpectrum.zeroLocus.{u2} R _inst_1 (Set.iUnion.{u2, u1} R ι (fun (i : ι) => s i))) (Set.iInter.{u2, u1} (PrimeSpectrum.{u2} R _inst_1) ι (fun (i : ι) => PrimeSpectrum.zeroLocus.{u2} R _inst_1 (s i)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_Union PrimeSpectrum.zeroLocus_iUnionₓ'. -/
theorem zeroLocus_iUnion {ι : Sort _} (s : ι → Set R) :
    zeroLocus (⋃ i, s i) = ⋂ i, zeroLocus (s i) :=
  (gc_set R).l_iSup
#align prime_spectrum.zero_locus_Union PrimeSpectrum.zeroLocus_iUnion

#print PrimeSpectrum.zeroLocus_bUnion /-
theorem zeroLocus_bUnion (s : Set (Set R)) :
    zeroLocus (⋃ s' ∈ s, s' : Set R) = ⋂ s' ∈ s, zeroLocus s' := by simp only [zero_locus_Union]
#align prime_spectrum.zero_locus_bUnion PrimeSpectrum.zeroLocus_bUnion
-/

/- warning: prime_spectrum.vanishing_ideal_Union -> PrimeSpectrum.vanishingIdeal_iUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {ι : Sort.{u2}} (t : ι -> (Set.{u1} (PrimeSpectrum.{u1} R _inst_1))), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 (Set.iUnion.{u1, u2} (PrimeSpectrum.{u1} R _inst_1) ι (fun (i : ι) => t i))) (iInf.{u1, u2} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasInf.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) ι (fun (i : ι) => PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 (t i)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {ι : Sort.{u1}} (t : ι -> (Set.{u2} (PrimeSpectrum.{u2} R _inst_1))), Eq.{succ u2} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (PrimeSpectrum.vanishingIdeal.{u2} R _inst_1 (Set.iUnion.{u2, u1} (PrimeSpectrum.{u2} R _inst_1) ι (fun (i : ι) => t i))) (iInf.{u2, u1} (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Submodule.instInfSetSubmodule.{u2, u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) ι (fun (i : ι) => PrimeSpectrum.vanishingIdeal.{u2} R _inst_1 (t i)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.vanishing_ideal_Union PrimeSpectrum.vanishingIdeal_iUnionₓ'. -/
theorem vanishingIdeal_iUnion {ι : Sort _} (t : ι → Set (PrimeSpectrum R)) :
    vanishingIdeal (⋃ i, t i) = ⨅ i, vanishingIdeal (t i) :=
  (gc R).u_iInf
#align prime_spectrum.vanishing_ideal_Union PrimeSpectrum.vanishingIdeal_iUnion

/- warning: prime_spectrum.zero_locus_inf -> PrimeSpectrum.zeroLocus_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Inf.inf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasInf.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) I J))) (Union.union.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasUnion.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Inf.inf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.instInfSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I J))) (Union.union.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instUnionSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) J)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_inf PrimeSpectrum.zeroLocus_infₓ'. -/
theorem zeroLocus_inf (I J : Ideal R) :
    zeroLocus ((I ⊓ J : Ideal R) : Set R) = zeroLocus I ∪ zeroLocus J :=
  Set.ext fun x => x.2.inf_le
#align prime_spectrum.zero_locus_inf PrimeSpectrum.zeroLocus_inf

/- warning: prime_spectrum.union_zero_locus -> PrimeSpectrum.union_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (s : Set.{u1} R) (s' : Set.{u1} R), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Union.union.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasUnion.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s')) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Inf.inf.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.hasInf.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Ideal.span.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) s) (Ideal.span.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) s'))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (s : Set.{u1} R) (s' : Set.{u1} R), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Union.union.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instUnionSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s')) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Inf.inf.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.instInfSubmodule.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) s) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) s'))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.union_zero_locus PrimeSpectrum.union_zeroLocusₓ'. -/
theorem union_zeroLocus (s s' : Set R) :
    zeroLocus s ∪ zeroLocus s' = zeroLocus (Ideal.span s ⊓ Ideal.span s' : Ideal R) :=
  by
  rw [zero_locus_inf]
  simp
#align prime_spectrum.union_zero_locus PrimeSpectrum.union_zeroLocus

/- warning: prime_spectrum.zero_locus_mul -> PrimeSpectrum.zeroLocus_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (J : Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (instHMul.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Ideal.hasMul.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) I J))) (Union.union.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasUnion.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) I)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (I : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (J : Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (instHMul.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ideal.instMulIdealToSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) I J))) (Union.union.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instUnionSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) I)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) J)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_mul PrimeSpectrum.zeroLocus_mulₓ'. -/
theorem zeroLocus_mul (I J : Ideal R) :
    zeroLocus ((I * J : Ideal R) : Set R) = zeroLocus I ∪ zeroLocus J :=
  Set.ext fun x => x.2.mul_le
#align prime_spectrum.zero_locus_mul PrimeSpectrum.zeroLocus_mul

/- warning: prime_spectrum.zero_locus_singleton_mul -> PrimeSpectrum.zeroLocus_singleton_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) f g))) (Union.union.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasUnion.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) f)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) g)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) f g))) (Union.union.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instUnionSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) f)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) g)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_singleton_mul PrimeSpectrum.zeroLocus_singleton_mulₓ'. -/
theorem zeroLocus_singleton_mul (f g : R) :
    zeroLocus ({f * g} : Set R) = zeroLocus {f} ∪ zeroLocus {g} :=
  Set.ext fun x => by simpa using x.2.mul_mem_iff_mem_or_mem
#align prime_spectrum.zero_locus_singleton_mul PrimeSpectrum.zeroLocus_singleton_mul

#print PrimeSpectrum.zeroLocus_pow /-
@[simp]
theorem zeroLocus_pow (I : Ideal R) {n : ℕ} (hn : 0 < n) :
    zeroLocus ((I ^ n : Ideal R) : Set R) = zeroLocus I :=
  zeroLocus_radical (I ^ n) ▸ (I.radical_pow n hn).symm ▸ zeroLocus_radical I
#align prime_spectrum.zero_locus_pow PrimeSpectrum.zeroLocus_pow
-/

/- warning: prime_spectrum.zero_locus_singleton_pow -> PrimeSpectrum.zeroLocus_singleton_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (n : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) f n))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) f)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (n : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) f n))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) f)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.zero_locus_singleton_pow PrimeSpectrum.zeroLocus_singleton_powₓ'. -/
@[simp]
theorem zeroLocus_singleton_pow (f : R) (n : ℕ) (hn : 0 < n) :
    zeroLocus ({f ^ n} : Set R) = zeroLocus {f} :=
  Set.ext fun x => by simpa using x.2.pow_mem_iff_mem n hn
#align prime_spectrum.zero_locus_singleton_pow PrimeSpectrum.zeroLocus_singleton_pow

/- warning: prime_spectrum.sup_vanishing_ideal_le -> PrimeSpectrum.sup_vanishingIdeal_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (t' : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)), LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (Sup.sup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SemilatticeSup.toHasSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (IdemSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Submodule.idemSemiring.{u1, u1} R (CommRing.toCommSemiring.{u1} R _inst_1) R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t')) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 (Inter.inter.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasInter.{u1} (PrimeSpectrum.{u1} R _inst_1)) t t'))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (t' : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)), LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) (Sup.sup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (SemilatticeSup.toSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (IdemCommSemiring.toSemilatticeSup.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Ideal.instIdemCommSemiringIdealToSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t')) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 (Inter.inter.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instInterSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) t t'))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.sup_vanishing_ideal_le PrimeSpectrum.sup_vanishingIdeal_leₓ'. -/
theorem sup_vanishingIdeal_le (t t' : Set (PrimeSpectrum R)) :
    vanishingIdeal t ⊔ vanishingIdeal t' ≤ vanishingIdeal (t ∩ t') :=
  by
  intro r
  rw [Submodule.mem_sup, mem_vanishing_ideal]
  rintro ⟨f, hf, g, hg, rfl⟩ x ⟨hxt, hxt'⟩
  rw [mem_vanishing_ideal] at hf hg
  apply Submodule.add_mem <;> solve_by_elim
#align prime_spectrum.sup_vanishing_ideal_le PrimeSpectrum.sup_vanishingIdeal_le

/- warning: prime_spectrum.mem_compl_zero_locus_iff_not_mem -> PrimeSpectrum.mem_compl_zeroLocus_iff_not_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {f : R} {I : PrimeSpectrum.{u1} R _inst_1}, Iff (Membership.Mem.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasMem.{u1} (PrimeSpectrum.{u1} R _inst_1)) I (HasCompl.compl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.booleanAlgebra.{u1} (PrimeSpectrum.{u1} R _inst_1))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) f)))) (Not (Membership.Mem.{u1, u1} R (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) f (PrimeSpectrum.asIdeal.{u1} R _inst_1 I)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {f : R} {I : PrimeSpectrum.{u1} R _inst_1}, Iff (Membership.mem.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) I (HasCompl.compl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instBooleanAlgebraSet.{u1} (PrimeSpectrum.{u1} R _inst_1))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) f)))) (Not (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) f (PrimeSpectrum.asIdeal.{u1} R _inst_1 I)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.mem_compl_zero_locus_iff_not_mem PrimeSpectrum.mem_compl_zeroLocus_iff_not_memₓ'. -/
theorem mem_compl_zeroLocus_iff_not_mem {f : R} {I : PrimeSpectrum R} :
    I ∈ (zeroLocus {f} : Set (PrimeSpectrum R))ᶜ ↔ f ∉ I.asIdeal := by
  rw [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff] <;> rfl
#align prime_spectrum.mem_compl_zero_locus_iff_not_mem PrimeSpectrum.mem_compl_zeroLocus_iff_not_mem

#print PrimeSpectrum.zariskiTopology /-
/-- The Zariski topology on the prime spectrum of a commutative ring is defined via the closed sets
of the topology: they are exactly those sets that are the zero locus of a subset of the ring. -/
instance zariskiTopology : TopologicalSpace (PrimeSpectrum R) :=
  TopologicalSpace.ofClosed (Set.range PrimeSpectrum.zeroLocus) ⟨Set.univ, by simp⟩
    (by
      intro Zs h
      rw [Set.sInter_eq_iInter]
      choose f hf using fun i : Zs => h i.Prop
      simp only [← hf]
      exact ⟨_, zero_locus_Union _⟩)
    (by
      rintro _ ⟨s, rfl⟩ _ ⟨t, rfl⟩
      exact ⟨_, (union_zero_locus s t).symm⟩)
#align prime_spectrum.zariski_topology PrimeSpectrum.zariskiTopology
-/

/- warning: prime_spectrum.is_open_iff -> PrimeSpectrum.isOpen_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (U : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)), Iff (IsOpen.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) U) (Exists.{succ u1} (Set.{u1} R) (fun (s : Set.{u1} R) => Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (HasCompl.compl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.booleanAlgebra.{u1} (PrimeSpectrum.{u1} R _inst_1))) U) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (U : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)), Iff (IsOpen.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) U) (Exists.{succ u1} (Set.{u1} R) (fun (s : Set.{u1} R) => Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (HasCompl.compl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instBooleanAlgebraSet.{u1} (PrimeSpectrum.{u1} R _inst_1))) U) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.is_open_iff PrimeSpectrum.isOpen_iffₓ'. -/
theorem isOpen_iff (U : Set (PrimeSpectrum R)) : IsOpen U ↔ ∃ s, Uᶜ = zeroLocus s := by
  simp only [@eq_comm _ (Uᶜ)] <;> rfl
#align prime_spectrum.is_open_iff PrimeSpectrum.isOpen_iff

#print PrimeSpectrum.isClosed_iff_zeroLocus /-
theorem isClosed_iff_zeroLocus (Z : Set (PrimeSpectrum R)) : IsClosed Z ↔ ∃ s, Z = zeroLocus s := by
  rw [← isOpen_compl_iff, is_open_iff, compl_compl]
#align prime_spectrum.is_closed_iff_zero_locus PrimeSpectrum.isClosed_iff_zeroLocus
-/

#print PrimeSpectrum.isClosed_iff_zeroLocus_ideal /-
theorem isClosed_iff_zeroLocus_ideal (Z : Set (PrimeSpectrum R)) :
    IsClosed Z ↔ ∃ I : Ideal R, Z = zeroLocus I :=
  (isClosed_iff_zeroLocus _).trans
    ⟨fun ⟨s, hs⟩ => ⟨_, (zeroLocus_span s).substr hs⟩, fun ⟨I, hI⟩ => ⟨I, hI⟩⟩
#align prime_spectrum.is_closed_iff_zero_locus_ideal PrimeSpectrum.isClosed_iff_zeroLocus_ideal
-/

#print PrimeSpectrum.isClosed_iff_zeroLocus_radical_ideal /-
theorem isClosed_iff_zeroLocus_radical_ideal (Z : Set (PrimeSpectrum R)) :
    IsClosed Z ↔ ∃ I : Ideal R, I.IsRadical ∧ Z = zeroLocus I :=
  (isClosed_iff_zeroLocus_ideal _).trans
    ⟨fun ⟨I, hI⟩ => ⟨_, I.radical_isRadical, (zeroLocus_radical I).substr hI⟩, fun ⟨I, _, hI⟩ =>
      ⟨I, hI⟩⟩
#align prime_spectrum.is_closed_iff_zero_locus_radical_ideal PrimeSpectrum.isClosed_iff_zeroLocus_radical_ideal
-/

#print PrimeSpectrum.isClosed_zeroLocus /-
theorem isClosed_zeroLocus (s : Set R) : IsClosed (zeroLocus s) :=
  by
  rw [is_closed_iff_zero_locus]
  exact ⟨s, rfl⟩
#align prime_spectrum.is_closed_zero_locus PrimeSpectrum.isClosed_zeroLocus
-/

#print PrimeSpectrum.isClosed_singleton_iff_isMaximal /-
theorem isClosed_singleton_iff_isMaximal (x : PrimeSpectrum R) :
    IsClosed ({x} : Set (PrimeSpectrum R)) ↔ x.asIdeal.IsMaximal :=
  by
  refine' (is_closed_iff_zero_locus _).trans ⟨fun h => _, fun h => _⟩
  · obtain ⟨s, hs⟩ := h
    rw [eq_comm, Set.eq_singleton_iff_unique_mem] at hs
    refine'
      ⟨⟨x.2.1, fun I hI =>
          Classical.not_not.1
            (mt (Ideal.exists_le_maximal I) <| not_exists.2 fun J => not_and.2 fun hJ hIJ => _)⟩⟩
    exact
      ne_of_lt (lt_of_lt_of_le hI hIJ)
        (symm <|
          congr_arg PrimeSpectrum.asIdeal
            (hs.2 ⟨J, hJ.is_prime⟩ fun r hr => hIJ (le_of_lt hI <| hs.1 hr)))
  · refine' ⟨x.as_ideal.1, _⟩
    rw [eq_comm, Set.eq_singleton_iff_unique_mem]
    refine' ⟨fun _ h => h, fun y hy => PrimeSpectrum.ext _ _ (h.eq_of_le y.2.ne_top hy).symm⟩
#align prime_spectrum.is_closed_singleton_iff_is_maximal PrimeSpectrum.isClosed_singleton_iff_isMaximal
-/

#print PrimeSpectrum.zeroLocus_vanishingIdeal_eq_closure /-
theorem zeroLocus_vanishingIdeal_eq_closure (t : Set (PrimeSpectrum R)) :
    zeroLocus (vanishingIdeal t : Set R) = closure t :=
  by
  apply Set.Subset.antisymm
  · rintro x hx t' ⟨ht', ht⟩
    obtain ⟨fs, rfl⟩ : ∃ s, t' = zero_locus s := by rwa [is_closed_iff_zero_locus] at ht'
    rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht
    exact Set.Subset.trans ht hx
  · rw [(is_closed_zero_locus _).closure_subset_iff]
    exact subset_zero_locus_vanishing_ideal t
#align prime_spectrum.zero_locus_vanishing_ideal_eq_closure PrimeSpectrum.zeroLocus_vanishingIdeal_eq_closure
-/

#print PrimeSpectrum.vanishingIdeal_closure /-
theorem vanishingIdeal_closure (t : Set (PrimeSpectrum R)) :
    vanishingIdeal (closure t) = vanishingIdeal t :=
  zeroLocus_vanishingIdeal_eq_closure t ▸ (gc R).u_l_u_eq_u t
#align prime_spectrum.vanishing_ideal_closure PrimeSpectrum.vanishingIdeal_closure
-/

#print PrimeSpectrum.closure_singleton /-
theorem closure_singleton (x) : closure ({x} : Set (PrimeSpectrum R)) = zeroLocus x.asIdeal := by
  rw [← zero_locus_vanishing_ideal_eq_closure, vanishing_ideal_singleton]
#align prime_spectrum.closure_singleton PrimeSpectrum.closure_singleton
-/

#print PrimeSpectrum.isRadical_vanishingIdeal /-
theorem isRadical_vanishingIdeal (s : Set (PrimeSpectrum R)) : (vanishingIdeal s).IsRadical :=
  by
  rw [← vanishing_ideal_closure, ← zero_locus_vanishing_ideal_eq_closure,
    vanishing_ideal_zero_locus_eq_radical]
  apply Ideal.radical_isRadical
#align prime_spectrum.is_radical_vanishing_ideal PrimeSpectrum.isRadical_vanishingIdeal
-/

/- warning: prime_spectrum.vanishing_ideal_anti_mono_iff -> PrimeSpectrum.vanishingIdeal_anti_mono_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)} {t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)}, (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) t) -> (Iff (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasSubset.{u1} (PrimeSpectrum.{u1} R _inst_1)) s t) (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 s)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)} {t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)}, (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) t) -> (Iff (HasSubset.Subset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instHasSubsetSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) s t) (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 s)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.vanishing_ideal_anti_mono_iff PrimeSpectrum.vanishingIdeal_anti_mono_iffₓ'. -/
theorem vanishingIdeal_anti_mono_iff {s t : Set (PrimeSpectrum R)} (ht : IsClosed t) :
    s ⊆ t ↔ vanishingIdeal t ≤ vanishingIdeal s :=
  ⟨vanishingIdeal_anti_mono, fun h =>
    by
    rw [← ht.closure_subset_iff, ← ht.closure_eq]
    convert← zero_locus_anti_mono_ideal h <;> apply zero_locus_vanishing_ideal_eq_closure⟩
#align prime_spectrum.vanishing_ideal_anti_mono_iff PrimeSpectrum.vanishingIdeal_anti_mono_iff

/- warning: prime_spectrum.vanishing_ideal_strict_anti_mono_iff -> PrimeSpectrum.vanishingIdeal_strict_anti_mono_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)} {t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)}, (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) s) -> (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) t) -> (Iff (HasSSubset.SSubset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasSsubset.{u1} (PrimeSpectrum.{u1} R _inst_1)) s t) (LT.lt.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLt.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 s)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {s : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)} {t : Set.{u1} (PrimeSpectrum.{u1} R _inst_1)}, (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) s) -> (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) t) -> (Iff (HasSSubset.SSubset.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instHasSSubsetSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) s t) (LT.lt.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLT.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 t) (PrimeSpectrum.vanishingIdeal.{u1} R _inst_1 s)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.vanishing_ideal_strict_anti_mono_iff PrimeSpectrum.vanishingIdeal_strict_anti_mono_iffₓ'. -/
theorem vanishingIdeal_strict_anti_mono_iff {s t : Set (PrimeSpectrum R)} (hs : IsClosed s)
    (ht : IsClosed t) : s ⊂ t ↔ vanishingIdeal t < vanishingIdeal s := by
  rw [Set.ssubset_def, vanishing_ideal_anti_mono_iff hs, vanishing_ideal_anti_mono_iff ht,
    lt_iff_le_not_le]
#align prime_spectrum.vanishing_ideal_strict_anti_mono_iff PrimeSpectrum.vanishingIdeal_strict_anti_mono_iff

/- warning: prime_spectrum.closeds_embedding -> PrimeSpectrum.closedsEmbedding is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_3 : CommRing.{u1} R], OrderEmbedding.{u1, u1} (OrderDual.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3))) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (OrderDual.hasLe.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)) (Preorder.toHasLe.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)) (PrimeSpectrum.{u1} R _inst_3) (TopologicalSpace.Closeds.setLike.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)))))) (Preorder.toHasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_3 : CommRing.{u1} R], OrderEmbedding.{u1, u1} (OrderDual.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3))) (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))) (OrderDual.instLEOrderDual.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)) (Preorder.toLE.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (TopologicalSpace.Closeds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3)) (TopologicalSpace.Closeds.instCompleteLatticeCloseds.{u1} (PrimeSpectrum.{u1} R _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_3))))))) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))))))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.closeds_embedding PrimeSpectrum.closedsEmbeddingₓ'. -/
/-- The antitone order embedding of closed subsets of `Spec R` into ideals of `R`. -/
def closedsEmbedding (R : Type _) [CommRing R] :
    (TopologicalSpace.Closeds <| PrimeSpectrum R)ᵒᵈ ↪o Ideal R :=
  OrderEmbedding.ofMapLEIff (fun s => vanishingIdeal s.ofDual) fun s t =>
    (vanishingIdeal_anti_mono_iff s.2).symm
#align prime_spectrum.closeds_embedding PrimeSpectrum.closedsEmbedding

#print PrimeSpectrum.t1Space_iff_isField /-
theorem t1Space_iff_isField [IsDomain R] : T1Space (PrimeSpectrum R) ↔ IsField R :=
  by
  refine' ⟨_, fun h => _⟩
  · intro h
    have hbot : Ideal.IsPrime (⊥ : Ideal R) := Ideal.bot_prime
    exact
      Classical.not_not.1
        (mt
          (Ring.ne_bot_of_isMaximal_of_not_isField <|
            (is_closed_singleton_iff_is_maximal _).1 (T1Space.t1 ⟨⊥, hbot⟩))
          (Classical.not_not.2 rfl))
  · refine' ⟨fun x => (is_closed_singleton_iff_is_maximal x).2 _⟩
    by_cases hx : x.as_ideal = ⊥
    · letI := h.to_field
      exact hx.symm ▸ Ideal.bot_isMaximal
    · exact absurd h (Ring.not_isField_iff_exists_prime.2 ⟨x.as_ideal, ⟨hx, x.2⟩⟩)
#align prime_spectrum.t1_space_iff_is_field PrimeSpectrum.t1Space_iff_isField
-/

-- mathport name: «exprZ( )»
local notation "Z(" a ")" => zeroLocus (a : Set R)

#print PrimeSpectrum.isIrreducible_zeroLocus_iff_of_radical /-
theorem isIrreducible_zeroLocus_iff_of_radical (I : Ideal R) (hI : I.IsRadical) :
    IsIrreducible (zeroLocus (I : Set R)) ↔ I.IsPrime :=
  by
  rw [Ideal.isPrime_iff, IsIrreducible]
  apply and_congr
  · rw [Set.nonempty_iff_ne_empty, Ne.def, zero_locus_empty_iff_eq_top]
  · trans ∀ x y : Ideal R, Z(I) ⊆ Z(x) ∪ Z(y) → Z(I) ⊆ Z(x) ∨ Z(I) ⊆ Z(y)
    · simp_rw [isPreirreducible_iff_closed_union_closed, is_closed_iff_zero_locus_ideal]
      constructor
      · rintro h x y
        exact h _ _ ⟨x, rfl⟩ ⟨y, rfl⟩
      · rintro h _ _ ⟨x, rfl⟩ ⟨y, rfl⟩
        exact h x y
    · simp_rw [← zero_locus_inf, subset_zero_locus_iff_le_vanishing_ideal,
        vanishing_ideal_zero_locus_eq_radical, hI.radical]
      constructor
      · simp_rw [← SetLike.mem_coe, ← Set.singleton_subset_iff, ← Ideal.span_le, ←
          Ideal.span_singleton_mul_span_singleton]
        refine' fun h x y h' => h _ _ _
        rw [← hI.radical_le_iff] at h'⊢
        simpa only [Ideal.radical_inf, Ideal.radical_mul] using h'
      · simp_rw [or_iff_not_imp_left, SetLike.not_le_iff_exists]
        rintro h s t h' ⟨x, hx, hx'⟩ y hy
        exact h (h' ⟨Ideal.mul_mem_right _ _ hx, Ideal.mul_mem_left _ _ hy⟩) hx'
#align prime_spectrum.is_irreducible_zero_locus_iff_of_radical PrimeSpectrum.isIrreducible_zeroLocus_iff_of_radical
-/

#print PrimeSpectrum.isIrreducible_zeroLocus_iff /-
theorem isIrreducible_zeroLocus_iff (I : Ideal R) :
    IsIrreducible (zeroLocus (I : Set R)) ↔ I.radical.IsPrime :=
  zeroLocus_radical I ▸ isIrreducible_zeroLocus_iff_of_radical _ I.radical_isRadical
#align prime_spectrum.is_irreducible_zero_locus_iff PrimeSpectrum.isIrreducible_zeroLocus_iff
-/

#print PrimeSpectrum.isIrreducible_iff_vanishingIdeal_isPrime /-
theorem isIrreducible_iff_vanishingIdeal_isPrime {s : Set (PrimeSpectrum R)} :
    IsIrreducible s ↔ (vanishingIdeal s).IsPrime := by
  rw [← isIrreducible_iff_closure, ← zero_locus_vanishing_ideal_eq_closure,
    is_irreducible_zero_locus_iff_of_radical _ (is_radical_vanishing_ideal s)]
#align prime_spectrum.is_irreducible_iff_vanishing_ideal_is_prime PrimeSpectrum.isIrreducible_iff_vanishingIdeal_isPrime
-/

instance [IsDomain R] : IrreducibleSpace (PrimeSpectrum R) :=
  by
  rw [irreducibleSpace_def, Set.top_eq_univ, ← zero_locus_bot, is_irreducible_zero_locus_iff]
  simpa using Ideal.bot_prime

instance : QuasiSober (PrimeSpectrum R) :=
  ⟨fun S h₁ h₂ =>
    ⟨⟨_, isIrreducible_iff_vanishingIdeal_isPrime.1 h₁⟩, by
      rw [IsGenericPoint, closure_singleton, zero_locus_vanishing_ideal_eq_closure, h₂.closure_eq]⟩⟩

section Comap

variable {S' : Type _} [CommRing S']

/- warning: prime_spectrum.preimage_comap_zero_locus_aux -> PrimeSpectrum.preimage_comap_zeroLocus_aux is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (s : Set.{u1} R), Eq.{succ u2} (Set.{u2} (PrimeSpectrum.{u2} S _inst_2)) (Set.preimage.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (fun (y : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.mk.{u1} R _inst_1 (Ideal.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f (PrimeSpectrum.asIdeal.{u2} S _inst_2 y)) (inferInstance.{0} (Ideal.IsPrime.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ideal.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f (PrimeSpectrum.asIdeal.{u2} S _inst_2 y))) (Ideal.IsPrime.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f (PrimeSpectrum.asIdeal.{u2} S _inst_2 y) (PrimeSpectrum.isPrime.{u2} S _inst_2 y)))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s)) (PrimeSpectrum.zeroLocus.{u2} S _inst_2 (Set.image.{u1, u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f) s))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (s : Set.{u1} R), Eq.{succ u2} (Set.{u2} (PrimeSpectrum.{u2} S _inst_2)) (Set.preimage.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (fun (y : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.mk.{u1} R _inst_1 (Ideal.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) f (PrimeSpectrum.asIdeal.{u2} S _inst_2 y)) (inferInstance.{0} (Ideal.IsPrime.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Ideal.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) f (PrimeSpectrum.asIdeal.{u2} S _inst_2 y))) (Ideal.IsPrime.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) f (PrimeSpectrum.asIdeal.{u2} S _inst_2 y) (PrimeSpectrum.IsPrime.{u2} S _inst_2 y)))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s)) (PrimeSpectrum.zeroLocus.{u2} S _inst_2 (Set.image.{u1, u2} R S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))))) f) s))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.preimage_comap_zero_locus_aux PrimeSpectrum.preimage_comap_zeroLocus_auxₓ'. -/
theorem preimage_comap_zeroLocus_aux (f : R →+* S) (s : Set R) :
    (fun y => ⟨Ideal.comap f y.asIdeal, inferInstance⟩ : PrimeSpectrum S → PrimeSpectrum R) ⁻¹'
        zeroLocus s =
      zeroLocus (f '' s) :=
  by
  ext x
  simp only [mem_zero_locus, Set.image_subset_iff]
  rfl
#align prime_spectrum.preimage_comap_zero_locus_aux PrimeSpectrum.preimage_comap_zeroLocus_aux

#print PrimeSpectrum.comap /-
/-- The function between prime spectra of commutative rings induced by a ring homomorphism.
This function is continuous. -/
def comap (f : R →+* S) : C(PrimeSpectrum S, PrimeSpectrum R)
    where
  toFun y := ⟨Ideal.comap f y.asIdeal, inferInstance⟩
  continuous_toFun :=
    by
    simp only [continuous_iff_isClosed, is_closed_iff_zero_locus]
    rintro _ ⟨s, rfl⟩
    exact ⟨_, preimage_comap_zero_locus_aux f s⟩
#align prime_spectrum.comap PrimeSpectrum.comap
-/

variable (f : R →+* S)

/- warning: prime_spectrum.comap_as_ideal -> PrimeSpectrum.comap_asIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (y : PrimeSpectrum.{u2} S _inst_2), Eq.{succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PrimeSpectrum.asIdeal.{u1} R _inst_1 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f) y)) (Ideal.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f (PrimeSpectrum.asIdeal.{u2} S _inst_2 y))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (y : PrimeSpectrum.{u2} S _inst_2), Eq.{succ u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PrimeSpectrum.asIdeal.{u1} R _inst_1 (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f) y)) (Ideal.comap.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) f (PrimeSpectrum.asIdeal.{u2} S _inst_2 y))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.comap_as_ideal PrimeSpectrum.comap_asIdealₓ'. -/
@[simp]
theorem comap_asIdeal (y : PrimeSpectrum S) : (comap f y).asIdeal = Ideal.comap f y.asIdeal :=
  rfl
#align prime_spectrum.comap_as_ideal PrimeSpectrum.comap_asIdeal

#print PrimeSpectrum.comap_id /-
@[simp]
theorem comap_id : comap (RingHom.id R) = ContinuousMap.id _ :=
  by
  ext
  rfl
#align prime_spectrum.comap_id PrimeSpectrum.comap_id
-/

/- warning: prime_spectrum.comap_comp -> PrimeSpectrum.comap_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] {S' : Type.{u3}} [_inst_3 : CommRing.{u3} S'] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (g : RingHom.{u2, u3} S S' (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u3} S' (Ring.toNonAssocRing.{u3} S' (CommRing.toRing.{u3} S' _inst_3)))), Eq.{max (succ u3) (succ u1)} (ContinuousMap.{u3, u1} (PrimeSpectrum.{u3} S' _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u3} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u3} R S' _inst_1 _inst_3 (RingHom.comp.{u1, u2, u3} R S S' (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u3} S' (Ring.toNonAssocRing.{u3} S' (CommRing.toRing.{u3} S' _inst_3))) g f)) (ContinuousMap.comp.{u3, u2, u1} (PrimeSpectrum.{u3} S' _inst_3) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u3} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f) (PrimeSpectrum.comap.{u2, u3} S S' _inst_2 _inst_3 g))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] {S' : Type.{u1}} [_inst_3 : CommRing.{u1} S'] (f : RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))) (g : RingHom.{u3, u1} S S' (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S' (CommSemiring.toSemiring.{u1} S' (CommRing.toCommSemiring.{u1} S' _inst_3)))), Eq.{max (succ u2) (succ u1)} (ContinuousMap.{u1, u2} (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1)) (PrimeSpectrum.comap.{u2, u1} R S' _inst_1 _inst_3 (RingHom.comp.{u2, u3, u1} R S S' (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S' (CommSemiring.toSemiring.{u1} S' (CommRing.toCommSemiring.{u1} S' _inst_3))) g f)) (ContinuousMap.comp.{u1, u3, u2} (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u3} S _inst_2) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u3} S _inst_2) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1) (PrimeSpectrum.comap.{u2, u3} R S _inst_1 _inst_2 f) (PrimeSpectrum.comap.{u3, u1} S S' _inst_2 _inst_3 g))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.comap_comp PrimeSpectrum.comap_compₓ'. -/
@[simp]
theorem comap_comp (f : R →+* S) (g : S →+* S') : comap (g.comp f) = (comap f).comp (comap g) :=
  rfl
#align prime_spectrum.comap_comp PrimeSpectrum.comap_comp

/- warning: prime_spectrum.comap_comp_apply -> PrimeSpectrum.comap_comp_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] {S' : Type.{u3}} [_inst_3 : CommRing.{u3} S'] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (g : RingHom.{u2, u3} S S' (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u3} S' (Ring.toNonAssocRing.{u3} S' (CommRing.toRing.{u3} S' _inst_3)))) (x : PrimeSpectrum.{u3} S' _inst_3), Eq.{succ u1} (PrimeSpectrum.{u1} R _inst_1) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (ContinuousMap.{u3, u1} (PrimeSpectrum.{u3} S' _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u3} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u3, u1} (PrimeSpectrum.{u3} S' _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u3} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u3} S' _inst_3) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u3, u1} (PrimeSpectrum.{u3} S' _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u3} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u3} R S' _inst_1 _inst_3 (RingHom.comp.{u1, u2, u3} R S S' (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))) (NonAssocRing.toNonAssocSemiring.{u3} S' (Ring.toNonAssocRing.{u3} S' (CommRing.toRing.{u3} S' _inst_3))) g f)) x) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f) (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (ContinuousMap.{u3, u2} (PrimeSpectrum.{u3} S' _inst_3) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u3} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2)) (fun (_x : ContinuousMap.{u3, u2} (PrimeSpectrum.{u3} S' _inst_3) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u3} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2)) => (PrimeSpectrum.{u3} S' _inst_3) -> (PrimeSpectrum.{u2} S _inst_2)) (ContinuousMap.hasCoeToFun.{u3, u2} (PrimeSpectrum.{u3} S' _inst_3) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u3} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2)) (PrimeSpectrum.comap.{u2, u3} S S' _inst_2 _inst_3 g) x))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] {S' : Type.{u1}} [_inst_3 : CommRing.{u1} S'] (f : RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))) (g : RingHom.{u3, u1} S S' (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S' (CommSemiring.toSemiring.{u1} S' (CommRing.toCommSemiring.{u1} S' _inst_3)))) (x : PrimeSpectrum.{u1} S' _inst_3), Eq.{succ u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u1} S' _inst_3) => PrimeSpectrum.{u2} R _inst_1) x) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (ContinuousMap.{u1, u2} (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1)) (PrimeSpectrum.{u1} S' _inst_3) (fun (_x : PrimeSpectrum.{u1} S' _inst_3) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u1} S' _inst_3) => PrimeSpectrum.{u2} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u1, u2} (ContinuousMap.{u1, u2} (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1)) (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1))) (PrimeSpectrum.comap.{u2, u1} R S' _inst_1 _inst_3 (RingHom.comp.{u2, u3, u1} R S S' (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Semiring.toNonAssocSemiring.{u1} S' (CommSemiring.toSemiring.{u1} S' (CommRing.toCommSemiring.{u1} S' _inst_3))) g f)) x) (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (ContinuousMap.{u3, u2} (PrimeSpectrum.{u3} S _inst_2) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u3} S _inst_2) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1)) (PrimeSpectrum.{u3} S _inst_2) (fun (_x : PrimeSpectrum.{u3} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u3} S _inst_2) => PrimeSpectrum.{u2} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u3, u2} (ContinuousMap.{u3, u2} (PrimeSpectrum.{u3} S _inst_2) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u3} S _inst_2) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1)) (PrimeSpectrum.{u3} S _inst_2) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u3} S _inst_2) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u3, u2} (PrimeSpectrum.{u3} S _inst_2) (PrimeSpectrum.{u2} R _inst_1) (PrimeSpectrum.zariskiTopology.{u3} S _inst_2) (PrimeSpectrum.zariskiTopology.{u2} R _inst_1))) (PrimeSpectrum.comap.{u2, u3} R S _inst_1 _inst_2 f) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (ContinuousMap.{u1, u3} (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u3} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u3} S _inst_2)) (PrimeSpectrum.{u1} S' _inst_3) (fun (_x : PrimeSpectrum.{u1} S' _inst_3) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u1} S' _inst_3) => PrimeSpectrum.{u3} S _inst_2) _x) (ContinuousMapClass.toFunLike.{max u3 u1, u1, u3} (ContinuousMap.{u1, u3} (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u3} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u3} S _inst_2)) (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u3} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u3} S _inst_2) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u3} (PrimeSpectrum.{u1} S' _inst_3) (PrimeSpectrum.{u3} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} S' _inst_3) (PrimeSpectrum.zariskiTopology.{u3} S _inst_2))) (PrimeSpectrum.comap.{u3, u1} S S' _inst_2 _inst_3 g) x))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.comap_comp_apply PrimeSpectrum.comap_comp_applyₓ'. -/
theorem comap_comp_apply (f : R →+* S) (g : S →+* S') (x : PrimeSpectrum S') :
    PrimeSpectrum.comap (g.comp f) x = (PrimeSpectrum.comap f) (PrimeSpectrum.comap g x) :=
  rfl
#align prime_spectrum.comap_comp_apply PrimeSpectrum.comap_comp_apply

/- warning: prime_spectrum.preimage_comap_zero_locus -> PrimeSpectrum.preimage_comap_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (s : Set.{u1} R), Eq.{succ u2} (Set.{u2} (PrimeSpectrum.{u2} S _inst_2)) (Set.preimage.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s)) (PrimeSpectrum.zeroLocus.{u2} S _inst_2 (Set.image.{u1, u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f) s))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (s : Set.{u1} R), Eq.{succ u2} (Set.{u2} (PrimeSpectrum.{u2} S _inst_2)) (Set.preimage.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f)) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 s)) (PrimeSpectrum.zeroLocus.{u2} S _inst_2 (Set.image.{u1, u2} R S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))))) f) s))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.preimage_comap_zero_locus PrimeSpectrum.preimage_comap_zeroLocusₓ'. -/
@[simp]
theorem preimage_comap_zeroLocus (s : Set R) : comap f ⁻¹' zeroLocus s = zeroLocus (f '' s) :=
  preimage_comap_zeroLocus_aux f s
#align prime_spectrum.preimage_comap_zero_locus PrimeSpectrum.preimage_comap_zeroLocus

/- warning: prime_spectrum.comap_injective_of_surjective -> PrimeSpectrum.comap_injective_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f)) -> (Function.Injective.{succ u2, succ u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))))) f)) -> (Function.Injective.{succ u2, succ u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.comap_injective_of_surjective PrimeSpectrum.comap_injective_of_surjectiveₓ'. -/
theorem comap_injective_of_surjective (f : R →+* S) (hf : Function.Surjective f) :
    Function.Injective (comap f) := fun x y h =>
  PrimeSpectrum.ext _ _
    (Ideal.comap_injective_of_surjective f hf
      (congr_arg PrimeSpectrum.asIdeal h : (comap f x).asIdeal = (comap f y).asIdeal))
#align prime_spectrum.comap_injective_of_surjective PrimeSpectrum.comap_injective_of_surjective

/- warning: prime_spectrum.comap_singleton_is_closed_of_surjective -> PrimeSpectrum.comap_singleton_isClosed_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f)) -> (forall (x : PrimeSpectrum.{u2} S _inst_2), (IsClosed.{u2} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (Singleton.singleton.{u2, u2} (PrimeSpectrum.{u2} S _inst_2) (Set.{u2} (PrimeSpectrum.{u2} S _inst_2)) (Set.hasSingleton.{u2} (PrimeSpectrum.{u2} S _inst_2)) x)) -> (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (Singleton.singleton.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasSingleton.{u1} (PrimeSpectrum.{u1} R _inst_1)) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f) x))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))))) f)) -> (forall (x : PrimeSpectrum.{u2} S _inst_2), (IsClosed.{u2} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (Singleton.singleton.{u2, u2} (PrimeSpectrum.{u2} S _inst_2) (Set.{u2} (PrimeSpectrum.{u2} S _inst_2)) (Set.instSingletonSet.{u2} (PrimeSpectrum.{u2} S _inst_2)) x)) -> (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (Singleton.singleton.{u1, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) x) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instSingletonSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f) x))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.comap_singleton_is_closed_of_surjective PrimeSpectrum.comap_singleton_isClosed_of_surjectiveₓ'. -/
theorem comap_singleton_isClosed_of_surjective (f : R →+* S) (hf : Function.Surjective f)
    (x : PrimeSpectrum S) (hx : IsClosed ({x} : Set (PrimeSpectrum S))) :
    IsClosed ({comap f x} : Set (PrimeSpectrum R)) :=
  haveI : x.as_ideal.is_maximal := (is_closed_singleton_iff_is_maximal x).1 hx
  (is_closed_singleton_iff_is_maximal _).2 (Ideal.comap_isMaximal_of_surjective f hf)
#align prime_spectrum.comap_singleton_is_closed_of_surjective PrimeSpectrum.comap_singleton_isClosed_of_surjective

/- warning: prime_spectrum.comap_singleton_is_closed_of_is_integral -> PrimeSpectrum.comap_singleton_isClosed_of_isIntegral is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))), (RingHom.IsIntegral.{u1, u2} R S _inst_1 (CommRing.toRing.{u2} S _inst_2) f) -> (forall (x : PrimeSpectrum.{u2} S _inst_2), (IsClosed.{u2} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (Singleton.singleton.{u2, u2} (PrimeSpectrum.{u2} S _inst_2) (Set.{u2} (PrimeSpectrum.{u2} S _inst_2)) (Set.hasSingleton.{u2} (PrimeSpectrum.{u2} S _inst_2)) x)) -> (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (Singleton.singleton.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasSingleton.{u1} (PrimeSpectrum.{u1} R _inst_1)) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f) x))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))), (RingHom.IsIntegral.{u1, u2} R S _inst_1 (CommRing.toRing.{u2} S _inst_2) f) -> (forall (x : PrimeSpectrum.{u2} S _inst_2), (IsClosed.{u2} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (Singleton.singleton.{u2, u2} (PrimeSpectrum.{u2} S _inst_2) (Set.{u2} (PrimeSpectrum.{u2} S _inst_2)) (Set.instSingletonSet.{u2} (PrimeSpectrum.{u2} S _inst_2)) x)) -> (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (Singleton.singleton.{u1, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) x) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instSingletonSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f) x))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.comap_singleton_is_closed_of_is_integral PrimeSpectrum.comap_singleton_isClosed_of_isIntegralₓ'. -/
theorem comap_singleton_isClosed_of_isIntegral (f : R →+* S) (hf : f.IsIntegral)
    (x : PrimeSpectrum S) (hx : IsClosed ({x} : Set (PrimeSpectrum S))) :
    IsClosed ({comap f x} : Set (PrimeSpectrum R)) :=
  (isClosed_singleton_iff_isMaximal _).2
    (Ideal.isMaximal_comap_of_isIntegral_of_is_maximal' f hf x.asIdeal <|
      (isClosed_singleton_iff_isMaximal x).1 hx)
#align prime_spectrum.comap_singleton_is_closed_of_is_integral PrimeSpectrum.comap_singleton_isClosed_of_isIntegral

variable (S)

/- warning: prime_spectrum.localization_comap_inducing -> PrimeSpectrum.localization_comap_inducing is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) [_inst_5 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_4], Inducing.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) [_inst_5 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_4], Inducing.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) _inst_4)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.localization_comap_inducing PrimeSpectrum.localization_comap_inducingₓ'. -/
theorem localization_comap_inducing [Algebra R S] (M : Submonoid R) [IsLocalization M S] :
    Inducing (comap (algebraMap R S)) := by
  constructor
  rw [topologicalSpace_eq_iff]
  intro U
  simp_rw [← isClosed_compl_iff]
  generalize Uᶜ = Z
  simp_rw [isClosed_induced_iff, is_closed_iff_zero_locus]
  constructor
  · rintro ⟨s, rfl⟩
    refine' ⟨_, ⟨algebraMap R S ⁻¹' Ideal.span s, rfl⟩, _⟩
    rw [preimage_comap_zero_locus, ← zero_locus_span, ← zero_locus_span s]
    congr 1
    exact congr_arg Submodule.carrier (IsLocalization.map_comap M S (Ideal.span s))
  · rintro ⟨_, ⟨t, rfl⟩, rfl⟩
    simp
#align prime_spectrum.localization_comap_inducing PrimeSpectrum.localization_comap_inducing

/- warning: prime_spectrum.localization_comap_injective -> PrimeSpectrum.localization_comap_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) [_inst_5 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_4], Function.Injective.{succ u2, succ u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) [_inst_5 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_4], Function.Injective.{succ u2, succ u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) _inst_4)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.localization_comap_injective PrimeSpectrum.localization_comap_injectiveₓ'. -/
theorem localization_comap_injective [Algebra R S] (M : Submonoid R) [IsLocalization M S] :
    Function.Injective (comap (algebraMap R S)) :=
  by
  intro p q h
  replace h := congr_arg (fun x : PrimeSpectrum R => Ideal.map (algebraMap R S) x.asIdeal) h
  dsimp only at h
  erw [IsLocalization.map_comap M S, IsLocalization.map_comap M S] at h
  ext1
  exact h
#align prime_spectrum.localization_comap_injective PrimeSpectrum.localization_comap_injective

/- warning: prime_spectrum.localization_comap_embedding -> PrimeSpectrum.localization_comap_embedding is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) [_inst_5 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_4], Embedding.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) [_inst_5 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_4], Embedding.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) _inst_4)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.localization_comap_embedding PrimeSpectrum.localization_comap_embeddingₓ'. -/
theorem localization_comap_embedding [Algebra R S] (M : Submonoid R) [IsLocalization M S] :
    Embedding (comap (algebraMap R S)) :=
  ⟨localization_comap_inducing S M, localization_comap_injective S M⟩
#align prime_spectrum.localization_comap_embedding PrimeSpectrum.localization_comap_embedding

/- warning: prime_spectrum.localization_comap_range -> PrimeSpectrum.localization_comap_range is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) [_inst_5 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_4], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.range.{u1, succ u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) _inst_4)))) (setOf.{u1} (PrimeSpectrum.{u1} R _inst_1) (fun (p : PrimeSpectrum.{u1} R _inst_1) => Disjoint.{u1} (Set.{u1} R) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} R) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} R) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} R) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} R) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} R) (Set.completeBooleanAlgebra.{u1} R)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} R) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} R) (Set.booleanAlgebra.{u1} R))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))) M) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (PrimeSpectrum.asIdeal.{u1} R _inst_1 p))))
but is expected to have type
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))] (M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) [_inst_5 : IsLocalization.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) M S (CommRing.toCommSemiring.{u2} S _inst_2) _inst_4], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.range.{u1, succ u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) _inst_4)))) (setOf.{u1} (PrimeSpectrum.{u1} R _inst_1) (fun (p : PrimeSpectrum.{u1} R _inst_1) => Disjoint.{u1} (Set.{u1} R) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} R) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} R) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} R) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} R) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} R) (Set.instCompleteBooleanAlgebraSet.{u1} R)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} R) (Preorder.toLE.{u1} (Set.{u1} R) (PartialOrder.toPreorder.{u1} (Set.{u1} R) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} R) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} R) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} R) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} R) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} R) (Set.instCompleteBooleanAlgebraSet.{u1} R)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} R) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} R) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} R) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} R) (Set.instCompleteBooleanAlgebraSet.{u1} R)))))) (SetLike.coe.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) R (Submonoid.instSetLikeSubmonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) M) (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (PrimeSpectrum.asIdeal.{u1} R _inst_1 p))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.localization_comap_range PrimeSpectrum.localization_comap_rangeₓ'. -/
theorem localization_comap_range [Algebra R S] (M : Submonoid R) [IsLocalization M S] :
    Set.range (comap (algebraMap R S)) = { p | Disjoint (M : Set R) p.asIdeal } :=
  by
  ext x
  constructor
  · simp_rw [disjoint_iff_inf_le]
    rintro ⟨p, rfl⟩ x ⟨hx₁, hx₂⟩
    exact (p.2.1 : ¬_) (p.as_ideal.eq_top_of_is_unit_mem hx₂ (IsLocalization.map_units S ⟨x, hx₁⟩))
  · intro h
    use ⟨x.as_ideal.map (algebraMap R S), IsLocalization.isPrime_of_isPrime_disjoint M S _ x.2 h⟩
    ext1
    exact IsLocalization.comap_map_of_isPrime_disjoint M S _ x.2 h
#align prime_spectrum.localization_comap_range PrimeSpectrum.localization_comap_range

section SpecOfSurjective

/-! The comap of a surjective ring homomorphism is a closed embedding between the prime spectra. -/


open Function RingHom

/- warning: prime_spectrum.comap_inducing_of_surjective -> PrimeSpectrum.comap_inducing_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f)) -> (Inducing.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f)))
but is expected to have type
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))))) f)) -> (Inducing.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.comap_inducing_of_surjective PrimeSpectrum.comap_inducing_of_surjectiveₓ'. -/
theorem comap_inducing_of_surjective (hf : Surjective f) : Inducing (comap f) :=
  {
    induced :=
      by
      simp_rw [topologicalSpace_eq_iff, ← isClosed_compl_iff, isClosed_induced_iff,
        is_closed_iff_zero_locus]
      refine' fun s =>
        ⟨fun ⟨F, hF⟩ =>
          ⟨zero_locus (f ⁻¹' F), ⟨f ⁻¹' F, rfl⟩, by
            rw [preimage_comap_zero_locus, surjective.image_preimage hf, hF]⟩,
          _⟩
      rintro ⟨-, ⟨F, rfl⟩, hF⟩
      exact ⟨f '' F, hF.symm.trans (preimage_comap_zero_locus f F)⟩ }
#align prime_spectrum.comap_inducing_of_surjective PrimeSpectrum.comap_inducing_of_surjective

/- warning: prime_spectrum.image_comap_zero_locus_eq_zero_locus_comap -> PrimeSpectrum.image_comap_zeroLocus_eq_zeroLocus_comap is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align prime_spectrum.image_comap_zero_locus_eq_zero_locus_comap PrimeSpectrum.image_comap_zeroLocus_eq_zeroLocus_comapₓ'. -/
theorem image_comap_zeroLocus_eq_zeroLocus_comap (hf : Surjective f) (I : Ideal S) :
    comap f '' zeroLocus I = zeroLocus (I.comap f) :=
  by
  simp only [Set.ext_iff, Set.mem_image, mem_zero_locus, SetLike.coe_subset_coe]
  refine' fun p => ⟨_, fun h_I_p => _⟩
  · rintro ⟨p, hp, rfl⟩ a ha
    exact hp ha
  · have hp : ker f ≤ p.as_ideal := (Ideal.comap_mono bot_le).trans h_I_p
    refine' ⟨⟨p.as_ideal.map f, Ideal.map_isPrime_of_surjective hf hp⟩, fun x hx => _, _⟩
    · obtain ⟨x', rfl⟩ := hf x
      exact Ideal.mem_map_of_mem f (h_I_p hx)
    · ext x
      change f x ∈ p.as_ideal.map f ↔ _
      rw [Ideal.mem_map_iff_of_surjective f hf]
      refine' ⟨_, fun hx => ⟨x, hx, rfl⟩⟩
      rintro ⟨x', hx', heq⟩
      rw [← sub_sub_cancel x' x]
      refine' p.as_ideal.sub_mem hx' (hp _)
      rwa [mem_ker, map_sub, sub_eq_zero]
#align prime_spectrum.image_comap_zero_locus_eq_zero_locus_comap PrimeSpectrum.image_comap_zeroLocus_eq_zeroLocus_comap

/- warning: prime_spectrum.range_comap_of_surjective -> PrimeSpectrum.range_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f)) -> (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.range.{u1, succ u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (HasLiftT.mk.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (CoeTCₓ.coe.{succ u1, succ u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Set.{u1} R) (SetLike.Set.hasCoeT.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (RingHom.ker.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (RingHom.ringHomClass.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f))))
but is expected to have type
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))))) f)) -> (Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.range.{u1, succ u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (SetLike.coe.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (RingHom.ker.{u1, u2, max u1 u2} R S (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) f))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.range_comap_of_surjective PrimeSpectrum.range_comap_of_surjectiveₓ'. -/
theorem range_comap_of_surjective (hf : Surjective f) : Set.range (comap f) = zeroLocus (ker f) :=
  by
  rw [← Set.image_univ]
  convert image_comap_zero_locus_eq_zero_locus_comap _ _ hf _
  rw [zero_locus_bot]
#align prime_spectrum.range_comap_of_surjective PrimeSpectrum.range_comap_of_surjective

/- warning: prime_spectrum.is_closed_range_comap_of_surjective -> PrimeSpectrum.isClosed_range_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f)) -> (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (Set.range.{u1, succ u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f))))
but is expected to have type
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))))) f)) -> (IsClosed.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (Set.range.{u1, succ u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.is_closed_range_comap_of_surjective PrimeSpectrum.isClosed_range_comap_of_surjectiveₓ'. -/
theorem isClosed_range_comap_of_surjective (hf : Surjective f) : IsClosed (Set.range (comap f)) :=
  by
  rw [range_comap_of_surjective _ f hf]
  exact is_closed_zero_locus ↑(ker f)
#align prime_spectrum.is_closed_range_comap_of_surjective PrimeSpectrum.isClosed_range_comap_of_surjective

/- warning: prime_spectrum.closed_embedding_comap_of_surjective -> PrimeSpectrum.closedEmbedding_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))) f)) -> (ClosedEmbedding.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_2) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f)))
but is expected to have type
  forall {R : Type.{u1}} (S : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))), (Function.Surjective.{succ u1, succ u2} R S (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))))) f)) -> (ClosedEmbedding.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (fun (_x : PrimeSpectrum.{u2} S _inst_2) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_2) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_2) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_2) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_2 f)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.closed_embedding_comap_of_surjective PrimeSpectrum.closedEmbedding_comap_of_surjectiveₓ'. -/
theorem closedEmbedding_comap_of_surjective (hf : Surjective f) : ClosedEmbedding (comap f) :=
  { induced := (comap_inducing_of_surjective S f hf).induced
    inj := comap_injective_of_surjective f hf
    closed_range := isClosed_range_comap_of_surjective S f hf }
#align prime_spectrum.closed_embedding_comap_of_surjective PrimeSpectrum.closedEmbedding_comap_of_surjective

end SpecOfSurjective

end Comap

section BasicOpen

#print PrimeSpectrum.basicOpen /-
/-- `basic_open r` is the open subset containing all prime ideals not containing `r`. -/
def basicOpen (r : R) : TopologicalSpace.Opens (PrimeSpectrum R)
    where
  carrier := { x | r ∉ x.asIdeal }
  is_open' := ⟨{r}, Set.ext fun x => Set.singleton_subset_iff.trans <| Classical.not_not.symm⟩
#align prime_spectrum.basic_open PrimeSpectrum.basicOpen
-/

#print PrimeSpectrum.mem_basicOpen /-
@[simp]
theorem mem_basicOpen (f : R) (x : PrimeSpectrum R) : x ∈ basicOpen f ↔ f ∉ x.asIdeal :=
  Iff.rfl
#align prime_spectrum.mem_basic_open PrimeSpectrum.mem_basicOpen
-/

#print PrimeSpectrum.isOpen_basicOpen /-
theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=
  (basicOpen a).IsOpen
#align prime_spectrum.is_open_basic_open PrimeSpectrum.isOpen_basicOpen
-/

/- warning: prime_spectrum.basic_open_eq_zero_locus_compl -> PrimeSpectrum.basicOpen_eq_zeroLocus_compl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (r : R), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (HasLiftT.mk.{succ u1, succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CoeTCₓ.coe.{succ u1, succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (SetLike.Set.hasCoeT.{u1, u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.setLike.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 r)) (HasCompl.compl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.booleanAlgebra.{u1} (PrimeSpectrum.{u1} R _inst_1))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) r)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (r : R), Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (SetLike.coe.{u1, u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.instSetLikeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 r)) (HasCompl.compl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (BooleanAlgebra.toHasCompl.{u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instBooleanAlgebraSet.{u1} (PrimeSpectrum.{u1} R _inst_1))) (PrimeSpectrum.zeroLocus.{u1} R _inst_1 (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) r)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.basic_open_eq_zero_locus_compl PrimeSpectrum.basicOpen_eq_zeroLocus_complₓ'. -/
@[simp]
theorem basicOpen_eq_zeroLocus_compl (r : R) :
    (basicOpen r : Set (PrimeSpectrum R)) = zeroLocus {r}ᶜ :=
  Set.ext fun x => by simpa only [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff]
#align prime_spectrum.basic_open_eq_zero_locus_compl PrimeSpectrum.basicOpen_eq_zeroLocus_compl

/- warning: prime_spectrum.basic_open_one -> PrimeSpectrum.basicOpen_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))) (Top.top.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toHasTop.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.completeLattice.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (Top.top.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toTop.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.basic_open_one PrimeSpectrum.basicOpen_oneₓ'. -/
@[simp]
theorem basicOpen_one : basicOpen (1 : R) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
#align prime_spectrum.basic_open_one PrimeSpectrum.basicOpen_one

/- warning: prime_spectrum.basic_open_zero -> PrimeSpectrum.basicOpen_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) (Bot.bot.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toHasBot.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.completeLattice.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (Bot.bot.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toBot.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.basic_open_zero PrimeSpectrum.basicOpen_zeroₓ'. -/
@[simp]
theorem basicOpen_zero : basicOpen (0 : R) = ⊥ :=
  TopologicalSpace.Opens.ext <| by simp
#align prime_spectrum.basic_open_zero PrimeSpectrum.basicOpen_zero

/- warning: prime_spectrum.basic_open_le_basic_open_iff -> PrimeSpectrum.basicOpen_le_basicOpen_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), Iff (LE.le.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Preorder.toHasLe.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.setLike.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f) (PrimeSpectrum.basicOpen.{u1} R _inst_1 g)) (Membership.Mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) f (Ideal.radical.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.hasSingleton.{u1} R) g))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), Iff (LE.le.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Preorder.toLE.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f) (PrimeSpectrum.basicOpen.{u1} R _inst_1 g)) (Membership.mem.{u1, u1} R (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) f (Ideal.radical.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (Ideal.span.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (Singleton.singleton.{u1, u1} R (Set.{u1} R) (Set.instSingletonSet.{u1} R) g))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.basic_open_le_basic_open_iff PrimeSpectrum.basicOpen_le_basicOpen_iffₓ'. -/
theorem basicOpen_le_basicOpen_iff (f g : R) :
    basicOpen f ≤ basicOpen g ↔ f ∈ (Ideal.span ({g} : Set R)).radical := by
  rw [← SetLike.coe_subset_coe, basic_open_eq_zero_locus_compl, basic_open_eq_zero_locus_compl,
    Set.compl_subset_compl, zero_locus_subset_zero_locus_singleton_iff]
#align prime_spectrum.basic_open_le_basic_open_iff PrimeSpectrum.basicOpen_le_basicOpen_iff

/- warning: prime_spectrum.basic_open_mul -> PrimeSpectrum.basicOpen_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) f g)) (Inf.inf.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (SemilatticeInf.toHasInf.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Lattice.toSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.completeLattice.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f) (PrimeSpectrum.basicOpen.{u1} R _inst_1 g))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) f g)) (Inf.inf.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Lattice.toInf.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f) (PrimeSpectrum.basicOpen.{u1} R _inst_1 g))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.basic_open_mul PrimeSpectrum.basicOpen_mulₓ'. -/
theorem basicOpen_mul (f g : R) : basicOpen (f * g) = basicOpen f ⊓ basicOpen g :=
  TopologicalSpace.Opens.ext <| by simp [zero_locus_singleton_mul]
#align prime_spectrum.basic_open_mul PrimeSpectrum.basicOpen_mul

/- warning: prime_spectrum.basic_open_mul_le_left -> PrimeSpectrum.basicOpen_mul_le_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), LE.le.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Preorder.toHasLe.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.setLike.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) f g)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), LE.le.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Preorder.toLE.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) f g)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f)
Case conversion may be inaccurate. Consider using '#align prime_spectrum.basic_open_mul_le_left PrimeSpectrum.basicOpen_mul_le_leftₓ'. -/
theorem basicOpen_mul_le_left (f g : R) : basicOpen (f * g) ≤ basicOpen f :=
  by
  rw [basic_open_mul f g]
  exact inf_le_left
#align prime_spectrum.basic_open_mul_le_left PrimeSpectrum.basicOpen_mul_le_left

/- warning: prime_spectrum.basic_open_mul_le_right -> PrimeSpectrum.basicOpen_mul_le_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), LE.le.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Preorder.toHasLe.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (SetLike.partialOrder.{u1, u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.setLike.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) f g)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 g)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (g : R), LE.le.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Preorder.toLE.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) f g)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 g)
Case conversion may be inaccurate. Consider using '#align prime_spectrum.basic_open_mul_le_right PrimeSpectrum.basicOpen_mul_le_rightₓ'. -/
theorem basicOpen_mul_le_right (f g : R) : basicOpen (f * g) ≤ basicOpen g :=
  by
  rw [basic_open_mul f g]
  exact inf_le_right
#align prime_spectrum.basic_open_mul_le_right PrimeSpectrum.basicOpen_mul_le_right

/- warning: prime_spectrum.basic_open_pow -> PrimeSpectrum.basicOpen_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (n : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1)))) f n)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R) (n : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) f n)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.basic_open_pow PrimeSpectrum.basicOpen_powₓ'. -/
@[simp]
theorem basicOpen_pow (f : R) (n : ℕ) (hn : 0 < n) : basicOpen (f ^ n) = basicOpen f :=
  TopologicalSpace.Opens.ext <| by simpa using zero_locus_singleton_pow f n hn
#align prime_spectrum.basic_open_pow PrimeSpectrum.basicOpen_pow

#print PrimeSpectrum.isTopologicalBasis_basic_opens /-
theorem isTopologicalBasis_basic_opens :
    TopologicalSpace.IsTopologicalBasis
      (Set.range fun r : R => (basicOpen r : Set (PrimeSpectrum R))) :=
  by
  apply TopologicalSpace.isTopologicalBasis_of_open_of_nhds
  · rintro _ ⟨r, rfl⟩
    exact is_open_basic_open
  · rintro p U hp ⟨s, hs⟩
    rw [← compl_compl U, Set.mem_compl_iff, ← hs, mem_zero_locus, Set.not_subset] at hp
    obtain ⟨f, hfs, hfp⟩ := hp
    refine' ⟨basic_open f, ⟨f, rfl⟩, hfp, _⟩
    rw [← Set.compl_subset_compl, ← hs, basic_open_eq_zero_locus_compl, compl_compl]
    exact zero_locus_anti_mono (set.singleton_subset_iff.mpr hfs)
#align prime_spectrum.is_topological_basis_basic_opens PrimeSpectrum.isTopologicalBasis_basic_opens
-/

#print PrimeSpectrum.isBasis_basic_opens /-
theorem isBasis_basic_opens : TopologicalSpace.Opens.IsBasis (Set.range (@basicOpen R _)) :=
  by
  unfold TopologicalSpace.Opens.IsBasis
  convert is_topological_basis_basic_opens
  rw [← Set.range_comp]
#align prime_spectrum.is_basis_basic_opens PrimeSpectrum.isBasis_basic_opens
-/

#print PrimeSpectrum.isCompact_basicOpen /-
theorem isCompact_basicOpen (f : R) : IsCompact (basicOpen f : Set (PrimeSpectrum R)) :=
  isCompact_of_finite_subfamily_closed fun ι Z hZc hZ =>
    by
    let I : ι → Ideal R := fun i => vanishing_ideal (Z i)
    have hI : ∀ i, Z i = zero_locus (I i) := fun i => by
      simpa only [zero_locus_vanishing_ideal_eq_closure] using (hZc i).closure_eq.symm
    rw [basic_open_eq_zero_locus_compl f, Set.inter_comm, ← Set.diff_eq, Set.diff_eq_empty,
      funext hI, ← zero_locus_supr] at hZ
    obtain ⟨n, hn⟩ : f ∈ (⨆ i : ι, I i).radical :=
      by
      rw [← vanishing_ideal_zero_locus_eq_radical]
      apply vanishing_ideal_anti_mono hZ
      exact subset_vanishing_ideal_zero_locus {f} (Set.mem_singleton f)
    rcases Submodule.exists_finset_of_mem_iSup I hn with ⟨s, hs⟩
    use s
    -- Using simp_rw here, because `hI` and `zero_locus_supr` need to be applied underneath binders
    simp_rw [basic_open_eq_zero_locus_compl f, Set.inter_comm (zero_locus {f}ᶜ), ← Set.diff_eq,
      Set.diff_eq_empty, hI, ← zero_locus_supr]
    rw [← zero_locus_radical]
    -- this one can't be in `simp_rw` because it would loop
    apply zero_locus_anti_mono
    rw [Set.singleton_subset_iff]
    exact ⟨n, hs⟩
#align prime_spectrum.is_compact_basic_open PrimeSpectrum.isCompact_basicOpen
-/

/- warning: prime_spectrum.basic_open_eq_bot_iff -> PrimeSpectrum.basicOpen_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R), Iff (Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f) (Bot.bot.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toHasBot.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.completeLattice.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))) (IsNilpotent.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_1))) f)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (f : R), Iff (Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 f) (Bot.bot.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toBot.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))) (IsNilpotent.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) f)
Case conversion may be inaccurate. Consider using '#align prime_spectrum.basic_open_eq_bot_iff PrimeSpectrum.basicOpen_eq_bot_iffₓ'. -/
@[simp]
theorem basicOpen_eq_bot_iff (f : R) : basicOpen f = ⊥ ↔ IsNilpotent f :=
  by
  rw [← TopologicalSpace.Opens.coe_inj, basic_open_eq_zero_locus_compl]
  simp only [Set.eq_univ_iff_forall, Set.singleton_subset_iff, TopologicalSpace.Opens.coe_bot,
    nilpotent_iff_mem_prime, Set.compl_empty_iff, mem_zero_locus, SetLike.mem_coe]
  exact ⟨fun h I hI => h ⟨I, hI⟩, fun h ⟨I, hI⟩ => h I hI⟩
#align prime_spectrum.basic_open_eq_bot_iff PrimeSpectrum.basicOpen_eq_bot_iff

/- warning: prime_spectrum.localization_away_comap_range -> PrimeSpectrum.localization_away_comap_range is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_3 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))] (r : R) [_inst_5 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) r S (CommRing.toCommSemiring.{u2} S _inst_3) _inst_4], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.range.{u1, succ u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_3) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_3 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3)) _inst_4)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (HasLiftT.mk.{succ u1, succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (CoeTCₓ.coe.{succ u1, succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (SetLike.Set.hasCoeT.{u1, u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.setLike.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))))) (PrimeSpectrum.basicOpen.{u1} R _inst_1 r))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_3 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_3))] (r : R) [_inst_5 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) r S (CommRing.toCommSemiring.{u2} S _inst_3) _inst_4], Eq.{succ u1} (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.range.{u1, succ u2} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.{u2} S _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_3) (fun (_x : PrimeSpectrum.{u2} S _inst_3) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_3) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_3 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_3)) _inst_4)))) (SetLike.coe.{u1, u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.instSetLikeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.basicOpen.{u1} R _inst_1 r))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.localization_away_comap_range PrimeSpectrum.localization_away_comap_rangeₓ'. -/
theorem localization_away_comap_range (S : Type v) [CommRing S] [Algebra R S] (r : R)
    [IsLocalization.Away r S] : Set.range (comap (algebraMap R S)) = basicOpen r :=
  by
  rw [localization_comap_range S (Submonoid.powers r)]
  ext
  simp only [mem_zero_locus, basic_open_eq_zero_locus_compl, SetLike.mem_coe, Set.mem_setOf_eq,
    Set.singleton_subset_iff, Set.mem_compl_iff, disjoint_iff_inf_le]
  constructor
  · intro h₁ h₂
    exact h₁ ⟨Submonoid.mem_powers r, h₂⟩
  · rintro h₁ _ ⟨⟨n, rfl⟩, h₃⟩
    exact h₁ (x.2.mem_of_pow_mem _ h₃)
#align prime_spectrum.localization_away_comap_range PrimeSpectrum.localization_away_comap_range

/- warning: prime_spectrum.localization_away_open_embedding -> PrimeSpectrum.localization_away_openEmbedding is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_3 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3))] (r : R) [_inst_5 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) r S (CommRing.toCommSemiring.{u2} S _inst_3) _inst_4], OpenEmbedding.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_3) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_3 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_3)) _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (S : Type.{u2}) [_inst_3 : CommRing.{u2} S] [_inst_4 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_3))] (r : R) [_inst_5 : IsLocalization.Away.{u1, u2} R (CommRing.toCommSemiring.{u1} R _inst_1) r S (CommRing.toCommSemiring.{u2} S _inst_3) _inst_4], OpenEmbedding.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_3) (fun (_x : PrimeSpectrum.{u2} S _inst_3) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_3) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_3) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_3) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_3 (algebraMap.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_3)) _inst_4)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.localization_away_open_embedding PrimeSpectrum.localization_away_openEmbeddingₓ'. -/
theorem localization_away_openEmbedding (S : Type v) [CommRing S] [Algebra R S] (r : R)
    [IsLocalization.Away r S] : OpenEmbedding (comap (algebraMap R S)) :=
  { toEmbedding := localization_comap_embedding S (Submonoid.powers r)
    open_range := by
      rw [localization_away_comap_range S r]
      exact is_open_basic_open }
#align prime_spectrum.localization_away_open_embedding PrimeSpectrum.localization_away_openEmbedding

end BasicOpen

/-- The prime spectrum of a commutative ring is a compact topological space. -/
instance : CompactSpace (PrimeSpectrum R)
    where isCompact_univ := by
    convert is_compact_basic_open (1 : R)
    rw [basic_open_one]
    rfl

section Order

/-!
## The specialization order

We endow `prime_spectrum R` with a partial order, where `x ≤ y` if and only if `y ∈ closure {x}`.
-/


instance : PartialOrder (PrimeSpectrum R) :=
  PartialOrder.lift asIdeal ext

/- warning: prime_spectrum.as_ideal_le_as_ideal -> PrimeSpectrum.asIdeal_le_asIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : PrimeSpectrum.{u1} R _inst_1) (y : PrimeSpectrum.{u1} R _inst_1), Iff (LE.le.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLe.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y)) (LE.le.{u1} (PrimeSpectrum.{u1} R _inst_1) (Preorder.toHasLe.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.partialOrder.{u1} R _inst_1))) x y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : PrimeSpectrum.{u1} R _inst_1) (y : PrimeSpectrum.{u1} R _inst_1), Iff (LE.le.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLE.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y)) (LE.le.{u1} (PrimeSpectrum.{u1} R _inst_1) (Preorder.toLE.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.instPartialOrderPrimeSpectrum.{u1} R _inst_1))) x y)
Case conversion may be inaccurate. Consider using '#align prime_spectrum.as_ideal_le_as_ideal PrimeSpectrum.asIdeal_le_asIdealₓ'. -/
@[simp]
theorem asIdeal_le_asIdeal (x y : PrimeSpectrum R) : x.asIdeal ≤ y.asIdeal ↔ x ≤ y :=
  Iff.rfl
#align prime_spectrum.as_ideal_le_as_ideal PrimeSpectrum.asIdeal_le_asIdeal

/- warning: prime_spectrum.as_ideal_lt_as_ideal -> PrimeSpectrum.asIdeal_lt_asIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : PrimeSpectrum.{u1} R _inst_1) (y : PrimeSpectrum.{u1} R _inst_1), Iff (LT.lt.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (Preorder.toHasLt.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) (SetLike.partialOrder.{u1, u1} (Ideal.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))) R (Submodule.setLike.{u1, u1} R R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y)) (LT.lt.{u1} (PrimeSpectrum.{u1} R _inst_1) (Preorder.toHasLt.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.partialOrder.{u1} R _inst_1))) x y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : PrimeSpectrum.{u1} R _inst_1) (y : PrimeSpectrum.{u1} R _inst_1), Iff (LT.lt.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Preorder.toLT.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Ideal.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Submodule.completeLattice.{u1, u1} R R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))))) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y)) (LT.lt.{u1} (PrimeSpectrum.{u1} R _inst_1) (Preorder.toLT.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.instPartialOrderPrimeSpectrum.{u1} R _inst_1))) x y)
Case conversion may be inaccurate. Consider using '#align prime_spectrum.as_ideal_lt_as_ideal PrimeSpectrum.asIdeal_lt_asIdealₓ'. -/
@[simp]
theorem asIdeal_lt_asIdeal (x y : PrimeSpectrum R) : x.asIdeal < y.asIdeal ↔ x < y :=
  Iff.rfl
#align prime_spectrum.as_ideal_lt_as_ideal PrimeSpectrum.asIdeal_lt_asIdeal

/- warning: prime_spectrum.le_iff_mem_closure -> PrimeSpectrum.le_iff_mem_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : PrimeSpectrum.{u1} R _inst_1) (y : PrimeSpectrum.{u1} R _inst_1), Iff (LE.le.{u1} (PrimeSpectrum.{u1} R _inst_1) (Preorder.toHasLe.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.partialOrder.{u1} R _inst_1))) x y) (Membership.Mem.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasMem.{u1} (PrimeSpectrum.{u1} R _inst_1)) y (closure.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (Singleton.singleton.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.hasSingleton.{u1} (PrimeSpectrum.{u1} R _inst_1)) x)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : PrimeSpectrum.{u1} R _inst_1) (y : PrimeSpectrum.{u1} R _inst_1), Iff (LE.le.{u1} (PrimeSpectrum.{u1} R _inst_1) (Preorder.toLE.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.instPartialOrderPrimeSpectrum.{u1} R _inst_1))) x y) (Membership.mem.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instMembershipSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) y (closure.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (Singleton.singleton.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Set.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Set.instSingletonSet.{u1} (PrimeSpectrum.{u1} R _inst_1)) x)))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.le_iff_mem_closure PrimeSpectrum.le_iff_mem_closureₓ'. -/
theorem le_iff_mem_closure (x y : PrimeSpectrum R) :
    x ≤ y ↔ y ∈ closure ({x} : Set (PrimeSpectrum R)) := by
  rw [← as_ideal_le_as_ideal, ← zero_locus_vanishing_ideal_eq_closure, mem_zero_locus,
    vanishing_ideal_singleton, SetLike.coe_subset_coe]
#align prime_spectrum.le_iff_mem_closure PrimeSpectrum.le_iff_mem_closure

/- warning: prime_spectrum.le_iff_specializes -> PrimeSpectrum.le_iff_specializes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : PrimeSpectrum.{u1} R _inst_1) (y : PrimeSpectrum.{u1} R _inst_1), Iff (LE.le.{u1} (PrimeSpectrum.{u1} R _inst_1) (Preorder.toHasLe.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.partialOrder.{u1} R _inst_1))) x y) (Specializes.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) x y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] (x : PrimeSpectrum.{u1} R _inst_1) (y : PrimeSpectrum.{u1} R _inst_1), Iff (LE.le.{u1} (PrimeSpectrum.{u1} R _inst_1) (Preorder.toLE.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.instPartialOrderPrimeSpectrum.{u1} R _inst_1))) x y) (Specializes.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) x y)
Case conversion may be inaccurate. Consider using '#align prime_spectrum.le_iff_specializes PrimeSpectrum.le_iff_specializesₓ'. -/
theorem le_iff_specializes (x y : PrimeSpectrum R) : x ≤ y ↔ x ⤳ y :=
  (le_iff_mem_closure x y).trans specializes_iff_mem_closure.symm
#align prime_spectrum.le_iff_specializes PrimeSpectrum.le_iff_specializes

/- warning: prime_spectrum.nhds_order_embedding -> PrimeSpectrum.nhdsOrderEmbedding is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], OrderEmbedding.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Filter.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Preorder.toHasLe.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.partialOrder.{u1} R _inst_1))) (Preorder.toHasLe.{u1} (Filter.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Filter.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Filter.partialOrder.{u1} (PrimeSpectrum.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R], OrderEmbedding.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (Filter.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Preorder.toLE.{u1} (PrimeSpectrum.{u1} R _inst_1) (PartialOrder.toPreorder.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.instPartialOrderPrimeSpectrum.{u1} R _inst_1))) (Preorder.toLE.{u1} (Filter.{u1} (PrimeSpectrum.{u1} R _inst_1)) (PartialOrder.toPreorder.{u1} (Filter.{u1} (PrimeSpectrum.{u1} R _inst_1)) (Filter.instPartialOrderFilter.{u1} (PrimeSpectrum.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.nhds_order_embedding PrimeSpectrum.nhdsOrderEmbeddingₓ'. -/
/-- `nhds` as an order embedding. -/
@[simps (config := { fullyApplied := true })]
def nhdsOrderEmbedding : PrimeSpectrum R ↪o Filter (PrimeSpectrum R) :=
  OrderEmbedding.ofMapLEIff nhds fun a b => (le_iff_specializes a b).symm
#align prime_spectrum.nhds_order_embedding PrimeSpectrum.nhdsOrderEmbedding

instance : T0Space (PrimeSpectrum R) :=
  ⟨nhdsOrderEmbedding.Injective⟩

instance [IsDomain R] : OrderBot (PrimeSpectrum R)
    where
  bot := ⟨⊥, Ideal.bot_prime⟩
  bot_le I := @bot_le _ _ _ I.asIdeal

instance {R : Type _} [Field R] : Unique (PrimeSpectrum R)
    where
  default := ⊥
  uniq x := ext _ _ ((IsSimpleOrder.eq_bot_or_eq_top _).resolve_right x.2.ne_top)

end Order

/- warning: prime_spectrum.localization_map_of_specializes -> PrimeSpectrum.localizationMapOfSpecializes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {x : PrimeSpectrum.{u1} R _inst_1} {y : PrimeSpectrum.{u1} R _inst_1}, (Specializes.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) x y) -> (RingHom.{u1, u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y) (PrimeSpectrum.isPrime.{u1} R _inst_1 y)) (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.isPrime.{u1} R _inst_1 x)) (NonAssocRing.toNonAssocSemiring.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y) (PrimeSpectrum.isPrime.{u1} R _inst_1 y)) (Ring.toNonAssocRing.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y) (PrimeSpectrum.isPrime.{u1} R _inst_1 y)) (CommRing.toRing.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y) (PrimeSpectrum.isPrime.{u1} R _inst_1 y)) (Localization.commRing.{u1} R _inst_1 (Ideal.primeCompl.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y) (PrimeSpectrum.isPrime.{u1} R _inst_1 y)))))) (NonAssocRing.toNonAssocSemiring.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.isPrime.{u1} R _inst_1 x)) (Ring.toNonAssocRing.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.isPrime.{u1} R _inst_1 x)) (CommRing.toRing.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.isPrime.{u1} R _inst_1 x)) (Localization.commRing.{u1} R _inst_1 (Ideal.primeCompl.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.isPrime.{u1} R _inst_1 x)))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {x : PrimeSpectrum.{u1} R _inst_1} {y : PrimeSpectrum.{u1} R _inst_1}, (Specializes.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) x y) -> (RingHom.{u1, u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y) (PrimeSpectrum.IsPrime.{u1} R _inst_1 y)) (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.IsPrime.{u1} R _inst_1 x)) (Semiring.toNonAssocSemiring.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y) (PrimeSpectrum.IsPrime.{u1} R _inst_1 y)) (CommSemiring.toSemiring.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y) (PrimeSpectrum.IsPrime.{u1} R _inst_1 y)) (Localization.instCommSemiringLocalizationToCommMonoid.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (Ideal.primeCompl.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 y) (PrimeSpectrum.IsPrime.{u1} R _inst_1 y))))) (Semiring.toNonAssocSemiring.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.IsPrime.{u1} R _inst_1 x)) (CommSemiring.toSemiring.{u1} (Localization.AtPrime.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.IsPrime.{u1} R _inst_1 x)) (Localization.instCommSemiringLocalizationToCommMonoid.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (Ideal.primeCompl.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1) (PrimeSpectrum.asIdeal.{u1} R _inst_1 x) (PrimeSpectrum.IsPrime.{u1} R _inst_1 x))))))
Case conversion may be inaccurate. Consider using '#align prime_spectrum.localization_map_of_specializes PrimeSpectrum.localizationMapOfSpecializesₓ'. -/
/-- If `x` specializes to `y`, then there is a natural map from the localization of `y` to the
localization of `x`. -/
def localizationMapOfSpecializes {x y : PrimeSpectrum R} (h : x ⤳ y) :
    Localization.AtPrime y.asIdeal →+* Localization.AtPrime x.asIdeal :=
  @IsLocalization.lift _ _ _ _ _ _ _ _ Localization.isLocalization
    (algebraMap R (Localization.AtPrime x.asIdeal))
    (by
      rintro ⟨a, ha⟩
      rw [← PrimeSpectrum.le_iff_specializes, ← as_ideal_le_as_ideal, ← SetLike.coe_subset_coe, ←
        Set.compl_subset_compl] at h
      exact (IsLocalization.map_units _ ⟨a, show a ∈ x.as_ideal.prime_compl from h ha⟩ : _))
#align prime_spectrum.localization_map_of_specializes PrimeSpectrum.localizationMapOfSpecializes

end PrimeSpectrum

namespace LocalRing

variable [LocalRing R]

#print LocalRing.closedPoint /-
/-- The closed point in the prime spectrum of a local ring. -/
def closedPoint : PrimeSpectrum R :=
  ⟨maximalIdeal R, (maximalIdeal.isMaximal R).IsPrime⟩
#align local_ring.closed_point LocalRing.closedPoint
-/

variable {R}

/- warning: local_ring.is_local_ring_hom_iff_comap_closed_point -> LocalRing.isLocalRingHom_iff_comap_closedPoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_3 : LocalRing.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {S : Type.{u2}} [_inst_4 : CommRing.{u2} S] [_inst_5 : LocalRing.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_4)))), Iff (IsLocalRingHom.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) f) (Eq.{succ u1} (PrimeSpectrum.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_4) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_4 f) (LocalRing.closedPoint.{u2} S _inst_4 _inst_5)) (LocalRing.closedPoint.{u1} R _inst_1 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_3 : LocalRing.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] {S : Type.{u2}} [_inst_4 : CommRing.{u2} S] [_inst_5 : LocalRing.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_4))] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_4)))), Iff (IsLocalRingHom.{u1, u2} R S (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_4)) f) (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_4) => PrimeSpectrum.{u1} R _inst_1) (LocalRing.closedPoint.{u2} S _inst_4 _inst_5)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_4) (fun (_x : PrimeSpectrum.{u2} S _inst_4) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_4) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_4 f) (LocalRing.closedPoint.{u2} S _inst_4 _inst_5)) (LocalRing.closedPoint.{u1} R _inst_1 _inst_3))
Case conversion may be inaccurate. Consider using '#align local_ring.is_local_ring_hom_iff_comap_closed_point LocalRing.isLocalRingHom_iff_comap_closedPointₓ'. -/
theorem isLocalRingHom_iff_comap_closedPoint {S : Type v} [CommRing S] [LocalRing S] (f : R →+* S) :
    IsLocalRingHom f ↔ PrimeSpectrum.comap f (closedPoint S) = closedPoint R :=
  by
  rw [(local_hom_tfae f).out 0 4, PrimeSpectrum.ext_iff]
  rfl
#align local_ring.is_local_ring_hom_iff_comap_closed_point LocalRing.isLocalRingHom_iff_comap_closedPoint

/- warning: local_ring.comap_closed_point -> LocalRing.comap_closedPoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_3 : LocalRing.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] {S : Type.{u2}} [_inst_4 : CommRing.{u2} S] [_inst_5 : LocalRing.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4))] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_4)))) [_inst_6 : IsLocalRingHom.{u1, u2} R S (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_4)) f], Eq.{succ u1} (PrimeSpectrum.{u1} R _inst_1) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (fun (_x : ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) => (PrimeSpectrum.{u2} S _inst_4) -> (PrimeSpectrum.{u1} R _inst_1)) (ContinuousMap.hasCoeToFun.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_4 f) (LocalRing.closedPoint.{u2} S _inst_4 _inst_5)) (LocalRing.closedPoint.{u1} R _inst_1 _inst_3)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_3 : LocalRing.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] {S : Type.{u2}} [_inst_4 : CommRing.{u2} S] [_inst_5 : LocalRing.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_4))] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_4)))) [_inst_6 : IsLocalRingHom.{u1, u2} R S (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_4)) f], Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_4) => PrimeSpectrum.{u1} R _inst_1) (LocalRing.closedPoint.{u2} S _inst_4 _inst_5)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_4) (fun (_x : PrimeSpectrum.{u2} S _inst_4) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : PrimeSpectrum.{u2} S _inst_4) => PrimeSpectrum.{u1} R _inst_1) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u2, u1} (ContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (PrimeSpectrum.{u2} S _inst_4) (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u2} S _inst_4) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (PrimeSpectrum.comap.{u1, u2} R S _inst_1 _inst_4 f) (LocalRing.closedPoint.{u2} S _inst_4 _inst_5)) (LocalRing.closedPoint.{u1} R _inst_1 _inst_3)
Case conversion may be inaccurate. Consider using '#align local_ring.comap_closed_point LocalRing.comap_closedPointₓ'. -/
@[simp]
theorem comap_closedPoint {S : Type v} [CommRing S] [LocalRing S] (f : R →+* S) [IsLocalRingHom f] :
    PrimeSpectrum.comap f (closedPoint S) = closedPoint R :=
  (isLocalRingHom_iff_comap_closedPoint f).mp inferInstance
#align local_ring.comap_closed_point LocalRing.comap_closedPoint

#print LocalRing.specializes_closedPoint /-
theorem specializes_closedPoint (x : PrimeSpectrum R) : x ⤳ closedPoint R :=
  (PrimeSpectrum.le_iff_specializes _ _).mp (LocalRing.le_maximalIdeal x.2.1)
#align local_ring.specializes_closed_point LocalRing.specializes_closedPoint
-/

/- warning: local_ring.closed_point_mem_iff -> LocalRing.closedPoint_mem_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_3 : LocalRing.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] (U : TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)), Iff (Membership.Mem.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (SetLike.hasMem.{u1, u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.setLike.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (LocalRing.closedPoint.{u1} R _inst_1 _inst_3) U) (Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) U (Top.top.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toHasTop.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.completeLattice.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_3 : LocalRing.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))] (U : TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)), Iff (Membership.mem.{u1, u1} (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (SetLike.instMembership.{u1, u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (PrimeSpectrum.{u1} R _inst_1) (TopologicalSpace.Opens.instSetLikeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1))) (LocalRing.closedPoint.{u1} R _inst_1 _inst_3) U) (Eq.{succ u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) U (Top.top.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (CompleteLattice.toTop.{u1} (TopologicalSpace.Opens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (PrimeSpectrum.{u1} R _inst_1) (PrimeSpectrum.zariskiTopology.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align local_ring.closed_point_mem_iff LocalRing.closedPoint_mem_iffₓ'. -/
theorem closedPoint_mem_iff (U : TopologicalSpace.Opens <| PrimeSpectrum R) :
    closedPoint R ∈ U ↔ U = ⊤ := by
  constructor
  · rw [eq_top_iff]
    exact fun h x _ => (specializes_closed_point x).mem_open U.2 h
  · rintro rfl
    trivial
#align local_ring.closed_point_mem_iff LocalRing.closedPoint_mem_iff

@[simp]
theorem PrimeSpectrum.comap_residue (x : PrimeSpectrum (ResidueField R)) :
    PrimeSpectrum.comap (residue R) x = closedPoint R :=
  by
  rw [Subsingleton.elim x ⊥]
  ext1
  exact Ideal.mk_ker
#align prime_spectrum.comap_residue PrimeSpectrum.comap_residue

end LocalRing

