/-
Copyright (c) 2020 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang, Johan Commelin

! This file was ported from Lean 3 source module algebraic_geometry.projective_spectrum.topology
! leanprover-community/mathlib commit 4280f5f32e16755ec7985ce11e189b6cd6ff6735
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.RingTheory.GradedAlgebra.HomogeneousIdeal
import Mathbin.Topology.Category.Top.Basic
import Mathbin.Topology.Sets.Opens

/-!
# Projective spectrum of a graded ring

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The projective spectrum of a graded commutative ring is the subtype of all homogenous ideals that
are prime and do not contain the irrelevant ideal.
It is naturally endowed with a topology: the Zariski topology.

## Notation
- `R` is a commutative semiring;
- `A` is a commutative ring and an `R`-algebra;
- `𝒜 : ℕ → submodule R A` is the grading of `A`;

## Main definitions

* `projective_spectrum 𝒜`: The projective spectrum of a graded ring `A`, or equivalently, the set of
  all homogeneous ideals of `A` that is both prime and relevant i.e. not containing irrelevant
  ideal. Henceforth, we call elements of projective spectrum *relevant homogeneous prime ideals*.
* `projective_spectrum.zero_locus 𝒜 s`: The zero locus of a subset `s` of `A`
  is the subset of `projective_spectrum 𝒜` consisting of all relevant homogeneous prime ideals that
  contain `s`.
* `projective_spectrum.vanishing_ideal t`: The vanishing ideal of a subset `t` of
  `projective_spectrum 𝒜` is the intersection of points in `t` (viewed as relevant homogeneous prime
  ideals).
* `projective_spectrum.Top`: the topological space of `projective_spectrum 𝒜` endowed with the
  Zariski topology.
-/


noncomputable section

open DirectSum BigOperators Pointwise

open DirectSum SetLike TopCat TopologicalSpace CategoryTheory Opposite

variable {R A : Type _}

variable [CommSemiring R] [CommRing A] [Algebra R A]

variable (𝒜 : ℕ → Submodule R A) [GradedAlgebra 𝒜]

/- warning: projective_spectrum -> ProjectiveSpectrum is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], Type.{u2}
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], Type.{u2}
Case conversion may be inaccurate. Consider using '#align projective_spectrum ProjectiveSpectrumₓ'. -/
/-- The projective spectrum of a graded commutative ring is the subtype of all homogenous ideals
that are prime and do not contain the irrelevant ideal. -/
@[ext, nolint has_nonempty_instance]
structure ProjectiveSpectrum where
  asHomogeneousIdeal : HomogeneousIdeal 𝒜
  IsPrime : as_homogeneous_ideal.toIdeal.IsPrime
  not_irrelevant_le : ¬HomogeneousIdeal.irrelevant 𝒜 ≤ as_homogeneous_ideal
#align projective_spectrum ProjectiveSpectrum

attribute [instance] ProjectiveSpectrum.isPrime

namespace ProjectiveSpectrum

/- warning: projective_spectrum.zero_locus -> ProjectiveSpectrum.zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], (Set.{u2} A) -> (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], (Set.{u2} A) -> (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus ProjectiveSpectrum.zeroLocusₓ'. -/
/-- The zero locus of a set `s` of elements of a commutative ring `A` is the set of all relevant
homogeneous prime ideals of the ring that contain the set `s`.

An element `f` of `A` can be thought of as a dependent function on the projective spectrum of `𝒜`.
At a point `x` (a homogeneous prime ideal) the function (i.e., element) `f` takes values in the
quotient ring `A` modulo the prime ideal `x`. In this manner, `zero_locus s` is exactly the subset
of `projective_spectrum 𝒜` where all "functions" in `s` vanish simultaneously. -/
def zeroLocus (s : Set A) : Set (ProjectiveSpectrum 𝒜) :=
  { x | s ⊆ x.asHomogeneousIdeal }
#align projective_spectrum.zero_locus ProjectiveSpectrum.zeroLocus

/- warning: projective_spectrum.mem_zero_locus -> ProjectiveSpectrum.mem_zeroLocus is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_zero_locus ProjectiveSpectrum.mem_zeroLocusₓ'. -/
@[simp]
theorem mem_zeroLocus (x : ProjectiveSpectrum 𝒜) (s : Set A) :
    x ∈ zeroLocus 𝒜 s ↔ s ⊆ x.asHomogeneousIdeal :=
  Iff.rfl
#align projective_spectrum.mem_zero_locus ProjectiveSpectrum.mem_zeroLocus

/- warning: projective_spectrum.zero_locus_span -> ProjectiveSpectrum.zeroLocus_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Ideal.span.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) s))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Ideal.span.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) s))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_span ProjectiveSpectrum.zeroLocus_spanₓ'. -/
@[simp]
theorem zeroLocus_span (s : Set A) : zeroLocus 𝒜 (Ideal.span s) = zeroLocus 𝒜 s :=
  by
  ext x
  exact (Submodule.gi _ _).gc s x.as_homogeneous_ideal.to_ideal
#align projective_spectrum.zero_locus_span ProjectiveSpectrum.zeroLocus_span

variable {𝒜}

/- warning: projective_spectrum.vanishing_ideal -> ProjectiveSpectrum.vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) -> (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) 𝒜 (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] {𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) -> (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) 𝒜 (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal ProjectiveSpectrum.vanishingIdealₓ'. -/
/-- The vanishing ideal of a set `t` of points of the projective spectrum of a commutative ring `R`
is the intersection of all the relevant homogeneous prime ideals in the set `t`.

An element `f` of `A` can be thought of as a dependent function on the projective spectrum of `𝒜`.
At a point `x` (a homogeneous prime ideal) the function (i.e., element) `f` takes values in the
quotient ring `A` modulo the prime ideal `x`. In this manner, `vanishing_ideal t` is exactly the
ideal of `A` consisting of all "functions" that vanish on all of `t`. -/
def vanishingIdeal (t : Set (ProjectiveSpectrum 𝒜)) : HomogeneousIdeal 𝒜 :=
  ⨅ (x : ProjectiveSpectrum 𝒜) (h : x ∈ t), x.asHomogeneousIdeal
#align projective_spectrum.vanishing_ideal ProjectiveSpectrum.vanishingIdeal

/- warning: projective_spectrum.coe_vanishing_ideal -> ProjectiveSpectrum.coe_vanishingIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.coe_vanishing_ideal ProjectiveSpectrum.coe_vanishingIdealₓ'. -/
theorem coe_vanishingIdeal (t : Set (ProjectiveSpectrum 𝒜)) :
    (vanishingIdeal t : Set A) =
      { f | ∀ x : ProjectiveSpectrum 𝒜, x ∈ t → f ∈ x.asHomogeneousIdeal } :=
  by
  ext f
  rw [vanishing_ideal, SetLike.mem_coe, ← HomogeneousIdeal.mem_iff, HomogeneousIdeal.toIdeal_iInf,
    Submodule.mem_iInf]
  apply forall_congr' fun x => _
  rw [HomogeneousIdeal.toIdeal_iInf, Submodule.mem_iInf, HomogeneousIdeal.mem_iff]
#align projective_spectrum.coe_vanishing_ideal ProjectiveSpectrum.coe_vanishingIdeal

/- warning: projective_spectrum.mem_vanishing_ideal -> ProjectiveSpectrum.mem_vanishingIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_vanishing_ideal ProjectiveSpectrum.mem_vanishingIdealₓ'. -/
theorem mem_vanishingIdeal (t : Set (ProjectiveSpectrum 𝒜)) (f : A) :
    f ∈ vanishingIdeal t ↔ ∀ x : ProjectiveSpectrum 𝒜, x ∈ t → f ∈ x.asHomogeneousIdeal := by
  rw [← SetLike.mem_coe, coe_vanishing_ideal, Set.mem_setOf_eq]
#align projective_spectrum.mem_vanishing_ideal ProjectiveSpectrum.mem_vanishingIdeal

/- warning: projective_spectrum.vanishing_ideal_singleton -> ProjectiveSpectrum.vanishingIdeal_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) 𝒜 (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasSingleton.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) x)) (ProjectiveSpectrum.asHomogeneousIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 x)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] {𝒜 : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 𝒜] (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4), Eq.{succ u1} (HomogeneousIdeal.{0, u1, u1} Nat (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) (Submodule.setLike.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3)) 𝒜 (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instSingletonSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) x)) (ProjectiveSpectrum.asHomogeneousIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 x)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_singleton ProjectiveSpectrum.vanishingIdeal_singletonₓ'. -/
@[simp]
theorem vanishingIdeal_singleton (x : ProjectiveSpectrum 𝒜) :
    vanishingIdeal ({x} : Set (ProjectiveSpectrum 𝒜)) = x.asHomogeneousIdeal := by
  simp [vanishing_ideal]
#align projective_spectrum.vanishing_ideal_singleton ProjectiveSpectrum.vanishingIdeal_singleton

/- warning: projective_spectrum.subset_zero_locus_iff_le_vanishing_ideal -> ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdeal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] {𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Iff (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I))) (LE.le.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Preorder.toHasLe.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) 𝒜 (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 t)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] {𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))} [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Iff (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) t (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I))) (LE.le.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) 𝒜 (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 t)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_zero_locus_iff_le_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdealₓ'. -/
theorem subset_zeroLocus_iff_le_vanishingIdeal (t : Set (ProjectiveSpectrum 𝒜)) (I : Ideal A) :
    t ⊆ zeroLocus 𝒜 I ↔ I ≤ (vanishingIdeal t).toIdeal :=
  ⟨fun h f k => (mem_vanishingIdeal _ _).mpr fun x j => (mem_zeroLocus _ _ _).mpr (h j) k, fun h =>
    fun x j =>
    (mem_zeroLocus _ _ _).mpr (le_trans h fun f h => ((mem_vanishingIdeal _ _).mp h) x j)⟩
#align projective_spectrum.subset_zero_locus_iff_le_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdeal

variable (𝒜)

/- warning: projective_spectrum.gc_ideal -> ProjectiveSpectrum.gc_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], GaloisConnection.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.completeBooleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))))))) (fun (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) => HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) 𝒜 (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 t))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], GaloisConnection.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (OrderDual.preorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (PartialOrder.toPreorder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instCompleteBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))))))) (fun (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (fun (t : OrderDual.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) => HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) 𝒜 (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 t))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.gc_ideal ProjectiveSpectrum.gc_idealₓ'. -/
/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/
theorem gc_ideal :
    @GaloisConnection (Ideal A) (Set (ProjectiveSpectrum 𝒜))ᵒᵈ _ _ (fun I => zeroLocus 𝒜 I) fun t =>
      (vanishingIdeal t).toIdeal :=
  fun I t => subset_zeroLocus_iff_le_vanishingIdeal t I
#align projective_spectrum.gc_ideal ProjectiveSpectrum.gc_ideal

/- warning: projective_spectrum.gc_set -> ProjectiveSpectrum.gc_set is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.gc_set ProjectiveSpectrum.gc_setₓ'. -/
/-- `zero_locus` and `vanishing_ideal` form a galois connection. -/
theorem gc_set :
    @GaloisConnection (Set A) (Set (ProjectiveSpectrum 𝒜))ᵒᵈ _ _ (fun s => zeroLocus 𝒜 s) fun t =>
      vanishingIdeal t :=
  by
  have ideal_gc : GaloisConnection Ideal.span coe := (Submodule.gi A _).gc
  simpa [zero_locus_span, Function.comp] using GaloisConnection.compose ideal_gc (gc_ideal 𝒜)
#align projective_spectrum.gc_set ProjectiveSpectrum.gc_set

/- warning: projective_spectrum.gc_homogeneous_ideal -> ProjectiveSpectrum.gc_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.gc_homogeneous_ideal ProjectiveSpectrum.gc_homogeneousIdealₓ'. -/
theorem gc_homogeneousIdeal :
    @GaloisConnection (HomogeneousIdeal 𝒜) (Set (ProjectiveSpectrum 𝒜))ᵒᵈ _ _
      (fun I => zeroLocus 𝒜 I) fun t => vanishingIdeal t :=
  fun I t => by
  simpa [show I.to_ideal ≤ (vanishing_ideal t).toIdeal ↔ I ≤ vanishing_ideal t from Iff.rfl] using
    subset_zero_locus_iff_le_vanishing_ideal t I.to_ideal
#align projective_spectrum.gc_homogeneous_ideal ProjectiveSpectrum.gc_homogeneousIdeal

/- warning: projective_spectrum.subset_zero_locus_iff_subset_vanishing_ideal -> ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_zero_locus_iff_subset_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdealₓ'. -/
theorem subset_zeroLocus_iff_subset_vanishingIdeal (t : Set (ProjectiveSpectrum 𝒜)) (s : Set A) :
    t ⊆ zeroLocus 𝒜 s ↔ s ⊆ vanishingIdeal t :=
  (gc_set _) s t
#align projective_spectrum.subset_zero_locus_iff_subset_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal

/- warning: projective_spectrum.subset_vanishing_ideal_zero_locus -> ProjectiveSpectrum.subset_vanishingIdeal_zeroLocus is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_vanishing_ideal_zero_locus ProjectiveSpectrum.subset_vanishingIdeal_zeroLocusₓ'. -/
theorem subset_vanishingIdeal_zeroLocus (s : Set A) : s ⊆ vanishingIdeal (zeroLocus 𝒜 s) :=
  (gc_set _).le_u_l s
#align projective_spectrum.subset_vanishing_ideal_zero_locus ProjectiveSpectrum.subset_vanishingIdeal_zeroLocus

/- warning: projective_spectrum.ideal_le_vanishing_ideal_zero_locus -> ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), LE.le.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Preorder.toHasLe.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) 𝒜 (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), LE.le.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))))) I (HomogeneousIdeal.toIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) 𝒜 (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4 (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocusₓ'. -/
theorem ideal_le_vanishingIdeal_zeroLocus (I : Ideal A) :
    I ≤ (vanishingIdeal (zeroLocus 𝒜 I)).toIdeal :=
  (gc_ideal _).le_u_l I
#align projective_spectrum.ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocus

/- warning: projective_spectrum.homogeneous_ideal_le_vanishing_ideal_zero_locus -> ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocus is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.homogeneous_ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocusₓ'. -/
theorem homogeneousIdeal_le_vanishingIdeal_zeroLocus (I : HomogeneousIdeal 𝒜) :
    I ≤ vanishingIdeal (zeroLocus 𝒜 I) :=
  (gc_homogeneousIdeal _).le_u_l I
#align projective_spectrum.homogeneous_ideal_le_vanishing_ideal_zero_locus ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocus

/- warning: projective_spectrum.subset_zero_locus_vanishing_ideal -> ProjectiveSpectrum.subset_zeroLocus_vanishingIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.subset_zero_locus_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_vanishingIdealₓ'. -/
theorem subset_zeroLocus_vanishingIdeal (t : Set (ProjectiveSpectrum 𝒜)) :
    t ⊆ zeroLocus 𝒜 (vanishingIdeal t) :=
  (gc_ideal _).l_u_le t
#align projective_spectrum.subset_zero_locus_vanishing_ideal ProjectiveSpectrum.subset_zeroLocus_vanishingIdeal

/- warning: projective_spectrum.zero_locus_anti_mono -> ProjectiveSpectrum.zeroLocus_anti_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] {s : Set.{u2} A} {t : Set.{u2} A}, (HasSubset.Subset.{u2} (Set.{u2} A) (Set.hasSubset.{u2} A) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 t) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] {s : Set.{u2} A} {t : Set.{u2} A}, (HasSubset.Subset.{u2} (Set.{u2} A) (Set.instHasSubsetSet.{u2} A) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 t) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_anti_mono ProjectiveSpectrum.zeroLocus_anti_monoₓ'. -/
theorem zeroLocus_anti_mono {s t : Set A} (h : s ⊆ t) : zeroLocus 𝒜 t ⊆ zeroLocus 𝒜 s :=
  (gc_set _).monotone_l h
#align projective_spectrum.zero_locus_anti_mono ProjectiveSpectrum.zeroLocus_anti_mono

/- warning: projective_spectrum.zero_locus_anti_mono_ideal -> ProjectiveSpectrum.zeroLocus_anti_mono_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] {s : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))} {t : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))}, (LE.le.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Preorder.toHasLe.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SetLike.partialOrder.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasSubset.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) t)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] {s : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))} {t : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))}, (LE.le.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Preorder.toLE.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (PartialOrder.toPreorder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))))) s t) -> (HasSubset.Subset.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instHasSubsetSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) t)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_anti_mono_ideal ProjectiveSpectrum.zeroLocus_anti_mono_idealₓ'. -/
theorem zeroLocus_anti_mono_ideal {s t : Ideal A} (h : s ≤ t) :
    zeroLocus 𝒜 (t : Set A) ⊆ zeroLocus 𝒜 (s : Set A) :=
  (gc_ideal _).monotone_l h
#align projective_spectrum.zero_locus_anti_mono_ideal ProjectiveSpectrum.zeroLocus_anti_mono_ideal

/- warning: projective_spectrum.zero_locus_anti_mono_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_anti_mono_homogeneous_ideal ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdealₓ'. -/
theorem zeroLocus_anti_mono_homogeneousIdeal {s t : HomogeneousIdeal 𝒜} (h : s ≤ t) :
    zeroLocus 𝒜 (t : Set A) ⊆ zeroLocus 𝒜 (s : Set A) :=
  (gc_homogeneousIdeal _).monotone_l h
#align projective_spectrum.zero_locus_anti_mono_homogeneous_ideal ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdeal

/- warning: projective_spectrum.vanishing_ideal_anti_mono -> ProjectiveSpectrum.vanishingIdeal_anti_mono is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_anti_mono ProjectiveSpectrum.vanishingIdeal_anti_monoₓ'. -/
theorem vanishingIdeal_anti_mono {s t : Set (ProjectiveSpectrum 𝒜)} (h : s ⊆ t) :
    vanishingIdeal t ≤ vanishingIdeal s :=
  (gc_ideal _).monotone_u h
#align projective_spectrum.vanishing_ideal_anti_mono ProjectiveSpectrum.vanishingIdeal_anti_mono

/- warning: projective_spectrum.zero_locus_bot -> ProjectiveSpectrum.zeroLocus_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Bot.bot.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.hasBot.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Bot.bot.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.instBotSubmodule.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_bot ProjectiveSpectrum.zeroLocus_botₓ'. -/
theorem zeroLocus_bot : zeroLocus 𝒜 ((⊥ : Ideal A) : Set A) = Set.univ :=
  (gc_ideal 𝒜).l_bot
#align projective_spectrum.zero_locus_bot ProjectiveSpectrum.zeroLocus_bot

/- warning: projective_spectrum.zero_locus_singleton_zero -> ProjectiveSpectrum.zeroLocus_singleton_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (CommMonoidWithZero.toZero.{u2} A (CommSemiring.toCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_zero ProjectiveSpectrum.zeroLocus_singleton_zeroₓ'. -/
@[simp]
theorem zeroLocus_singleton_zero : zeroLocus 𝒜 ({0} : Set A) = Set.univ :=
  zeroLocus_bot _
#align projective_spectrum.zero_locus_singleton_zero ProjectiveSpectrum.zeroLocus_singleton_zero

/- warning: projective_spectrum.zero_locus_empty -> ProjectiveSpectrum.zeroLocus_empty is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.hasEmptyc.{u2} A))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} A) (Set.instEmptyCollectionSet.{u2} A))) (Set.univ.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_empty ProjectiveSpectrum.zeroLocus_emptyₓ'. -/
@[simp]
theorem zeroLocus_empty : zeroLocus 𝒜 (∅ : Set A) = Set.univ :=
  (gc_set 𝒜).l_bot
#align projective_spectrum.zero_locus_empty ProjectiveSpectrum.zeroLocus_empty

/- warning: projective_spectrum.vanishing_ideal_univ -> ProjectiveSpectrum.vanishingIdeal_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) 𝒜 (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))) (Top.top.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) 𝒜 (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.hasTop.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) 𝒜 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) 𝒜 (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))) (Top.top.{u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) 𝒜 (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (HomogeneousIdeal.instTopHomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) 𝒜 _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_univ ProjectiveSpectrum.vanishingIdeal_univₓ'. -/
@[simp]
theorem vanishingIdeal_univ : vanishingIdeal (∅ : Set (ProjectiveSpectrum 𝒜)) = ⊤ := by
  simpa using (gc_ideal _).u_top
#align projective_spectrum.vanishing_ideal_univ ProjectiveSpectrum.vanishingIdeal_univ

/- warning: projective_spectrum.zero_locus_empty_of_one_mem -> ProjectiveSpectrum.zeroLocus_empty_of_one_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] {s : Set.{u2} A}, (Membership.Mem.{u2, u2} A (Set.{u2} A) (Set.hasMem.{u2} A) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) s) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] {s : Set.{u2} A}, (Membership.mem.{u2, u2} A (Set.{u2} A) (Set.instMembershipSet.{u2} A) (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) s) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_empty_of_one_mem ProjectiveSpectrum.zeroLocus_empty_of_one_memₓ'. -/
theorem zeroLocus_empty_of_one_mem {s : Set A} (h : (1 : A) ∈ s) : zeroLocus 𝒜 s = ∅ :=
  Set.eq_empty_iff_forall_not_mem.mpr fun x hx =>
    (inferInstance : x.asHomogeneousIdeal.toIdeal.IsPrime).ne_top <|
      x.asHomogeneousIdeal.toIdeal.eq_top_iff_one.mpr <| hx h
#align projective_spectrum.zero_locus_empty_of_one_mem ProjectiveSpectrum.zeroLocus_empty_of_one_mem

/- warning: projective_spectrum.zero_locus_singleton_one -> ProjectiveSpectrum.zeroLocus_singleton_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))))) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))))) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_one ProjectiveSpectrum.zeroLocus_singleton_oneₓ'. -/
@[simp]
theorem zeroLocus_singleton_one : zeroLocus 𝒜 ({1} : Set A) = ∅ :=
  zeroLocus_empty_of_one_mem 𝒜 (Set.mem_singleton (1 : A))
#align projective_spectrum.zero_locus_singleton_one ProjectiveSpectrum.zeroLocus_singleton_one

/- warning: projective_spectrum.zero_locus_univ -> ProjectiveSpectrum.zeroLocus_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Set.univ.{u2} A)) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasEmptyc.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Set.univ.{u2} A)) (EmptyCollection.emptyCollection.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instEmptyCollectionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_univ ProjectiveSpectrum.zeroLocus_univₓ'. -/
@[simp]
theorem zeroLocus_univ : zeroLocus 𝒜 (Set.univ : Set A) = ∅ :=
  zeroLocus_empty_of_one_mem _ (Set.mem_univ 1)
#align projective_spectrum.zero_locus_univ ProjectiveSpectrum.zeroLocus_univ

/- warning: projective_spectrum.zero_locus_sup_ideal -> ProjectiveSpectrum.zeroLocus_sup_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (J : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Sup.sup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (SemilatticeSup.toHasSup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (IdemSemiring.toSemilatticeSup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.idemSemiring.{u2, u2} A (CommRing.toCommSemiring.{u2} A _inst_2) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Algebra.id.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) I J))) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasInter.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (J : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Sup.sup.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (SemilatticeSup.toSup.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (IdemCommSemiring.toSemilatticeSup.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.instIdemCommSemiringIdealToSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I J))) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instInterSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_sup_ideal ProjectiveSpectrum.zeroLocus_sup_idealₓ'. -/
theorem zeroLocus_sup_ideal (I J : Ideal A) :
    zeroLocus 𝒜 ((I ⊔ J : Ideal A) : Set A) = zeroLocus _ I ∩ zeroLocus _ J :=
  (gc_ideal 𝒜).l_sup
#align projective_spectrum.zero_locus_sup_ideal ProjectiveSpectrum.zeroLocus_sup_ideal

/- warning: projective_spectrum.zero_locus_sup_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_sup_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_sup_homogeneous_ideal ProjectiveSpectrum.zeroLocus_sup_homogeneousIdealₓ'. -/
theorem zeroLocus_sup_homogeneousIdeal (I J : HomogeneousIdeal 𝒜) :
    zeroLocus 𝒜 ((I ⊔ J : HomogeneousIdeal 𝒜) : Set A) = zeroLocus _ I ∩ zeroLocus _ J :=
  (gc_homogeneousIdeal 𝒜).l_sup
#align projective_spectrum.zero_locus_sup_homogeneous_ideal ProjectiveSpectrum.zeroLocus_sup_homogeneousIdeal

/- warning: projective_spectrum.zero_locus_union -> ProjectiveSpectrum.zeroLocus_union is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Union.union.{u2} (Set.{u2} A) (Set.hasUnion.{u2} A) s s')) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasInter.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s'))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Union.union.{u2} (Set.{u2} A) (Set.instUnionSet.{u2} A) s s')) (Inter.inter.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instInterSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s'))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_union ProjectiveSpectrum.zeroLocus_unionₓ'. -/
theorem zeroLocus_union (s s' : Set A) : zeroLocus 𝒜 (s ∪ s') = zeroLocus _ s ∩ zeroLocus _ s' :=
  (gc_set 𝒜).l_sup
#align projective_spectrum.zero_locus_union ProjectiveSpectrum.zeroLocus_union

/- warning: projective_spectrum.vanishing_ideal_union -> ProjectiveSpectrum.vanishingIdeal_union is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_union ProjectiveSpectrum.vanishingIdeal_unionₓ'. -/
theorem vanishingIdeal_union (t t' : Set (ProjectiveSpectrum 𝒜)) :
    vanishingIdeal (t ∪ t') = vanishingIdeal t ⊓ vanishingIdeal t' := by
  ext1 <;> convert(gc_ideal 𝒜).u_inf
#align projective_spectrum.vanishing_ideal_union ProjectiveSpectrum.vanishingIdeal_union

/- warning: projective_spectrum.zero_locus_supr_ideal -> ProjectiveSpectrum.zeroLocus_iSup_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] {γ : Sort.{u3}} (I : γ -> (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (iSup.{u2, u3} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (ConditionallyCompleteLattice.toHasSup.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) γ (fun (i : γ) => I i)))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) γ (fun (i : γ) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (I i))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] {γ : Sort.{u3}} (I : γ -> (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (iSup.{u2, u3} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (ConditionallyCompleteLattice.toSupSet.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.completeLattice.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) γ (fun (i : γ) => I i)))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) γ (fun (i : γ) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (I i))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_supr_ideal ProjectiveSpectrum.zeroLocus_iSup_idealₓ'. -/
theorem zeroLocus_iSup_ideal {γ : Sort _} (I : γ → Ideal A) :
    zeroLocus _ ((⨆ i, I i : Ideal A) : Set A) = ⋂ i, zeroLocus 𝒜 (I i) :=
  (gc_ideal 𝒜).l_iSup
#align projective_spectrum.zero_locus_supr_ideal ProjectiveSpectrum.zeroLocus_iSup_ideal

/- warning: projective_spectrum.zero_locus_supr_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_supr_homogeneous_ideal ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdealₓ'. -/
theorem zeroLocus_iSup_homogeneousIdeal {γ : Sort _} (I : γ → HomogeneousIdeal 𝒜) :
    zeroLocus _ ((⨆ i, I i : HomogeneousIdeal 𝒜) : Set A) = ⋂ i, zeroLocus 𝒜 (I i) :=
  (gc_homogeneousIdeal 𝒜).l_iSup
#align projective_spectrum.zero_locus_supr_homogeneous_ideal ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdeal

/- warning: projective_spectrum.zero_locus_Union -> ProjectiveSpectrum.zeroLocus_iUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] {γ : Sort.{u3}} (s : γ -> (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Set.iUnion.{u2, u3} A γ (fun (i : γ) => s i))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) γ (fun (i : γ) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (s i)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] {γ : Sort.{u3}} (s : γ -> (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Set.iUnion.{u2, u3} A γ (fun (i : γ) => s i))) (Set.iInter.{u2, u3} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) γ (fun (i : γ) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (s i)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_Union ProjectiveSpectrum.zeroLocus_iUnionₓ'. -/
theorem zeroLocus_iUnion {γ : Sort _} (s : γ → Set A) :
    zeroLocus 𝒜 (⋃ i, s i) = ⋂ i, zeroLocus 𝒜 (s i) :=
  (gc_set 𝒜).l_iSup
#align projective_spectrum.zero_locus_Union ProjectiveSpectrum.zeroLocus_iUnion

/- warning: projective_spectrum.zero_locus_bUnion -> ProjectiveSpectrum.zeroLocus_bUnion is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Set.iUnion.{u2, succ u2} A (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iUnion.{u2, 0} A (Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) => s')))) (Set.iInter.{u2, succ u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iInter.{u2, 0} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.Mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.hasMem.{u2} (Set.{u2} A)) s' s) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s')))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} (Set.{u2} A)), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Set.iUnion.{u2, succ u2} A (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iUnion.{u2, 0} A (Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) => s')))) (Set.iInter.{u2, succ u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.{u2} A) (fun (s' : Set.{u2} A) => Set.iInter.{u2, 0} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) (fun (H : Membership.mem.{u2, u2} (Set.{u2} A) (Set.{u2} (Set.{u2} A)) (Set.instMembershipSet.{u2} (Set.{u2} A)) s' s) => ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s')))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_bUnion ProjectiveSpectrum.zeroLocus_bUnionₓ'. -/
theorem zeroLocus_bUnion (s : Set (Set A)) :
    zeroLocus 𝒜 (⋃ s' ∈ s, s' : Set A) = ⋂ s' ∈ s, zeroLocus 𝒜 s' := by simp only [zero_locus_Union]
#align projective_spectrum.zero_locus_bUnion ProjectiveSpectrum.zeroLocus_bUnion

/- warning: projective_spectrum.vanishing_ideal_Union -> ProjectiveSpectrum.vanishingIdeal_iUnion is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_Union ProjectiveSpectrum.vanishingIdeal_iUnionₓ'. -/
theorem vanishingIdeal_iUnion {γ : Sort _} (t : γ → Set (ProjectiveSpectrum 𝒜)) :
    vanishingIdeal (⋃ i, t i) = ⨅ i, vanishingIdeal (t i) :=
  HomogeneousIdeal.toIdeal_injective <| by
    convert(gc_ideal 𝒜).u_iInf <;> exact HomogeneousIdeal.toIdeal_iInf _
#align projective_spectrum.vanishing_ideal_Union ProjectiveSpectrum.vanishingIdeal_iUnion

/- warning: projective_spectrum.zero_locus_inf -> ProjectiveSpectrum.zeroLocus_inf is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (J : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Inf.inf.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.hasInf.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (J : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Inf.inf.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.instInfSubmodule.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_inf ProjectiveSpectrum.zeroLocus_infₓ'. -/
theorem zeroLocus_inf (I J : Ideal A) :
    zeroLocus 𝒜 ((I ⊓ J : Ideal A) : Set A) = zeroLocus 𝒜 I ∪ zeroLocus 𝒜 J :=
  Set.ext fun x => x.IsPrime.inf_le
#align projective_spectrum.zero_locus_inf ProjectiveSpectrum.zeroLocus_inf

/- warning: projective_spectrum.union_zero_locus -> ProjectiveSpectrum.union_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s')) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (Inf.inf.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Submodule.hasInf.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))) (Ideal.span.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) s) (Ideal.span.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) s'))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} A) (s' : Set.{u2} A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s')) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Inf.inf.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Submodule.instInfSubmodule.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (Ideal.span.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) s) (Ideal.span.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) s'))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.union_zero_locus ProjectiveSpectrum.union_zeroLocusₓ'. -/
theorem union_zeroLocus (s s' : Set A) :
    zeroLocus 𝒜 s ∪ zeroLocus 𝒜 s' = zeroLocus 𝒜 (Ideal.span s ⊓ Ideal.span s' : Ideal A) :=
  by
  rw [zero_locus_inf]
  simp
#align projective_spectrum.union_zero_locus ProjectiveSpectrum.union_zeroLocus

/- warning: projective_spectrum.zero_locus_mul_ideal -> ProjectiveSpectrum.zeroLocus_mul_ideal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (I : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (J : Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) (HMul.hMul.{u2, u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (instHMul.{u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Ideal.hasMul.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (HasLiftT.mk.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (CoeTCₓ.coe.{succ u2, succ u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) (Set.{u2} A) (SetLike.Set.hasCoeT.{u2, u2} (Ideal.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))))) J)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (I : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (J : Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) (HMul.hMul.{u2, u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (instHMul.{u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) (Ideal.instMulIdealToSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) I J))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) I)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (SetLike.coe.{u2, u2} (Ideal.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))) A (Submodule.setLike.{u2, u2} A A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Semiring.toModule.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))) J)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_mul_ideal ProjectiveSpectrum.zeroLocus_mul_idealₓ'. -/
theorem zeroLocus_mul_ideal (I J : Ideal A) :
    zeroLocus 𝒜 ((I * J : Ideal A) : Set A) = zeroLocus 𝒜 I ∪ zeroLocus 𝒜 J :=
  Set.ext fun x => x.IsPrime.mul_le
#align projective_spectrum.zero_locus_mul_ideal ProjectiveSpectrum.zeroLocus_mul_ideal

/- warning: projective_spectrum.zero_locus_mul_homogeneous_ideal -> ProjectiveSpectrum.zeroLocus_mul_homogeneousIdeal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_mul_homogeneous_ideal ProjectiveSpectrum.zeroLocus_mul_homogeneousIdealₓ'. -/
theorem zeroLocus_mul_homogeneousIdeal (I J : HomogeneousIdeal 𝒜) :
    zeroLocus 𝒜 ((I * J : HomogeneousIdeal 𝒜) : Set A) = zeroLocus 𝒜 I ∪ zeroLocus 𝒜 J :=
  Set.ext fun x => x.IsPrime.mul_le
#align projective_spectrum.zero_locus_mul_homogeneous_ideal ProjectiveSpectrum.zeroLocus_mul_homogeneousIdeal

/- warning: projective_spectrum.zero_locus_singleton_mul -> ProjectiveSpectrum.zeroLocus_singleton_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (g : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasUnion.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) f)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) g)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (g : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g))) (Union.union.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instUnionSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) f)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) g)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_mul ProjectiveSpectrum.zeroLocus_singleton_mulₓ'. -/
theorem zeroLocus_singleton_mul (f g : A) :
    zeroLocus 𝒜 ({f * g} : Set A) = zeroLocus 𝒜 {f} ∪ zeroLocus 𝒜 {g} :=
  Set.ext fun x => by simpa using x.is_prime.mul_mem_iff_mem_or_mem
#align projective_spectrum.zero_locus_singleton_mul ProjectiveSpectrum.zeroLocus_singleton_mul

/- warning: projective_spectrum.zero_locus_singleton_pow -> ProjectiveSpectrum.zeroLocus_singleton_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (n : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (Ring.toMonoid.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f n))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) f)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (n : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) f n))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) f)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_singleton_pow ProjectiveSpectrum.zeroLocus_singleton_powₓ'. -/
@[simp]
theorem zeroLocus_singleton_pow (f : A) (n : ℕ) (hn : 0 < n) :
    zeroLocus 𝒜 ({f ^ n} : Set A) = zeroLocus 𝒜 {f} :=
  Set.ext fun x => by simpa using x.is_prime.pow_mem_iff_mem n hn
#align projective_spectrum.zero_locus_singleton_pow ProjectiveSpectrum.zeroLocus_singleton_pow

/- warning: projective_spectrum.sup_vanishing_ideal_le -> ProjectiveSpectrum.sup_vanishingIdeal_le is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.sup_vanishing_ideal_le ProjectiveSpectrum.sup_vanishingIdeal_leₓ'. -/
theorem sup_vanishingIdeal_le (t t' : Set (ProjectiveSpectrum 𝒜)) :
    vanishingIdeal t ⊔ vanishingIdeal t' ≤ vanishingIdeal (t ∩ t') :=
  by
  intro r
  rw [← HomogeneousIdeal.mem_iff, HomogeneousIdeal.toIdeal_sup, mem_vanishing_ideal,
    Submodule.mem_sup]
  rintro ⟨f, hf, g, hg, rfl⟩ x ⟨hxt, hxt'⟩
  erw [mem_vanishing_ideal] at hf hg
  apply Submodule.add_mem <;> solve_by_elim
#align projective_spectrum.sup_vanishing_ideal_le ProjectiveSpectrum.sup_vanishingIdeal_le

/- warning: projective_spectrum.mem_compl_zero_locus_iff_not_mem -> ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_mem is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_compl_zero_locus_iff_not_mem ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_memₓ'. -/
theorem mem_compl_zeroLocus_iff_not_mem {f : A} {I : ProjectiveSpectrum 𝒜} :
    I ∈ (zeroLocus 𝒜 {f} : Set (ProjectiveSpectrum 𝒜))ᶜ ↔ f ∉ I.asHomogeneousIdeal := by
  rw [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff] <;> rfl
#align projective_spectrum.mem_compl_zero_locus_iff_not_mem ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_mem

/- warning: projective_spectrum.zariski_topology -> ProjectiveSpectrum.zariskiTopology is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], TopologicalSpace.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], TopologicalSpace.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zariski_topology ProjectiveSpectrum.zariskiTopologyₓ'. -/
/-- The Zariski topology on the prime spectrum of a commutative ring is defined via the closed sets
of the topology: they are exactly those sets that are the zero locus of a subset of the ring. -/
instance zariskiTopology : TopologicalSpace (ProjectiveSpectrum 𝒜) :=
  TopologicalSpace.ofClosed (Set.range (ProjectiveSpectrum.zeroLocus 𝒜)) ⟨Set.univ, by simp⟩
    (by
      intro Zs h
      rw [Set.sInter_eq_iInter]
      let f : Zs → Set _ := fun i => Classical.choose (h i.2)
      have hf : ∀ i : Zs, ↑i = zero_locus 𝒜 (f i) := fun i => (Classical.choose_spec (h i.2)).symm
      simp only [hf]
      exact ⟨_, zero_locus_Union 𝒜 _⟩)
    (by
      rintro _ ⟨s, rfl⟩ _ ⟨t, rfl⟩
      exact ⟨_, (union_zero_locus 𝒜 s t).symm⟩)
#align projective_spectrum.zariski_topology ProjectiveSpectrum.zariskiTopology

/- warning: projective_spectrum.Top -> ProjectiveSpectrum.top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], TopCat.{u2}
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], TopCat.{u2}
Case conversion may be inaccurate. Consider using '#align projective_spectrum.Top ProjectiveSpectrum.topₓ'. -/
/-- The underlying topology of `Proj` is the projective spectrum of graded ring `A`. -/
def top : TopCat :=
  TopCat.of (ProjectiveSpectrum 𝒜)
#align projective_spectrum.Top ProjectiveSpectrum.top

/- warning: projective_spectrum.is_open_iff -> ProjectiveSpectrum.isOpen_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (U : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)), Iff (IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) U) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.booleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) U) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (U : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)), Iff (IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) U) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) U) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_open_iff ProjectiveSpectrum.isOpen_iffₓ'. -/
theorem isOpen_iff (U : Set (ProjectiveSpectrum 𝒜)) : IsOpen U ↔ ∃ s, Uᶜ = zeroLocus 𝒜 s := by
  simp only [@eq_comm _ (Uᶜ)] <;> rfl
#align projective_spectrum.is_open_iff ProjectiveSpectrum.isOpen_iff

/- warning: projective_spectrum.is_closed_iff_zero_locus -> ProjectiveSpectrum.isClosed_iff_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (Z : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)), Iff (IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) Z) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) Z (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (Z : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)), Iff (IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) Z) (Exists.{succ u2} (Set.{u2} A) (fun (s : Set.{u2} A) => Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) Z (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_closed_iff_zero_locus ProjectiveSpectrum.isClosed_iff_zeroLocusₓ'. -/
theorem isClosed_iff_zeroLocus (Z : Set (ProjectiveSpectrum 𝒜)) :
    IsClosed Z ↔ ∃ s, Z = zeroLocus 𝒜 s := by rw [← isOpen_compl_iff, is_open_iff, compl_compl]
#align projective_spectrum.is_closed_iff_zero_locus ProjectiveSpectrum.isClosed_iff_zeroLocus

/- warning: projective_spectrum.is_closed_zero_locus -> ProjectiveSpectrum.isClosed_zeroLocus is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} A), IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (s : Set.{u2} A), IsClosed.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 s)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_closed_zero_locus ProjectiveSpectrum.isClosed_zeroLocusₓ'. -/
theorem isClosed_zeroLocus (s : Set A) : IsClosed (zeroLocus 𝒜 s) :=
  by
  rw [is_closed_iff_zero_locus]
  exact ⟨s, rfl⟩
#align projective_spectrum.is_closed_zero_locus ProjectiveSpectrum.isClosed_zeroLocus

/- warning: projective_spectrum.zero_locus_vanishing_ideal_eq_closure -> ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closure is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.zero_locus_vanishing_ideal_eq_closure ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closureₓ'. -/
theorem zeroLocus_vanishingIdeal_eq_closure (t : Set (ProjectiveSpectrum 𝒜)) :
    zeroLocus 𝒜 (vanishingIdeal t : Set A) = closure t :=
  by
  apply Set.Subset.antisymm
  · rintro x hx t' ⟨ht', ht⟩
    obtain ⟨fs, rfl⟩ : ∃ s, t' = zero_locus 𝒜 s := by rwa [is_closed_iff_zero_locus] at ht'
    rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht
    exact Set.Subset.trans ht hx
  · rw [(is_closed_zero_locus _ _).closure_subset_iff]
    exact subset_zero_locus_vanishing_ideal 𝒜 t
#align projective_spectrum.zero_locus_vanishing_ideal_eq_closure ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closure

/- warning: projective_spectrum.vanishing_ideal_closure -> ProjectiveSpectrum.vanishingIdeal_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (ProjectiveSpectrum.vanishingIdeal._proof_1.{u1, u2} R A _inst_1 _inst_2 _inst_3) 𝒜 (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) t)) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 t)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (t : Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)), Eq.{succ u2} (HomogeneousIdeal.{0, u2, u2} Nat (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) (Submodule.setLike.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) (Submodule.addSubmonoidClass.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) 𝒜 (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_4) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) t)) (ProjectiveSpectrum.vanishingIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 t)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.vanishing_ideal_closure ProjectiveSpectrum.vanishingIdeal_closureₓ'. -/
theorem vanishingIdeal_closure (t : Set (ProjectiveSpectrum 𝒜)) :
    vanishingIdeal (closure t) = vanishingIdeal t :=
  by
  have := (gc_ideal 𝒜).u_l_u_eq_u t
  dsimp only at this
  ext1
  erw [zero_locus_vanishing_ideal_eq_closure 𝒜 t] at this
  exact this
#align projective_spectrum.vanishing_ideal_closure ProjectiveSpectrum.vanishingIdeal_closure

section BasicOpen

/- warning: projective_spectrum.basic_open -> ProjectiveSpectrum.basicOpen is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], A -> (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], A -> (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open ProjectiveSpectrum.basicOpenₓ'. -/
/-- `basic_open r` is the open subset containing all prime ideals not containing `r`. -/
def basicOpen (r : A) : TopologicalSpace.Opens (ProjectiveSpectrum 𝒜)
    where
  carrier := { x | r ∉ x.asHomogeneousIdeal }
  is_open' := ⟨{r}, Set.ext fun x => Set.singleton_subset_iff.trans <| Classical.not_not.symm⟩
#align projective_spectrum.basic_open ProjectiveSpectrum.basicOpen

/- warning: projective_spectrum.mem_basic_open -> ProjectiveSpectrum.mem_basicOpen is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_basic_open ProjectiveSpectrum.mem_basicOpenₓ'. -/
@[simp]
theorem mem_basicOpen (f : A) (x : ProjectiveSpectrum 𝒜) :
    x ∈ basicOpen 𝒜 f ↔ f ∉ x.asHomogeneousIdeal :=
  Iff.rfl
#align projective_spectrum.mem_basic_open ProjectiveSpectrum.mem_basicOpen

/- warning: projective_spectrum.mem_coe_basic_open -> ProjectiveSpectrum.mem_coe_basicOpen is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.mem_coe_basic_open ProjectiveSpectrum.mem_coe_basicOpenₓ'. -/
theorem mem_coe_basicOpen (f : A) (x : ProjectiveSpectrum 𝒜) :
    x ∈ (↑(basicOpen 𝒜 f) : Set (ProjectiveSpectrum 𝒜)) ↔ f ∉ x.asHomogeneousIdeal :=
  Iff.rfl
#align projective_spectrum.mem_coe_basic_open ProjectiveSpectrum.mem_coe_basicOpen

/- warning: projective_spectrum.is_open_basic_open -> ProjectiveSpectrum.isOpen_basicOpen is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] {a : A}, IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CoeTCₓ.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 a))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] {a : A}, IsOpen.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (SetLike.coe.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 a))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_open_basic_open ProjectiveSpectrum.isOpen_basicOpenₓ'. -/
theorem isOpen_basicOpen {a : A} : IsOpen (basicOpen 𝒜 a : Set (ProjectiveSpectrum 𝒜)) :=
  (basicOpen 𝒜 a).IsOpen
#align projective_spectrum.is_open_basic_open ProjectiveSpectrum.isOpen_basicOpen

/- warning: projective_spectrum.basic_open_eq_zero_locus_compl -> ProjectiveSpectrum.basicOpen_eq_zeroLocus_compl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (r : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CoeTCₓ.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 r)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.booleanAlgebra.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.hasSingleton.{u2} A) r)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (r : A), Eq.{succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (SetLike.coe.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 r)) (HasCompl.compl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (BooleanAlgebra.toHasCompl.{u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instBooleanAlgebraSet.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) (ProjectiveSpectrum.zeroLocus.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (Singleton.singleton.{u2, u2} A (Set.{u2} A) (Set.instSingletonSet.{u2} A) r)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_eq_zero_locus_compl ProjectiveSpectrum.basicOpen_eq_zeroLocus_complₓ'. -/
@[simp]
theorem basicOpen_eq_zeroLocus_compl (r : A) :
    (basicOpen 𝒜 r : Set (ProjectiveSpectrum 𝒜)) = zeroLocus 𝒜 {r}ᶜ :=
  Set.ext fun x => by simpa only [Set.mem_compl_iff, mem_zero_locus, Set.singleton_subset_iff]
#align projective_spectrum.basic_open_eq_zero_locus_compl ProjectiveSpectrum.basicOpen_eq_zeroLocus_compl

/- warning: projective_spectrum.basic_open_one -> ProjectiveSpectrum.basicOpen_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2))))))))) (Top.top.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.toHasTop.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) (Top.top.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.toTop.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_one ProjectiveSpectrum.basicOpen_oneₓ'. -/
@[simp]
theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
#align projective_spectrum.basic_open_one ProjectiveSpectrum.basicOpen_one

/- warning: projective_spectrum.basic_open_zero -> ProjectiveSpectrum.basicOpen_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))))) (Bot.bot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.toHasBot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (CommMonoidWithZero.toZero.{u2} A (CommSemiring.toCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) (Bot.bot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.toBot.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_zero ProjectiveSpectrum.basicOpen_zeroₓ'. -/
@[simp]
theorem basicOpen_zero : basicOpen 𝒜 (0 : A) = ⊥ :=
  TopologicalSpace.Opens.ext <| by simp
#align projective_spectrum.basic_open_zero ProjectiveSpectrum.basicOpen_zero

/- warning: projective_spectrum.basic_open_mul -> ProjectiveSpectrum.basicOpen_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (g : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g)) (Inf.inf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (SemilatticeInf.toHasInf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Lattice.toSemilatticeInf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ConditionallyCompleteLattice.toLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 f) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 g))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (g : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g)) (Inf.inf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Lattice.toInf.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ConditionallyCompleteLattice.toLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 f) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 g))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_mul ProjectiveSpectrum.basicOpen_mulₓ'. -/
theorem basicOpen_mul (f g : A) : basicOpen 𝒜 (f * g) = basicOpen 𝒜 f ⊓ basicOpen 𝒜 g :=
  TopologicalSpace.Opens.ext <| by simp [zero_locus_singleton_mul]
#align projective_spectrum.basic_open_mul ProjectiveSpectrum.basicOpen_mul

/- warning: projective_spectrum.basic_open_mul_le_left -> ProjectiveSpectrum.basicOpen_mul_le_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Preorder.toHasLe.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (SetLike.partialOrder.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 f)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Preorder.toLE.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 f)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_mul_le_left ProjectiveSpectrum.basicOpen_mul_le_leftₓ'. -/
theorem basicOpen_mul_le_left (f g : A) : basicOpen 𝒜 (f * g) ≤ basicOpen 𝒜 f :=
  by
  rw [basic_open_mul 𝒜 f g]
  exact inf_le_left
#align projective_spectrum.basic_open_mul_le_left ProjectiveSpectrum.basicOpen_mul_le_left

/- warning: projective_spectrum.basic_open_mul_le_right -> ProjectiveSpectrum.basicOpen_mul_le_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Preorder.toHasLe.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (SetLike.partialOrder.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 g)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (g : A), LE.le.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Preorder.toLE.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (PartialOrder.toPreorder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) f g)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 g)
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_mul_le_right ProjectiveSpectrum.basicOpen_mul_le_rightₓ'. -/
theorem basicOpen_mul_le_right (f g : A) : basicOpen 𝒜 (f * g) ≤ basicOpen 𝒜 g :=
  by
  rw [basic_open_mul 𝒜 f g]
  exact inf_le_right
#align projective_spectrum.basic_open_mul_le_right ProjectiveSpectrum.basicOpen_mul_le_right

/- warning: projective_spectrum.basic_open_pow -> ProjectiveSpectrum.basicOpen_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (n : Nat), (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n) -> (Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (Ring.toMonoid.{u2} A (CommRing.toRing.{u2} A _inst_2)))) f n)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 f))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (f : A) (n : Nat), (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n) -> (Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)))))) f n)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 f))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_pow ProjectiveSpectrum.basicOpen_powₓ'. -/
@[simp]
theorem basicOpen_pow (f : A) (n : ℕ) (hn : 0 < n) : basicOpen 𝒜 (f ^ n) = basicOpen 𝒜 f :=
  TopologicalSpace.Opens.ext <| by simpa using zero_locus_singleton_pow 𝒜 f n hn
#align projective_spectrum.basic_open_pow ProjectiveSpectrum.basicOpen_pow

/- warning: projective_spectrum.basic_open_eq_union_of_projection -> ProjectiveSpectrum.basicOpen_eq_union_of_projection is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (f : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 f) (iSup.{u2, 1} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ConditionallyCompleteLattice.toHasSup.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.completeLattice.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))) Nat (fun (i : Nat) => ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3)) => A -> A) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R A A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (GradedAlgebra.proj.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜 _inst_4 i) f)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜] (f : A), Eq.{succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 f) (iSup.{u2, 1} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ConditionallyCompleteLattice.toSupSet.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)))) Nat (fun (i : Nat) => ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : A) => A) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R A A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (GradedAlgebra.proj.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜 _inst_4 i) f)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.basic_open_eq_union_of_projection ProjectiveSpectrum.basicOpen_eq_union_of_projectionₓ'. -/
theorem basicOpen_eq_union_of_projection (f : A) :
    basicOpen 𝒜 f = ⨆ i : ℕ, basicOpen 𝒜 (GradedAlgebra.proj 𝒜 i f) :=
  TopologicalSpace.Opens.ext <|
    Set.ext fun z => by
      erw [mem_coe_basic_open, TopologicalSpace.Opens.mem_sSup]
      constructor <;> intro hz
      · rcases show ∃ i, GradedAlgebra.proj 𝒜 i f ∉ z.as_homogeneous_ideal
            by
            contrapose! hz with H
            classical
              rw [← DirectSum.sum_support_decompose 𝒜 f]
              apply Ideal.sum_mem _ fun i hi => H i with
          ⟨i, hi⟩
        exact ⟨basic_open 𝒜 (GradedAlgebra.proj 𝒜 i f), ⟨i, rfl⟩, by rwa [mem_basic_open]⟩
      · obtain ⟨_, ⟨i, rfl⟩, hz⟩ := hz
        exact fun rid => hz (z.1.2 i rid)
#align projective_spectrum.basic_open_eq_union_of_projection ProjectiveSpectrum.basicOpen_eq_union_of_projection

/- warning: projective_spectrum.is_topological_basis_basic_opens -> ProjectiveSpectrum.isTopologicalBasis_basic_opens is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜], TopologicalSpace.IsTopologicalBasis.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.range.{u2, succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) A (fun (r : A) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (HasLiftT.mk.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (CoeTCₓ.coe.{succ u2, succ u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (SetLike.Set.hasCoeT.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (TopologicalSpace.Opens.setLike.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))))) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 r)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_3 𝒜], TopologicalSpace.IsTopologicalBasis.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.range.{u2, succ u2} (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) A (fun (r : A) => SetLike.coe.{u2, u2} (TopologicalSpace.Opens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (TopologicalSpace.Opens.instSetLikeOpens.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (ProjectiveSpectrum.basicOpen.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4 r)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.is_topological_basis_basic_opens ProjectiveSpectrum.isTopologicalBasis_basic_opensₓ'. -/
theorem isTopologicalBasis_basic_opens :
    TopologicalSpace.IsTopologicalBasis
      (Set.range fun r : A => (basicOpen 𝒜 r : Set (ProjectiveSpectrum 𝒜))) :=
  by
  apply TopologicalSpace.isTopologicalBasis_of_open_of_nhds
  · rintro _ ⟨r, rfl⟩
    exact is_open_basic_open 𝒜
  · rintro p U hp ⟨s, hs⟩
    rw [← compl_compl U, Set.mem_compl_iff, ← hs, mem_zero_locus, Set.not_subset] at hp
    obtain ⟨f, hfs, hfp⟩ := hp
    refine' ⟨basic_open 𝒜 f, ⟨f, rfl⟩, hfp, _⟩
    rw [← Set.compl_subset_compl, ← hs, basic_open_eq_zero_locus_compl, compl_compl]
    exact zero_locus_anti_mono 𝒜 (set.singleton_subset_iff.mpr hfs)
#align projective_spectrum.is_topological_basis_basic_opens ProjectiveSpectrum.isTopologicalBasis_basic_opens

end BasicOpen

section Order

/-!
## The specialization order

We endow `projective_spectrum 𝒜` with a partial order,
where `x ≤ y` if and only if `y ∈ closure {x}`.
-/


instance : PartialOrder (ProjectiveSpectrum 𝒜) :=
  PartialOrder.lift asHomogeneousIdeal fun ⟨_, _, _⟩ ⟨_, _, _⟩ => mk.inj_eq.mpr

/- warning: projective_spectrum.as_ideal_le_as_ideal -> ProjectiveSpectrum.as_ideal_le_as_ideal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.as_ideal_le_as_ideal ProjectiveSpectrum.as_ideal_le_as_idealₓ'. -/
@[simp]
theorem as_ideal_le_as_ideal (x y : ProjectiveSpectrum 𝒜) :
    x.asHomogeneousIdeal ≤ y.asHomogeneousIdeal ↔ x ≤ y :=
  Iff.rfl
#align projective_spectrum.as_ideal_le_as_ideal ProjectiveSpectrum.as_ideal_le_as_ideal

/- warning: projective_spectrum.as_ideal_lt_as_ideal -> ProjectiveSpectrum.as_ideal_lt_as_ideal is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align projective_spectrum.as_ideal_lt_as_ideal ProjectiveSpectrum.as_ideal_lt_as_idealₓ'. -/
@[simp]
theorem as_ideal_lt_as_ideal (x y : ProjectiveSpectrum 𝒜) :
    x.asHomogeneousIdeal < y.asHomogeneousIdeal ↔ x < y :=
  Iff.rfl
#align projective_spectrum.as_ideal_lt_as_ideal ProjectiveSpectrum.as_ideal_lt_as_ideal

/- warning: projective_spectrum.le_iff_mem_closure -> ProjectiveSpectrum.le_iff_mem_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] (𝒜 : Nat -> (Submodule.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} A (NonUnitalNonAssocRing.toAddCommGroup.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u1, u2} Nat R A (fun (a : Nat) (b : Nat) => Nat.decidableEq a b) Nat.addMonoid _inst_1 (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_3 𝒜] (x : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (y : ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4), Iff (LE.le.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Preorder.toHasLe.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (PartialOrder.toPreorder.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.partialOrder.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) x y) (Membership.Mem.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasMem.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) y (closure.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Singleton.singleton.{u2, u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.hasSingleton.{u2} (ProjectiveSpectrum.{u1, u2} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) x)))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] (𝒜 : Nat -> (Submodule.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u2, u1} R A _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3))) [_inst_4 : GradedAlgebra.{0, u2, u1} Nat R A (fun (a : Nat) (b : Nat) => instDecidableEqNat a b) Nat.addMonoid _inst_1 (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_3 𝒜] (x : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (y : ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4), Iff (LE.le.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Preorder.toLE.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (PartialOrder.toPreorder.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.instPartialOrderProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4))) x y) (Membership.mem.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instMembershipSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) y (closure.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (ProjectiveSpectrum.zariskiTopology.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Singleton.singleton.{u1, u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4) (Set.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) (Set.instSingletonSet.{u1} (ProjectiveSpectrum.{u2, u1} R A _inst_1 _inst_2 _inst_3 𝒜 _inst_4)) x)))
Case conversion may be inaccurate. Consider using '#align projective_spectrum.le_iff_mem_closure ProjectiveSpectrum.le_iff_mem_closureₓ'. -/
theorem le_iff_mem_closure (x y : ProjectiveSpectrum 𝒜) :
    x ≤ y ↔ y ∈ closure ({x} : Set (ProjectiveSpectrum 𝒜)) :=
  by
  rw [← as_ideal_le_as_ideal, ← zero_locus_vanishing_ideal_eq_closure, mem_zero_locus,
    vanishing_ideal_singleton]
  simp only [coe_subset_coe, Subtype.coe_le_coe, coe_coe]
#align projective_spectrum.le_iff_mem_closure ProjectiveSpectrum.le_iff_mem_closure

end Order

end ProjectiveSpectrum

