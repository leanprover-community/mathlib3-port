/-
Copyright (c) 2022 Yaël Dillies, Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies, Bhavik Mehta

! This file was ported from Lean 3 source module combinatorics.simple_graph.triangle.basic
! leanprover-community/mathlib commit ee05e9ce1322178f0c12004eb93c00d2c8c00ed2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Combinatorics.SimpleGraph.Clique

/-!
# Triangles in graphs

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

A *triangle* in a simple graph is a `3`-clique, namely a set of three vertices that are
pairwise adjacent.

This module defines and proves properties about triangles in simple graphs.

## Main declarations

* `simple_graph.far_from_triangle_free`: Predicate for a graph to have enough triangles that, to
  remove all of them, one must one must remove a lot of edges. This is the crux of the Triangle
  Removal lemma.

## TODO

* Generalise `far_from_triangle_free` to other graphs, to state and prove the Graph Removal Lemma.
* Find a better name for `far_from_triangle_free`. Added 4/26/2022. Remove this TODO if it gets old.
-/


open Finset Fintype Nat

open Classical

namespace SimpleGraph

variable {α 𝕜 : Type _} [Fintype α] [LinearOrderedField 𝕜] {G H : SimpleGraph α} {ε δ : 𝕜} {n : ℕ}
  {s : Finset α}

#print SimpleGraph.FarFromTriangleFree /-
/-- A simple graph is *`ε`-triangle-free far* if one must remove at least `ε * (card α)^2` edges to
make it triangle-free. -/
def FarFromTriangleFree (G : SimpleGraph α) (ε : 𝕜) : Prop :=
  (G.DeleteFar fun H => H.CliqueFree 3) <| ε * (card α ^ 2 : ℕ)
#align simple_graph.far_from_triangle_free SimpleGraph.FarFromTriangleFree
-/

/- warning: simple_graph.far_from_triangle_free_iff -> SimpleGraph.farFromTriangleFree_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : Fintype.{u1} α] [_inst_2 : LinearOrderedField.{u2} 𝕜] {G : SimpleGraph.{u1} α} {ε : 𝕜}, Iff (SimpleGraph.FarFromTriangleFree.{u1, u2} α 𝕜 _inst_1 _inst_2 G ε) (forall {{H : SimpleGraph.{u1} α}}, (LE.le.{u1} (SimpleGraph.{u1} α) (SimpleGraph.hasLe.{u1} α) H G) -> (SimpleGraph.CliqueFree.{u1} α H (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (LE.le.{u2} 𝕜 (Preorder.toLE.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_2))))))) (HMul.hMul.{u2, u2, u2} 𝕜 𝕜 𝕜 (instHMul.{u2} 𝕜 (Distrib.toHasMul.{u2} 𝕜 (Ring.toDistrib.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))) ε ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat 𝕜 (HasLiftT.mk.{1, succ u2} Nat 𝕜 (CoeTCₓ.coe.{1, succ u2} Nat 𝕜 (Nat.castCoe.{u2} 𝕜 (AddMonoidWithOne.toNatCast.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} α _inst_1) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HSub.hSub.{u2, u2, u2} 𝕜 𝕜 𝕜 (instHSub.{u2} 𝕜 (SubNegMonoid.toHasSub.{u2} 𝕜 (AddGroup.toSubNegMonoid.{u2} 𝕜 (AddGroupWithOne.toAddGroup.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2))))))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat 𝕜 (HasLiftT.mk.{1, succ u2} Nat 𝕜 (CoeTCₓ.coe.{1, succ u2} Nat 𝕜 (Nat.castCoe.{u2} 𝕜 (AddMonoidWithOne.toNatCast.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} α) (SimpleGraph.edgeFinset.{u1} α G (SimpleGraph.fintypeEdgeSet.{u1} α G (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u1} α a b)) _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u1} α G a b)))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat 𝕜 (HasLiftT.mk.{1, succ u2} Nat 𝕜 (CoeTCₓ.coe.{1, succ u2} Nat 𝕜 (Nat.castCoe.{u2} 𝕜 (AddMonoidWithOne.toNatCast.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} α) (SimpleGraph.edgeFinset.{u1} α H (SimpleGraph.fintypeEdgeSet.{u1} α H (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u1} α a b)) _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u1} α H a b)))))))))
but is expected to have type
  forall {α : Type.{u2}} {𝕜 : Type.{u1}} [_inst_1 : Fintype.{u2} α] [_inst_2 : LinearOrderedField.{u1} 𝕜] {G : SimpleGraph.{u2} α} {ε : 𝕜}, Iff (SimpleGraph.FarFromTriangleFree.{u2, u1} α 𝕜 _inst_1 _inst_2 G ε) (forall {{H : SimpleGraph.{u2} α}}, (LE.le.{u2} (SimpleGraph.{u2} α) (SimpleGraph.instLESimpleGraph.{u2} α) H G) -> (SimpleGraph.CliqueFree.{u2} α H (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> (LE.le.{u1} 𝕜 (Preorder.toLE.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_2)))))) (HMul.hMul.{u1, u1, u1} 𝕜 𝕜 𝕜 (instHMul.{u1} 𝕜 (NonUnitalNonAssocRing.toMul.{u1} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))))) ε (Nat.cast.{u1} 𝕜 (NonAssocRing.toNatCast.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u2} α _inst_1) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HSub.hSub.{u1, u1, u1} 𝕜 𝕜 𝕜 (instHSub.{u1} 𝕜 (Ring.toSub.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (Nat.cast.{u1} 𝕜 (NonAssocRing.toNatCast.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (Finset.card.{u2} (Sym2.{u2} α) (SimpleGraph.edgeFinset.{u2} α G (SimpleGraph.fintypeEdgeSet.{u2} α G (Quotient.fintype.{u2} (Prod.{u2, u2} α α) (instFintypeProd.{u2, u2} α α _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} α) (fun (a : Prod.{u2, u2} α α) (b : Prod.{u2, u2} α α) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} α α) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} α α) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} α α) (instHasEquiv.{succ u2} (Prod.{u2, u2} α α) (Sym2.Rel.setoid.{u2} α)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u2} α G a b)))))) (Nat.cast.{u1} 𝕜 (NonAssocRing.toNatCast.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (Finset.card.{u2} (Sym2.{u2} α) (SimpleGraph.edgeFinset.{u2} α H (SimpleGraph.fintypeEdgeSet.{u2} α H (Quotient.fintype.{u2} (Prod.{u2, u2} α α) (instFintypeProd.{u2, u2} α α _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} α) (fun (a : Prod.{u2, u2} α α) (b : Prod.{u2, u2} α α) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} α α) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} α α) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} α α) (instHasEquiv.{succ u2} (Prod.{u2, u2} α α) (Sym2.Rel.setoid.{u2} α)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u2} α H a b)))))))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free_iff SimpleGraph.farFromTriangleFree_iffₓ'. -/
theorem farFromTriangleFree_iff :
    G.FarFromTriangleFree ε ↔
      ∀ ⦃H⦄,
        H ≤ G → H.CliqueFree 3 → ε * (card α ^ 2 : ℕ) ≤ G.edgeFinset.card - H.edgeFinset.card :=
  deleteFar_iff
#align simple_graph.far_from_triangle_free_iff SimpleGraph.farFromTriangleFree_iff

/- warning: simple_graph.far_from_triangle_free.le_card_sub_card -> SimpleGraph.farFromTriangleFree.le_card_sub_card is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : Fintype.{u1} α] [_inst_2 : LinearOrderedField.{u2} 𝕜] {G : SimpleGraph.{u1} α} {ε : 𝕜}, (SimpleGraph.FarFromTriangleFree.{u1, u2} α 𝕜 _inst_1 _inst_2 G ε) -> (forall {{H : SimpleGraph.{u1} α}}, (LE.le.{u1} (SimpleGraph.{u1} α) (SimpleGraph.hasLe.{u1} α) H G) -> (SimpleGraph.CliqueFree.{u1} α H (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (LE.le.{u2} 𝕜 (Preorder.toLE.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_2))))))) (HMul.hMul.{u2, u2, u2} 𝕜 𝕜 𝕜 (instHMul.{u2} 𝕜 (Distrib.toHasMul.{u2} 𝕜 (Ring.toDistrib.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))) ε ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat 𝕜 (HasLiftT.mk.{1, succ u2} Nat 𝕜 (CoeTCₓ.coe.{1, succ u2} Nat 𝕜 (Nat.castCoe.{u2} 𝕜 (AddMonoidWithOne.toNatCast.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} α _inst_1) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (HSub.hSub.{u2, u2, u2} 𝕜 𝕜 𝕜 (instHSub.{u2} 𝕜 (SubNegMonoid.toHasSub.{u2} 𝕜 (AddGroup.toSubNegMonoid.{u2} 𝕜 (AddGroupWithOne.toAddGroup.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2))))))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat 𝕜 (HasLiftT.mk.{1, succ u2} Nat 𝕜 (CoeTCₓ.coe.{1, succ u2} Nat 𝕜 (Nat.castCoe.{u2} 𝕜 (AddMonoidWithOne.toNatCast.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} α) (SimpleGraph.edgeFinset.{u1} α G (SimpleGraph.fintypeEdgeSet.{u1} α G (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u1} α a b)) _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u1} α G a b)))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat 𝕜 (HasLiftT.mk.{1, succ u2} Nat 𝕜 (CoeTCₓ.coe.{1, succ u2} Nat 𝕜 (Nat.castCoe.{u2} 𝕜 (AddMonoidWithOne.toNatCast.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} α) (SimpleGraph.edgeFinset.{u1} α H (SimpleGraph.fintypeEdgeSet.{u1} α H (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u1} α a b)) _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u1} α H a b)))))))))
but is expected to have type
  forall {α : Type.{u2}} {𝕜 : Type.{u1}} [_inst_1 : Fintype.{u2} α] [_inst_2 : LinearOrderedField.{u1} 𝕜] {G : SimpleGraph.{u2} α} {ε : 𝕜}, (SimpleGraph.FarFromTriangleFree.{u2, u1} α 𝕜 _inst_1 _inst_2 G ε) -> (forall {{H : SimpleGraph.{u2} α}}, (LE.le.{u2} (SimpleGraph.{u2} α) (SimpleGraph.instLESimpleGraph.{u2} α) H G) -> (SimpleGraph.CliqueFree.{u2} α H (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> (LE.le.{u1} 𝕜 (Preorder.toLE.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_2)))))) (HMul.hMul.{u1, u1, u1} 𝕜 𝕜 𝕜 (instHMul.{u1} 𝕜 (NonUnitalNonAssocRing.toMul.{u1} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))))) ε (Nat.cast.{u1} 𝕜 (NonAssocRing.toNatCast.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u2} α _inst_1) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (HSub.hSub.{u1, u1, u1} 𝕜 𝕜 𝕜 (instHSub.{u1} 𝕜 (Ring.toSub.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (Nat.cast.{u1} 𝕜 (NonAssocRing.toNatCast.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (Finset.card.{u2} (Sym2.{u2} α) (SimpleGraph.edgeFinset.{u2} α G (SimpleGraph.fintypeEdgeSet.{u2} α G (Quotient.fintype.{u2} (Prod.{u2, u2} α α) (instFintypeProd.{u2, u2} α α _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} α) (fun (a : Prod.{u2, u2} α α) (b : Prod.{u2, u2} α α) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} α α) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} α α) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} α α) (instHasEquiv.{succ u2} (Prod.{u2, u2} α α) (Sym2.Rel.setoid.{u2} α)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u2} α G a b)))))) (Nat.cast.{u1} 𝕜 (NonAssocRing.toNatCast.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (Finset.card.{u2} (Sym2.{u2} α) (SimpleGraph.edgeFinset.{u2} α H (SimpleGraph.fintypeEdgeSet.{u2} α H (Quotient.fintype.{u2} (Prod.{u2, u2} α α) (instFintypeProd.{u2, u2} α α _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} α) (fun (a : Prod.{u2, u2} α α) (b : Prod.{u2, u2} α α) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} α α) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} α α) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} α α) (instHasEquiv.{succ u2} (Prod.{u2, u2} α α) (Sym2.Rel.setoid.{u2} α)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u2} α H a b)))))))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.le_card_sub_card SimpleGraph.farFromTriangleFree.le_card_sub_cardₓ'. -/
alias far_from_triangle_free_iff ↔ far_from_triangle_free.le_card_sub_card _
#align simple_graph.far_from_triangle_free.le_card_sub_card SimpleGraph.farFromTriangleFree.le_card_sub_card

/- warning: simple_graph.far_from_triangle_free.mono -> SimpleGraph.farFromTriangleFree.mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : Fintype.{u1} α] [_inst_2 : LinearOrderedField.{u2} 𝕜] {G : SimpleGraph.{u1} α} {ε : 𝕜} {δ : 𝕜}, (SimpleGraph.FarFromTriangleFree.{u1, u2} α 𝕜 _inst_1 _inst_2 G ε) -> (LE.le.{u2} 𝕜 (Preorder.toLE.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_2))))))) δ ε) -> (SimpleGraph.FarFromTriangleFree.{u1, u2} α 𝕜 _inst_1 _inst_2 G δ)
but is expected to have type
  forall {α : Type.{u2}} {𝕜 : Type.{u1}} [_inst_1 : Fintype.{u2} α] [_inst_2 : LinearOrderedField.{u1} 𝕜] {G : SimpleGraph.{u2} α} {ε : 𝕜} {δ : 𝕜}, (SimpleGraph.FarFromTriangleFree.{u2, u1} α 𝕜 _inst_1 _inst_2 G ε) -> (LE.le.{u1} 𝕜 (Preorder.toLE.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_2)))))) δ ε) -> (SimpleGraph.FarFromTriangleFree.{u2, u1} α 𝕜 _inst_1 _inst_2 G δ)
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.mono SimpleGraph.farFromTriangleFree.monoₓ'. -/
theorem farFromTriangleFree.mono (hε : G.FarFromTriangleFree ε) (h : δ ≤ ε) :
    G.FarFromTriangleFree δ :=
  hε.mono <| mul_le_mul_of_nonneg_right h <| cast_nonneg _
#align simple_graph.far_from_triangle_free.mono SimpleGraph.farFromTriangleFree.mono

/- warning: simple_graph.far_from_triangle_free.clique_finset_nonempty' -> SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : Fintype.{u1} α] [_inst_2 : LinearOrderedField.{u2} 𝕜] {G : SimpleGraph.{u1} α} {H : SimpleGraph.{u1} α} {ε : 𝕜}, (LE.le.{u1} (SimpleGraph.{u1} α) (SimpleGraph.hasLe.{u1} α) H G) -> (SimpleGraph.FarFromTriangleFree.{u1, u2} α 𝕜 _inst_1 _inst_2 G ε) -> (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_2))))))) (HSub.hSub.{u2, u2, u2} 𝕜 𝕜 𝕜 (instHSub.{u2} 𝕜 (SubNegMonoid.toHasSub.{u2} 𝕜 (AddGroup.toSubNegMonoid.{u2} 𝕜 (AddGroupWithOne.toAddGroup.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2))))))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat 𝕜 (HasLiftT.mk.{1, succ u2} Nat 𝕜 (CoeTCₓ.coe.{1, succ u2} Nat 𝕜 (Nat.castCoe.{u2} 𝕜 (AddMonoidWithOne.toNatCast.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} α) (SimpleGraph.edgeFinset.{u1} α G (SimpleGraph.fintypeEdgeSet.{u1} α G (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u1} α a b)) _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u1} α G a b)))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat 𝕜 (HasLiftT.mk.{1, succ u2} Nat 𝕜 (CoeTCₓ.coe.{1, succ u2} Nat 𝕜 (Nat.castCoe.{u2} 𝕜 (AddMonoidWithOne.toNatCast.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))))))) (Finset.card.{u1} (Sym2.{u1} α) (SimpleGraph.edgeFinset.{u1} α H (SimpleGraph.fintypeEdgeSet.{u1} α H (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u1} α a b)) _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u1} α H a b))))))) (HMul.hMul.{u2, u2, u2} 𝕜 𝕜 𝕜 (instHMul.{u2} 𝕜 (Distrib.toHasMul.{u2} 𝕜 (Ring.toDistrib.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))) ε ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat 𝕜 (HasLiftT.mk.{1, succ u2} Nat 𝕜 (CoeTCₓ.coe.{1, succ u2} Nat 𝕜 (Nat.castCoe.{u2} 𝕜 (AddMonoidWithOne.toNatCast.{u2} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u2} 𝕜 (NonAssocRing.toAddGroupWithOne.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2)))))))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Fintype.card.{u1} α _inst_1) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))) -> (Finset.Nonempty.{u1} (Finset.{u1} α) (SimpleGraph.cliqueFinset.{u1} α H _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u1} α a b)) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u1} α H a b)) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {α : Type.{u2}} {𝕜 : Type.{u1}} [_inst_1 : Fintype.{u2} α] [_inst_2 : LinearOrderedField.{u1} 𝕜] {G : SimpleGraph.{u2} α} {H : SimpleGraph.{u2} α} {ε : 𝕜}, (LE.le.{u2} (SimpleGraph.{u2} α) (SimpleGraph.instLESimpleGraph.{u2} α) H G) -> (SimpleGraph.FarFromTriangleFree.{u2, u1} α 𝕜 _inst_1 _inst_2 G ε) -> (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_2)))))) (HSub.hSub.{u1, u1, u1} 𝕜 𝕜 𝕜 (instHSub.{u1} 𝕜 (Ring.toSub.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (Nat.cast.{u1} 𝕜 (NonAssocRing.toNatCast.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (Finset.card.{u2} (Sym2.{u2} α) (SimpleGraph.edgeFinset.{u2} α G (SimpleGraph.fintypeEdgeSet.{u2} α G (Quotient.fintype.{u2} (Prod.{u2, u2} α α) (instFintypeProd.{u2, u2} α α _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} α) (fun (a : Prod.{u2, u2} α α) (b : Prod.{u2, u2} α α) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} α α) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} α α) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} α α) (instHasEquiv.{succ u2} (Prod.{u2, u2} α α) (Sym2.Rel.setoid.{u2} α)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u2} α G a b)))))) (Nat.cast.{u1} 𝕜 (NonAssocRing.toNatCast.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (Finset.card.{u2} (Sym2.{u2} α) (SimpleGraph.edgeFinset.{u2} α H (SimpleGraph.fintypeEdgeSet.{u2} α H (Quotient.fintype.{u2} (Prod.{u2, u2} α α) (instFintypeProd.{u2, u2} α α _inst_1 _inst_1) (Sym2.Rel.setoid.{u2} α) (fun (a : Prod.{u2, u2} α α) (b : Prod.{u2, u2} α α) => Classical.propDecidable ((fun (x._@.Mathlib.Data.Fintype.Basic._hyg.7705 : Prod.{u2, u2} α α) (x._@.Mathlib.Data.Fintype.Basic._hyg.7707 : Prod.{u2, u2} α α) => HasEquiv.Equiv.{succ u2, 0} (Prod.{u2, u2} α α) (instHasEquiv.{succ u2} (Prod.{u2, u2} α α) (Sym2.Rel.setoid.{u2} α)) x._@.Mathlib.Data.Fintype.Basic._hyg.7705 x._@.Mathlib.Data.Fintype.Basic._hyg.7707) a b))) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u2} α H a b))))))) (HMul.hMul.{u1, u1, u1} 𝕜 𝕜 𝕜 (instHMul.{u1} 𝕜 (NonUnitalNonAssocRing.toMul.{u1} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))))) ε (Nat.cast.{u1} 𝕜 (NonAssocRing.toNatCast.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 (LinearOrderedField.toField.{u1} 𝕜 _inst_2))))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Fintype.card.{u2} α _inst_1) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))) -> (Finset.Nonempty.{u2} (Finset.{u2} α) (SimpleGraph.cliqueFinset.{u2} α H _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u2} α a b)) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u2} α H a b)) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.clique_finset_nonempty' SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty'ₓ'. -/
theorem FarFromTriangleFree.cliqueFinset_nonempty' (hH : H ≤ G) (hG : G.FarFromTriangleFree ε)
    (hcard : (G.edgeFinset.card - H.edgeFinset.card : 𝕜) < ε * (card α ^ 2 : ℕ)) :
    (H.cliqueFinset 3).Nonempty :=
  nonempty_of_ne_empty <|
    H.cliqueFinset_eq_empty_iff.Not.2 fun hH' => (hG.le_card_sub_card hH hH').not_lt hcard
#align simple_graph.far_from_triangle_free.clique_finset_nonempty' SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty'

variable [Nonempty α]

/- warning: simple_graph.far_from_triangle_free.nonpos -> SimpleGraph.FarFromTriangleFree.nonpos is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : Fintype.{u1} α] [_inst_2 : LinearOrderedField.{u2} 𝕜] {G : SimpleGraph.{u1} α} {ε : 𝕜} [_inst_3 : Nonempty.{succ u1} α], (SimpleGraph.FarFromTriangleFree.{u1, u2} α 𝕜 _inst_1 _inst_2 G ε) -> (SimpleGraph.CliqueFree.{u1} α G (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (LE.le.{u2} 𝕜 (Preorder.toLE.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_2))))))) ε (OfNat.ofNat.{u2} 𝕜 0 (OfNat.mk.{u2} 𝕜 0 (Zero.zero.{u2} 𝕜 (MulZeroClass.toHasZero.{u2} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} 𝕜 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2))))))))))))
but is expected to have type
  forall {α : Type.{u2}} {𝕜 : Type.{u1}} [_inst_1 : Fintype.{u2} α] [_inst_2 : LinearOrderedField.{u1} 𝕜] {G : SimpleGraph.{u2} α} {ε : 𝕜} [_inst_3 : Nonempty.{succ u2} α], (SimpleGraph.FarFromTriangleFree.{u2, u1} α 𝕜 _inst_1 _inst_2 G ε) -> (SimpleGraph.CliqueFree.{u2} α G (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> (LE.le.{u1} 𝕜 (Preorder.toLE.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_2)))))) ε (OfNat.ofNat.{u1} 𝕜 0 (Zero.toOfNat0.{u1} 𝕜 (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.nonpos SimpleGraph.FarFromTriangleFree.nonposₓ'. -/
theorem FarFromTriangleFree.nonpos (h₀ : G.FarFromTriangleFree ε) (h₁ : G.CliqueFree 3) : ε ≤ 0 :=
  by
  have := h₀ (empty_subset _)
  rw [coe_empty, Finset.card_empty, cast_zero, delete_edges_empty_eq] at this
  exact nonpos_of_mul_nonpos_left (this h₁) (cast_pos.2 <| sq_pos_of_pos Fintype.card_pos)
#align simple_graph.far_from_triangle_free.nonpos SimpleGraph.FarFromTriangleFree.nonpos

/- warning: simple_graph.clique_free.not_far_from_triangle_free -> SimpleGraph.CliqueFree.not_farFromTriangleFree is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : Fintype.{u1} α] [_inst_2 : LinearOrderedField.{u2} 𝕜] {G : SimpleGraph.{u1} α} {ε : 𝕜} [_inst_3 : Nonempty.{succ u1} α], (SimpleGraph.CliqueFree.{u1} α G (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_2))))))) (OfNat.ofNat.{u2} 𝕜 0 (OfNat.mk.{u2} 𝕜 0 (Zero.zero.{u2} 𝕜 (MulZeroClass.toHasZero.{u2} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} 𝕜 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2))))))))))) ε) -> (Not (SimpleGraph.FarFromTriangleFree.{u1, u2} α 𝕜 _inst_1 _inst_2 G ε))
but is expected to have type
  forall {α : Type.{u2}} {𝕜 : Type.{u1}} [_inst_1 : Fintype.{u2} α] [_inst_2 : LinearOrderedField.{u1} 𝕜] {G : SimpleGraph.{u2} α} {ε : 𝕜} [_inst_3 : Nonempty.{succ u2} α], (SimpleGraph.CliqueFree.{u2} α G (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_2)))))) (OfNat.ofNat.{u1} 𝕜 0 (Zero.toOfNat0.{u1} 𝕜 (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_2))))))) ε) -> (Not (SimpleGraph.FarFromTriangleFree.{u2, u1} α 𝕜 _inst_1 _inst_2 G ε))
Case conversion may be inaccurate. Consider using '#align simple_graph.clique_free.not_far_from_triangle_free SimpleGraph.CliqueFree.not_farFromTriangleFreeₓ'. -/
theorem CliqueFree.not_farFromTriangleFree (hG : G.CliqueFree 3) (hε : 0 < ε) :
    ¬G.FarFromTriangleFree ε := fun h => (h.nonpos hG).not_lt hε
#align simple_graph.clique_free.not_far_from_triangle_free SimpleGraph.CliqueFree.not_farFromTriangleFree

/- warning: simple_graph.far_from_triangle_free.not_clique_free -> SimpleGraph.FarFromTriangleFree.not_cliqueFree is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : Fintype.{u1} α] [_inst_2 : LinearOrderedField.{u2} 𝕜] {G : SimpleGraph.{u1} α} {ε : 𝕜} [_inst_3 : Nonempty.{succ u1} α], (SimpleGraph.FarFromTriangleFree.{u1, u2} α 𝕜 _inst_1 _inst_2 G ε) -> (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_2))))))) (OfNat.ofNat.{u2} 𝕜 0 (OfNat.mk.{u2} 𝕜 0 (Zero.zero.{u2} 𝕜 (MulZeroClass.toHasZero.{u2} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} 𝕜 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2))))))))))) ε) -> (Not (SimpleGraph.CliqueFree.{u1} α G (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {α : Type.{u2}} {𝕜 : Type.{u1}} [_inst_1 : Fintype.{u2} α] [_inst_2 : LinearOrderedField.{u1} 𝕜] {G : SimpleGraph.{u2} α} {ε : 𝕜} [_inst_3 : Nonempty.{succ u2} α], (SimpleGraph.FarFromTriangleFree.{u2, u1} α 𝕜 _inst_1 _inst_2 G ε) -> (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_2)))))) (OfNat.ofNat.{u1} 𝕜 0 (Zero.toOfNat0.{u1} 𝕜 (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_2))))))) ε) -> (Not (SimpleGraph.CliqueFree.{u2} α G (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.not_clique_free SimpleGraph.FarFromTriangleFree.not_cliqueFreeₓ'. -/
theorem FarFromTriangleFree.not_cliqueFree (hG : G.FarFromTriangleFree ε) (hε : 0 < ε) :
    ¬G.CliqueFree 3 := fun h => (hG.nonpos h).not_lt hε
#align simple_graph.far_from_triangle_free.not_clique_free SimpleGraph.FarFromTriangleFree.not_cliqueFree

/- warning: simple_graph.far_from_triangle_free.clique_finset_nonempty -> SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : Fintype.{u1} α] [_inst_2 : LinearOrderedField.{u2} 𝕜] {G : SimpleGraph.{u1} α} {ε : 𝕜} [_inst_3 : Nonempty.{succ u1} α], (SimpleGraph.FarFromTriangleFree.{u1, u2} α 𝕜 _inst_1 _inst_2 G ε) -> (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedAddCommGroup.toPartialOrder.{u2} 𝕜 (StrictOrderedRing.toOrderedAddCommGroup.{u2} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u2} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u2} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u2} 𝕜 _inst_2))))))) (OfNat.ofNat.{u2} 𝕜 0 (OfNat.mk.{u2} 𝕜 0 (Zero.zero.{u2} 𝕜 (MulZeroClass.toHasZero.{u2} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} 𝕜 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u2} 𝕜 (Ring.toNonAssocRing.{u2} 𝕜 (DivisionRing.toRing.{u2} 𝕜 (Field.toDivisionRing.{u2} 𝕜 (LinearOrderedField.toField.{u2} 𝕜 _inst_2))))))))))) ε) -> (Finset.Nonempty.{u1} (Finset.{u1} α) (SimpleGraph.cliqueFinset.{u1} α G _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u1} α a b)) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u1} α G a b)) (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {α : Type.{u2}} {𝕜 : Type.{u1}} [_inst_1 : Fintype.{u2} α] [_inst_2 : LinearOrderedField.{u1} 𝕜] {G : SimpleGraph.{u2} α} {ε : 𝕜} [_inst_3 : Nonempty.{succ u2} α], (SimpleGraph.FarFromTriangleFree.{u2, u1} α 𝕜 _inst_1 _inst_2 G ε) -> (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedRing.toPartialOrder.{u1} 𝕜 (LinearOrderedRing.toStrictOrderedRing.{u1} 𝕜 (LinearOrderedCommRing.toLinearOrderedRing.{u1} 𝕜 (LinearOrderedField.toLinearOrderedCommRing.{u1} 𝕜 _inst_2)))))) (OfNat.ofNat.{u1} 𝕜 0 (Zero.toOfNat0.{u1} 𝕜 (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 (LinearOrderedField.toLinearOrderedSemifield.{u1} 𝕜 _inst_2))))))) ε) -> (Finset.Nonempty.{u2} (Finset.{u2} α) (SimpleGraph.cliqueFinset.{u2} α G _inst_1 (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u2} α a b)) (fun (a : α) (b : α) => Classical.propDecidable (SimpleGraph.Adj.{u2} α G a b)) (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))))
Case conversion may be inaccurate. Consider using '#align simple_graph.far_from_triangle_free.clique_finset_nonempty SimpleGraph.FarFromTriangleFree.cliqueFinset_nonemptyₓ'. -/
theorem FarFromTriangleFree.cliqueFinset_nonempty (hG : G.FarFromTriangleFree ε) (hε : 0 < ε) :
    (G.cliqueFinset 3).Nonempty :=
  nonempty_of_ne_empty <| G.cliqueFinset_eq_empty_iff.Not.2 <| hG.not_cliqueFree hε
#align simple_graph.far_from_triangle_free.clique_finset_nonempty SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty

end SimpleGraph

