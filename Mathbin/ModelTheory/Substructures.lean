/-
Copyright (c) 2021 Aaron Anderson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Anderson

! This file was ported from Lean 3 source module model_theory.substructures
! leanprover-community/mathlib commit 6cf5900728239efa287df7761ec2a1ac9cf39b29
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Order.Closure
import Mathbin.ModelTheory.Semantics
import Mathbin.ModelTheory.Encoding

/-!
# First-Order Substructures

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
This file defines substructures of first-order structures in a similar manner to the various
substructures appearing in the algebra library.

## Main Definitions
* A `first_order.language.substructure` is defined so that `L.substructure M` is the type of all
substructures of the `L`-structure `M`.
* `first_order.language.substructure.closure` is defined so that if `s : set M`, `closure L s` is
the least substructure of `M` containing `s`.
* `first_order.language.substructure.comap` is defined so that `s.comap f` is the preimage of the
substructure `s` under the homomorphism `f`, as a substructure.
* `first_order.language.substructure.map` is defined so that `s.map f` is the image of the
substructure `s` under the homomorphism `f`, as a substructure.
* `first_order.language.hom.range` is defined so that `f.map` is the range of the
the homomorphism `f`, as a substructure.
* `first_order.language.hom.dom_restrict` and `first_order.language.hom.cod_restrict` restrict
the domain and codomain respectively of first-order homomorphisms to substructures.
* `first_order.language.embedding.dom_restrict` and `first_order.language.embedding.cod_restrict`
restrict the domain and codomain respectively of first-order embeddings to substructures.
* `first_order.language.substructure.inclusion` is the inclusion embedding between substructures.

## Main Results
* `L.substructure M` forms a `complete_lattice`.

-/


universe u v w

namespace FirstOrder

namespace Language

variable {L : Language.{u, v}} {M : Type w} {N P : Type _}

variable [L.Structure M] [L.Structure N] [L.Structure P]

open FirstOrder Cardinal

open Structure Cardinal

section ClosedUnder

open Set

variable {n : ℕ} (f : L.Functions n) (s : Set M)

#print FirstOrder.Language.ClosedUnder /-
/-- Indicates that a set in a given structure is a closed under a function symbol. -/
def ClosedUnder : Prop :=
  ∀ x : Fin n → M, (∀ i : Fin n, x i ∈ s) → funMap f x ∈ s
#align first_order.language.closed_under FirstOrder.Language.ClosedUnder
-/

variable (L)

#print FirstOrder.Language.closedUnder_univ /-
@[simp]
theorem closedUnder_univ : ClosedUnder f (univ : Set M) := fun _ _ => mem_univ _
#align first_order.language.closed_under_univ FirstOrder.Language.closedUnder_univ
-/

variable {L f s} {t : Set M}

namespace ClosedUnder

/- warning: first_order.language.closed_under.inter -> FirstOrder.Language.ClosedUnder.inter is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {n : Nat} {f : FirstOrder.Language.Functions.{u1, u2} L n} {s : Set.{u3} M} {t : Set.{u3} M}, (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f s) -> (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f t) -> (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f (Inter.inter.{u3} (Set.{u3} M) (Set.hasInter.{u3} M) s t))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {n : Nat} {f : FirstOrder.Language.Functions.{u1, u2} L n} {s : Set.{u3} M} {t : Set.{u3} M}, (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f s) -> (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f t) -> (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f (Inter.inter.{u3} (Set.{u3} M) (Set.instInterSet.{u3} M) s t))
Case conversion may be inaccurate. Consider using '#align first_order.language.closed_under.inter FirstOrder.Language.ClosedUnder.interₓ'. -/
theorem inter (hs : ClosedUnder f s) (ht : ClosedUnder f t) : ClosedUnder f (s ∩ t) := fun x h =>
  mem_inter (hs x fun i => mem_of_mem_inter_left (h i)) (ht x fun i => mem_of_mem_inter_right (h i))
#align first_order.language.closed_under.inter FirstOrder.Language.ClosedUnder.inter

/- warning: first_order.language.closed_under.inf -> FirstOrder.Language.ClosedUnder.inf is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {n : Nat} {f : FirstOrder.Language.Functions.{u1, u2} L n} {s : Set.{u3} M} {t : Set.{u3} M}, (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f s) -> (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f t) -> (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f (Inf.inf.{u3} (Set.{u3} M) (SemilatticeInf.toHasInf.{u3} (Set.{u3} M) (Lattice.toSemilatticeInf.{u3} (Set.{u3} M) (ConditionallyCompleteLattice.toLattice.{u3} (Set.{u3} M) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M)))))))) s t))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {n : Nat} {f : FirstOrder.Language.Functions.{u1, u2} L n} {s : Set.{u3} M} {t : Set.{u3} M}, (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f s) -> (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f t) -> (FirstOrder.Language.ClosedUnder.{u1, u2, u3} L M _inst_1 n f (Inf.inf.{u3} (Set.{u3} M) (Lattice.toInf.{u3} (Set.{u3} M) (ConditionallyCompleteLattice.toLattice.{u3} (Set.{u3} M) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) s t))
Case conversion may be inaccurate. Consider using '#align first_order.language.closed_under.inf FirstOrder.Language.ClosedUnder.infₓ'. -/
theorem inf (hs : ClosedUnder f s) (ht : ClosedUnder f t) : ClosedUnder f (s ⊓ t) :=
  hs.inter ht
#align first_order.language.closed_under.inf FirstOrder.Language.ClosedUnder.inf

variable {S : Set (Set M)}

#print FirstOrder.Language.ClosedUnder.sInf /-
theorem sInf (hS : ∀ s, s ∈ S → ClosedUnder f s) : ClosedUnder f (sInf S) := fun x h s hs =>
  hS s hs x fun i => h i s hs
#align first_order.language.closed_under.Inf FirstOrder.Language.ClosedUnder.sInf
-/

end ClosedUnder

end ClosedUnder

variable (L) (M)

#print FirstOrder.Language.Substructure /-
/-- A substructure of a structure `M` is a set closed under application of function symbols. -/
structure Substructure where
  carrier : Set M
  fun_mem : ∀ {n}, ∀ f : L.Functions n, ClosedUnder f carrier
#align first_order.language.substructure FirstOrder.Language.Substructure
-/

variable {L} {M}

namespace Substructure

instance : SetLike (L.Substructure M) M :=
  ⟨Substructure.carrier, fun p q h => by cases p <;> cases q <;> congr ⟩

#print FirstOrder.Language.Substructure.Simps.coe /-
/-- See Note [custom simps projection] -/
def Simps.coe (S : L.Substructure M) : Set M :=
  S
#align first_order.language.substructure.simps.coe FirstOrder.Language.Substructure.Simps.coe
-/

initialize_simps_projections Substructure (carrier → coe)

#print FirstOrder.Language.Substructure.mem_carrier /-
@[simp]
theorem mem_carrier {s : L.Substructure M} {x : M} : x ∈ s.carrier ↔ x ∈ s :=
  Iff.rfl
#align first_order.language.substructure.mem_carrier FirstOrder.Language.Substructure.mem_carrier
-/

#print FirstOrder.Language.Substructure.ext /-
/-- Two substructures are equal if they have the same elements. -/
@[ext]
theorem ext {S T : L.Substructure M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=
  SetLike.ext h
#align first_order.language.substructure.ext FirstOrder.Language.Substructure.ext
-/

#print FirstOrder.Language.Substructure.copy /-
/-- Copy a substructure replacing `carrier` with a set that is equal to it. -/
protected def copy (S : L.Substructure M) (s : Set M) (hs : s = S) : L.Substructure M
    where
  carrier := s
  fun_mem n f := hs.symm ▸ S.fun_mem f
#align first_order.language.substructure.copy FirstOrder.Language.Substructure.copy
-/

end Substructure

variable {S : L.Substructure M}

/- warning: first_order.language.term.realize_mem -> FirstOrder.Language.Term.realize_mem is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {α : Type.{u4}} (t : FirstOrder.Language.Term.{u1, u2, u4} L α) (xs : α -> M), (forall (a : α), Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (xs a) S) -> (Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Term.realize.{u1, u2, u3, u4} L M _inst_1 α xs t) S)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] {S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1} {α : Type.{u1}} (t : FirstOrder.Language.Term.{u2, u3, u1} L α) (xs : α -> M), (forall (a : α), Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) (xs a) S) -> (Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) (FirstOrder.Language.Term.realize.{u2, u3, u4, u1} L M _inst_1 α xs t) S)
Case conversion may be inaccurate. Consider using '#align first_order.language.term.realize_mem FirstOrder.Language.Term.realize_memₓ'. -/
theorem Term.realize_mem {α : Type _} (t : L.term α) (xs : α → M) (h : ∀ a, xs a ∈ S) :
    t.realize xs ∈ S := by
  induction' t with a n f ts ih
  · exact h a
  · exact substructure.fun_mem _ _ _ ih
#align first_order.language.term.realize_mem FirstOrder.Language.Term.realize_mem

namespace Substructure

#print FirstOrder.Language.Substructure.coe_copy /-
@[simp]
theorem coe_copy {s : Set M} (hs : s = S) : (S.copy s hs : Set M) = s :=
  rfl
#align first_order.language.substructure.coe_copy FirstOrder.Language.Substructure.coe_copy
-/

#print FirstOrder.Language.Substructure.copy_eq /-
theorem copy_eq {s : Set M} (hs : s = S) : S.copy s hs = S :=
  SetLike.coe_injective hs
#align first_order.language.substructure.copy_eq FirstOrder.Language.Substructure.copy_eq
-/

/- warning: first_order.language.substructure.constants_mem -> FirstOrder.Language.Substructure.constants_mem is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} (c : FirstOrder.Language.Constants.{u1, u2} L), Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) (FirstOrder.Language.Constants.{u1, u2} L) M (HasLiftT.mk.{succ u1, succ u3} (FirstOrder.Language.Constants.{u1, u2} L) M (CoeTCₓ.coe.{succ u1, succ u3} (FirstOrder.Language.Constants.{u1, u2} L) M (FirstOrder.Language.hasCoeT.{u1, u2, u3} L M _inst_1))) c) S
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} (c : FirstOrder.Language.Constants.{u1, u2} L), Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.constantMap.{u1, u2, u3} L M _inst_1 c) S
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.constants_mem FirstOrder.Language.Substructure.constants_memₓ'. -/
theorem constants_mem (c : L.Constants) : ↑c ∈ S :=
  mem_carrier.2 (S.fun_mem c _ Fin.elim0)
#align first_order.language.substructure.constants_mem FirstOrder.Language.Substructure.constants_mem

/-- The substructure `M` of the structure `M`. -/
instance : Top (L.Substructure M) :=
  ⟨{  carrier := Set.univ
      fun_mem := fun n f x h => Set.mem_univ _ }⟩

instance : Inhabited (L.Substructure M) :=
  ⟨⊤⟩

#print FirstOrder.Language.Substructure.mem_top /-
@[simp]
theorem mem_top (x : M) : x ∈ (⊤ : L.Substructure M) :=
  Set.mem_univ x
#align first_order.language.substructure.mem_top FirstOrder.Language.Substructure.mem_top
-/

#print FirstOrder.Language.Substructure.coe_top /-
@[simp]
theorem coe_top : ((⊤ : L.Substructure M) : Set M) = Set.univ :=
  rfl
#align first_order.language.substructure.coe_top FirstOrder.Language.Substructure.coe_top
-/

/-- The inf of two substructures is their intersection. -/
instance : Inf (L.Substructure M) :=
  ⟨fun S₁ S₂ =>
    { carrier := S₁ ∩ S₂
      fun_mem := fun n f => (S₁.fun_mem f).inf (S₂.fun_mem f) }⟩

/- warning: first_order.language.substructure.coe_inf -> FirstOrder.Language.Substructure.coe_inf is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (p : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (p' : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), Eq.{succ u3} (Set.{u3} M) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (Inf.inf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInf.{u1, u2, u3} L M _inst_1) p p')) (Inter.inter.{u3} (Set.{u3} M) (Set.hasInter.{u3} M) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) p) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) p'))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (p : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (p' : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), Eq.{succ u3} (Set.{u3} M) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) (Inf.inf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInf.{u1, u2, u3} L M _inst_1) p p')) (Inter.inter.{u3} (Set.{u3} M) (Set.instInterSet.{u3} M) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) p) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) p'))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.coe_inf FirstOrder.Language.Substructure.coe_infₓ'. -/
@[simp]
theorem coe_inf (p p' : L.Substructure M) : ((p ⊓ p' : L.Substructure M) : Set M) = p ∩ p' :=
  rfl
#align first_order.language.substructure.coe_inf FirstOrder.Language.Substructure.coe_inf

#print FirstOrder.Language.Substructure.mem_inf /-
@[simp]
theorem mem_inf {p p' : L.Substructure M} {x : M} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=
  Iff.rfl
#align first_order.language.substructure.mem_inf FirstOrder.Language.Substructure.mem_inf
-/

instance : InfSet (L.Substructure M) :=
  ⟨fun s =>
    { carrier := ⋂ t ∈ s, ↑t
      fun_mem := fun n f =>
        ClosedUnder.sInf
          (by
            rintro _ ⟨t, rfl⟩
            by_cases h : t ∈ s
            · simpa [h] using t.fun_mem f
            · simp [h]) }⟩

#print FirstOrder.Language.Substructure.coe_sInf /-
@[simp, norm_cast]
theorem coe_sInf (S : Set (L.Substructure M)) :
    ((sInf S : L.Substructure M) : Set M) = ⋂ s ∈ S, ↑s :=
  rfl
#align first_order.language.substructure.coe_Inf FirstOrder.Language.Substructure.coe_sInf
-/

#print FirstOrder.Language.Substructure.mem_sInf /-
theorem mem_sInf {S : Set (L.Substructure M)} {x : M} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=
  Set.mem_iInter₂
#align first_order.language.substructure.mem_Inf FirstOrder.Language.Substructure.mem_sInf
-/

/- warning: first_order.language.substructure.mem_infi -> FirstOrder.Language.Substructure.mem_iInf is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {ι : Sort.{u4}} {S : ι -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)} {x : M}, Iff (Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (iInf.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u1, u2, u3} L M _inst_1) ι (fun (i : ι) => S i))) (forall (i : ι), Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (S i))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] {ι : Sort.{u1}} {S : ι -> (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1)} {x : M}, Iff (Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x (iInf.{u4, u1} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u2, u3, u4} L M _inst_1) ι (fun (i : ι) => S i))) (forall (i : ι), Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x (S i))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.mem_infi FirstOrder.Language.Substructure.mem_iInfₓ'. -/
theorem mem_iInf {ι : Sort _} {S : ι → L.Substructure M} {x : M} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i :=
  by simp only [iInf, mem_Inf, Set.forall_range_iff]
#align first_order.language.substructure.mem_infi FirstOrder.Language.Substructure.mem_iInf

/- warning: first_order.language.substructure.coe_infi -> FirstOrder.Language.Substructure.coe_iInf is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {ι : Sort.{u4}} {S : ι -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)}, Eq.{succ u3} (Set.{u3} M) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (iInf.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u1, u2, u3} L M _inst_1) ι (fun (i : ι) => S i))) (Set.iInter.{u3, u4} M ι (fun (i : ι) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (S i)))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] {ι : Sort.{u1}} {S : ι -> (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1)}, Eq.{succ u4} (Set.{u4} M) (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1) (iInf.{u4, u1} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u2, u3, u4} L M _inst_1) ι (fun (i : ι) => S i))) (Set.iInter.{u4, u1} M ι (fun (i : ι) => SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1) (S i)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.coe_infi FirstOrder.Language.Substructure.coe_iInfₓ'. -/
@[simp, norm_cast]
theorem coe_iInf {ι : Sort _} {S : ι → L.Substructure M} : (↑(⨅ i, S i) : Set M) = ⋂ i, S i := by
  simp only [iInf, coe_Inf, Set.biInter_range]
#align first_order.language.substructure.coe_infi FirstOrder.Language.Substructure.coe_iInf

/-- Substructures of a structure form a complete lattice. -/
instance : CompleteLattice (L.Substructure M) :=
  {
    completeLatticeOfInf (L.Substructure M) fun s =>
      IsGLB.of_image (fun S T => show (S : Set M) ≤ T ↔ S ≤ T from SetLike.coe_subset_coe)
        isGLB_biInf with
    le := (· ≤ ·)
    lt := (· < ·)
    top := ⊤
    le_top := fun S x hx => mem_top x
    inf := (· ⊓ ·)
    sInf := InfSet.sInf
    le_inf := fun a b c ha hb x hx => ⟨ha hx, hb hx⟩
    inf_le_left := fun a b x => And.left
    inf_le_right := fun a b x => And.right }

variable (L)

/- warning: first_order.language.substructure.closure -> FirstOrder.Language.Substructure.closure is a dubious translation:
lean 3 declaration is
  forall (L : FirstOrder.Language.{u1, u2}) {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))
but is expected to have type
  forall (L : FirstOrder.Language.{u1, u2}) {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.closure FirstOrder.Language.Substructure.closureₓ'. -/
/-- The `L.substructure` generated by a set. -/
def closure : LowerAdjoint (coe : L.Substructure M → Set M) :=
  ⟨fun s => sInf { S | s ⊆ S }, fun s S =>
    ⟨Set.Subset.trans fun x hx => mem_sInf.2 fun S hS => hS hx, fun h => sInf_le h⟩⟩
#align first_order.language.substructure.closure FirstOrder.Language.Substructure.closure

variable {L} {s : Set M}

#print FirstOrder.Language.Substructure.mem_closure /-
theorem mem_closure {x : M} : x ∈ closure L s ↔ ∀ S : L.Substructure M, s ⊆ S → x ∈ S :=
  mem_sInf
#align first_order.language.substructure.mem_closure FirstOrder.Language.Substructure.mem_closure
-/

#print FirstOrder.Language.Substructure.subset_closure /-
/-- The substructure generated by a set includes the set. -/
@[simp]
theorem subset_closure : s ⊆ closure L s :=
  (closure L).le_closure s
#align first_order.language.substructure.subset_closure FirstOrder.Language.Substructure.subset_closure
-/

#print FirstOrder.Language.Substructure.not_mem_of_not_mem_closure /-
theorem not_mem_of_not_mem_closure {P : M} (hP : P ∉ closure L s) : P ∉ s := fun h =>
  hP (subset_closure h)
#align first_order.language.substructure.not_mem_of_not_mem_closure FirstOrder.Language.Substructure.not_mem_of_not_mem_closure
-/

#print FirstOrder.Language.Substructure.closed /-
@[simp]
theorem closed (S : L.Substructure M) : (closure L).closed (S : Set M) :=
  congr rfl ((closure L).eq_of_le Set.Subset.rfl fun x xS => mem_closure.2 fun T hT => hT xS)
#align first_order.language.substructure.closed FirstOrder.Language.Substructure.closed
-/

open Set

/- warning: first_order.language.substructure.closure_le -> FirstOrder.Language.Substructure.closure_le is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {s : Set.{u3} M}, Iff (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s) S) (HasSubset.Subset.{u3} (Set.{u3} M) (Set.hasSubset.{u3} M) s ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {s : Set.{u3} M}, Iff (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s) S) (HasSubset.Subset.{u3} (Set.{u3} M) (Set.instHasSubsetSet.{u3} M) s (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) S))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.closure_le FirstOrder.Language.Substructure.closure_leₓ'. -/
/-- A substructure `S` includes `closure L s` if and only if it includes `s`. -/
@[simp]
theorem closure_le : closure L s ≤ S ↔ s ⊆ S :=
  (closure L).closure_le_closed_iff_le s S.closed
#align first_order.language.substructure.closure_le FirstOrder.Language.Substructure.closure_le

/- warning: first_order.language.substructure.closure_mono -> FirstOrder.Language.Substructure.closure_mono is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {{s : Set.{u3} M}} {{t : Set.{u3} M}}, (HasSubset.Subset.{u3} (Set.{u3} M) (Set.hasSubset.{u3} M) s t) -> (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) t))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {{s : Set.{u3} M}} {{t : Set.{u3} M}}, (HasSubset.Subset.{u3} (Set.{u3} M) (Set.instHasSubsetSet.{u3} M) s t) -> (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) t))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.closure_mono FirstOrder.Language.Substructure.closure_monoₓ'. -/
/-- Substructure closure of a set is monotone in its argument: if `s ⊆ t`,
then `closure L s ≤ closure L t`. -/
theorem closure_mono ⦃s t : Set M⦄ (h : s ⊆ t) : closure L s ≤ closure L t :=
  (closure L).Monotone h
#align first_order.language.substructure.closure_mono FirstOrder.Language.Substructure.closure_mono

/- warning: first_order.language.substructure.closure_eq_of_le -> FirstOrder.Language.Substructure.closure_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {s : Set.{u3} M}, (HasSubset.Subset.{u3} (Set.{u3} M) (Set.hasSubset.{u3} M) s ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S)) -> (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s)) -> (Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s) S)
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {s : Set.{u3} M}, (HasSubset.Subset.{u3} (Set.{u3} M) (Set.instHasSubsetSet.{u3} M) s (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) S)) -> (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) S (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s)) -> (Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s) S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.closure_eq_of_le FirstOrder.Language.Substructure.closure_eq_of_leₓ'. -/
theorem closure_eq_of_le (h₁ : s ⊆ S) (h₂ : S ≤ closure L s) : closure L s = S :=
  (closure L).eq_of_le h₁ h₂
#align first_order.language.substructure.closure_eq_of_le FirstOrder.Language.Substructure.closure_eq_of_le

#print FirstOrder.Language.Substructure.coe_closure_eq_range_term_realize /-
theorem coe_closure_eq_range_term_realize :
    (closure L s : Set M) = range (@Term.realize L _ _ _ (coe : s → M)) :=
  by
  let S : L.substructure M := ⟨range (term.realize coe), fun n f x hx => _⟩
  · change _ = (S : Set M)
    rw [← SetLike.ext'_iff]
    refine' closure_eq_of_le (fun x hx => ⟨var ⟨x, hx⟩, rfl⟩) (le_sInf fun S' hS' => _)
    · rintro _ ⟨t, rfl⟩
      exact t.realize_mem _ fun i => hS' i.2
  · simp only [mem_range] at *
    refine' ⟨func f fun i => Classical.choose (hx i), _⟩
    simp only [term.realize, fun i => Classical.choose_spec (hx i)]
#align first_order.language.substructure.coe_closure_eq_range_term_realize FirstOrder.Language.Substructure.coe_closure_eq_range_term_realize
-/

#print FirstOrder.Language.Substructure.small_closure /-
instance small_closure [Small.{u} s] : Small.{u} (closure L s) :=
  by
  rw [← SetLike.coe_sort_coe, substructure.coe_closure_eq_range_term_realize]
  exact small_range _
#align first_order.language.substructure.small_closure FirstOrder.Language.Substructure.small_closure
-/

#print FirstOrder.Language.Substructure.mem_closure_iff_exists_term /-
theorem mem_closure_iff_exists_term {x : M} :
    x ∈ closure L s ↔ ∃ t : L.term s, t.realize (coe : s → M) = x := by
  rw [← SetLike.mem_coe, coe_closure_eq_range_term_realize, mem_range]
#align first_order.language.substructure.mem_closure_iff_exists_term FirstOrder.Language.Substructure.mem_closure_iff_exists_term
-/

#print FirstOrder.Language.Substructure.lift_card_closure_le_card_term /-
theorem lift_card_closure_le_card_term : Cardinal.lift.{max u w} (#closure L s) ≤ (#L.term s) :=
  by
  rw [← SetLike.coe_sort_coe, coe_closure_eq_range_term_realize]
  rw [← Cardinal.lift_id'.{w, max u w} (#L.term s)]
  exact Cardinal.mk_range_le_lift
#align first_order.language.substructure.lift_card_closure_le_card_term FirstOrder.Language.Substructure.lift_card_closure_le_card_term
-/

/- warning: first_order.language.substructure.lift_card_closure_le -> FirstOrder.Language.Substructure.lift_card_closure_le is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {s : Set.{u3} M}, LE.le.{succ (max u3 u1)} Cardinal.{max u3 u1} Cardinal.hasLe.{max u3 u1} (Cardinal.lift.{u1, u3} (Cardinal.mk.{u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s)))) (LinearOrder.max.{succ (max u3 u1)} Cardinal.{max u3 u1} Cardinal.linearOrder.{max u3 u1} Cardinal.aleph0.{max u3 u1} (HAdd.hAdd.{succ (max u3 u1), succ (max u3 u1), succ (max u3 u1)} Cardinal.{max u3 u1} Cardinal.{max u3 u1} Cardinal.{max u3 u1} (instHAdd.{succ (max u3 u1)} Cardinal.{max u3 u1} Cardinal.hasAdd.{max u3 u1}) (Cardinal.lift.{u1, u3} (Cardinal.mk.{u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) s))) (Cardinal.lift.{u3, u1} (Cardinal.mk.{u1} (Sigma.{0, u1} Nat (fun (i : Nat) => FirstOrder.Language.Functions.{u1, u2} L i))))))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {s : Set.{u3} M}, LE.le.{max (succ u1) (succ u3)} Cardinal.{max u3 u1} Cardinal.instLECardinal.{max u1 u3} (Cardinal.lift.{u1, u3} (Cardinal.mk.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s))))) (Max.max.{succ (max u1 u3)} Cardinal.{max u1 u3} (CanonicallyLinearOrderedAddMonoid.toMax.{max (succ u1) (succ u3)} Cardinal.{max u1 u3} Cardinal.instCanonicallyLinearOrderedAddMonoidCardinal.{max u1 u3}) Cardinal.aleph0.{max u1 u3} (HAdd.hAdd.{max (succ u1) (succ u3), max (succ u1) (succ u3), max (succ u1) (succ u3)} Cardinal.{max u3 u1} Cardinal.{max u1 u3} Cardinal.{max u3 u1} (instHAdd.{max (succ u1) (succ u3)} Cardinal.{max u3 u1} Cardinal.instAddCardinal.{max u1 u3}) (Cardinal.lift.{u1, u3} (Cardinal.mk.{u3} (Set.Elem.{u3} M s))) (Cardinal.lift.{u3, u1} (Cardinal.mk.{u1} (Sigma.{0, u1} Nat (fun (i : Nat) => FirstOrder.Language.Functions.{u1, u2} L i))))))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.lift_card_closure_le FirstOrder.Language.Substructure.lift_card_closure_leₓ'. -/
theorem lift_card_closure_le :
    Cardinal.lift.{u, w} (#closure L s) ≤
      max ℵ₀ (Cardinal.lift.{u, w} (#s) + Cardinal.lift.{w, u} (#Σi, L.Functions i)) :=
  by
  rw [← lift_umax]
  refine' lift_card_closure_le_card_term.trans (term.card_le.trans _)
  rw [mk_sum, lift_umax]
#align first_order.language.substructure.lift_card_closure_le FirstOrder.Language.Substructure.lift_card_closure_le

variable (L)

#print Set.Countable.substructure_closure /-
theorem Set.Countable.substructure_closure [Countable (Σl, L.Functions l)] (h : s.Countable) :
    Countable.{w + 1} (closure L s) :=
  by
  haveI : Countable s := h.to_subtype
  rw [← mk_le_aleph_0_iff, ← lift_le_aleph_0]
  exact lift_card_closure_le_card_term.trans mk_le_aleph_0
#align set.countable.substructure_closure Set.Countable.substructure_closure
-/

variable {L} (S)

#print FirstOrder.Language.Substructure.closure_induction /-
/-- An induction principle for closure membership. If `p` holds for all elements of `s`, and
is preserved under function symbols, then `p` holds for all elements of the closure of `s`. -/
@[elab_as_elim]
theorem closure_induction {p : M → Prop} {x} (h : x ∈ closure L s) (Hs : ∀ x ∈ s, p x)
    (Hfun : ∀ {n : ℕ} (f : L.Functions n), ClosedUnder f (setOf p)) : p x :=
  (@closure_le L M _ ⟨setOf p, fun n => Hfun⟩ _).2 Hs h
#align first_order.language.substructure.closure_induction FirstOrder.Language.Substructure.closure_induction
-/

#print FirstOrder.Language.Substructure.dense_induction /-
/-- If `s` is a dense set in a structure `M`, `substructure.closure L s = ⊤`, then in order to prove
that some predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`, and verify
that `p` is preserved under function symbols. -/
@[elab_as_elim]
theorem dense_induction {p : M → Prop} (x : M) {s : Set M} (hs : closure L s = ⊤)
    (Hs : ∀ x ∈ s, p x) (Hfun : ∀ {n : ℕ} (f : L.Functions n), ClosedUnder f (setOf p)) : p x :=
  by
  have : ∀ x ∈ closure L s, p x := fun x hx => closure_induction hx Hs fun n => Hfun
  simpa [hs] using this x
#align first_order.language.substructure.dense_induction FirstOrder.Language.Substructure.dense_induction
-/

variable (L) (M)

/- warning: first_order.language.substructure.gi -> FirstOrder.Language.Substructure.gi is a dubious translation:
lean 3 declaration is
  forall (L : FirstOrder.Language.{u1, u2}) (M : Type.{u3}) [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], GaloisInsertion.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))
but is expected to have type
  forall (L : FirstOrder.Language.{u1, u2}) (M : Type.{u3}) [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], GaloisInsertion.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1)) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.gi FirstOrder.Language.Substructure.giₓ'. -/
/-- `closure` forms a Galois insertion with the coercion to set. -/
protected def gi : GaloisInsertion (@closure L M _) coe
    where
  choice s _ := closure L s
  gc := (closure L).gc
  le_l_u s := subset_closure
  choice_eq s h := rfl
#align first_order.language.substructure.gi FirstOrder.Language.Substructure.gi

variable {L} {M}

#print FirstOrder.Language.Substructure.closure_eq /-
/-- Closure of a substructure `S` equals `S`. -/
@[simp]
theorem closure_eq : closure L (S : Set M) = S :=
  (Substructure.gi L M).l_u_eq S
#align first_order.language.substructure.closure_eq FirstOrder.Language.Substructure.closure_eq
-/

/- warning: first_order.language.substructure.closure_empty -> FirstOrder.Language.Substructure.closure_empty is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (EmptyCollection.emptyCollection.{u3} (Set.{u3} M) (Set.hasEmptyc.{u3} M))) (Bot.bot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toHasBot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (EmptyCollection.emptyCollection.{u3} (Set.{u3} M) (Set.instEmptyCollectionSet.{u3} M))) (Bot.bot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toBot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.closure_empty FirstOrder.Language.Substructure.closure_emptyₓ'. -/
@[simp]
theorem closure_empty : closure L (∅ : Set M) = ⊥ :=
  (Substructure.gi L M).gc.l_bot
#align first_order.language.substructure.closure_empty FirstOrder.Language.Substructure.closure_empty

#print FirstOrder.Language.Substructure.closure_univ /-
@[simp]
theorem closure_univ : closure L (univ : Set M) = ⊤ :=
  @coe_top L M _ ▸ closure_eq ⊤
#align first_order.language.substructure.closure_univ FirstOrder.Language.Substructure.closure_univ
-/

/- warning: first_order.language.substructure.closure_union -> FirstOrder.Language.Substructure.closure_union is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (s : Set.{u3} M) (t : Set.{u3} M), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Union.union.{u3} (Set.{u3} M) (Set.hasUnion.{u3} M) s t)) (Sup.sup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SemilatticeSup.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Lattice.toSemilatticeSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) t))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (s : Set.{u3} M) (t : Set.{u3} M), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Union.union.{u3} (Set.{u3} M) (Set.instUnionSet.{u3} M) s t)) (Sup.sup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SemilatticeSup.toSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Lattice.toSemilatticeSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) t))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.closure_union FirstOrder.Language.Substructure.closure_unionₓ'. -/
theorem closure_union (s t : Set M) : closure L (s ∪ t) = closure L s ⊔ closure L t :=
  (Substructure.gi L M).gc.l_sup
#align first_order.language.substructure.closure_union FirstOrder.Language.Substructure.closure_union

/- warning: first_order.language.substructure.closure_Union -> FirstOrder.Language.Substructure.closure_unionᵢ is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {ι : Sort.{u4}} (s : ι -> (Set.{u3} M)), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Set.iUnion.{u3, u4} M ι (fun (i : ι) => s i))) (iSup.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))) ι (fun (i : ι) => coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (s i)))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] {ι : Sort.{u1}} (s : ι -> (Set.{u4} M)), Eq.{succ u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (LowerAdjoint.toFun.{u4, u4} (Set.{u4} M) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (Set.{u4} M) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} M) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} M) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} M) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} M) (Set.instCompleteBooleanAlgebraSet.{u4} M))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u2, u3, u4} L M _inst_1) (Set.iUnion.{u4, u1} M ι (fun (i : ι) => s i))) (iSup.{u4, u1} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (ConditionallyCompleteLattice.toSupSet.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))) ι (fun (i : ι) => LowerAdjoint.toFun.{u4, u4} (Set.{u4} M) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (Set.{u4} M) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} M) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} M) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} M) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} M) (Set.instCompleteBooleanAlgebraSet.{u4} M))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u2, u3, u4} L M _inst_1) (s i)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.closure_Union FirstOrder.Language.Substructure.closure_unionᵢₓ'. -/
theorem closure_unionᵢ {ι} (s : ι → Set M) : closure L (⋃ i, s i) = ⨆ i, closure L (s i) :=
  (Substructure.gi L M).gc.l_iSup
#align first_order.language.substructure.closure_Union FirstOrder.Language.Substructure.closure_unionᵢ

/- warning: first_order.language.substructure.small_bot -> FirstOrder.Language.Substructure.small_bot is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], Small.{u1, u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Bot.bot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toHasBot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], Small.{u1, u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (Bot.bot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toBot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.small_bot FirstOrder.Language.Substructure.small_botₓ'. -/
instance small_bot : Small.{u} (⊥ : L.Substructure M) :=
  by
  rw [← closure_empty]
  exact substructure.small_closure
#align first_order.language.substructure.small_bot FirstOrder.Language.Substructure.small_bot

/-!
### `comap` and `map`
-/


#print FirstOrder.Language.Substructure.comap /-
/-- The preimage of a substructure along a homomorphism is a substructure. -/
@[simps]
def comap (φ : M →[L] N) (S : L.Substructure N) : L.Substructure M
    where
  carrier := φ ⁻¹' S
  fun_mem n f x hx := by
    rw [mem_preimage, φ.map_fun]
    exact S.fun_mem f (φ ∘ x) hx
#align first_order.language.substructure.comap FirstOrder.Language.Substructure.comap
-/

/- warning: first_order.language.substructure.mem_comap -> FirstOrder.Language.Substructure.mem_comap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {S : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2} {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {x : M}, Iff (Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S)) (Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f x) S)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {S : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2} {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {x : M}, Iff (Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S)) (Membership.mem.{u1, u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) x) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f x) S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.mem_comap FirstOrder.Language.Substructure.mem_comapₓ'. -/
@[simp]
theorem mem_comap {S : L.Substructure N} {f : M →[L] N} {x : M} : x ∈ S.comap f ↔ f x ∈ S :=
  Iff.rfl
#align first_order.language.substructure.mem_comap FirstOrder.Language.Substructure.mem_comap

/- warning: first_order.language.substructure.comap_comap -> FirstOrder.Language.Substructure.comap_comap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u5}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] [_inst_3 : FirstOrder.Language.Structure.{u1, u2, u5} L P] (S : FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (g : FirstOrder.Language.Hom.{u1, u2, u4, u5} L N P _inst_2 _inst_3) (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u1, u2, u4, u5} L N P _inst_2 _inst_3 g S)) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u5} L M P _inst_1 _inst_3 (FirstOrder.Language.Hom.comp.{u1, u2, u3, u4, u5} L M N _inst_1 _inst_2 P _inst_3 g f) S)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u1}} {P : Type.{u2}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u1} L N] [_inst_3 : FirstOrder.Language.Structure.{u3, u4, u2} L P] (S : FirstOrder.Language.Substructure.{u3, u4, u2} L P _inst_3) (g : FirstOrder.Language.Hom.{u3, u4, u1, u2} L N P _inst_2 _inst_3) (f : FirstOrder.Language.Hom.{u3, u4, u5, u1} L M N _inst_1 _inst_2), Eq.{succ u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u3, u4, u5, u1} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u3, u4, u1, u2} L N P _inst_2 _inst_3 g S)) (FirstOrder.Language.Substructure.comap.{u3, u4, u5, u2} L M P _inst_1 _inst_3 (FirstOrder.Language.Hom.comp.{u3, u4, u5, u1, u2} L M N _inst_1 _inst_2 P _inst_3 g f) S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_comap FirstOrder.Language.Substructure.comap_comapₓ'. -/
theorem comap_comap (S : L.Substructure P) (g : N →[L] P) (f : M →[L] N) :
    (S.comap g).comap f = S.comap (g.comp f) :=
  rfl
#align first_order.language.substructure.comap_comap FirstOrder.Language.Substructure.comap_comap

/- warning: first_order.language.substructure.comap_id -> FirstOrder.Language.Substructure.comap_id is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {P : Type.{u3}} [_inst_3 : FirstOrder.Language.Structure.{u1, u2, u3} L P] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L P _inst_3), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L P _inst_3) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u3} L P P _inst_3 _inst_3 (FirstOrder.Language.Hom.id.{u1, u2, u3} L P _inst_3) S) S
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {P : Type.{u1}} [_inst_3 : FirstOrder.Language.Structure.{u2, u3, u1} L P] (S : FirstOrder.Language.Substructure.{u2, u3, u1} L P _inst_3), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L P _inst_3) (FirstOrder.Language.Substructure.comap.{u2, u3, u1, u1} L P P _inst_3 _inst_3 (FirstOrder.Language.Hom.id.{u2, u3, u1} L P _inst_3) S) S
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_id FirstOrder.Language.Substructure.comap_idₓ'. -/
@[simp]
theorem comap_id (S : L.Substructure P) : S.comap (Hom.id _ _) = S :=
  ext (by simp)
#align first_order.language.substructure.comap_id FirstOrder.Language.Substructure.comap_id

#print FirstOrder.Language.Substructure.map /-
/-- The image of a substructure along a homomorphism is a substructure. -/
@[simps]
def map (φ : M →[L] N) (S : L.Substructure M) : L.Substructure N
    where
  carrier := φ '' S
  fun_mem n f x hx :=
    (mem_image _ _ _).1
      ⟨funMap f fun i => Classical.choose (hx i),
        S.fun_mem f _ fun i => (Classical.choose_spec (hx i)).1,
        by
        simp only [hom.map_fun, SetLike.mem_coe]
        exact congr rfl (funext fun i => (Classical.choose_spec (hx i)).2)⟩
#align first_order.language.substructure.map FirstOrder.Language.Substructure.map
-/

/- warning: first_order.language.substructure.mem_map -> FirstOrder.Language.Substructure.mem_map is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {y : N}, Iff (Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) y (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S)) (Exists.{succ u3} M (fun (x : M) => Exists.{0} (Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S) (fun (H : Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S) => Eq.{succ u4} N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f x) y)))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1} {y : N}, Iff (Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) y (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S)) (Exists.{succ u4} M (fun (x : M) => And (Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x S) (Eq.{succ u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) x) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (a : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) a) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f x) y)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.mem_map FirstOrder.Language.Substructure.mem_mapₓ'. -/
@[simp]
theorem mem_map {f : M →[L] N} {S : L.Substructure M} {y : N} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y :=
  mem_image_iff_bex
#align first_order.language.substructure.mem_map FirstOrder.Language.Substructure.mem_map

/- warning: first_order.language.substructure.mem_map_of_mem -> FirstOrder.Language.Substructure.mem_map_of_mem is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {x : M}, (Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S) -> (Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f x) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) {S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1} {x : M}, (Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x S) -> (Membership.mem.{u1, u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) x) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f x) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.mem_map_of_mem FirstOrder.Language.Substructure.mem_map_of_memₓ'. -/
theorem mem_map_of_mem (f : M →[L] N) {S : L.Substructure M} {x : M} (hx : x ∈ S) : f x ∈ S.map f :=
  mem_image_of_mem f hx
#align first_order.language.substructure.mem_map_of_mem FirstOrder.Language.Substructure.mem_map_of_mem

/- warning: first_order.language.substructure.apply_coe_mem_map -> FirstOrder.Language.Substructure.apply_coe_mem_map is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (x : coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S), Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S))))) x)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (x : Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x S)), Membership.mem.{u1, u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) (Subtype.val.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (Set.{u4} M) (Set.instMembershipSet.{u4} M) x (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1) S)) x)) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f (Subtype.val.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (Set.{u4} M) (Set.instMembershipSet.{u4} M) x (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1) S)) x)) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.apply_coe_mem_map FirstOrder.Language.Substructure.apply_coe_mem_mapₓ'. -/
theorem apply_coe_mem_map (f : M →[L] N) (S : L.Substructure M) (x : S) : f x ∈ S.map f :=
  mem_map_of_mem f x.Prop
#align first_order.language.substructure.apply_coe_mem_map FirstOrder.Language.Substructure.apply_coe_mem_map

/- warning: first_order.language.substructure.map_map -> FirstOrder.Language.Substructure.map_map is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u5}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] [_inst_3 : FirstOrder.Language.Structure.{u1, u2, u5} L P] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (g : FirstOrder.Language.Hom.{u1, u2, u4, u5} L N P _inst_2 _inst_3) (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (FirstOrder.Language.Substructure.map.{u1, u2, u4, u5} L N P _inst_2 _inst_3 g (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u5} L M P _inst_1 _inst_3 (FirstOrder.Language.Hom.comp.{u1, u2, u3, u4, u5} L M N _inst_1 _inst_2 P _inst_3 g f) S)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u2}} {P : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u2} L N] [_inst_3 : FirstOrder.Language.Structure.{u3, u4, u1} L P] (S : FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (g : FirstOrder.Language.Hom.{u3, u4, u2, u1} L N P _inst_2 _inst_3) (f : FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2), Eq.{succ u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (FirstOrder.Language.Substructure.map.{u3, u4, u2, u1} L N P _inst_2 _inst_3 g (FirstOrder.Language.Substructure.map.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f S)) (FirstOrder.Language.Substructure.map.{u3, u4, u5, u1} L M P _inst_1 _inst_3 (FirstOrder.Language.Hom.comp.{u3, u4, u5, u2, u1} L M N _inst_1 _inst_2 P _inst_3 g f) S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_map FirstOrder.Language.Substructure.map_mapₓ'. -/
theorem map_map (g : N →[L] P) (f : M →[L] N) : (S.map f).map g = S.map (g.comp f) :=
  SetLike.coe_injective <| image_image _ _ _
#align first_order.language.substructure.map_map FirstOrder.Language.Substructure.map_map

/- warning: first_order.language.substructure.map_le_iff_le_comap -> FirstOrder.Language.Substructure.map_le_iff_le_comap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {T : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2}, Iff (LE.le.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) T) (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1} {T : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2}, Iff (LE.le.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Preorder.toLE.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) T) (LE.le.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))))) S (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_le_iff_le_comap FirstOrder.Language.Substructure.map_le_iff_le_comapₓ'. -/
theorem map_le_iff_le_comap {f : M →[L] N} {S : L.Substructure M} {T : L.Substructure N} :
    S.map f ≤ T ↔ S ≤ T.comap f :=
  image_subset_iff
#align first_order.language.substructure.map_le_iff_le_comap FirstOrder.Language.Substructure.map_le_iff_le_comap

/- warning: first_order.language.substructure.gc_map_comap -> FirstOrder.Language.Substructure.gc_map_comap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), GaloisConnection.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2), GaloisConnection.{u4, u1} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.gc_map_comap FirstOrder.Language.Substructure.gc_map_comapₓ'. -/
theorem gc_map_comap (f : M →[L] N) : GaloisConnection (map f) (comap f) := fun S T =>
  map_le_iff_le_comap
#align first_order.language.substructure.gc_map_comap FirstOrder.Language.Substructure.gc_map_comap

/- warning: first_order.language.substructure.map_le_of_le_comap -> FirstOrder.Language.Substructure.map_le_of_le_comap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) {T : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2} {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T)) -> (LE.le.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) T)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) {T : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2} {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (LE.le.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))))) S (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T)) -> (LE.le.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Preorder.toLE.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) T)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_le_of_le_comap FirstOrder.Language.Substructure.map_le_of_le_comapₓ'. -/
theorem map_le_of_le_comap {T : L.Substructure N} {f : M →[L] N} : S ≤ T.comap f → S.map f ≤ T :=
  (gc_map_comap f).l_le
#align first_order.language.substructure.map_le_of_le_comap FirstOrder.Language.Substructure.map_le_of_le_comap

/- warning: first_order.language.substructure.le_comap_of_map_le -> FirstOrder.Language.Substructure.le_comap_of_map_le is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) {T : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2} {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (LE.le.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) T) -> (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) {T : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2} {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (LE.le.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Preorder.toLE.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) T) -> (LE.le.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))))) S (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.le_comap_of_map_le FirstOrder.Language.Substructure.le_comap_of_map_leₓ'. -/
theorem le_comap_of_map_le {T : L.Substructure N} {f : M →[L] N} : S.map f ≤ T → S ≤ T.comap f :=
  (gc_map_comap f).le_u
#align first_order.language.substructure.le_comap_of_map_le FirstOrder.Language.Substructure.le_comap_of_map_le

/- warning: first_order.language.substructure.le_comap_map -> FirstOrder.Language.Substructure.le_comap_map is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, LE.le.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))))) S (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.le_comap_map FirstOrder.Language.Substructure.le_comap_mapₓ'. -/
theorem le_comap_map {f : M →[L] N} : S ≤ (S.map f).comap f :=
  (gc_map_comap f).le_u_l _
#align first_order.language.substructure.le_comap_map FirstOrder.Language.Substructure.le_comap_map

/- warning: first_order.language.substructure.map_comap_le -> FirstOrder.Language.Substructure.map_comap_le is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {S : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2} {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, LE.le.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S)) S
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {S : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2} {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, LE.le.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Preorder.toLE.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S)) S
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_comap_le FirstOrder.Language.Substructure.map_comap_leₓ'. -/
theorem map_comap_le {S : L.Substructure N} {f : M →[L] N} : (S.comap f).map f ≤ S :=
  (gc_map_comap f).l_u_le _
#align first_order.language.substructure.map_comap_le FirstOrder.Language.Substructure.map_comap_le

/- warning: first_order.language.substructure.monotone_map -> FirstOrder.Language.Substructure.monotone_map is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, Monotone.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, Monotone.{u4, u1} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.monotone_map FirstOrder.Language.Substructure.monotone_mapₓ'. -/
theorem monotone_map {f : M →[L] N} : Monotone (map f) :=
  (gc_map_comap f).monotone_l
#align first_order.language.substructure.monotone_map FirstOrder.Language.Substructure.monotone_map

/- warning: first_order.language.substructure.monotone_comap -> FirstOrder.Language.Substructure.monotone_comap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, Monotone.{u4, u3} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, Monotone.{u1, u4} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2)))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.monotone_comap FirstOrder.Language.Substructure.monotone_comapₓ'. -/
theorem monotone_comap {f : M →[L] N} : Monotone (comap f) :=
  (gc_map_comap f).monotone_u
#align first_order.language.substructure.monotone_comap FirstOrder.Language.Substructure.monotone_comap

/- warning: first_order.language.substructure.map_comap_map -> FirstOrder.Language.Substructure.map_comap_map is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_comap_map FirstOrder.Language.Substructure.map_comap_mapₓ'. -/
@[simp]
theorem map_comap_map {f : M →[L] N} : ((S.map f).comap f).map f = S.map f :=
  (gc_map_comap f).l_u_l_eq_l _
#align first_order.language.substructure.map_comap_map FirstOrder.Language.Substructure.map_comap_map

/- warning: first_order.language.substructure.comap_map_comap -> FirstOrder.Language.Substructure.comap_map_comap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {S : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2} {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S))) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {S : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2} {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, Eq.{succ u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S))) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_map_comap FirstOrder.Language.Substructure.comap_map_comapₓ'. -/
@[simp]
theorem comap_map_comap {S : L.Substructure N} {f : M →[L] N} :
    ((S.comap f).map f).comap f = S.comap f :=
  (gc_map_comap f).u_l_u_eq_u _
#align first_order.language.substructure.comap_map_comap FirstOrder.Language.Substructure.comap_map_comap

/- warning: first_order.language.substructure.map_sup -> FirstOrder.Language.Substructure.map_sup is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (T : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (Sup.sup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SemilatticeSup.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Lattice.toSemilatticeSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) S T)) (Sup.sup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SemilatticeSup.toHasSup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Lattice.toSemilatticeSup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (ConditionallyCompleteLattice.toLattice.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u4} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (T : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (Sup.sup.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SemilatticeSup.toSup.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (Lattice.toSemilatticeSup.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))))) S T)) (Sup.sup.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SemilatticeSup.toSup.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Lattice.toSemilatticeSup.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (ConditionallyCompleteLattice.toLattice.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_sup FirstOrder.Language.Substructure.map_supₓ'. -/
theorem map_sup (S T : L.Substructure M) (f : M →[L] N) : (S ⊔ T).map f = S.map f ⊔ T.map f :=
  (gc_map_comap f).l_sup
#align first_order.language.substructure.map_sup FirstOrder.Language.Substructure.map_sup

/- warning: first_order.language.substructure.map_supr -> FirstOrder.Language.Substructure.map_iSup is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {ι : Sort.{u5}} (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (s : ι -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (iSup.{u3, u5} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))) ι s)) (iSup.{u4, u5} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (ConditionallyCompleteLattice.toHasSup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u4} L N _inst_2))) ι (fun (i : ι) => FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (s i)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u1} L N] {ι : Sort.{u2}} (f : FirstOrder.Language.Hom.{u3, u4, u5, u1} L M N _inst_1 _inst_2) (s : ι -> (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1)), Eq.{succ u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u3, u4, u5, u1} L M N _inst_1 _inst_2 f (iSup.{u5, u2} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (ConditionallyCompleteLattice.toSupSet.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1))) ι s)) (iSup.{u1, u2} (FirstOrder.Language.Substructure.{u3, u4, u1} L N _inst_2) (ConditionallyCompleteLattice.toSupSet.{u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u1} L N _inst_2))) ι (fun (i : ι) => FirstOrder.Language.Substructure.map.{u3, u4, u5, u1} L M N _inst_1 _inst_2 f (s i)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_supr FirstOrder.Language.Substructure.map_iSupₓ'. -/
theorem map_iSup {ι : Sort _} (f : M →[L] N) (s : ι → L.Substructure M) :
    (iSup s).map f = ⨆ i, (s i).map f :=
  (gc_map_comap f).l_iSup
#align first_order.language.substructure.map_supr FirstOrder.Language.Substructure.map_iSup

/- warning: first_order.language.substructure.comap_inf -> FirstOrder.Language.Substructure.comap_inf is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (S : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (T : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (Inf.inf.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instInf.{u1, u2, u4} L N _inst_2) S T)) (Inf.inf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInf.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (S : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (T : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (Inf.inf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instInf.{u2, u3, u1} L N _inst_2) S T)) (Inf.inf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instInf.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_inf FirstOrder.Language.Substructure.comap_infₓ'. -/
theorem comap_inf (S T : L.Substructure N) (f : M →[L] N) :
    (S ⊓ T).comap f = S.comap f ⊓ T.comap f :=
  (gc_map_comap f).u_inf
#align first_order.language.substructure.comap_inf FirstOrder.Language.Substructure.comap_inf

/- warning: first_order.language.substructure.comap_infi -> FirstOrder.Language.Substructure.comap_iInf is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {ι : Sort.{u5}} (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (s : ι -> (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2)), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (iInf.{u4, u5} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instInfSet.{u1, u2, u4} L N _inst_2) ι s)) (iInf.{u3, u5} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u1, u2, u3} L M _inst_1) ι (fun (i : ι) => FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (s i)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u1} L N] {ι : Sort.{u2}} (f : FirstOrder.Language.Hom.{u3, u4, u5, u1} L M N _inst_1 _inst_2) (s : ι -> (FirstOrder.Language.Substructure.{u3, u4, u1} L N _inst_2)), Eq.{succ u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u3, u4, u5, u1} L M N _inst_1 _inst_2 f (iInf.{u1, u2} (FirstOrder.Language.Substructure.{u3, u4, u1} L N _inst_2) (FirstOrder.Language.Substructure.instInfSet.{u3, u4, u1} L N _inst_2) ι s)) (iInf.{u5, u2} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u3, u4, u5} L M _inst_1) ι (fun (i : ι) => FirstOrder.Language.Substructure.comap.{u3, u4, u5, u1} L M N _inst_1 _inst_2 f (s i)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_infi FirstOrder.Language.Substructure.comap_iInfₓ'. -/
theorem comap_iInf {ι : Sort _} (f : M →[L] N) (s : ι → L.Substructure N) :
    (iInf s).comap f = ⨅ i, (s i).comap f :=
  (gc_map_comap f).u_iInf
#align first_order.language.substructure.comap_infi FirstOrder.Language.Substructure.comap_iInf

/- warning: first_order.language.substructure.map_bot -> FirstOrder.Language.Substructure.map_bot is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (Bot.bot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toHasBot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (Bot.bot.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteLattice.toHasBot.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u4} L N _inst_2)))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (Bot.bot.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toBot.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (Bot.bot.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toBot.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_bot FirstOrder.Language.Substructure.map_botₓ'. -/
@[simp]
theorem map_bot (f : M →[L] N) : (⊥ : L.Substructure M).map f = ⊥ :=
  (gc_map_comap f).l_bot
#align first_order.language.substructure.map_bot FirstOrder.Language.Substructure.map_bot

/- warning: first_order.language.substructure.comap_top -> FirstOrder.Language.Substructure.comap_top is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (Top.top.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instTop.{u1, u2, u4} L N _inst_2))) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (Top.top.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instTop.{u2, u3, u1} L N _inst_2))) (Top.top.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u2, u3, u4} L M _inst_1))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_top FirstOrder.Language.Substructure.comap_topₓ'. -/
@[simp]
theorem comap_top (f : M →[L] N) : (⊤ : L.Substructure N).comap f = ⊤ :=
  (gc_map_comap f).u_top
#align first_order.language.substructure.comap_top FirstOrder.Language.Substructure.comap_top

#print FirstOrder.Language.Substructure.map_id /-
@[simp]
theorem map_id (S : L.Substructure M) : S.map (Hom.id L M) = S :=
  ext fun x => ⟨fun ⟨_, h, rfl⟩ => h, fun h => ⟨_, h, rfl⟩⟩
#align first_order.language.substructure.map_id FirstOrder.Language.Substructure.map_id
-/

/- warning: first_order.language.substructure.map_closure -> FirstOrder.Language.Substructure.map_closure is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (s : Set.{u3} M), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s)) (coeFn.{succ u4, succ u4} (LowerAdjoint.{u4, u4} (Set.{u4} N) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (Set.{u4} N) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} N) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} N) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} N) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} N) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} N) (Set.completeBooleanAlgebra.{u4} N))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (HasLiftT.mk.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (CoeTCₓ.coe.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (SetLike.Set.hasCoeT.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))))) (fun (_x : LowerAdjoint.{u4, u4} (Set.{u4} N) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (Set.{u4} N) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} N) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} N) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} N) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} N) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} N) (Set.completeBooleanAlgebra.{u4} N))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (HasLiftT.mk.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (CoeTCₓ.coe.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (SetLike.Set.hasCoeT.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))))) => (Set.{u4} N) -> (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2)) (LowerAdjoint.hasCoeToFun.{u4, u4} (Set.{u4} N) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (Set.{u4} N) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} N) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} N) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} N) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} N) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} N) (Set.completeBooleanAlgebra.{u4} N))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (HasLiftT.mk.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (CoeTCₓ.coe.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (SetLike.Set.hasCoeT.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u4} L N _inst_2) (Set.image.{u3, u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) s))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (s : Set.{u4} M), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (LowerAdjoint.toFun.{u4, u4} (Set.{u4} M) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (Set.{u4} M) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} M) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} M) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} M) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} M) (Set.instCompleteBooleanAlgebraSet.{u4} M))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u2, u3, u4} L M _inst_1) s)) (LowerAdjoint.toFun.{u1, u1} (Set.{u1} N) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (Set.{u1} N) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} N) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} N) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} N) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} N) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} N) (Set.instCompleteBooleanAlgebraSet.{u1} N))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) (FirstOrder.Language.Substructure.closure.{u2, u3, u1} L N _inst_2) (Set.image.{u4, u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f) s))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_closure FirstOrder.Language.Substructure.map_closureₓ'. -/
theorem map_closure (f : M →[L] N) (s : Set M) : (closure L s).map f = closure L (f '' s) :=
  Eq.symm <|
    closure_eq_of_le (Set.image_subset f subset_closure) <|
      map_le_iff_le_comap.2 <| closure_le.2 fun x hx => subset_closure ⟨x, hx, rfl⟩
#align first_order.language.substructure.map_closure FirstOrder.Language.Substructure.map_closure

/- warning: first_order.language.substructure.closure_image -> FirstOrder.Language.Substructure.closure_image is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {s : Set.{u3} M} (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (coeFn.{succ u4, succ u4} (LowerAdjoint.{u4, u4} (Set.{u4} N) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (Set.{u4} N) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} N) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} N) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} N) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} N) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} N) (Set.completeBooleanAlgebra.{u4} N))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (HasLiftT.mk.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (CoeTCₓ.coe.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (SetLike.Set.hasCoeT.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))))) (fun (_x : LowerAdjoint.{u4, u4} (Set.{u4} N) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (Set.{u4} N) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} N) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} N) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} N) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} N) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} N) (Set.completeBooleanAlgebra.{u4} N))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (HasLiftT.mk.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (CoeTCₓ.coe.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (SetLike.Set.hasCoeT.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))))) => (Set.{u4} N) -> (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2)) (LowerAdjoint.hasCoeToFun.{u4, u4} (Set.{u4} N) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (Set.{u4} N) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} N) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} N) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} N) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} N) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} N) (Set.completeBooleanAlgebra.{u4} N))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (HasLiftT.mk.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (CoeTCₓ.coe.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (SetLike.Set.hasCoeT.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u4} L N _inst_2) (Set.image.{u3, u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) s)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {s : Set.{u4} M} (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (LowerAdjoint.toFun.{u1, u1} (Set.{u1} N) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (Set.{u1} N) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} N) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} N) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} N) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} N) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} N) (Set.instCompleteBooleanAlgebraSet.{u1} N))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) (FirstOrder.Language.Substructure.closure.{u2, u3, u1} L N _inst_2) (Set.image.{u4, u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f) s)) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (LowerAdjoint.toFun.{u4, u4} (Set.{u4} M) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (Set.{u4} M) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} M) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} M) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} M) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} M) (Set.instCompleteBooleanAlgebraSet.{u4} M))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u2, u3, u4} L M _inst_1) s))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.closure_image FirstOrder.Language.Substructure.closure_imageₓ'. -/
@[simp]
theorem closure_image (f : M →[L] N) : closure L (f '' s) = map f (closure L s) :=
  (map_closure f s).symm
#align first_order.language.substructure.closure_image FirstOrder.Language.Substructure.closure_image

section GaloisCoinsertion

variable {ι : Type _} {f : M →[L] N} (hf : Function.Injective f)

include hf

/- warning: first_order.language.substructure.gci_map_comap -> FirstOrder.Language.Substructure.gciMapComap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (GaloisCoinsertion.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (GaloisCoinsertion.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.gci_map_comap FirstOrder.Language.Substructure.gciMapComapₓ'. -/
/-- `map f` and `comap f` form a `galois_coinsertion` when `f` is injective. -/
def gciMapComap : GaloisCoinsertion (map f) (comap f) :=
  (gc_map_comap f).toGaloisCoinsertion fun S x => by simp [mem_comap, mem_map, hf.eq_iff]
#align first_order.language.substructure.gci_map_comap FirstOrder.Language.Substructure.gciMapComap

/- warning: first_order.language.substructure.comap_map_eq_of_injective -> FirstOrder.Language.Substructure.comap_map_eq_of_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S)) S)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Injective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1), Eq.{succ u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S)) S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_map_eq_of_injective FirstOrder.Language.Substructure.comap_map_eq_of_injectiveₓ'. -/
theorem comap_map_eq_of_injective (S : L.Substructure M) : (S.map f).comap f = S :=
  (gciMapComap hf).u_l_eq _
#align first_order.language.substructure.comap_map_eq_of_injective FirstOrder.Language.Substructure.comap_map_eq_of_injective

/- warning: first_order.language.substructure.comap_surjective_of_injective -> FirstOrder.Language.Substructure.comap_surjective_of_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (Function.Surjective.{succ u4, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Injective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (Function.Surjective.{succ u1, succ u4} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_surjective_of_injective FirstOrder.Language.Substructure.comap_surjective_of_injectiveₓ'. -/
theorem comap_surjective_of_injective : Function.Surjective (comap f) :=
  (gciMapComap hf).u_surjective
#align first_order.language.substructure.comap_surjective_of_injective FirstOrder.Language.Substructure.comap_surjective_of_injective

/- warning: first_order.language.substructure.map_injective_of_injective -> FirstOrder.Language.Substructure.map_injective_of_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (Function.Injective.{succ u3, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Injective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (Function.Injective.{succ u4, succ u1} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_injective_of_injective FirstOrder.Language.Substructure.map_injective_of_injectiveₓ'. -/
theorem map_injective_of_injective : Function.Injective (map f) :=
  (gciMapComap hf).l_injective
#align first_order.language.substructure.map_injective_of_injective FirstOrder.Language.Substructure.map_injective_of_injective

/- warning: first_order.language.substructure.comap_inf_map_of_injective -> FirstOrder.Language.Substructure.comap_inf_map_of_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (T : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (Inf.inf.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instInf.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T))) (Inf.inf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInf.{u1, u2, u3} L M _inst_1) S T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Injective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (T : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1), Eq.{succ u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (Inf.inf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instInf.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T))) (Inf.inf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instInf.{u2, u3, u4} L M _inst_1) S T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_inf_map_of_injective FirstOrder.Language.Substructure.comap_inf_map_of_injectiveₓ'. -/
theorem comap_inf_map_of_injective (S T : L.Substructure M) : (S.map f ⊓ T.map f).comap f = S ⊓ T :=
  (gciMapComap hf).u_inf_l _ _
#align first_order.language.substructure.comap_inf_map_of_injective FirstOrder.Language.Substructure.comap_inf_map_of_injective

/- warning: first_order.language.substructure.comap_infi_map_of_injective -> FirstOrder.Language.Substructure.comap_iInf_map_of_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {ι : Type.{u5}} {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : ι -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (iInf.{u4, succ u5} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instInfSet.{u1, u2, u4} L N _inst_2) ι (fun (i : ι) => FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (S i)))) (iInf.{u3, succ u5} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u1, u2, u3} L M _inst_1) ι S))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u2}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u2} L N] {ι : Type.{u1}} {f : FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2}, (Function.Injective.{succ u5, succ u2} M N (FunLike.coe.{max (succ u5) (succ u2), succ u5, succ u2} (FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u3, u4, u5, u2} L M N _inst_1 _inst_2) f)) -> (forall (S : ι -> (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1)), Eq.{succ u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f (iInf.{u2, succ u1} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (FirstOrder.Language.Substructure.instInfSet.{u3, u4, u2} L N _inst_2) ι (fun (i : ι) => FirstOrder.Language.Substructure.map.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f (S i)))) (iInf.{u5, succ u1} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u3, u4, u5} L M _inst_1) ι S))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_infi_map_of_injective FirstOrder.Language.Substructure.comap_iInf_map_of_injectiveₓ'. -/
theorem comap_iInf_map_of_injective (S : ι → L.Substructure M) :
    (⨅ i, (S i).map f).comap f = iInf S :=
  (gciMapComap hf).u_iInf_l _
#align first_order.language.substructure.comap_infi_map_of_injective FirstOrder.Language.Substructure.comap_iInf_map_of_injective

/- warning: first_order.language.substructure.comap_sup_map_of_injective -> FirstOrder.Language.Substructure.comap_sup_map_of_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (T : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (Sup.sup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SemilatticeSup.toHasSup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Lattice.toSemilatticeSup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (ConditionallyCompleteLattice.toLattice.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u4} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T))) (Sup.sup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SemilatticeSup.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Lattice.toSemilatticeSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) S T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Injective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (T : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1), Eq.{succ u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (Sup.sup.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SemilatticeSup.toSup.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Lattice.toSemilatticeSup.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (ConditionallyCompleteLattice.toLattice.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T))) (Sup.sup.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SemilatticeSup.toSup.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (Lattice.toSemilatticeSup.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))))) S T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_sup_map_of_injective FirstOrder.Language.Substructure.comap_sup_map_of_injectiveₓ'. -/
theorem comap_sup_map_of_injective (S T : L.Substructure M) : (S.map f ⊔ T.map f).comap f = S ⊔ T :=
  (gciMapComap hf).u_sup_l _ _
#align first_order.language.substructure.comap_sup_map_of_injective FirstOrder.Language.Substructure.comap_sup_map_of_injective

/- warning: first_order.language.substructure.comap_supr_map_of_injective -> FirstOrder.Language.Substructure.comap_iSup_map_of_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {ι : Type.{u5}} {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : ι -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (iSup.{u4, succ u5} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (ConditionallyCompleteLattice.toHasSup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u4} L N _inst_2))) ι (fun (i : ι) => FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (S i)))) (iSup.{u3, succ u5} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))) ι S))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u2}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u2} L N] {ι : Type.{u1}} {f : FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2}, (Function.Injective.{succ u5, succ u2} M N (FunLike.coe.{max (succ u5) (succ u2), succ u5, succ u2} (FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u3, u4, u5, u2} L M N _inst_1 _inst_2) f)) -> (forall (S : ι -> (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1)), Eq.{succ u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f (iSup.{u2, succ u1} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (ConditionallyCompleteLattice.toSupSet.{u2} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u2} L N _inst_2))) ι (fun (i : ι) => FirstOrder.Language.Substructure.map.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f (S i)))) (iSup.{u5, succ u1} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (ConditionallyCompleteLattice.toSupSet.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1))) ι S))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_supr_map_of_injective FirstOrder.Language.Substructure.comap_iSup_map_of_injectiveₓ'. -/
theorem comap_iSup_map_of_injective (S : ι → L.Substructure M) :
    (⨆ i, (S i).map f).comap f = iSup S :=
  (gciMapComap hf).u_iSup_l _
#align first_order.language.substructure.comap_supr_map_of_injective FirstOrder.Language.Substructure.comap_iSup_map_of_injective

/- warning: first_order.language.substructure.map_le_map_iff_of_injective -> FirstOrder.Language.Substructure.map_le_map_iff_of_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {T : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, Iff (LE.le.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T)) (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Injective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (forall {S : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1} {T : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1}, Iff (LE.le.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Preorder.toLE.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T)) (LE.le.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))))) S T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_le_map_iff_of_injective FirstOrder.Language.Substructure.map_le_map_iff_of_injectiveₓ'. -/
theorem map_le_map_iff_of_injective {S T : L.Substructure M} : S.map f ≤ T.map f ↔ S ≤ T :=
  (gciMapComap hf).l_le_l_iff
#align first_order.language.substructure.map_le_map_iff_of_injective FirstOrder.Language.Substructure.map_le_map_iff_of_injective

/- warning: first_order.language.substructure.map_strict_mono_of_injective -> FirstOrder.Language.Substructure.map_strictMono_of_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (StrictMono.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Injective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (StrictMono.{u4, u1} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_strict_mono_of_injective FirstOrder.Language.Substructure.map_strictMono_of_injectiveₓ'. -/
theorem map_strictMono_of_injective : StrictMono (map f) :=
  (gciMapComap hf).strictMono_l
#align first_order.language.substructure.map_strict_mono_of_injective FirstOrder.Language.Substructure.map_strictMono_of_injective

end GaloisCoinsertion

section GaloisInsertion

variable {ι : Type _} {f : M →[L] N} (hf : Function.Surjective f)

include hf

/- warning: first_order.language.substructure.gi_map_comap -> FirstOrder.Language.Substructure.giMapComap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (GaloisInsertion.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (GaloisInsertion.{u3, u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.gi_map_comap FirstOrder.Language.Substructure.giMapComapₓ'. -/
/-- `map f` and `comap f` form a `galois_insertion` when `f` is surjective. -/
def giMapComap : GaloisInsertion (map f) (comap f) :=
  (gc_map_comap f).toGaloisInsertion fun S x h =>
    let ⟨y, hy⟩ := hf x
    mem_map.2 ⟨y, by simp [hy, h]⟩
#align first_order.language.substructure.gi_map_comap FirstOrder.Language.Substructure.giMapComap

/- warning: first_order.language.substructure.map_comap_eq_of_surjective -> FirstOrder.Language.Substructure.map_comap_eq_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S)) S)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S)) S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_comap_eq_of_surjective FirstOrder.Language.Substructure.map_comap_eq_of_surjectiveₓ'. -/
theorem map_comap_eq_of_surjective (S : L.Substructure N) : (S.comap f).map f = S :=
  (giMapComap hf).l_u_eq _
#align first_order.language.substructure.map_comap_eq_of_surjective FirstOrder.Language.Substructure.map_comap_eq_of_surjective

/- warning: first_order.language.substructure.map_surjective_of_surjective -> FirstOrder.Language.Substructure.map_surjective_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (Function.Surjective.{succ u3, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (Function.Surjective.{succ u4, succ u1} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_surjective_of_surjective FirstOrder.Language.Substructure.map_surjective_of_surjectiveₓ'. -/
theorem map_surjective_of_surjective : Function.Surjective (map f) :=
  (giMapComap hf).l_surjective
#align first_order.language.substructure.map_surjective_of_surjective FirstOrder.Language.Substructure.map_surjective_of_surjective

/- warning: first_order.language.substructure.comap_injective_of_surjective -> FirstOrder.Language.Substructure.comap_injective_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (Function.Injective.{succ u4, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (Function.Injective.{succ u1, succ u4} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_injective_of_surjective FirstOrder.Language.Substructure.comap_injective_of_surjectiveₓ'. -/
theorem comap_injective_of_surjective : Function.Injective (comap f) :=
  (giMapComap hf).u_injective
#align first_order.language.substructure.comap_injective_of_surjective FirstOrder.Language.Substructure.comap_injective_of_surjective

/- warning: first_order.language.substructure.map_inf_comap_of_surjective -> FirstOrder.Language.Substructure.map_inf_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (T : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (Inf.inf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInf.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T))) (Inf.inf.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instInf.{u1, u2, u4} L N _inst_2) S T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (T : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (Inf.inf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instInf.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T))) (Inf.inf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instInf.{u2, u3, u1} L N _inst_2) S T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_inf_comap_of_surjective FirstOrder.Language.Substructure.map_inf_comap_of_surjectiveₓ'. -/
theorem map_inf_comap_of_surjective (S T : L.Substructure N) :
    (S.comap f ⊓ T.comap f).map f = S ⊓ T :=
  (giMapComap hf).l_inf_u _ _
#align first_order.language.substructure.map_inf_comap_of_surjective FirstOrder.Language.Substructure.map_inf_comap_of_surjective

/- warning: first_order.language.substructure.map_infi_comap_of_surjective -> FirstOrder.Language.Substructure.map_iInf_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {ι : Type.{u5}} {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : ι -> (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2)), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (iInf.{u3, succ u5} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u1, u2, u3} L M _inst_1) ι (fun (i : ι) => FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (S i)))) (iInf.{u4, succ u5} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instInfSet.{u1, u2, u4} L N _inst_2) ι S))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u2}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u2} L N] {ι : Type.{u1}} {f : FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u5, succ u2} M N (FunLike.coe.{max (succ u5) (succ u2), succ u5, succ u2} (FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u3, u4, u5, u2} L M N _inst_1 _inst_2) f)) -> (forall (S : ι -> (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2)), Eq.{succ u2} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (FirstOrder.Language.Substructure.map.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f (iInf.{u5, succ u1} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instInfSet.{u3, u4, u5} L M _inst_1) ι (fun (i : ι) => FirstOrder.Language.Substructure.comap.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f (S i)))) (iInf.{u2, succ u1} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (FirstOrder.Language.Substructure.instInfSet.{u3, u4, u2} L N _inst_2) ι S))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_infi_comap_of_surjective FirstOrder.Language.Substructure.map_iInf_comap_of_surjectiveₓ'. -/
theorem map_iInf_comap_of_surjective (S : ι → L.Substructure N) :
    (⨅ i, (S i).comap f).map f = iInf S :=
  (giMapComap hf).l_iInf_u _
#align first_order.language.substructure.map_infi_comap_of_surjective FirstOrder.Language.Substructure.map_iInf_comap_of_surjective

/- warning: first_order.language.substructure.map_sup_comap_of_surjective -> FirstOrder.Language.Substructure.map_sup_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (T : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (Sup.sup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SemilatticeSup.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Lattice.toSemilatticeSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T))) (Sup.sup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SemilatticeSup.toHasSup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Lattice.toSemilatticeSup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (ConditionallyCompleteLattice.toLattice.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u4} L N _inst_2))))) S T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (forall (S : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (T : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (Sup.sup.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SemilatticeSup.toSup.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (Lattice.toSemilatticeSup.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))))) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T))) (Sup.sup.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SemilatticeSup.toSup.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Lattice.toSemilatticeSup.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (ConditionallyCompleteLattice.toLattice.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) S T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_sup_comap_of_surjective FirstOrder.Language.Substructure.map_sup_comap_of_surjectiveₓ'. -/
theorem map_sup_comap_of_surjective (S T : L.Substructure N) :
    (S.comap f ⊔ T.comap f).map f = S ⊔ T :=
  (giMapComap hf).l_sup_u _ _
#align first_order.language.substructure.map_sup_comap_of_surjective FirstOrder.Language.Substructure.map_sup_comap_of_surjective

/- warning: first_order.language.substructure.map_supr_comap_of_surjective -> FirstOrder.Language.Substructure.map_iSup_comap_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {ι : Type.{u5}} {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall (S : ι -> (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2)), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (iSup.{u3, succ u5} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))) ι (fun (i : ι) => FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (S i)))) (iSup.{u4, succ u5} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (ConditionallyCompleteLattice.toHasSup.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u4} L N _inst_2))) ι S))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u2}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u2} L N] {ι : Type.{u1}} {f : FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u5, succ u2} M N (FunLike.coe.{max (succ u5) (succ u2), succ u5, succ u2} (FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u3, u4, u5, u2} L M N _inst_1 _inst_2) f)) -> (forall (S : ι -> (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2)), Eq.{succ u2} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (FirstOrder.Language.Substructure.map.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f (iSup.{u5, succ u1} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (ConditionallyCompleteLattice.toSupSet.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1))) ι (fun (i : ι) => FirstOrder.Language.Substructure.comap.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f (S i)))) (iSup.{u2, succ u1} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (ConditionallyCompleteLattice.toSupSet.{u2} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (CompleteLattice.toConditionallyCompleteLattice.{u2} (FirstOrder.Language.Substructure.{u3, u4, u2} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u2} L N _inst_2))) ι S))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.map_supr_comap_of_surjective FirstOrder.Language.Substructure.map_iSup_comap_of_surjectiveₓ'. -/
theorem map_iSup_comap_of_surjective (S : ι → L.Substructure N) :
    (⨆ i, (S i).comap f).map f = iSup S :=
  (giMapComap hf).l_iSup_u _
#align first_order.language.substructure.map_supr_comap_of_surjective FirstOrder.Language.Substructure.map_iSup_comap_of_surjective

/- warning: first_order.language.substructure.comap_le_comap_iff_of_surjective -> FirstOrder.Language.Substructure.comap_le_comap_iff_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (forall {S : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2} {T : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2}, Iff (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f T)) (LE.le.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))) S T))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (forall {S : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2} {T : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2}, Iff (LE.le.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1))))) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f S) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f T)) (LE.le.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Preorder.toLE.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) S T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_le_comap_iff_of_surjective FirstOrder.Language.Substructure.comap_le_comap_iff_of_surjectiveₓ'. -/
theorem comap_le_comap_iff_of_surjective {S T : L.Substructure N} : S.comap f ≤ T.comap f ↔ S ≤ T :=
  (giMapComap hf).u_le_u_iff
#align first_order.language.substructure.comap_le_comap_iff_of_surjective FirstOrder.Language.Substructure.comap_le_comap_iff_of_surjective

/- warning: first_order.language.substructure.comap_strict_mono_of_surjective -> FirstOrder.Language.Substructure.comap_strictMono_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (StrictMono.{u4, u3} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Function.Surjective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f)) -> (StrictMono.{u1, u4} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2)))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.comap_strict_mono_of_surjective FirstOrder.Language.Substructure.comap_strictMono_of_surjectiveₓ'. -/
theorem comap_strictMono_of_surjective : StrictMono (comap f) :=
  (giMapComap hf).strictMono_u
#align first_order.language.substructure.comap_strict_mono_of_surjective FirstOrder.Language.Substructure.comap_strictMono_of_surjective

end GaloisInsertion

#print FirstOrder.Language.Substructure.inducedStructure /-
instance inducedStructure {S : L.Substructure M} : L.Structure S
    where
  funMap n f x := ⟨funMap f fun i => x i, S.fun_mem f (fun i => x i) fun i => (x i).2⟩
  rel_map n r x := RelMap r fun i => (x i : M)
#align first_order.language.substructure.induced_Structure FirstOrder.Language.Substructure.inducedStructure
-/

#print FirstOrder.Language.Substructure.subtype /-
/-- The natural embedding of an `L.substructure` of `M` into `M`. -/
def subtype (S : L.Substructure M) : S ↪[L] M
    where
  toFun := coe
  inj' := Subtype.coe_injective
#align first_order.language.substructure.subtype FirstOrder.Language.Substructure.subtype
-/

#print FirstOrder.Language.Substructure.coeSubtype /-
@[simp]
theorem coeSubtype : ⇑S.Subtype = coe :=
  rfl
#align first_order.language.substructure.coe_subtype FirstOrder.Language.Substructure.coeSubtype
-/

#print FirstOrder.Language.Substructure.topEquiv /-
/-- The equivalence between the maximal substructure of a structure and the structure itself. -/
def topEquiv : (⊤ : L.Substructure M) ≃[L] M
    where
  toFun := subtype ⊤
  invFun m := ⟨m, mem_top m⟩
  left_inv m := by simp
  right_inv m := rfl
#align first_order.language.substructure.top_equiv FirstOrder.Language.Substructure.topEquiv
-/

#print FirstOrder.Language.Substructure.coe_topEquiv /-
@[simp]
theorem coe_topEquiv : ⇑(topEquiv : (⊤ : L.Substructure M) ≃[L] M) = coe :=
  rfl
#align first_order.language.substructure.coe_top_equiv FirstOrder.Language.Substructure.coe_topEquiv
-/

#print FirstOrder.Language.Substructure.closure_induction' /-
/-- A dependent version of `substructure.closure_induction`. -/
@[elab_as_elim]
theorem closure_induction' (s : Set M) {p : ∀ x, x ∈ closure L s → Prop}
    (Hs : ∀ (x) (h : x ∈ s), p x (subset_closure h))
    (Hfun : ∀ {n : ℕ} (f : L.Functions n), ClosedUnder f { x | ∃ hx, p x hx }) {x}
    (hx : x ∈ closure L s) : p x hx :=
  by
  refine' Exists.elim _ fun (hx : x ∈ closure L s) (hc : p x hx) => hc
  exact closure_induction hx (fun x hx => ⟨subset_closure hx, Hs x hx⟩) @Hfun
#align first_order.language.substructure.closure_induction' FirstOrder.Language.Substructure.closure_induction'
-/

end Substructure

namespace Lhom

open Substructure

variable {L' : Language} [L'.Structure M] (φ : L →ᴸ L') [φ.IsExpansionOn M]

include φ

/- warning: first_order.language.Lhom.substructure_reduct -> FirstOrder.Language.LHom.substructureReduct is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {L' : FirstOrder.Language.{u4, u5}} [_inst_4 : FirstOrder.Language.Structure.{u4, u5, u3} L' M] (φ : FirstOrder.Language.LHom.{u1, u2, u4, u5} L L') [_inst_5 : FirstOrder.Language.LHom.IsExpansionOn.{u1, u2, u4, u5, u3} L L' φ M _inst_1 _inst_4], OrderEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u4, u5, u3} L' M _inst_4)))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {L' : FirstOrder.Language.{u4, u5}} [_inst_4 : FirstOrder.Language.Structure.{u4, u5, u3} L' M] (φ : FirstOrder.Language.LHom.{u1, u2, u4, u5} L L') [_inst_5 : FirstOrder.Language.LHom.IsExpansionOn.{u1, u2, u4, u5, u3} L L' φ M _inst_1 _inst_4], OrderEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (FirstOrder.Language.Substructure.instCompleteLattice.{u4, u5, u3} L' M _inst_4))))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))))
Case conversion may be inaccurate. Consider using '#align first_order.language.Lhom.substructure_reduct FirstOrder.Language.LHom.substructureReductₓ'. -/
/-- Reduces the language of a substructure along a language hom. -/
def substructureReduct : L'.Substructure M ↪o L.Substructure M
    where
  toFun S :=
    { carrier := S
      fun_mem := fun n f x hx =>
        by
        have h := S.fun_mem (φ.on_function f) x hx
        simp only [Lhom.map_on_function, substructure.mem_carrier] at h
        exact h }
  inj' S T h := by
    simp only [SetLike.coe_set_eq] at h
    exact h
  map_rel_iff' S T := Iff.rfl
#align first_order.language.Lhom.substructure_reduct FirstOrder.Language.LHom.substructureReduct

/- warning: first_order.language.Lhom.mem_substructure_reduct -> FirstOrder.Language.LHom.mem_substructureReduct is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {L' : FirstOrder.Language.{u4, u5}} [_inst_4 : FirstOrder.Language.Structure.{u4, u5, u3} L' M] (φ : FirstOrder.Language.LHom.{u1, u2, u4, u5} L L') [_inst_5 : FirstOrder.Language.LHom.IsExpansionOn.{u1, u2, u4, u5, u3} L L' φ M _inst_1 _inst_4] {x : M} {S : FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4}, Iff (Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (coeFn.{succ u3, succ u3} (OrderEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u4, u5, u3} L' M _inst_4)))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))))) (fun (_x : RelEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (LE.le.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u4, u5, u3} L' M _inst_4))))) (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (RelEmbedding.hasCoeToFun.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (LE.le.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u4, u5, u3} L' M _inst_4))))) (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.LHom.substructureReduct.{u1, u2, u3, u4, u5} L M _inst_1 L' _inst_4 φ _inst_5) S)) (Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u4, u5, u3} L' M _inst_4)) x S)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] {L' : FirstOrder.Language.{u2, u1}} [_inst_4 : FirstOrder.Language.Structure.{u2, u1, u5} L' M] (φ : FirstOrder.Language.LHom.{u3, u4, u2, u1} L L') [_inst_5 : FirstOrder.Language.LHom.IsExpansionOn.{u3, u4, u2, u1, u5} L L' φ M _inst_1 _inst_4] {x : M} {S : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4}, Iff (Membership.mem.{u5, u5} M ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) S) (SetLike.instMembership.{u5, u5} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) S) M (FirstOrder.Language.Substructure.instSetLike.{u3, u4, u5} L M _inst_1)) x (FunLike.coe.{succ u5, succ u5, succ u5} (OrderEmbedding.{u5, u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u5} L' M _inst_4))))) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1)))))) (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (fun (_x : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) _x) (RelHomClass.toFunLike.{u5, u5, u5} (OrderEmbedding.{u5, u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u5} L' M _inst_4))))) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1)))))) (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => LE.le.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u5} L' M _inst_4))))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) => LE.le.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u5, u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => LE.le.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u5} L' M _inst_4))))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) => LE.le.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (FirstOrder.Language.LHom.substructureReduct.{u3, u4, u5, u2, u1} L M _inst_1 L' _inst_4 φ _inst_5) S)) (Membership.mem.{u5, u5} M (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (SetLike.instMembership.{u5, u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u2, u1, u5} L' M _inst_4)) x S)
Case conversion may be inaccurate. Consider using '#align first_order.language.Lhom.mem_substructure_reduct FirstOrder.Language.LHom.mem_substructureReductₓ'. -/
@[simp]
theorem mem_substructureReduct {x : M} {S : L'.Substructure M} :
    x ∈ φ.substructureReduct S ↔ x ∈ S :=
  Iff.rfl
#align first_order.language.Lhom.mem_substructure_reduct FirstOrder.Language.LHom.mem_substructureReduct

/- warning: first_order.language.Lhom.coe_substructure_reduct -> FirstOrder.Language.LHom.coe_substructureReduct is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {L' : FirstOrder.Language.{u4, u5}} [_inst_4 : FirstOrder.Language.Structure.{u4, u5, u3} L' M] (φ : FirstOrder.Language.LHom.{u1, u2, u4, u5} L L') [_inst_5 : FirstOrder.Language.LHom.IsExpansionOn.{u1, u2, u4, u5, u3} L L' φ M _inst_1 _inst_4] {S : FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4}, Eq.{succ u3} (Set.{u3} M) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (coeFn.{succ u3, succ u3} (OrderEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u4, u5, u3} L' M _inst_4)))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))))) (fun (_x : RelEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (LE.le.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u4, u5, u3} L' M _inst_4))))) (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (RelEmbedding.hasCoeToFun.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (LE.le.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u4, u5, u3} L' M _inst_4))))) (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.LHom.substructureReduct.{u1, u2, u3, u4, u5} L M _inst_1 L' _inst_4 φ _inst_5) S)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u4, u5, u3} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u4, u5, u3} L' M _inst_4)))) S)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] {L' : FirstOrder.Language.{u2, u1}} [_inst_4 : FirstOrder.Language.Structure.{u2, u1, u5} L' M] (φ : FirstOrder.Language.LHom.{u3, u4, u2, u1} L L') [_inst_5 : FirstOrder.Language.LHom.IsExpansionOn.{u3, u4, u2, u1, u5} L L' φ M _inst_1 _inst_4] {S : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4}, Eq.{succ u5} (Set.{u5} M) (SetLike.coe.{u5, u5} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) S) M (FirstOrder.Language.Substructure.instSetLike.{u3, u4, u5} L M _inst_1) (FunLike.coe.{succ u5, succ u5, succ u5} (OrderEmbedding.{u5, u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u5} L' M _inst_4))))) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1)))))) (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (fun (_x : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) _x) (RelHomClass.toFunLike.{u5, u5, u5} (OrderEmbedding.{u5, u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u5} L' M _inst_4))))) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1)))))) (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => LE.le.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u5} L' M _inst_4))))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) => LE.le.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u5, u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) => LE.le.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u5} L' M _inst_4))))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) => LE.le.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u5} (FirstOrder.Language.Substructure.{u3, u4, u5} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u5} L M _inst_1))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (FirstOrder.Language.LHom.substructureReduct.{u3, u4, u5, u2, u1} L M _inst_1 L' _inst_4 φ _inst_5) S)) (SetLike.coe.{u5, u5} (FirstOrder.Language.Substructure.{u2, u1, u5} L' M _inst_4) M (FirstOrder.Language.Substructure.instSetLike.{u2, u1, u5} L' M _inst_4) S)
Case conversion may be inaccurate. Consider using '#align first_order.language.Lhom.coe_substructure_reduct FirstOrder.Language.LHom.coe_substructureReductₓ'. -/
@[simp]
theorem coe_substructureReduct {S : L'.Substructure M} : (φ.substructureReduct S : Set M) = ↑S :=
  rfl
#align first_order.language.Lhom.coe_substructure_reduct FirstOrder.Language.LHom.coe_substructureReduct

end Lhom

namespace Substructure

#print FirstOrder.Language.Substructure.withConstants /-
/-- Turns any substructure containing a constant set `A` into a `L[[A]]`-substructure. -/
def withConstants (S : L.Substructure M) {A : Set M} (h : A ⊆ S) : L[[A]].Substructure M
    where
  carrier := S
  fun_mem n f := by
    cases f
    · exact S.fun_mem f
    · cases n
      · exact fun _ _ => h f.2
      · exact isEmptyElim f
#align first_order.language.substructure.with_constants FirstOrder.Language.Substructure.withConstants
-/

variable {A : Set M} {s : Set M} (h : A ⊆ S)

#print FirstOrder.Language.Substructure.mem_withConstants /-
@[simp]
theorem mem_withConstants {x : M} : x ∈ S.withConstants h ↔ x ∈ S :=
  Iff.rfl
#align first_order.language.substructure.mem_with_constants FirstOrder.Language.Substructure.mem_withConstants
-/

#print FirstOrder.Language.Substructure.coe_withConstants /-
@[simp]
theorem coe_withConstants : (S.withConstants h : Set M) = ↑S :=
  rfl
#align first_order.language.substructure.coe_with_constants FirstOrder.Language.Substructure.coe_withConstants
-/

/- warning: first_order.language.substructure.reduct_with_constants -> FirstOrder.Language.Substructure.reduct_withConstants is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {A : Set.{u3} M} (h : HasSubset.Subset.{u3} (Set.{u3} M) (Set.hasSubset.{u3} M) A ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S)), Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (OrderEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A)))))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))))) (fun (_x : RelEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (LE.le.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))))))) (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (RelEmbedding.hasCoeToFun.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (LE.le.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))))))) (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.LHom.substructureReduct.{u1, u2, u3, max u1 u3, u2} L M _inst_1 (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A)) (FirstOrder.Language.lhomWithConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) (FirstOrder.Language.withConstants_expansion.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.withConstants.{u1, u2, u3} L M _inst_1 S A h)) S
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {A : Set.{u3} M} (h : HasSubset.Subset.{u3} (Set.{u3} M) (Set.instHasSubsetSet.{u3} M) A (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) S)), Eq.{succ u3} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) => FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.withConstants.{u1, u2, u3} L M _inst_1 S A h)) (FunLike.coe.{succ u3, succ u3, succ u3} (OrderEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.instCompleteLattice.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))))))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (fun (_x : FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) => FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) _x) (RelHomClass.toFunLike.{u3, u3, u3} (OrderEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.instCompleteLattice.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))))))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) => LE.le.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.instCompleteLattice.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))))))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) => LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) => LE.le.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.instCompleteLattice.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))))))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) => LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (FirstOrder.Language.LHom.substructureReduct.{u1, u2, u3, max u1 u3, u2} L M _inst_1 (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A)) (FirstOrder.Language.lhomWithConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) (FirstOrder.Language.withConstants_expansion.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.withConstants.{u1, u2, u3} L M _inst_1 S A h)) S
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.reduct_with_constants FirstOrder.Language.Substructure.reduct_withConstantsₓ'. -/
@[simp]
theorem reduct_withConstants : (L.lhomWithConstants A).substructureReduct (S.withConstants h) = S :=
  by
  ext
  simp
#align first_order.language.substructure.reduct_with_constants FirstOrder.Language.Substructure.reduct_withConstants

#print FirstOrder.Language.Substructure.subset_closure_withConstants /-
theorem subset_closure_withConstants : A ⊆ closure (L[[A]]) s :=
  by
  intro a ha
  simp only [SetLike.mem_coe]
  let a' : L[[A]].Constants := Sum.inr ⟨a, ha⟩
  exact constants_mem a'
#align first_order.language.substructure.subset_closure_with_constants FirstOrder.Language.Substructure.subset_closure_withConstants
-/

/- warning: first_order.language.substructure.closure_with_constants_eq -> FirstOrder.Language.Substructure.closure_withConstants_eq is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {A : Set.{u3} M} {s : Set.{u3} M}, Eq.{succ u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A)))))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A)))))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A)))) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A)))))))) (FirstOrder.Language.Substructure.closure.{max u1 u3, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) A) (FirstOrder.Language.paramsStructure.{u3} M A))) s) (FirstOrder.Language.Substructure.withConstants.{u1, u2, u3} L M _inst_1 (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Union.union.{u3} (Set.{u3} M) (Set.hasUnion.{u3} M) A s)) A (HasSubset.Subset.trans.{u3} (Set.{u3} M) (Set.hasSubset.{u3} M) (Set.hasSubset.Subset.isTrans.{u3} M) A (Union.union.{u3} (Set.{u3} M) (Set.hasUnion.{u3} M) A s) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Union.union.{u3} (Set.{u3} M) (Set.hasUnion.{u3} M) A s))) (Set.subset_union_left.{u3} M A s) (FirstOrder.Language.Substructure.subset_closure.{u1, u2, u3} L M _inst_1 (Union.union.{u3} (Set.{u3} M) (Set.hasUnion.{u3} M) A s))))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {A : Set.{u3} M} {s : Set.{u3} M}, Eq.{succ u3} (FirstOrder.Language.Substructure.{max u3 u1, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{max u3 u1, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{max u3 u1, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{max u3 u1, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{max u3 u1, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) (FirstOrder.Language.Substructure.instCompleteLattice.{max u3 u1, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A)))))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{max u3 u1, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) M (FirstOrder.Language.Substructure.instSetLike.{max u3 u1, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A)))) (FirstOrder.Language.Substructure.closure.{max u3 u1, u2, u3} (FirstOrder.Language.withConstants.{u1, u2, u3} L (Set.Elem.{u3} M A)) M (FirstOrder.Language.withConstantsStructure.{u1, u2, u3, u3} L M _inst_1 (Set.Elem.{u3} M A) (FirstOrder.Language.paramsStructure.{u3} M A))) s) (FirstOrder.Language.Substructure.withConstants.{u1, u2, u3} L M _inst_1 (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Union.union.{u3} (Set.{u3} M) (Set.instUnionSet.{u3} M) A s)) A (HasSubset.Subset.trans.{u3} (Set.{u3} M) (Set.instHasSubsetSet.{u3} M) (Set.instIsTransSetSubsetInstHasSubsetSet.{u3} M) A (Union.union.{u3} (Set.{u3} M) (Set.instUnionSet.{u3} M) A s) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Union.union.{u3} (Set.{u3} M) (Set.instUnionSet.{u3} M) A s))) (Set.subset_union_left.{u3} M A s) (FirstOrder.Language.Substructure.subset_closure.{u1, u2, u3} L M _inst_1 (Union.union.{u3} (Set.{u3} M) (Set.instUnionSet.{u3} M) A s))))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.closure_with_constants_eq FirstOrder.Language.Substructure.closure_withConstants_eqₓ'. -/
theorem closure_withConstants_eq :
    closure (L[[A]]) s =
      (closure L (A ∪ s)).withConstants ((A.subset_union_left s).trans subset_closure) :=
  by
  refine' closure_eq_of_le ((A.subset_union_right s).trans subset_closure) _
  rw [← (L.Lhom_with_constants A).substructureReduct.le_iff_le]
  simp only [subset_closure, reduct_with_constants, closure_le, Lhom.coe_substructure_reduct,
    Set.union_subset_iff, and_true_iff]
  · exact subset_closure_with_constants
  · infer_instance
  · infer_instance
#align first_order.language.substructure.closure_with_constants_eq FirstOrder.Language.Substructure.closure_withConstants_eq

end Substructure

namespace Hom

open Substructure

#print FirstOrder.Language.Hom.domRestrict /-
/-- The restriction of a first-order hom to a substructure `s ⊆ M` gives a hom `s → N`. -/
@[simps]
def domRestrict (f : M →[L] N) (p : L.Substructure M) : p →[L] N :=
  f.comp p.Subtype.toHom
#align first_order.language.hom.dom_restrict FirstOrder.Language.Hom.domRestrict
-/

#print FirstOrder.Language.Hom.codRestrict /-
/-- A first-order hom `f : M → N` whose values lie in a substructure `p ⊆ N` can be restricted to a
hom `M → p`. -/
@[simps]
def codRestrict (p : L.Substructure N) (f : M →[L] N) (h : ∀ c, f c ∈ p) : M →[L] p
    where
  toFun c := ⟨f c, h c⟩
  map_rel' n R x h := f.map_rel R x h
#align first_order.language.hom.cod_restrict FirstOrder.Language.Hom.codRestrict
-/

/- warning: first_order.language.hom.comp_cod_restrict -> FirstOrder.Language.Hom.comp_codRestrict is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u5}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] [_inst_3 : FirstOrder.Language.Structure.{u1, u2, u5} L P] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (g : FirstOrder.Language.Hom.{u1, u2, u4, u5} L N P _inst_2 _inst_3) (p : FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (h : forall (b : N), Membership.Mem.{u5, u5} P (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (SetLike.hasMem.{u5, u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u5} L P _inst_3)) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (FirstOrder.Language.Hom.{u1, u2, u4, u5} L N P _inst_2 _inst_3) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u4, u5} L N P _inst_2 _inst_3) => N -> P) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u4, u5} L N P _inst_2 _inst_3) g b) p), Eq.{max (succ u3) (succ u5)} (FirstOrder.Language.Hom.{u1, u2, u3, u5} L M (coeSort.{succ u5, succ (succ u5)} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u5} L P _inst_3)) p) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u5} L P _inst_3 p)) (FirstOrder.Language.Hom.comp.{u1, u2, u3, u4, u5} L M N _inst_1 _inst_2 (coeSort.{succ u5, succ (succ u5)} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u5} L P _inst_3)) p) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u5} L P _inst_3 p) (FirstOrder.Language.Hom.codRestrict.{u1, u2, u4, u5} L N P _inst_2 _inst_3 p g h) f) (FirstOrder.Language.Hom.codRestrict.{u1, u2, u3, u5} L M P _inst_1 _inst_3 p (FirstOrder.Language.Hom.comp.{u1, u2, u3, u4, u5} L M N _inst_1 _inst_2 P _inst_3 g f) (fun (b : M) => h (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f b)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u2}} {P : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u2} L N] [_inst_3 : FirstOrder.Language.Structure.{u3, u4, u1} L P] (f : FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2) (g : FirstOrder.Language.Hom.{u3, u4, u2, u1} L N P _inst_2 _inst_3) (p : FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (h : forall (b : N), Membership.mem.{u1, u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : N) => P) b) (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u3, u4, u1} L P _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Hom.{u3, u4, u2, u1} L N P _inst_2 _inst_3) N (fun (_x : N) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : N) => P) _x) (FirstOrder.Language.Hom.funLike.{u3, u4, u2, u1} L N P _inst_2 _inst_3) g b) p), Eq.{max (succ u5) (succ u1)} (FirstOrder.Language.Hom.{u3, u4, u5, u1} L M (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u3, u4, u1} L P _inst_3)) x p)) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u3, u4, u1} L P _inst_3 p)) (FirstOrder.Language.Hom.comp.{u3, u4, u5, u2, u1} L M N _inst_1 _inst_2 (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u3, u4, u1} L P _inst_3)) x p)) (FirstOrder.Language.Substructure.inducedStructure.{u3, u4, u1} L P _inst_3 p) (FirstOrder.Language.Hom.codRestrict.{u3, u4, u2, u1} L N P _inst_2 _inst_3 p g h) f) (FirstOrder.Language.Hom.codRestrict.{u3, u4, u5, u1} L M P _inst_1 _inst_3 p (FirstOrder.Language.Hom.comp.{u3, u4, u5, u2, u1} L M N _inst_1 _inst_2 P _inst_3 g f) (fun (b : M) => h (FunLike.coe.{max (succ u5) (succ u2), succ u5, succ u2} (FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u3, u4, u5, u2} L M N _inst_1 _inst_2) f b)))
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.comp_cod_restrict FirstOrder.Language.Hom.comp_codRestrictₓ'. -/
@[simp]
theorem comp_codRestrict (f : M →[L] N) (g : N →[L] P) (p : L.Substructure P) (h : ∀ b, g b ∈ p) :
    ((codRestrict p g h).comp f : M →[L] p) = codRestrict p (g.comp f) fun b => h _ :=
  ext fun b => rfl
#align first_order.language.hom.comp_cod_restrict FirstOrder.Language.Hom.comp_codRestrict

/- warning: first_order.language.hom.subtype_comp_cod_restrict -> FirstOrder.Language.Hom.subtype_comp_codRestrict is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (p : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (h : forall (b : M), Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f b) p), Eq.{max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (FirstOrder.Language.Hom.comp.{u1, u2, u3, u4, u4} L M (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 p) N _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u4, u4} L (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) N (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 p) _inst_2 (FirstOrder.Language.Substructure.subtype.{u1, u2, u4} L N _inst_2 p)) (FirstOrder.Language.Hom.codRestrict.{u1, u2, u3, u4} L M N _inst_1 _inst_2 p f h)) f
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (p : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (h : forall (b : M), Membership.mem.{u1, u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) b) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f b) p), Eq.{max (succ u4) (succ u1)} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (FirstOrder.Language.Hom.comp.{u2, u3, u4, u1, u1} L M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x p)) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 p) N _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u1, u1} L (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x p)) N (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 p) _inst_2 (FirstOrder.Language.Substructure.subtype.{u2, u3, u1} L N _inst_2 p)) (FirstOrder.Language.Hom.codRestrict.{u2, u3, u4, u1} L M N _inst_1 _inst_2 p f h)) f
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.subtype_comp_cod_restrict FirstOrder.Language.Hom.subtype_comp_codRestrictₓ'. -/
@[simp]
theorem subtype_comp_codRestrict (f : M →[L] N) (p : L.Substructure N) (h : ∀ b, f b ∈ p) :
    p.Subtype.toHom.comp (codRestrict p f h) = f :=
  ext fun b => rfl
#align first_order.language.hom.subtype_comp_cod_restrict FirstOrder.Language.Hom.subtype_comp_codRestrict

#print FirstOrder.Language.Hom.range /-
/-- The range of a first-order hom `f : M → N` is a submodule of `N`.
See Note [range copy pattern]. -/
def range (f : M →[L] N) : L.Substructure N :=
  (map f ⊤).copy (Set.range f) Set.image_univ.symm
#align first_order.language.hom.range FirstOrder.Language.Hom.range
-/

/- warning: first_order.language.hom.range_coe -> FirstOrder.Language.Hom.range_coe is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u4} (Set.{u4} N) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (HasLiftT.mk.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (CoeTCₓ.coe.{succ u4, succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Set.{u4} N) (SetLike.Set.hasCoeT.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (Set.range.{u4, succ u3} N M (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2), Eq.{succ u1} (Set.{u1} N) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)) (Set.range.{u1, succ u4} N M (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f))
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.range_coe FirstOrder.Language.Hom.range_coeₓ'. -/
theorem range_coe (f : M →[L] N) : (range f : Set N) = Set.range f :=
  rfl
#align first_order.language.hom.range_coe FirstOrder.Language.Hom.range_coe

/- warning: first_order.language.hom.mem_range -> FirstOrder.Language.Hom.mem_range is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {x : N}, Iff (Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (Exists.{succ u3} M (fun (y : M) => Eq.{succ u4} N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f y) x))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {x : N}, Iff (Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)) (Exists.{succ u4} M (fun (y : M) => Eq.{succ u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) y) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f y) x))
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.mem_range FirstOrder.Language.Hom.mem_rangeₓ'. -/
@[simp]
theorem mem_range {f : M →[L] N} {x} : x ∈ range f ↔ ∃ y, f y = x :=
  Iff.rfl
#align first_order.language.hom.mem_range FirstOrder.Language.Hom.mem_range

/- warning: first_order.language.hom.range_eq_map -> FirstOrder.Language.Hom.range_eq_map is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f (Top.top.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u2, u3, u4} L M _inst_1)))
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.range_eq_map FirstOrder.Language.Hom.range_eq_mapₓ'. -/
theorem range_eq_map (f : M →[L] N) : f.range = map f ⊤ :=
  by
  ext
  simp
#align first_order.language.hom.range_eq_map FirstOrder.Language.Hom.range_eq_map

/- warning: first_order.language.hom.mem_range_self -> FirstOrder.Language.Hom.mem_range_self is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (x : M), Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f x) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (x : M), Membership.mem.{u1, u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) x) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f x) (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.mem_range_self FirstOrder.Language.Hom.mem_range_selfₓ'. -/
theorem mem_range_self (f : M →[L] N) (x : M) : f x ∈ f.range :=
  ⟨x, rfl⟩
#align first_order.language.hom.mem_range_self FirstOrder.Language.Hom.mem_range_self

#print FirstOrder.Language.Hom.range_id /-
@[simp]
theorem range_id : range (id L M) = ⊤ :=
  SetLike.coe_injective Set.range_id
#align first_order.language.hom.range_id FirstOrder.Language.Hom.range_id
-/

/- warning: first_order.language.hom.range_comp -> FirstOrder.Language.Hom.range_comp is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u5}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] [_inst_3 : FirstOrder.Language.Structure.{u1, u2, u5} L P] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (g : FirstOrder.Language.Hom.{u1, u2, u4, u5} L N P _inst_2 _inst_3), Eq.{succ u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (FirstOrder.Language.Hom.range.{u1, u2, u3, u5} L M P _inst_1 _inst_3 (FirstOrder.Language.Hom.comp.{u1, u2, u3, u4, u5} L M N _inst_1 _inst_2 P _inst_3 g f)) (FirstOrder.Language.Substructure.map.{u1, u2, u4, u5} L N P _inst_2 _inst_3 g (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u2}} {P : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u2} L N] [_inst_3 : FirstOrder.Language.Structure.{u3, u4, u1} L P] (f : FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2) (g : FirstOrder.Language.Hom.{u3, u4, u2, u1} L N P _inst_2 _inst_3), Eq.{succ u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (FirstOrder.Language.Hom.range.{u3, u4, u5, u1} L M P _inst_1 _inst_3 (FirstOrder.Language.Hom.comp.{u3, u4, u5, u2, u1} L M N _inst_1 _inst_2 P _inst_3 g f)) (FirstOrder.Language.Substructure.map.{u3, u4, u2, u1} L N P _inst_2 _inst_3 g (FirstOrder.Language.Hom.range.{u3, u4, u5, u2} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.range_comp FirstOrder.Language.Hom.range_compₓ'. -/
theorem range_comp (f : M →[L] N) (g : N →[L] P) : range (g.comp f : M →[L] P) = map g (range f) :=
  SetLike.coe_injective (Set.range_comp g f)
#align first_order.language.hom.range_comp FirstOrder.Language.Hom.range_comp

/- warning: first_order.language.hom.range_comp_le_range -> FirstOrder.Language.Hom.range_comp_le_range is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u5}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] [_inst_3 : FirstOrder.Language.Structure.{u1, u2, u5} L P] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (g : FirstOrder.Language.Hom.{u1, u2, u4, u5} L N P _inst_2 _inst_3), LE.le.{u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (Preorder.toLE.{u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (PartialOrder.toPreorder.{u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (SetLike.partialOrder.{u5, u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u5} L P _inst_3)))) (FirstOrder.Language.Hom.range.{u1, u2, u3, u5} L M P _inst_1 _inst_3 (FirstOrder.Language.Hom.comp.{u1, u2, u3, u4, u5} L M N _inst_1 _inst_2 P _inst_3 g f)) (FirstOrder.Language.Hom.range.{u1, u2, u4, u5} L N P _inst_2 _inst_3 g)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u2}} {P : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u2} L N] [_inst_3 : FirstOrder.Language.Structure.{u3, u4, u1} L P] (f : FirstOrder.Language.Hom.{u3, u4, u5, u2} L M N _inst_1 _inst_2) (g : FirstOrder.Language.Hom.{u3, u4, u2, u1} L N P _inst_2 _inst_3), LE.le.{u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (Preorder.toLE.{u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u4, u1} L P _inst_3))))) (FirstOrder.Language.Hom.range.{u3, u4, u5, u1} L M P _inst_1 _inst_3 (FirstOrder.Language.Hom.comp.{u3, u4, u5, u2, u1} L M N _inst_1 _inst_2 P _inst_3 g f)) (FirstOrder.Language.Hom.range.{u3, u4, u2, u1} L N P _inst_2 _inst_3 g)
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.range_comp_le_range FirstOrder.Language.Hom.range_comp_le_rangeₓ'. -/
theorem range_comp_le_range (f : M →[L] N) (g : N →[L] P) : range (g.comp f : M →[L] P) ≤ range g :=
  SetLike.coe_mono (Set.range_comp_subset_range f g)
#align first_order.language.hom.range_comp_le_range FirstOrder.Language.Hom.range_comp_le_range

/- warning: first_order.language.hom.range_eq_top -> FirstOrder.Language.Hom.range_eq_top is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, Iff (Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) (Top.top.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instTop.{u1, u2, u4} L N _inst_2))) (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, Iff (Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) (Top.top.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instTop.{u2, u3, u1} L N _inst_2))) (Function.Surjective.{succ u4, succ u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f))
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.range_eq_top FirstOrder.Language.Hom.range_eq_topₓ'. -/
theorem range_eq_top {f : M →[L] N} : range f = ⊤ ↔ Function.Surjective f := by
  rw [SetLike.ext'_iff, range_coe, coe_top, Set.range_iff_surjective]
#align first_order.language.hom.range_eq_top FirstOrder.Language.Hom.range_eq_top

/- warning: first_order.language.hom.range_le_iff_comap -> FirstOrder.Language.Hom.range_le_iff_comap is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {p : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2}, Iff (LE.le.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p) (Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f p) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {p : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2}, Iff (LE.le.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Preorder.toLE.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p) (Eq.{succ u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.comap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f p) (Top.top.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u2, u3, u4} L M _inst_1)))
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.range_le_iff_comap FirstOrder.Language.Hom.range_le_iff_comapₓ'. -/
theorem range_le_iff_comap {f : M →[L] N} {p : L.Substructure N} : range f ≤ p ↔ comap f p = ⊤ := by
  rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]
#align first_order.language.hom.range_le_iff_comap FirstOrder.Language.Hom.range_le_iff_comap

/- warning: first_order.language.hom.map_le_range -> FirstOrder.Language.Hom.map_le_range is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {p : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, LE.le.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (Preorder.toLE.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.partialOrder.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)))) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f p) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {p : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1}, LE.le.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (Preorder.toLE.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u1} L N _inst_2))))) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f p) (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.map_le_range FirstOrder.Language.Hom.map_le_rangeₓ'. -/
theorem map_le_range {f : M →[L] N} {p : L.Substructure M} : map f p ≤ range f :=
  SetLike.coe_mono (Set.image_subset_range f p)
#align first_order.language.hom.map_le_range FirstOrder.Language.Hom.map_le_range

#print FirstOrder.Language.Hom.eqLocus /-
/-- The substructure of elements `x : M` such that `f x = g x` -/
def eqLocus (f g : M →[L] N) : Substructure L M
    where
  carrier := { x : M | f x = g x }
  fun_mem n fn x hx :=
    by
    have h : f ∘ x = g ∘ x := by
      ext
      repeat' rw [Function.comp_apply]
      apply hx
    simp [h]
#align first_order.language.hom.eq_locus FirstOrder.Language.Hom.eqLocus
-/

/- warning: first_order.language.hom.eq_on_closure -> FirstOrder.Language.Hom.eqOn_closure is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {g : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {s : Set.{u3} M}, (Set.EqOn.{u3, u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) g) s) -> (Set.EqOn.{u3, u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) g) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s)))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {g : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {s : Set.{u4} M}, (Set.EqOn.{u4, u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) g) s) -> (Set.EqOn.{u4, u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) g) (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1) (LowerAdjoint.toFun.{u4, u4} (Set.{u4} M) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (Set.{u4} M) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} M) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} M) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} M) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} M) (Set.instCompleteBooleanAlgebraSet.{u4} M))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u2, u3, u4} L M _inst_1) s)))
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.eq_on_closure FirstOrder.Language.Hom.eqOn_closureₓ'. -/
/-- If two `L.hom`s are equal on a set, then they are equal on its substructure closure. -/
theorem eqOn_closure {f g : M →[L] N} {s : Set M} (h : Set.EqOn f g s) :
    Set.EqOn f g (closure L s) :=
  show closure L s ≤ f.eqLocus g from closure_le.2 h
#align first_order.language.hom.eq_on_closure FirstOrder.Language.Hom.eqOn_closure

/- warning: first_order.language.hom.eq_of_eq_on_top -> FirstOrder.Language.Hom.eq_of_eqOn_top is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {g : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Set.EqOn.{u3, u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) g) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))) -> (Eq.{max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f g)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {g : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Set.EqOn.{u4, u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) g) (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1) (Top.top.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u2, u3, u4} L M _inst_1)))) -> (Eq.{max (succ u4) (succ u1)} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.eq_of_eq_on_top FirstOrder.Language.Hom.eq_of_eqOn_topₓ'. -/
theorem eq_of_eqOn_top {f g : M →[L] N} (h : Set.EqOn f g (⊤ : Substructure L M)) : f = g :=
  ext fun x => h trivial
#align first_order.language.hom.eq_of_eq_on_top FirstOrder.Language.Hom.eq_of_eqOn_top

variable {s : Set M}

/- warning: first_order.language.hom.eq_of_eq_on_dense -> FirstOrder.Language.Hom.eq_of_eqOn_dense is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {s : Set.{u3} M}, (Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) -> (forall {f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {g : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, (Set.EqOn.{u3, u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) g) s) -> (Eq.{max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f g))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] {s : Set.{u4} M}, (Eq.{succ u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (LowerAdjoint.toFun.{u4, u4} (Set.{u4} M) (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (PartialOrder.toPreorder.{u4} (Set.{u4} M) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} M) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} M) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} M) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} M) (Set.instCompleteBooleanAlgebraSet.{u4} M))))))) (PartialOrder.toPreorder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u3, u4} L M _inst_1)))) (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u2, u3, u4} L M _inst_1) s) (Top.top.{u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u2, u3, u4} L M _inst_1))) -> (forall {f : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2} {g : FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2}, (Set.EqOn.{u4, u1} M N (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2) g) s) -> (Eq.{max (succ u4) (succ u1)} (FirstOrder.Language.Hom.{u2, u3, u4, u1} L M N _inst_1 _inst_2) f g))
Case conversion may be inaccurate. Consider using '#align first_order.language.hom.eq_of_eq_on_dense FirstOrder.Language.Hom.eq_of_eqOn_denseₓ'. -/
theorem eq_of_eqOn_dense (hs : closure L s = ⊤) {f g : M →[L] N} (h : s.EqOn f g) : f = g :=
  eq_of_eqOn_top <| hs ▸ eqOn_closure h
#align first_order.language.hom.eq_of_eq_on_dense FirstOrder.Language.Hom.eq_of_eqOn_dense

end Hom

namespace Embedding

open Substructure

#print FirstOrder.Language.Embedding.domRestrict /-
/-- The restriction of a first-order embedding to a substructure `s ⊆ M` gives an embedding `s → N`.
-/
def domRestrict (f : M ↪[L] N) (p : L.Substructure M) : p ↪[L] N :=
  f.comp p.Subtype
#align first_order.language.embedding.dom_restrict FirstOrder.Language.Embedding.domRestrict
-/

/- warning: first_order.language.embedding.dom_restrict_apply -> FirstOrder.Language.Embedding.domRestrict_apply is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (p : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (x : coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p), Eq.{succ u4} N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) N (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 p) _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) N (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 p) _inst_2) => (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) N (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 p) _inst_2) (FirstOrder.Language.Embedding.domRestrict.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f p) x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x p))))) x))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (p : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (x : Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)), Eq.{succ u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) => N) x) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) N (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u4} L M _inst_1 p) _inst_2) (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) (fun (_x : Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) => N) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) N (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u4} L M _inst_1 p) _inst_2) (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) N (FirstOrder.Language.Embedding.embeddingLike.{u2, u3, u4, u1} L (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) N (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u4} L M _inst_1 p) _inst_2)) (FirstOrder.Language.Embedding.domRestrict.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f p) x) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2)) f (Subtype.val.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (Set.{u4} M) (Set.instMembershipSet.{u4} M) x (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1) p)) x))
Case conversion may be inaccurate. Consider using '#align first_order.language.embedding.dom_restrict_apply FirstOrder.Language.Embedding.domRestrict_applyₓ'. -/
@[simp]
theorem domRestrict_apply (f : M ↪[L] N) (p : L.Substructure M) (x : p) : f.domRestrict p x = f x :=
  rfl
#align first_order.language.embedding.dom_restrict_apply FirstOrder.Language.Embedding.domRestrict_apply

#print FirstOrder.Language.Embedding.codRestrict /-
/-- A first-order embedding `f : M → N` whose values lie in a substructure `p ⊆ N` can be restricted
to an embedding `M → p`. -/
def codRestrict (p : L.Substructure N) (f : M ↪[L] N) (h : ∀ c, f c ∈ p) : M ↪[L] p
    where
  toFun := f.toHom.codRestrict p h
  inj' a b ab := f.Injective (Subtype.mk_eq_mk.1 ab)
  map_fun' n F x := (f.toHom.codRestrict p h).map_fun' F x
  map_rel' n r x := by
    simp only
    rw [← p.subtype.map_rel, Function.comp.assoc]
    change rel_map r (hom.comp p.subtype.to_hom (f.to_hom.cod_restrict p h) ∘ x) ↔ _
    rw [hom.subtype_comp_cod_restrict, ← f.map_rel]
    rfl
#align first_order.language.embedding.cod_restrict FirstOrder.Language.Embedding.codRestrict
-/

/- warning: first_order.language.embedding.cod_restrict_apply -> FirstOrder.Language.Embedding.codRestrict_apply is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (p : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {h : forall (c : M), Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f c) p} (x : M), Eq.{succ u4} N ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) N (HasLiftT.mk.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) N (CoeTCₓ.coe.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) N (coeBase.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) N (coeSubtype.{succ u4} N (fun (x : N) => Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) x p))))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 p)) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 p)) => M -> (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p)) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 p)) (FirstOrder.Language.Embedding.codRestrict.{u1, u2, u3, u4} L M N _inst_1 _inst_2 p f h) x)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f x)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (p : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (f : FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) {h : forall (c : M), Membership.mem.{u1, u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) c) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2)) f c) p} (x : M), Eq.{succ u1} N (Subtype.val.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2) p)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x p)) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 p)) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x p)) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x p)) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 p)) M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x p)) (FirstOrder.Language.Embedding.embeddingLike.{u2, u3, u4, u1} L M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x p)) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 p))) (FirstOrder.Language.Embedding.codRestrict.{u2, u3, u4, u1} L M N _inst_1 _inst_2 p f h) x)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2)) f x)
Case conversion may be inaccurate. Consider using '#align first_order.language.embedding.cod_restrict_apply FirstOrder.Language.Embedding.codRestrict_applyₓ'. -/
@[simp]
theorem codRestrict_apply (p : L.Substructure N) (f : M ↪[L] N) {h} (x : M) :
    (codRestrict p f h x : N) = f x :=
  rfl
#align first_order.language.embedding.cod_restrict_apply FirstOrder.Language.Embedding.codRestrict_apply

/- warning: first_order.language.embedding.comp_cod_restrict -> FirstOrder.Language.Embedding.comp_codRestrict is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u5}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] [_inst_3 : FirstOrder.Language.Structure.{u1, u2, u5} L P] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (g : FirstOrder.Language.Embedding.{u1, u2, u4, u5} L N P _inst_2 _inst_3) (p : FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (h : forall (b : N), Membership.Mem.{u5, u5} P (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) (SetLike.hasMem.{u5, u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u5} L P _inst_3)) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (FirstOrder.Language.Embedding.{u1, u2, u4, u5} L N P _inst_2 _inst_3) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u4, u5} L N P _inst_2 _inst_3) => N -> P) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u4, u5} L N P _inst_2 _inst_3) g b) p), Eq.{max (succ u3) (succ u5)} (FirstOrder.Language.Embedding.{u1, u2, u3, u5} L M (coeSort.{succ u5, succ (succ u5)} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u5} L P _inst_3)) p) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u5} L P _inst_3 p)) (FirstOrder.Language.Embedding.comp.{u1, u2, u3, u4, u5} L M N _inst_1 _inst_2 (coeSort.{succ u5, succ (succ u5)} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (FirstOrder.Language.Substructure.{u1, u2, u5} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u5} L P _inst_3)) p) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u5} L P _inst_3 p) (FirstOrder.Language.Embedding.codRestrict.{u1, u2, u4, u5} L N P _inst_2 _inst_3 p g h) f) (FirstOrder.Language.Embedding.codRestrict.{u1, u2, u3, u5} L M P _inst_1 _inst_3 p (FirstOrder.Language.Embedding.comp.{u1, u2, u3, u4, u5} L M N _inst_1 _inst_2 P _inst_3 g f) (fun (b : M) => h (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f b)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u4}} {M : Type.{u5}} {N : Type.{u2}} {P : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u4, u5} L M] [_inst_2 : FirstOrder.Language.Structure.{u3, u4, u2} L N] [_inst_3 : FirstOrder.Language.Structure.{u3, u4, u1} L P] (f : FirstOrder.Language.Embedding.{u3, u4, u5, u2} L M N _inst_1 _inst_2) (g : FirstOrder.Language.Embedding.{u3, u4, u2, u1} L N P _inst_2 _inst_3) (p : FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (h : forall (b : N), Membership.mem.{u1, u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : N) => P) b) (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u3, u4, u1} L P _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u3, u4, u2, u1} L N P _inst_2 _inst_3) N (fun (_x : N) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : N) => P) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u3, u4, u2, u1} L N P _inst_2 _inst_3) N P (FirstOrder.Language.Embedding.embeddingLike.{u3, u4, u2, u1} L N P _inst_2 _inst_3)) g b) p), Eq.{max (succ u5) (succ u1)} (FirstOrder.Language.Embedding.{u3, u4, u5, u1} L M (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u3, u4, u1} L P _inst_3)) x p)) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u3, u4, u1} L P _inst_3 p)) (FirstOrder.Language.Embedding.comp.{u3, u4, u5, u2, u1} L M N _inst_1 _inst_2 (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u4, u1} L P _inst_3) P (FirstOrder.Language.Substructure.instSetLike.{u3, u4, u1} L P _inst_3)) x p)) (FirstOrder.Language.Substructure.inducedStructure.{u3, u4, u1} L P _inst_3 p) (FirstOrder.Language.Embedding.codRestrict.{u3, u4, u2, u1} L N P _inst_2 _inst_3 p g h) f) (FirstOrder.Language.Embedding.codRestrict.{u3, u4, u5, u1} L M P _inst_1 _inst_3 p (FirstOrder.Language.Embedding.comp.{u3, u4, u5, u2, u1} L M N _inst_1 _inst_2 P _inst_3 g f) (fun (b : M) => h (FunLike.coe.{max (succ u5) (succ u2), succ u5, succ u2} (FirstOrder.Language.Embedding.{u3, u4, u5, u2} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u5) (succ u2), succ u5, succ u2} (FirstOrder.Language.Embedding.{u3, u4, u5, u2} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u3, u4, u5, u2} L M N _inst_1 _inst_2)) f b)))
Case conversion may be inaccurate. Consider using '#align first_order.language.embedding.comp_cod_restrict FirstOrder.Language.Embedding.comp_codRestrictₓ'. -/
@[simp]
theorem comp_codRestrict (f : M ↪[L] N) (g : N ↪[L] P) (p : L.Substructure P) (h : ∀ b, g b ∈ p) :
    ((codRestrict p g h).comp f : M ↪[L] p) = codRestrict p (g.comp f) fun b => h _ :=
  ext fun b => rfl
#align first_order.language.embedding.comp_cod_restrict FirstOrder.Language.Embedding.comp_codRestrict

/- warning: first_order.language.embedding.subtype_comp_cod_restrict -> FirstOrder.Language.Embedding.subtype_comp_codRestrict is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (p : FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (h : forall (b : M), Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f b) p), Eq.{max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (FirstOrder.Language.Embedding.comp.{u1, u2, u3, u4, u4} L M (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) p) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 p) N _inst_2 (FirstOrder.Language.Substructure.subtype.{u1, u2, u4} L N _inst_2 p) (FirstOrder.Language.Embedding.codRestrict.{u1, u2, u3, u4} L M N _inst_1 _inst_2 p f h)) f
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (p : FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (h : forall (b : M), Membership.mem.{u1, u1} ((fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) b) (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2)) f b) p), Eq.{max (succ u4) (succ u1)} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (FirstOrder.Language.Embedding.comp.{u2, u3, u4, u1, u1} L M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x p)) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 p) N _inst_2 (FirstOrder.Language.Substructure.subtype.{u2, u3, u1} L N _inst_2 p) (FirstOrder.Language.Embedding.codRestrict.{u2, u3, u4, u1} L M N _inst_1 _inst_2 p f h)) f
Case conversion may be inaccurate. Consider using '#align first_order.language.embedding.subtype_comp_cod_restrict FirstOrder.Language.Embedding.subtype_comp_codRestrictₓ'. -/
@[simp]
theorem subtype_comp_codRestrict (f : M ↪[L] N) (p : L.Substructure N) (h : ∀ b, f b ∈ p) :
    p.Subtype.comp (codRestrict p f h) = f :=
  ext fun b => rfl
#align first_order.language.embedding.subtype_comp_cod_restrict FirstOrder.Language.Embedding.subtype_comp_codRestrict

#print FirstOrder.Language.Embedding.substructureEquivMap /-
/-- The equivalence between a substructure `s` and its image `s.map f.to_hom`, where `f` is an
  embedding. -/
noncomputable def substructureEquivMap (f : M ↪[L] N) (s : L.Substructure M) : s ≃[L] s.map f.toHom
    where
  toFun := codRestrict (s.map f.toHom) (f.domRestrict s) fun ⟨m, hm⟩ => ⟨m, hm, rfl⟩
  invFun n := ⟨Classical.choose n.2, (Classical.choose_spec n.2).1⟩
  left_inv := fun ⟨m, hm⟩ =>
    Subtype.mk_eq_mk.2
      (f.Injective
        (Classical.choose_spec
            (codRestrict (s.map f.toHom) (f.domRestrict s) (fun ⟨m, hm⟩ => ⟨m, hm, rfl⟩)
                ⟨m, hm⟩).2).2)
  right_inv := fun ⟨n, hn⟩ => Subtype.mk_eq_mk.2 (Classical.choose_spec hn).2
#align first_order.language.embedding.substructure_equiv_map FirstOrder.Language.Embedding.substructureEquivMap
-/

/- warning: first_order.language.embedding.substructure_equiv_map_apply -> FirstOrder.Language.Embedding.substructureEquivMap_apply is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (p : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (x : coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p), Eq.{succ u4} N ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p)) N (HasLiftT.mk.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p)) N (CoeTCₓ.coe.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p)) N (coeBase.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p)) N (coeSubtype.{succ u4} N (fun (x : N) => Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) x (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p)))))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Equiv.{u1, u2, u3, u4} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p)) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 p) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p))) (fun (_x : FirstOrder.Language.Equiv.{u1, u2, u3, u4} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p)) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 p) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p))) => (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) -> (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p))) (FirstOrder.Language.Equiv.hasCoeToFun.{u1, u2, u3, u4} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p)) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 p) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) p))) (FirstOrder.Language.Embedding.substructureEquivMap.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f p) x)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) p) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x p))))) x))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (p : FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (x : Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)), Eq.{succ u1} N (Subtype.val.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Equiv.{u2, u3, u4, u1} L (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u4} L M _inst_1 p) (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) (fun (_x : Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.8209 : Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) => Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Equiv.{u2, u3, u4, u1} L (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u4} L M _inst_1 p) (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (EquivLike.toEmbeddingLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Equiv.{u2, u3, u4, u1} L (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u4} L M _inst_1 p) (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (FirstOrder.Language.Equiv.instEquivLikeEquiv.{u2, u3, u4, u1} L (Subtype.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) (SetLike.instMembership.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1)) x p)) (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))) (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u4} L M _inst_1 p) (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 (FirstOrder.Language.Substructure.map.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) p))))) (FirstOrder.Language.Embedding.substructureEquivMap.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f p) x)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2)) f (Subtype.val.{succ u4} M (fun (x : M) => Membership.mem.{u4, u4} M (Set.{u4} M) (Set.instMembershipSet.{u4} M) x (SetLike.coe.{u4, u4} (FirstOrder.Language.Substructure.{u2, u3, u4} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u4} L M _inst_1) p)) x))
Case conversion may be inaccurate. Consider using '#align first_order.language.embedding.substructure_equiv_map_apply FirstOrder.Language.Embedding.substructureEquivMap_applyₓ'. -/
@[simp]
theorem substructureEquivMap_apply (f : M ↪[L] N) (p : L.Substructure M) (x : p) :
    (f.substructureEquivMap p x : N) = f x :=
  rfl
#align first_order.language.embedding.substructure_equiv_map_apply FirstOrder.Language.Embedding.substructureEquivMap_apply

#print FirstOrder.Language.Embedding.equivRange /-
/-- The equivalence between the domain and the range of an embedding `f`. -/
noncomputable def equivRange (f : M ↪[L] N) : M ≃[L] f.toHom.range
    where
  toFun := codRestrict f.toHom.range f f.toHom.mem_range_self
  invFun n := Classical.choose n.2
  left_inv m :=
    f.Injective (Classical.choose_spec (codRestrict f.toHom.range f f.toHom.mem_range_self m).2)
  right_inv := fun ⟨n, hn⟩ => Subtype.mk_eq_mk.2 (Classical.choose_spec hn)
#align first_order.language.embedding.equiv_range FirstOrder.Language.Embedding.equivRange
-/

/- warning: first_order.language.embedding.equiv_range_apply -> FirstOrder.Language.Embedding.equivRange_apply is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (x : M), Eq.{succ u4} N ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))) N (HasLiftT.mk.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))) N (CoeTCₓ.coe.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))) N (coeBase.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))) N (coeSubtype.{succ u4} N (fun (x : N) => Membership.Mem.{u4, u4} N (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (SetLike.hasMem.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))))))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Equiv.{u1, u2, u3, u4} L M (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)))) (fun (_x : FirstOrder.Language.Equiv.{u1, u2, u3, u4} L M (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)))) => M -> (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)))) (FirstOrder.Language.Equiv.hasCoeToFun.{u1, u2, u3, u4} L M (coeSort.{succ u4, succ (succ u4)} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u4} L N _inst_2)) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)))) (FirstOrder.Language.Embedding.equivRange.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) x)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f x)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) (x : M), Eq.{succ u1} N (Subtype.val.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (Set.{u1} N) (Set.instMembershipSet.{u1} N) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Equiv.{u2, u3, u4, u1} L M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.8209 : M) => Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Equiv.{u2, u3, u4, u1} L M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) (EquivLike.toEmbeddingLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Equiv.{u2, u3, u4, u1} L M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) (FirstOrder.Language.Equiv.instEquivLikeEquiv.{u2, u3, u4, u1} L M (Subtype.{succ u1} N (fun (x : N) => Membership.mem.{u1, u1} N (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) N (FirstOrder.Language.Substructure.instSetLike.{u2, u3, u1} L N _inst_2)) x (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))) _inst_1 (FirstOrder.Language.Substructure.inducedStructure.{u2, u3, u1} L N _inst_2 (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)))))) (FirstOrder.Language.Embedding.equivRange.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f) x)) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u4, succ u1} (FirstOrder.Language.Embedding.{u2, u3, u4, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u2, u3, u4, u1} L M N _inst_1 _inst_2)) f x)
Case conversion may be inaccurate. Consider using '#align first_order.language.embedding.equiv_range_apply FirstOrder.Language.Embedding.equivRange_applyₓ'. -/
@[simp]
theorem equivRange_apply (f : M ↪[L] N) (x : M) : (f.equivRange x : N) = f x :=
  rfl
#align first_order.language.embedding.equiv_range_apply FirstOrder.Language.Embedding.equivRange_apply

end Embedding

namespace Equiv

/- warning: first_order.language.equiv.to_hom_range -> FirstOrder.Language.Equiv.toHom_range is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Equiv.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{succ u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Equiv.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (Top.top.{u4} (FirstOrder.Language.Substructure.{u1, u2, u4} L N _inst_2) (FirstOrder.Language.Substructure.instTop.{u1, u2, u4} L N _inst_2))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u3}} {M : Type.{u4}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u2, u3, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u3, u1} L N] (f : FirstOrder.Language.Equiv.{u2, u3, u4, u1} L M N _inst_1 _inst_2), Eq.{succ u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Hom.range.{u2, u3, u4, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Equiv.toHom.{u2, u3, u4, u1} L M N _inst_1 _inst_2 f)) (Top.top.{u1} (FirstOrder.Language.Substructure.{u2, u3, u1} L N _inst_2) (FirstOrder.Language.Substructure.instTop.{u2, u3, u1} L N _inst_2))
Case conversion may be inaccurate. Consider using '#align first_order.language.equiv.to_hom_range FirstOrder.Language.Equiv.toHom_rangeₓ'. -/
theorem toHom_range (f : M ≃[L] N) : f.toHom.range = ⊤ :=
  by
  ext n
  simp only [hom.mem_range, coe_to_hom, substructure.mem_top, iff_true_iff]
  exact ⟨f.symm n, apply_symm_apply _ _⟩
#align first_order.language.equiv.to_hom_range FirstOrder.Language.Equiv.toHom_range

end Equiv

namespace Substructure

/- warning: first_order.language.substructure.inclusion -> FirstOrder.Language.Substructure.inclusion is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {T : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S T) -> (FirstOrder.Language.Embedding.{u1, u2, u3, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) T) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 T))
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {T : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, (LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) S T) -> (FirstOrder.Language.Embedding.{u1, u2, u3, u3} L (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x T)) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 T))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.inclusion FirstOrder.Language.Substructure.inclusionₓ'. -/
/-- The embedding associated to an inclusion of substructures. -/
def inclusion {S T : L.Substructure M} (h : S ≤ T) : S ↪[L] T :=
  S.Subtype.codRestrict _ fun x => h x.2
#align first_order.language.substructure.inclusion FirstOrder.Language.Substructure.inclusion

/- warning: first_order.language.substructure.coe_inclusion -> FirstOrder.Language.Substructure.coe_inclusion is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {T : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} (h : LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S T), Eq.{succ u3} ((fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) T) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 T)) => (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) -> (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) T)) (FirstOrder.Language.Substructure.inclusion.{u1, u2, u3} L M _inst_1 S T h)) (coeFn.{succ u3, succ u3} (FirstOrder.Language.Embedding.{u1, u2, u3, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) T) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 T)) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) T) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 T)) => (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) -> (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) T)) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) T) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 T)) (FirstOrder.Language.Substructure.inclusion.{u1, u2, u3} L M _inst_1 S T h)) (Set.inclusion.{u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Set.{u3} M) (Set.hasMem.{u3} M) x ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) S)) (fun (x : M) => Membership.Mem.{u3, u3} M (Set.{u3} M) (Set.hasMem.{u3} M) x ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) T)) h)
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {T : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} (h : LE.le.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Preorder.toLE.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) S T), Eq.{succ u3} (forall (a : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)), (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x T)) a) (FunLike.coe.{succ u3, succ u3, succ u3} (FirstOrder.Language.Embedding.{u1, u2, u3, u3} L (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x T)) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 T)) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) (fun (_x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x T)) _x) (EmbeddingLike.toFunLike.{succ u3, succ u3, succ u3} (FirstOrder.Language.Embedding.{u1, u2, u3, u3} L (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x T)) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 T)) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x T)) (FirstOrder.Language.Embedding.embeddingLike.{u1, u2, u3, u3} L (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x T)) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 T))) (FirstOrder.Language.Substructure.inclusion.{u1, u2, u3} L M _inst_1 S T h)) (Set.inclusion.{u3} M (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) S) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) T) h)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.coe_inclusion FirstOrder.Language.Substructure.coe_inclusionₓ'. -/
@[simp]
theorem coe_inclusion {S T : L.Substructure M} (h : S ≤ T) :
    (inclusion h : S → T) = Set.inclusion h :=
  rfl
#align first_order.language.substructure.coe_inclusion FirstOrder.Language.Substructure.coe_inclusion

#print FirstOrder.Language.Substructure.range_subtype /-
theorem range_subtype (S : L.Substructure M) : S.Subtype.toHom.range = S :=
  by
  ext x
  simp only [hom.mem_range, embedding.coe_to_hom, coeSubtype]
  refine' ⟨_, fun h => ⟨⟨x, h⟩, rfl⟩⟩
  rintro ⟨⟨y, hy⟩, rfl⟩
  exact hy
#align first_order.language.substructure.range_subtype FirstOrder.Language.Substructure.range_subtype
-/

end Substructure

end Language

end FirstOrder

