/-
Copyright (c) 2022 Aaron Anderson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Anderson

! This file was ported from Lean 3 source module model_theory.elementary_maps
! leanprover-community/mathlib commit dbdf71cee7bb20367cb7e37279c08b0c218cf967
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Fintype.Basic
import Mathbin.ModelTheory.Substructures

/-!
# Elementary Maps Between First-Order Structures

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main Definitions
* A `first_order.language.elementary_embedding` is an embedding that commutes with the
  realizations of formulas.
* A `first_order.language.elementary_substructure` is a substructure where the realization of each
  formula agrees with the realization in the larger model.
* The `first_order.language.elementary_diagram` of a structure is the set of all sentences with
  parameters that the structure satisfies.
* `first_order.language.elementary_embedding.of_models_elementary_diagram` is the canonical
elementary embedding of any structure into a model of its elementary diagram.

## Main Results
* The Tarski-Vaught Test for embeddings: `first_order.language.embedding.is_elementary_of_exists`
gives a simple criterion for an embedding to be elementary.
* The Tarski-Vaught Test for substructures: `first_order.language.embedding.is_elementary_of_exists`
gives a simple criterion for a substructure to be elementary.
 -/


open FirstOrder

namespace FirstOrder

namespace Language

open Structure

variable (L : Language) (M : Type _) (N : Type _) {P : Type _} {Q : Type _}

variable [L.Structure M] [L.Structure N] [L.Structure P] [L.Structure Q]

#print FirstOrder.Language.ElementaryEmbedding /-
/-- An elementary embedding of first-order structures is an embedding that commutes with the
  realizations of formulas. -/
structure ElementaryEmbedding where
  toFun : M → N
  map_formula' :
    ∀ ⦃n⦄ (φ : L.Formula (Fin n)) (x : Fin n → M), φ.realize (to_fun ∘ x) ↔ φ.realize x := by
    obviously
#align first_order.language.elementary_embedding FirstOrder.Language.ElementaryEmbedding
-/

-- mathport name: elementary_embedding
scoped[FirstOrder] notation:25 A " ↪ₑ[" L "] " B => FirstOrder.Language.ElementaryEmbedding L A B

variable {L} {M} {N}

namespace ElementaryEmbedding

#print FirstOrder.Language.ElementaryEmbedding.funLike /-
instance funLike : FunLike (M ↪ₑ[L] N) M fun _ => N
    where
  coe f := f.toFun
  coe_injective' f g h := by
    cases f
    cases g
    simp only
    ext x
    exact Function.funext_iff.1 h x
#align first_order.language.elementary_embedding.fun_like FirstOrder.Language.ElementaryEmbedding.funLike
-/

instance : CoeFun (M ↪ₑ[L] N) fun _ => M → N :=
  FunLike.hasCoeToFun

/- warning: first_order.language.elementary_embedding.map_bounded_formula -> FirstOrder.Language.ElementaryEmbedding.map_boundedFormula is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {α : Type.{u5}} {n : Nat} (φ : FirstOrder.Language.BoundedFormula.{u1, u2, u5} L α n) (v : α -> M) (xs : (Fin n) -> M), Iff (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u4, u5} L N _inst_2 α n φ (Function.comp.{succ u5, succ u3, succ u4} α M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) v) (Function.comp.{1, succ u3, succ u4} (Fin n) M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) xs)) (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u3, u5} L M _inst_1 α n φ v xs)
but is expected to have type
  forall {L : FirstOrder.Language.{u5, u4}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : FirstOrder.Language.Structure.{u5, u4, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u5, u4, u2} L N] (f : FirstOrder.Language.ElementaryEmbedding.{u5, u4, u3, u2} L M N _inst_1 _inst_2) {α : Type.{u1}} {n : Nat} (φ : FirstOrder.Language.BoundedFormula.{u5, u4, u1} L α n) (v : α -> M) (xs : (Fin n) -> M), Iff (FirstOrder.Language.BoundedFormula.Realize.{u5, u4, u2, u1} L N _inst_2 α n φ (Function.comp.{succ u1, succ u3, succ u2} α M N (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (FirstOrder.Language.ElementaryEmbedding.{u5, u4, u3, u2} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u5, u4, u3, u2} L M N _inst_1 _inst_2) f) v) (Function.comp.{1, succ u3, succ u2} (Fin n) M N (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (FirstOrder.Language.ElementaryEmbedding.{u5, u4, u3, u2} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u5, u4, u3, u2} L M N _inst_1 _inst_2) f) xs)) (FirstOrder.Language.BoundedFormula.Realize.{u5, u4, u3, u1} L M _inst_1 α n φ v xs)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.map_bounded_formula FirstOrder.Language.ElementaryEmbedding.map_boundedFormulaₓ'. -/
@[simp]
theorem map_boundedFormula (f : M ↪ₑ[L] N) {α : Type _} {n : ℕ} (φ : L.BoundedFormula α n)
    (v : α → M) (xs : Fin n → M) : φ.realize (f ∘ v) (f ∘ xs) ↔ φ.realize v xs := by
  classical
    rw [← bounded_formula.realize_restrict_free_var Set.Subset.rfl, Set.inclusion_eq_id, iff_eq_eq]
    swap
    · infer_instance
    have h :=
      f.map_formula' ((φ.restrict_free_var id).toFormula.relabel (Fintype.equivFin _))
        (Sum.elim (v ∘ coe) xs ∘ (Fintype.equivFin _).symm)
    simp only [formula.realize_relabel, bounded_formula.realize_to_formula, iff_eq_eq] at h
    rw [← Function.comp.assoc _ _ (Fintype.equivFin _).symm,
      Function.comp.assoc _ (Fintype.equivFin _).symm (Fintype.equivFin _), Equiv.symm_comp_self,
      Function.comp.right_id, Function.comp.assoc, Sum.elim_comp_inl,
      Function.comp.assoc _ _ Sum.inr, Sum.elim_comp_inr, ← Function.comp.assoc] at h
    refine' h.trans _
    rw [Function.comp.assoc _ _ (Fintype.equivFin _), Equiv.symm_comp_self, Function.comp.right_id,
      Sum.elim_comp_inl, Sum.elim_comp_inr, ← Set.inclusion_eq_id,
      bounded_formula.realize_restrict_free_var Set.Subset.rfl]
#align first_order.language.elementary_embedding.map_bounded_formula FirstOrder.Language.ElementaryEmbedding.map_boundedFormula

/- warning: first_order.language.elementary_embedding.map_formula -> FirstOrder.Language.ElementaryEmbedding.map_formula is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {α : Type.{u5}} (φ : FirstOrder.Language.Formula.{u1, u2, u5} L α) (x : α -> M), Iff (FirstOrder.Language.Formula.Realize.{u1, u2, u4, u5} L N _inst_2 α φ (Function.comp.{succ u5, succ u3, succ u4} α M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) x)) (FirstOrder.Language.Formula.Realize.{u1, u2, u3, u5} L M _inst_1 α φ x)
but is expected to have type
  forall {L : FirstOrder.Language.{u5, u4}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : FirstOrder.Language.Structure.{u5, u4, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u5, u4, u2} L N] (f : FirstOrder.Language.ElementaryEmbedding.{u5, u4, u3, u2} L M N _inst_1 _inst_2) {α : Type.{u1}} (φ : FirstOrder.Language.Formula.{u5, u4, u1} L α) (x : α -> M), Iff (FirstOrder.Language.Formula.Realize.{u5, u4, u2, u1} L N _inst_2 α φ (Function.comp.{succ u1, succ u3, succ u2} α M N (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (FirstOrder.Language.ElementaryEmbedding.{u5, u4, u3, u2} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u5, u4, u3, u2} L M N _inst_1 _inst_2) f) x)) (FirstOrder.Language.Formula.Realize.{u5, u4, u3, u1} L M _inst_1 α φ x)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.map_formula FirstOrder.Language.ElementaryEmbedding.map_formulaₓ'. -/
@[simp]
theorem map_formula (f : M ↪ₑ[L] N) {α : Type _} (φ : L.Formula α) (x : α → M) :
    φ.realize (f ∘ x) ↔ φ.realize x := by
  rw [formula.realize, formula.realize, ← f.map_bounded_formula, Unique.eq_default (f ∘ default)]
#align first_order.language.elementary_embedding.map_formula FirstOrder.Language.ElementaryEmbedding.map_formula

/- warning: first_order.language.elementary_embedding.map_sentence -> FirstOrder.Language.ElementaryEmbedding.map_sentence is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) -> (forall (φ : FirstOrder.Language.Sentence.{u1, u2} L), Iff (FirstOrder.Language.Sentence.Realize.{u1, u2, u3} L M _inst_1 φ) (FirstOrder.Language.Sentence.Realize.{u1, u2, u4} L N _inst_2 φ))
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N], (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) -> (forall (φ : FirstOrder.Language.Sentence.{u4, u3} L), Iff (FirstOrder.Language.Sentence.Realize.{u4, u3, u2} L M _inst_1 φ) (FirstOrder.Language.Sentence.Realize.{u4, u3, u1} L N _inst_2 φ))
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.map_sentence FirstOrder.Language.ElementaryEmbedding.map_sentenceₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem map_sentence (f : M ↪ₑ[L] N) (φ : L.Sentence) : M ⊨ φ ↔ N ⊨ φ := by
  rw [sentence.realize, sentence.realize, ← f.map_formula, Unique.eq_default (f ∘ default)]
#align first_order.language.elementary_embedding.map_sentence FirstOrder.Language.ElementaryEmbedding.map_sentence

/- warning: first_order.language.elementary_embedding.Theory_model_iff -> FirstOrder.Language.ElementaryEmbedding.theory_model_iff is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) -> (forall (T : FirstOrder.Language.Theory.{u1, u2} L), Iff (FirstOrder.Language.Theory.Model.{u1, u2, u3} L M _inst_1 T) (FirstOrder.Language.Theory.Model.{u1, u2, u4} L N _inst_2 T))
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N], (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) -> (forall (T : FirstOrder.Language.Theory.{u4, u3} L), Iff (FirstOrder.Language.Theory.Model.{u4, u3, u2} L M _inst_1 T) (FirstOrder.Language.Theory.Model.{u4, u3, u1} L N _inst_2 T))
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.Theory_model_iff FirstOrder.Language.ElementaryEmbedding.theory_model_iffₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem theory_model_iff (f : M ↪ₑ[L] N) (T : L.Theory) : M ⊨ T ↔ N ⊨ T := by
  simp only [Theory.model_iff, f.map_sentence]
#align first_order.language.elementary_embedding.Theory_model_iff FirstOrder.Language.ElementaryEmbedding.theory_model_iff

/- warning: first_order.language.elementary_embedding.elementarily_equivalent -> FirstOrder.Language.ElementaryEmbedding.elementarilyEquivalent is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) -> (FirstOrder.Language.ElementarilyEquivalent.{u1, u2, u3, u4} L M N _inst_1 _inst_2)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N], (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) -> (FirstOrder.Language.ElementarilyEquivalent.{u4, u3, u2, u1} L M N _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.elementarily_equivalent FirstOrder.Language.ElementaryEmbedding.elementarilyEquivalentₓ'. -/
theorem elementarilyEquivalent (f : M ↪ₑ[L] N) : M ≅[L] N :=
  elementarilyEquivalent_iff.2 f.map_sentence
#align first_order.language.elementary_embedding.elementarily_equivalent FirstOrder.Language.ElementaryEmbedding.elementarilyEquivalent

/- warning: first_order.language.elementary_embedding.injective -> FirstOrder.Language.ElementaryEmbedding.injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (φ : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Function.Injective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) φ)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] (φ : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2), Function.Injective.{succ u2, succ u1} M N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) φ)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.injective FirstOrder.Language.ElementaryEmbedding.injectiveₓ'. -/
@[simp]
theorem injective (φ : M ↪ₑ[L] N) : Function.Injective φ :=
  by
  intro x y
  have h :=
    φ.map_formula ((var 0).equal (var 1) : L.formula (Fin 2)) fun i => if i = 0 then x else y
  rw [formula.realize_equal, formula.realize_equal] at h
  simp only [Nat.one_ne_zero, term.realize, Fin.one_eq_zero_iff, if_true, eq_self_iff_true,
    Function.comp_apply, if_false] at h
  exact h.1
#align first_order.language.elementary_embedding.injective FirstOrder.Language.ElementaryEmbedding.injective

#print FirstOrder.Language.ElementaryEmbedding.embeddingLike /-
instance embeddingLike : EmbeddingLike (M ↪ₑ[L] N) M N :=
  { show FunLike (M ↪ₑ[L] N) M fun _ => N from inferInstance with injective' := injective }
#align first_order.language.elementary_embedding.embedding_like FirstOrder.Language.ElementaryEmbedding.embeddingLike
-/

/- warning: first_order.language.elementary_embedding.map_fun -> FirstOrder.Language.ElementaryEmbedding.map_fun is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (φ : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {n : Nat} (f : FirstOrder.Language.Functions.{u1, u2} L n) (x : (Fin n) -> M), Eq.{succ u4} N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) φ (FirstOrder.Language.Structure.funMap.{u1, u2, u3} L M _inst_1 n f x)) (FirstOrder.Language.Structure.funMap.{u1, u2, u4} L N _inst_2 n f (Function.comp.{1, succ u3, succ u4} (Fin n) M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) φ) x))
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] (φ : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) {n : Nat} (f : FirstOrder.Language.Functions.{u4, u3} L n) (x : (Fin n) -> M), Eq.{succ u1} ((fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) (FirstOrder.Language.Structure.funMap.{u4, u3, u2} L M _inst_1 n f x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) φ (FirstOrder.Language.Structure.funMap.{u4, u3, u2} L M _inst_1 n f x)) (FirstOrder.Language.Structure.funMap.{u4, u3, u1} L N _inst_2 n f (Function.comp.{1, succ u2, succ u1} (Fin n) M N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) φ) x))
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.map_fun FirstOrder.Language.ElementaryEmbedding.map_funₓ'. -/
@[simp]
theorem map_fun (φ : M ↪ₑ[L] N) {n : ℕ} (f : L.Functions n) (x : Fin n → M) :
    φ (funMap f x) = funMap f (φ ∘ x) :=
  by
  have h := φ.map_formula (formula.graph f) (Fin.cons (fun_map f x) x)
  rw [formula.realize_graph, Fin.comp_cons, formula.realize_graph] at h
  rw [eq_comm, h]
#align first_order.language.elementary_embedding.map_fun FirstOrder.Language.ElementaryEmbedding.map_fun

/- warning: first_order.language.elementary_embedding.map_rel -> FirstOrder.Language.ElementaryEmbedding.map_rel is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (φ : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {n : Nat} (r : FirstOrder.Language.Relations.{u1, u2} L n) (x : (Fin n) -> M), Iff (FirstOrder.Language.Structure.RelMap.{u1, u2, u4} L N _inst_2 n r (Function.comp.{1, succ u3, succ u4} (Fin n) M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) φ) x)) (FirstOrder.Language.Structure.RelMap.{u1, u2, u3} L M _inst_1 n r x)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] (φ : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) {n : Nat} (r : FirstOrder.Language.Relations.{u4, u3} L n) (x : (Fin n) -> M), Iff (FirstOrder.Language.Structure.RelMap.{u4, u3, u1} L N _inst_2 n r (Function.comp.{1, succ u2, succ u1} (Fin n) M N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) φ) x)) (FirstOrder.Language.Structure.RelMap.{u4, u3, u2} L M _inst_1 n r x)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.map_rel FirstOrder.Language.ElementaryEmbedding.map_relₓ'. -/
@[simp]
theorem map_rel (φ : M ↪ₑ[L] N) {n : ℕ} (r : L.Relations n) (x : Fin n → M) :
    RelMap r (φ ∘ x) ↔ RelMap r x :=
  haveI h := φ.map_formula (r.formula var) x
  h
#align first_order.language.elementary_embedding.map_rel FirstOrder.Language.ElementaryEmbedding.map_rel

/- warning: first_order.language.elementary_embedding.strong_hom_class -> FirstOrder.Language.ElementaryEmbedding.strongHomClass is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], FirstOrder.Language.StrongHomClass.{u1, u2, max u3 u4, u3, u4} L (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M N (FirstOrder.Language.ElementaryEmbedding.funLike.{u1, u2, u3, u4} L M N _inst_1 _inst_2) _inst_1 _inst_2
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], FirstOrder.Language.StrongHomClass.{u2, u1, max u4 u3, u3, u4} L (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M N (FirstOrder.Language.ElementaryEmbedding.funLike.{u1, u2, u3, u4} L M N _inst_1 _inst_2) _inst_1 _inst_2
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.strong_hom_class FirstOrder.Language.ElementaryEmbedding.strongHomClassₓ'. -/
instance strongHomClass : StrongHomClass L (M ↪ₑ[L] N) M N
    where
  map_fun := map_fun
  map_rel := map_rel
#align first_order.language.elementary_embedding.strong_hom_class FirstOrder.Language.ElementaryEmbedding.strongHomClass

/- warning: first_order.language.elementary_embedding.map_constants -> FirstOrder.Language.ElementaryEmbedding.map_constants is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (φ : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (c : FirstOrder.Language.Constants.{u1, u2} L), Eq.{succ u4} N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) φ ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) (FirstOrder.Language.Constants.{u1, u2} L) M (HasLiftT.mk.{succ u1, succ u3} (FirstOrder.Language.Constants.{u1, u2} L) M (CoeTCₓ.coe.{succ u1, succ u3} (FirstOrder.Language.Constants.{u1, u2} L) M (FirstOrder.Language.hasCoeT.{u1, u2, u3} L M _inst_1))) c)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) (FirstOrder.Language.Constants.{u1, u2} L) N (HasLiftT.mk.{succ u1, succ u4} (FirstOrder.Language.Constants.{u1, u2} L) N (CoeTCₓ.coe.{succ u1, succ u4} (FirstOrder.Language.Constants.{u1, u2} L) N (FirstOrder.Language.hasCoeT.{u1, u2, u4} L N _inst_2))) c)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] (φ : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) (c : FirstOrder.Language.Constants.{u4, u3} L), Eq.{succ u1} ((fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) (FirstOrder.Language.constantMap.{u4, u3, u2} L M _inst_1 c)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) φ (FirstOrder.Language.constantMap.{u4, u3, u2} L M _inst_1 c)) (FirstOrder.Language.constantMap.{u4, u3, u1} L ((fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) (FirstOrder.Language.constantMap.{u4, u3, u2} L M _inst_1 c)) _inst_2 c)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.map_constants FirstOrder.Language.ElementaryEmbedding.map_constantsₓ'. -/
@[simp]
theorem map_constants (φ : M ↪ₑ[L] N) (c : L.Constants) : φ c = c :=
  HomClass.map_constants φ c
#align first_order.language.elementary_embedding.map_constants FirstOrder.Language.ElementaryEmbedding.map_constants

#print FirstOrder.Language.ElementaryEmbedding.toEmbedding /-
/-- An elementary embedding is also a first-order embedding. -/
def toEmbedding (f : M ↪ₑ[L] N) : M ↪[L] N
    where
  toFun := f
  inj' := f.Injective
#align first_order.language.elementary_embedding.to_embedding FirstOrder.Language.ElementaryEmbedding.toEmbedding
-/

#print FirstOrder.Language.ElementaryEmbedding.toHom /-
/-- An elementary embedding is also a first-order homomorphism. -/
def toHom (f : M ↪ₑ[L] N) : M →[L] N where toFun := f
#align first_order.language.elementary_embedding.to_hom FirstOrder.Language.ElementaryEmbedding.toHom
-/

/- warning: first_order.language.elementary_embedding.to_embedding_to_hom -> FirstOrder.Language.ElementaryEmbedding.toEmbedding_toHom is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.ElementaryEmbedding.toEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (FirstOrder.Language.ElementaryEmbedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] (f : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (FirstOrder.Language.Hom.{u4, u3, u2, u1} L M N _inst_1 _inst_2) (FirstOrder.Language.Embedding.toHom.{u4, u3, u2, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.ElementaryEmbedding.toEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2 f)) (FirstOrder.Language.ElementaryEmbedding.toHom.{u4, u3, u2, u1} L M N _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.to_embedding_to_hom FirstOrder.Language.ElementaryEmbedding.toEmbedding_toHomₓ'. -/
@[simp]
theorem toEmbedding_toHom (f : M ↪ₑ[L] N) : f.toEmbedding.toHom = f.toHom :=
  rfl
#align first_order.language.elementary_embedding.to_embedding_to_hom FirstOrder.Language.ElementaryEmbedding.toEmbedding_toHom

/- warning: first_order.language.elementary_embedding.coe_to_hom -> FirstOrder.Language.ElementaryEmbedding.coe_toHom is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, Eq.{max (succ u3) (succ u4)} ((fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (FirstOrder.Language.ElementaryEmbedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] {f : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2}, Eq.{max (succ u2) (succ u1)} (forall (a : M), (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Hom.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) (FirstOrder.Language.ElementaryEmbedding.toHom.{u4, u3, u2, u1} L M N _inst_1 _inst_2 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) f)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.coe_to_hom FirstOrder.Language.ElementaryEmbedding.coe_toHomₓ'. -/
@[simp]
theorem coe_toHom {f : M ↪ₑ[L] N} : (f.toHom : M → N) = (f : M → N) :=
  rfl
#align first_order.language.elementary_embedding.coe_to_hom FirstOrder.Language.ElementaryEmbedding.coe_toHom

/- warning: first_order.language.elementary_embedding.coe_to_embedding -> FirstOrder.Language.ElementaryEmbedding.coe_toEmbedding is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{max (succ u3) (succ u4)} ((fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.toEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (FirstOrder.Language.ElementaryEmbedding.toEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] (f : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (forall (a : M), (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2)) (FirstOrder.Language.ElementaryEmbedding.toEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) f)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.coe_to_embedding FirstOrder.Language.ElementaryEmbedding.coe_toEmbeddingₓ'. -/
@[simp]
theorem coe_toEmbedding (f : M ↪ₑ[L] N) : (f.toEmbedding : M → N) = (f : M → N) :=
  rfl
#align first_order.language.elementary_embedding.coe_to_embedding FirstOrder.Language.ElementaryEmbedding.coe_toEmbedding

/- warning: first_order.language.elementary_embedding.coe_injective -> FirstOrder.Language.ElementaryEmbedding.coe_injective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], Function.Injective.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (M -> N) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (ᾰ : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u1}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u2, u1, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u2, u1, u4} L N], Function.Injective.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u2, u1, u3, u4} L M N _inst_1 _inst_2) (M -> N) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (FirstOrder.Language.ElementaryEmbedding.{u2, u1, u3, u4} L M N _inst_1 _inst_2) M (fun (ᾰ : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) ᾰ) (FirstOrder.Language.ElementaryEmbedding.funLike.{u2, u1, u3, u4} L M N _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.coe_injective FirstOrder.Language.ElementaryEmbedding.coe_injectiveₓ'. -/
theorem coe_injective : @Function.Injective (M ↪ₑ[L] N) (M → N) coeFn :=
  FunLike.coe_injective
#align first_order.language.elementary_embedding.coe_injective FirstOrder.Language.ElementaryEmbedding.coe_injective

/- warning: first_order.language.elementary_embedding.ext -> FirstOrder.Language.ElementaryEmbedding.ext is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {{f : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2}} {{g : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2}}, (forall (x : M), Eq.{succ u4} N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) g x)) -> (Eq.{max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f g)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] {{f : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2}} {{g : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2}}, (forall (x : M), Eq.{succ u1} ((fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) g x)) -> (Eq.{max (succ u2) (succ u1)} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.ext FirstOrder.Language.ElementaryEmbedding.extₓ'. -/
@[ext]
theorem ext ⦃f g : M ↪ₑ[L] N⦄ (h : ∀ x, f x = g x) : f = g :=
  FunLike.ext f g h
#align first_order.language.elementary_embedding.ext FirstOrder.Language.ElementaryEmbedding.ext

/- warning: first_order.language.elementary_embedding.ext_iff -> FirstOrder.Language.ElementaryEmbedding.ext_iff is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] {f : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2} {g : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2}, Iff (Eq.{max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f g) (forall (x : M), Eq.{succ u4} N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) g x))
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] {f : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2} {g : FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2}, Iff (Eq.{max (succ u2) (succ u1)} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) f g) (forall (x : M), Eq.{succ u1} ((fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) g x))
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.ext_iff FirstOrder.Language.ElementaryEmbedding.ext_iffₓ'. -/
theorem ext_iff {f g : M ↪ₑ[L] N} : f = g ↔ ∀ x, f x = g x :=
  FunLike.ext_iff
#align first_order.language.elementary_embedding.ext_iff FirstOrder.Language.ElementaryEmbedding.ext_iff

variable (L) (M)

#print FirstOrder.Language.ElementaryEmbedding.refl /-
/-- The identity elementary embedding from a structure to itself -/
@[refl]
def refl : M ↪ₑ[L] M where toFun := id
#align first_order.language.elementary_embedding.refl FirstOrder.Language.ElementaryEmbedding.refl
-/

variable {L} {M}

instance : Inhabited (M ↪ₑ[L] M) :=
  ⟨refl L M⟩

/- warning: first_order.language.elementary_embedding.refl_apply -> FirstOrder.Language.ElementaryEmbedding.refl_apply is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (x : M), Eq.{succ u3} M (coeFn.{succ u3, succ u3} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u3} L M M _inst_1 _inst_1) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u3} L M M _inst_1 _inst_1) => M -> M) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u3} L M M _inst_1 _inst_1) (FirstOrder.Language.ElementaryEmbedding.refl.{u1, u2, u3} L M _inst_1) x) x
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u1}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u2, u1, u3} L M] (x : M), Eq.{succ u3} ((fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => M) x) (FunLike.coe.{succ u3, succ u3, succ u3} (FirstOrder.Language.ElementaryEmbedding.{u2, u1, u3, u3} L M M _inst_1 _inst_1) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => M) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u2, u1, u3, u3} L M M _inst_1 _inst_1) (FirstOrder.Language.ElementaryEmbedding.refl.{u2, u1, u3} L M _inst_1) x) x
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.refl_apply FirstOrder.Language.ElementaryEmbedding.refl_applyₓ'. -/
@[simp]
theorem refl_apply (x : M) : refl L M x = x :=
  rfl
#align first_order.language.elementary_embedding.refl_apply FirstOrder.Language.ElementaryEmbedding.refl_apply

#print FirstOrder.Language.ElementaryEmbedding.comp /-
/-- Composition of elementary embeddings -/
@[trans]
def comp (hnp : N ↪ₑ[L] P) (hmn : M ↪ₑ[L] N) : M ↪ₑ[L] P where toFun := hnp ∘ hmn
#align first_order.language.elementary_embedding.comp FirstOrder.Language.ElementaryEmbedding.comp
-/

/- warning: first_order.language.elementary_embedding.comp_apply -> FirstOrder.Language.ElementaryEmbedding.comp_apply is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u5}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] [_inst_3 : FirstOrder.Language.Structure.{u1, u2, u5} L P] (g : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u4, u5} L N P _inst_2 _inst_3) (f : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (x : M), Eq.{succ u5} P (coeFn.{max (succ u3) (succ u5), max (succ u3) (succ u5)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u5} L M P _inst_1 _inst_3) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u5} L M P _inst_1 _inst_3) => M -> P) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u5} L M P _inst_1 _inst_3) (FirstOrder.Language.ElementaryEmbedding.comp.{u1, u2, u3, u4, u5} L M N P _inst_1 _inst_2 _inst_3 g f) x) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u4, u5} L N P _inst_2 _inst_3) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u4, u5} L N P _inst_2 _inst_3) => N -> P) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u4, u5} L N P _inst_2 _inst_3) g (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f x))
but is expected to have type
  forall {L : FirstOrder.Language.{u5, u4}} {M : Type.{u1}} {N : Type.{u3}} {P : Type.{u2}} [_inst_1 : FirstOrder.Language.Structure.{u5, u4, u1} L M] [_inst_2 : FirstOrder.Language.Structure.{u5, u4, u3} L N] [_inst_3 : FirstOrder.Language.Structure.{u5, u4, u2} L P] (g : FirstOrder.Language.ElementaryEmbedding.{u5, u4, u3, u2} L N P _inst_2 _inst_3) (f : FirstOrder.Language.ElementaryEmbedding.{u5, u4, u1, u3} L M N _inst_1 _inst_2) (x : M), Eq.{succ u2} ((fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => P) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (FirstOrder.Language.ElementaryEmbedding.{u5, u4, u1, u2} L M P _inst_1 _inst_3) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => P) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u5, u4, u1, u2} L M P _inst_1 _inst_3) (FirstOrder.Language.ElementaryEmbedding.comp.{u5, u4, u1, u3, u2} L M N P _inst_1 _inst_2 _inst_3 g f) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (FirstOrder.Language.ElementaryEmbedding.{u5, u4, u3, u2} L N P _inst_2 _inst_3) N (fun (_x : N) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : N) => P) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u5, u4, u3, u2} L N P _inst_2 _inst_3) g (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (FirstOrder.Language.ElementaryEmbedding.{u5, u4, u1, u3} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u5, u4, u1, u3} L M N _inst_1 _inst_2) f x))
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.comp_apply FirstOrder.Language.ElementaryEmbedding.comp_applyₓ'. -/
@[simp]
theorem comp_apply (g : N ↪ₑ[L] P) (f : M ↪ₑ[L] N) (x : M) : g.comp f x = g (f x) :=
  rfl
#align first_order.language.elementary_embedding.comp_apply FirstOrder.Language.ElementaryEmbedding.comp_apply

/- warning: first_order.language.elementary_embedding.comp_assoc -> FirstOrder.Language.ElementaryEmbedding.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u5}} {Q : Type.{u6}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] [_inst_3 : FirstOrder.Language.Structure.{u1, u2, u5} L P] [_inst_4 : FirstOrder.Language.Structure.{u1, u2, u6} L Q] (f : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (g : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u4, u5} L N P _inst_2 _inst_3) (h : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u5, u6} L P Q _inst_3 _inst_4), Eq.{max (succ u3) (succ u6)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u6} L M Q _inst_1 _inst_4) (FirstOrder.Language.ElementaryEmbedding.comp.{u1, u2, u3, u4, u6} L M N Q _inst_1 _inst_2 _inst_4 (FirstOrder.Language.ElementaryEmbedding.comp.{u1, u2, u4, u5, u6} L N P Q _inst_2 _inst_3 _inst_4 h g) f) (FirstOrder.Language.ElementaryEmbedding.comp.{u1, u2, u3, u5, u6} L M P Q _inst_1 _inst_3 _inst_4 h (FirstOrder.Language.ElementaryEmbedding.comp.{u1, u2, u3, u4, u5} L M N P _inst_1 _inst_2 _inst_3 g f))
but is expected to have type
  forall {L : FirstOrder.Language.{u6, u5}} {M : Type.{u4}} {N : Type.{u3}} {P : Type.{u2}} {Q : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u6, u5, u4} L M] [_inst_2 : FirstOrder.Language.Structure.{u6, u5, u3} L N] [_inst_3 : FirstOrder.Language.Structure.{u6, u5, u2} L P] [_inst_4 : FirstOrder.Language.Structure.{u6, u5, u1} L Q] (f : FirstOrder.Language.ElementaryEmbedding.{u6, u5, u4, u3} L M N _inst_1 _inst_2) (g : FirstOrder.Language.ElementaryEmbedding.{u6, u5, u3, u2} L N P _inst_2 _inst_3) (h : FirstOrder.Language.ElementaryEmbedding.{u6, u5, u2, u1} L P Q _inst_3 _inst_4), Eq.{max (succ u4) (succ u1)} (FirstOrder.Language.ElementaryEmbedding.{u6, u5, u4, u1} L M Q _inst_1 _inst_4) (FirstOrder.Language.ElementaryEmbedding.comp.{u6, u5, u4, u3, u1} L M N Q _inst_1 _inst_2 _inst_4 (FirstOrder.Language.ElementaryEmbedding.comp.{u6, u5, u3, u2, u1} L N P Q _inst_2 _inst_3 _inst_4 h g) f) (FirstOrder.Language.ElementaryEmbedding.comp.{u6, u5, u4, u2, u1} L M P Q _inst_1 _inst_3 _inst_4 h (FirstOrder.Language.ElementaryEmbedding.comp.{u6, u5, u4, u3, u2} L M N P _inst_1 _inst_2 _inst_3 g f))
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_embedding.comp_assoc FirstOrder.Language.ElementaryEmbedding.comp_assocₓ'. -/
/-- Composition of elementary embeddings is associative. -/
theorem comp_assoc (f : M ↪ₑ[L] N) (g : N ↪ₑ[L] P) (h : P ↪ₑ[L] Q) :
    (h.comp g).comp f = h.comp (g.comp f) :=
  rfl
#align first_order.language.elementary_embedding.comp_assoc FirstOrder.Language.ElementaryEmbedding.comp_assoc

end ElementaryEmbedding

variable (L) (M)

#print FirstOrder.Language.elementaryDiagram /-
/-- The elementary diagram of an `L`-structure is the set of all sentences with parameters it
  satisfies. -/
abbrev elementaryDiagram : L[[M]].Theory :=
  L[[M]].completeTheory M
#align first_order.language.elementary_diagram FirstOrder.Language.elementaryDiagram
-/

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
#print FirstOrder.Language.ElementaryEmbedding.ofModelsElementaryDiagram /-
/-- The canonical elementary embedding of an `L`-structure into any model of its elementary diagram
-/
@[simps]
def ElementaryEmbedding.ofModelsElementaryDiagram (N : Type _) [L.Structure N] [L[[M]].Structure N]
    [(lhomWithConstants L M).IsExpansionOn N] [N ⊨ L.elementaryDiagram M] : M ↪ₑ[L] N :=
  ⟨(coe : L[[M]].Constants → N) ∘ Sum.inr, fun n φ x =>
    by
    refine'
      trans _
        ((realize_iff_of_model_complete_theory M N
              (((L.Lhom_with_constants M).onBoundedFormula φ).subst
                  (constants.term ∘ Sum.inr ∘ x)).alls).trans
          _)
    ·
      simp_rw [sentence.realize, bounded_formula.realize_alls, bounded_formula.realize_subst,
        Lhom.realize_on_bounded_formula, formula.realize, Unique.forall_iff, realize_constants]
    · simp_rw [sentence.realize, bounded_formula.realize_alls, bounded_formula.realize_subst,
        Lhom.realize_on_bounded_formula, formula.realize, Unique.forall_iff]
      rfl⟩
#align first_order.language.elementary_embedding.of_models_elementary_diagram FirstOrder.Language.ElementaryEmbedding.ofModelsElementaryDiagram
-/

variable {L M}

namespace Embedding

/- warning: first_order.language.embedding.is_elementary_of_exists -> FirstOrder.Language.Embedding.isElementary_of_exists is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2), (forall (n : Nat) (φ : FirstOrder.Language.BoundedFormula.{u1, u2, 0} L Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (x : (Fin n) -> M) (a : N), (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u4, 0} L N _inst_2 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) φ (Inhabited.default.{succ u4} (Empty -> N) (Unique.inhabited.{succ u4} (Empty -> N) (Pi.uniqueOfIsEmpty.{1, succ u4} Empty Empty.isEmpty (fun (ᾰ : Empty) => N)))) (Fin.snoc.{u4} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => N) (Function.comp.{1, succ u3, succ u4} (Fin n) M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) x) a)) -> (Exists.{succ u3} M (fun (b : M) => FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u4, 0} L N _inst_2 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) φ (Inhabited.default.{succ u4} (Empty -> N) (Unique.inhabited.{succ u4} (Empty -> N) (Pi.uniqueOfIsEmpty.{1, succ u4} Empty Empty.isEmpty (fun (ᾰ : Empty) => N)))) (Fin.snoc.{u4} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => N) (Function.comp.{1, succ u3, succ u4} (Fin n) M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f b))))) -> (forall {n : Nat} (φ : FirstOrder.Language.Formula.{u1, u2, 0} L (Fin n)) (x : (Fin n) -> M), Iff (FirstOrder.Language.Formula.Realize.{u1, u2, u4, 0} L N _inst_2 (Fin n) φ (Function.comp.{1, succ u3, succ u4} (Fin n) M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) x)) (FirstOrder.Language.Formula.Realize.{u1, u2, u3, 0} L M _inst_1 (Fin n) φ x))
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] (f : FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2), (forall (n : Nat) (φ : FirstOrder.Language.BoundedFormula.{u4, u3, 0} L Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x : (Fin n) -> M) (a : N), (FirstOrder.Language.BoundedFormula.Realize.{u4, u3, u1, 0} L N _inst_2 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) φ (Inhabited.default.{succ u1} (Empty -> N) (Unique.instInhabited.{succ u1} (Empty -> N) (Pi.uniqueOfIsEmpty.{succ u1, 1} Empty instIsEmptyEmpty (fun (ᾰ : Empty) => N)))) (Fin.snoc.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => N) (Function.comp.{1, succ u2, succ u1} (Fin n) M N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2)) f) x) a)) -> (Exists.{succ u2} M (fun (b : M) => FirstOrder.Language.BoundedFormula.Realize.{u4, u3, u1, 0} L N _inst_2 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) φ (Inhabited.default.{succ u1} (Empty -> N) (Unique.instInhabited.{succ u1} (Empty -> N) (Pi.uniqueOfIsEmpty.{succ u1, 1} Empty instIsEmptyEmpty (fun (ᾰ : Empty) => N)))) (Fin.snoc.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => N) (Function.comp.{1, succ u2, succ u1} (Fin n) M N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2)) f) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2)) f b))))) -> (forall {n : Nat} (φ : FirstOrder.Language.Formula.{u4, u3, 0} L (Fin n)) (x : (Fin n) -> M), Iff (FirstOrder.Language.Formula.Realize.{u4, u3, u1, 0} L N _inst_2 (Fin n) φ (Function.comp.{1, succ u2, succ u1} (Fin n) M N (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2)) f) x)) (FirstOrder.Language.Formula.Realize.{u4, u3, u2, 0} L M _inst_1 (Fin n) φ x))
Case conversion may be inaccurate. Consider using '#align first_order.language.embedding.is_elementary_of_exists FirstOrder.Language.Embedding.isElementary_of_existsₓ'. -/
/-- The Tarski-Vaught test for elementarity of an embedding. -/
theorem isElementary_of_exists (f : M ↪[L] N)
    (htv :
      ∀ (n : ℕ) (φ : L.BoundedFormula Empty (n + 1)) (x : Fin n → M) (a : N),
        φ.realize default (Fin.snoc (f ∘ x) a : _ → N) →
          ∃ b : M, φ.realize default (Fin.snoc (f ∘ x) (f b) : _ → N)) :
    ∀ {n} (φ : L.Formula (Fin n)) (x : Fin n → M), φ.realize (f ∘ x) ↔ φ.realize x :=
  by
  suffices h :
    ∀ (n : ℕ) (φ : L.bounded_formula Empty n) (xs : Fin n → M),
      φ.realize (f ∘ default) (f ∘ xs) ↔ φ.realize default xs
  · intro n φ x
    refine' φ.realize_relabel_sum_inr.symm.trans (trans (h n _ _) φ.realize_relabel_sum_inr)
  refine' fun n φ => φ.recOn _ _ _ _ _
  · exact fun _ _ => Iff.rfl
  · intros
    simp [bounded_formula.realize, ← Sum.comp_elim, embedding.realize_term]
  · intros
    simp [bounded_formula.realize, ← Sum.comp_elim, embedding.realize_term]
  · intro _ _ _ ih1 ih2 _
    simp [ih1, ih2]
  · intro n φ ih xs
    simp only [bounded_formula.realize_all]
    refine' ⟨fun h a => _, _⟩
    · rw [← ih, Fin.comp_snoc]
      exact h (f a)
    · contrapose!
      rintro ⟨a, ha⟩
      obtain ⟨b, hb⟩ := htv n φ.not xs a _
      · refine' ⟨b, fun h => hb (Eq.mp _ ((ih _).2 h))⟩
        rw [Unique.eq_default (f ∘ default), Fin.comp_snoc]
      · rw [bounded_formula.realize_not, ← Unique.eq_default (f ∘ default)]
        exact ha
#align first_order.language.embedding.is_elementary_of_exists FirstOrder.Language.Embedding.isElementary_of_exists

/- warning: first_order.language.embedding.to_elementary_embedding -> FirstOrder.Language.Embedding.toElementaryEmbedding is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2), (forall (n : Nat) (φ : FirstOrder.Language.BoundedFormula.{u1, u2, 0} L Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (x : (Fin n) -> M) (a : N), (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u4, 0} L N _inst_2 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) φ (Inhabited.default.{succ u4} (Empty -> N) (Unique.inhabited.{succ u4} (Empty -> N) (Pi.uniqueOfIsEmpty.{1, succ u4} Empty Empty.isEmpty (fun (ᾰ : Empty) => N)))) (Fin.snoc.{u4} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => N) (Function.comp.{1, succ u3, succ u4} (Fin n) M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) x) a)) -> (Exists.{succ u3} M (fun (b : M) => FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u4, 0} L N _inst_2 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) φ (Inhabited.default.{succ u4} (Empty -> N) (Unique.inhabited.{succ u4} (Empty -> N) (Pi.uniqueOfIsEmpty.{1, succ u4} Empty Empty.isEmpty (fun (ᾰ : Empty) => N)))) (Fin.snoc.{u4} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => N) (Function.comp.{1, succ u3, succ u4} (Fin n) M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f) x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Embedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f b))))) -> (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2)
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2), (forall (n : Nat) (φ : FirstOrder.Language.BoundedFormula.{u1, u2, 0} L Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x : (Fin n) -> M) (a : N), (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u4, 0} L N _inst_2 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) φ (Inhabited.default.{succ u4} (Empty -> N) (Unique.instInhabited.{succ u4} (Empty -> N) (Pi.uniqueOfIsEmpty.{succ u4, 1} Empty instIsEmptyEmpty (fun (ᾰ : Empty) => N)))) (Fin.snoc.{u4} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => N) (Function.comp.{1, succ u3, succ u4} (Fin n) M N (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u1, u2, u3, u4} L M N _inst_1 _inst_2)) f) x) a)) -> (Exists.{succ u3} M (fun (b : M) => FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u4, 0} L N _inst_2 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) φ (Inhabited.default.{succ u4} (Empty -> N) (Unique.instInhabited.{succ u4} (Empty -> N) (Pi.uniqueOfIsEmpty.{succ u4, 1} Empty instIsEmptyEmpty (fun (ᾰ : Empty) => N)))) (Fin.snoc.{u4} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => N) (Function.comp.{1, succ u3, succ u4} (Fin n) M N (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u1, u2, u3, u4} L M N _inst_1 _inst_2)) f) x) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.6670 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u3, succ u4} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Embedding.embeddingLike.{u1, u2, u3, u4} L M N _inst_1 _inst_2)) f b))))) -> (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align first_order.language.embedding.to_elementary_embedding FirstOrder.Language.Embedding.toElementaryEmbeddingₓ'. -/
/-- Bundles an embedding satisfying the Tarski-Vaught test as an elementary embedding. -/
@[simps]
def toElementaryEmbedding (f : M ↪[L] N)
    (htv :
      ∀ (n : ℕ) (φ : L.BoundedFormula Empty (n + 1)) (x : Fin n → M) (a : N),
        φ.realize default (Fin.snoc (f ∘ x) a : _ → N) →
          ∃ b : M, φ.realize default (Fin.snoc (f ∘ x) (f b) : _ → N)) :
    M ↪ₑ[L] N :=
  ⟨f, fun _ => f.isElementary_of_exists htv⟩
#align first_order.language.embedding.to_elementary_embedding FirstOrder.Language.Embedding.toElementaryEmbedding

end Embedding

namespace Equiv

#print FirstOrder.Language.Equiv.toElementaryEmbedding /-
/-- A first-order equivalence is also an elementary embedding. -/
def toElementaryEmbedding (f : M ≃[L] N) : M ↪ₑ[L] N where toFun := f
#align first_order.language.equiv.to_elementary_embedding FirstOrder.Language.Equiv.toElementaryEmbedding
-/

/- warning: first_order.language.equiv.to_elementary_embedding_to_embedding -> FirstOrder.Language.Equiv.toElementaryEmbedding_toEmbedding is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Equiv.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{max (succ u3) (succ u4)} (FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (FirstOrder.Language.ElementaryEmbedding.toEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Equiv.toElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (FirstOrder.Language.Equiv.toEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] (f : FirstOrder.Language.Equiv.{u4, u3, u2, u1} L M N _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (FirstOrder.Language.Embedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) (FirstOrder.Language.ElementaryEmbedding.toEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2 (FirstOrder.Language.Equiv.toElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2 f)) (FirstOrder.Language.Equiv.toEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align first_order.language.equiv.to_elementary_embedding_to_embedding FirstOrder.Language.Equiv.toElementaryEmbedding_toEmbeddingₓ'. -/
@[simp]
theorem toElementaryEmbedding_toEmbedding (f : M ≃[L] N) :
    f.toElementaryEmbedding.toEmbedding = f.toEmbedding :=
  rfl
#align first_order.language.equiv.to_elementary_embedding_to_embedding FirstOrder.Language.Equiv.toElementaryEmbedding_toEmbedding

/- warning: first_order.language.equiv.coe_to_elementary_embedding -> FirstOrder.Language.Equiv.coe_toElementaryEmbedding is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Equiv.{u1, u2, u3, u4} L M N _inst_1 _inst_2), Eq.{max (succ u3) (succ u4)} ((fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Equiv.toElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (FirstOrder.Language.Equiv.toElementaryEmbedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Equiv.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Equiv.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Equiv.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)
but is expected to have type
  forall {L : FirstOrder.Language.{u4, u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u4, u3, u2} L M] [_inst_2 : FirstOrder.Language.Structure.{u4, u3, u1} L N] (f : FirstOrder.Language.Equiv.{u4, u3, u2, u1} L M N _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (forall (a : M), (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : M) => N) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u4, u3, u2, u1} L M N _inst_1 _inst_2) (FirstOrder.Language.Equiv.toElementaryEmbedding.{u4, u3, u2, u1} L M N _inst_1 _inst_2 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Equiv.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.8209 : M) => N) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Equiv.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M N (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (FirstOrder.Language.Equiv.{u4, u3, u2, u1} L M N _inst_1 _inst_2) M N (FirstOrder.Language.Equiv.instEquivLikeEquiv.{u4, u3, u2, u1} L M N _inst_1 _inst_2))) f)
Case conversion may be inaccurate. Consider using '#align first_order.language.equiv.coe_to_elementary_embedding FirstOrder.Language.Equiv.coe_toElementaryEmbeddingₓ'. -/
@[simp]
theorem coe_toElementaryEmbedding (f : M ≃[L] N) :
    (f.toElementaryEmbedding : M → N) = (f : M → N) :=
  rfl
#align first_order.language.equiv.coe_to_elementary_embedding FirstOrder.Language.Equiv.coe_toElementaryEmbedding

end Equiv

/- warning: first_order.language.realize_term_substructure -> FirstOrder.Language.realize_term_substructure is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {α : Type.{u4}} {S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} (v : α -> (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S)) (t : FirstOrder.Language.Term.{u1, u2, u4} L α), Eq.{succ u3} M (FirstOrder.Language.Term.realize.{u1, u2, u3, u4} L M _inst_1 α (Function.comp.{succ u4, succ u3, succ u3} α (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)))))) v) t) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S))))) (FirstOrder.Language.Term.realize.{u1, u2, u3, u4} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) α v t))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {α : Type.{u4}} {S : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1} (v : α -> (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S))) (t : FirstOrder.Language.Term.{u3, u2, u4} L α), Eq.{succ u1} M (FirstOrder.Language.Term.realize.{u3, u2, u1, u4} L M _inst_1 α (Function.comp.{succ u4, succ u1, succ u1} α (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) S))) v) t) (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) S)) (FirstOrder.Language.Term.realize.{u3, u2, u1, u4} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) (FirstOrder.Language.Substructure.inducedStructure.{u3, u2, u1} L M _inst_1 S) α v t))
Case conversion may be inaccurate. Consider using '#align first_order.language.realize_term_substructure FirstOrder.Language.realize_term_substructureₓ'. -/
@[simp]
theorem realize_term_substructure {α : Type _} {S : L.Substructure M} (v : α → S) (t : L.term α) :
    t.realize (coe ∘ v) = (↑(t.realize v) : M) :=
  S.Subtype.realize_term t
#align first_order.language.realize_term_substructure FirstOrder.Language.realize_term_substructure

namespace Substructure

/- warning: first_order.language.substructure.realize_bounded_formula_top -> FirstOrder.Language.Substructure.realize_boundedFormula_top is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {α : Type.{u4}} {n : Nat} {φ : FirstOrder.Language.BoundedFormula.{u1, u2, u4} L α n} {v : α -> (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))} {xs : (Fin n) -> (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))}, Iff (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u3, u4} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) α n φ v xs) (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u3, u4} L M _inst_1 α n φ (Function.comp.{succ u4, succ u3, succ u3} α (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))))))) v) (Function.comp.{1, succ u3, succ u3} (Fin n) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))))))) xs))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {α : Type.{u4}} {n : Nat} {φ : FirstOrder.Language.BoundedFormula.{u3, u2, u4} L α n} {v : α -> (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1))))} {xs : (Fin n) -> (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1))))}, Iff (FirstOrder.Language.BoundedFormula.Realize.{u3, u2, u1, u4} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1)))) (FirstOrder.Language.Substructure.inducedStructure.{u3, u2, u1} L M _inst_1 (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1))) α n φ v xs) (FirstOrder.Language.BoundedFormula.Realize.{u3, u2, u1, u4} L M _inst_1 α n φ (Function.comp.{succ u4, succ u1, succ u1} α (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1)))) M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1))))) v) (Function.comp.{1, succ u1, succ u1} (Fin n) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1)))) M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1))))) xs))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.realize_bounded_formula_top FirstOrder.Language.Substructure.realize_boundedFormula_topₓ'. -/
@[simp]
theorem realize_boundedFormula_top {α : Type _} {n : ℕ} {φ : L.BoundedFormula α n}
    {v : α → (⊤ : L.Substructure M)} {xs : Fin n → (⊤ : L.Substructure M)} :
    φ.realize v xs ↔ φ.realize ((coe : _ → M) ∘ v) (coe ∘ xs) :=
  by
  rw [← substructure.top_equiv.realize_bounded_formula φ]
  simp
#align first_order.language.substructure.realize_bounded_formula_top FirstOrder.Language.Substructure.realize_boundedFormula_top

/- warning: first_order.language.substructure.realize_formula_top -> FirstOrder.Language.Substructure.realize_formula_top is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {α : Type.{u4}} {φ : FirstOrder.Language.Formula.{u1, u2, u4} L α} {v : α -> (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))}, Iff (FirstOrder.Language.Formula.Realize.{u1, u2, u3, u4} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) α φ v) (FirstOrder.Language.Formula.Realize.{u1, u2, u3, u4} L M _inst_1 α φ (Function.comp.{succ u4, succ u3, succ u3} α (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1))) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))))))) v))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {α : Type.{u4}} {φ : FirstOrder.Language.Formula.{u3, u2, u4} L α} {v : α -> (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1))))}, Iff (FirstOrder.Language.Formula.Realize.{u3, u2, u1, u4} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1)))) (FirstOrder.Language.Substructure.inducedStructure.{u3, u2, u1} L M _inst_1 (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1))) α φ v) (FirstOrder.Language.Formula.Realize.{u3, u2, u1, u4} L M _inst_1 α φ (Function.comp.{succ u4, succ u1, succ u1} α (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1))))) M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1))))) v))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.realize_formula_top FirstOrder.Language.Substructure.realize_formula_topₓ'. -/
@[simp]
theorem realize_formula_top {α : Type _} {φ : L.Formula α} {v : α → (⊤ : L.Substructure M)} :
    φ.realize v ↔ φ.realize ((coe : (⊤ : L.Substructure M) → M) ∘ v) :=
  by
  rw [← substructure.top_equiv.realize_formula φ]
  simp
#align first_order.language.substructure.realize_formula_top FirstOrder.Language.Substructure.realize_formula_top

#print FirstOrder.Language.Substructure.IsElementary /-
/-- A substructure is elementary when every formula applied to a tuple in the subtructure
  agrees with its value in the overall structure. -/
def IsElementary (S : L.Substructure M) : Prop :=
  ∀ ⦃n⦄ (φ : L.Formula (Fin n)) (x : Fin n → S), φ.realize ((coe : _ → M) ∘ x) ↔ φ.realize x
#align first_order.language.substructure.is_elementary FirstOrder.Language.Substructure.IsElementary
-/

end Substructure

variable (L M)

#print FirstOrder.Language.ElementarySubstructure /-
/-- An elementary substructure is one in which every formula applied to a tuple in the subtructure
  agrees with its value in the overall structure. -/
structure ElementarySubstructure where
  toSubstructure : L.Substructure M
  isElementary' : to_substructure.IsElementary
#align first_order.language.elementary_substructure FirstOrder.Language.ElementarySubstructure
-/

variable {L M}

namespace ElementarySubstructure

instance : Coe (L.ElementarySubstructure M) (L.Substructure M) :=
  ⟨ElementarySubstructure.toSubstructure⟩

instance : SetLike (L.ElementarySubstructure M) M :=
  ⟨fun x => x.toSubstructure.carrier, fun ⟨⟨s, hs1⟩, hs2⟩ ⟨⟨t, ht1⟩, ht2⟩ h =>
    by
    congr
    exact h⟩

#print FirstOrder.Language.ElementarySubstructure.inducedStructure /-
instance inducedStructure (S : L.ElementarySubstructure M) : L.Structure S :=
  Substructure.inducedStructure
#align first_order.language.elementary_substructure.induced_Structure FirstOrder.Language.ElementarySubstructure.inducedStructure
-/

/- warning: first_order.language.elementary_substructure.is_elementary -> FirstOrder.Language.ElementarySubstructure.isElementary is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (S : FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1), FirstOrder.Language.Substructure.IsElementary.{u1, u2, u3} L M _inst_1 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeBase.{succ u3, succ u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.ElementarySubstructure.instCoe.{u1, u2, u3} L M _inst_1)))) S)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] (S : FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1), FirstOrder.Language.Substructure.IsElementary.{u3, u2, u1} L M _inst_1 (FirstOrder.Language.ElementarySubstructure.toSubstructure.{u3, u2, u1} L M _inst_1 S)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_substructure.is_elementary FirstOrder.Language.ElementarySubstructure.isElementaryₓ'. -/
@[simp]
theorem isElementary (S : L.ElementarySubstructure M) : (S : L.Substructure M).IsElementary :=
  S.isElementary'
#align first_order.language.elementary_substructure.is_elementary FirstOrder.Language.ElementarySubstructure.isElementary

#print FirstOrder.Language.ElementarySubstructure.subtype /-
/-- The natural embedding of an `L.substructure` of `M` into `M`. -/
def subtype (S : L.ElementarySubstructure M) : S ↪ₑ[L] M
    where
  toFun := coe
  map_formula' := S.IsElementary
#align first_order.language.elementary_substructure.subtype FirstOrder.Language.ElementarySubstructure.subtype
-/

/- warning: first_order.language.elementary_substructure.coe_subtype -> FirstOrder.Language.ElementarySubstructure.coeSubtype is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {S : FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1}, Eq.{succ u3} ((coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) -> M) (coeFn.{succ u3, succ u3} (FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) _inst_1) (fun (_x : FirstOrder.Language.ElementaryEmbedding.{u1, u2, u3, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) _inst_1) => (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) -> M) (FirstOrder.Language.ElementaryEmbedding.hasCoeToFun.{u1, u2, u3, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) _inst_1) (FirstOrder.Language.ElementarySubstructure.subtype.{u1, u2, u3} L M _inst_1 S)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S))))))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {S : FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1}, Eq.{succ u1} (forall (ᾰ : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)), (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) => M) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (FirstOrder.Language.ElementaryEmbedding.{u3, u2, u1, u1} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) M (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u3, u2, u1} L M _inst_1 S) _inst_1) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) (fun (_x : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) => (fun (a._@.Mathlib.ModelTheory.ElementaryMaps._hyg.1034 : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) => M) _x) (FirstOrder.Language.ElementaryEmbedding.funLike.{u3, u2, u1, u1} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) M (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u3, u2, u1} L M _inst_1 S) _inst_1) (FirstOrder.Language.ElementarySubstructure.subtype.{u3, u2, u1} L M _inst_1 S)) (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1) S)))
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_substructure.coe_subtype FirstOrder.Language.ElementarySubstructure.coeSubtypeₓ'. -/
@[simp]
theorem coeSubtype {S : L.ElementarySubstructure M} : ⇑S.Subtype = coe :=
  rfl
#align first_order.language.elementary_substructure.coe_subtype FirstOrder.Language.ElementarySubstructure.coeSubtype

/-- The substructure `M` of the structure `M` is elementary. -/
instance : Top (L.ElementarySubstructure M) :=
  ⟨⟨⊤, fun n φ x => Substructure.realize_formula_top.symm⟩⟩

instance : Inhabited (L.ElementarySubstructure M) :=
  ⟨⊤⟩

/- warning: first_order.language.elementary_substructure.mem_top -> FirstOrder.Language.ElementarySubstructure.mem_top is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (x : M), Membership.Mem.{u3, u3} M (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) x (Top.top.{u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.ElementarySubstructure.instTop.{u1, u2, u3} L M _inst_1))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u1}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u2, u1, u3} L M] (x : M), Membership.mem.{u3, u3} M (FirstOrder.Language.ElementarySubstructure.{u2, u1, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u2, u1, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u2, u1, u3} L M _inst_1)) x (Top.top.{u3} (FirstOrder.Language.ElementarySubstructure.{u2, u1, u3} L M _inst_1) (FirstOrder.Language.ElementarySubstructure.instTop.{u2, u1, u3} L M _inst_1))
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_substructure.mem_top FirstOrder.Language.ElementarySubstructure.mem_topₓ'. -/
@[simp]
theorem mem_top (x : M) : x ∈ (⊤ : L.ElementarySubstructure M) :=
  Set.mem_univ x
#align first_order.language.elementary_substructure.mem_top FirstOrder.Language.ElementarySubstructure.mem_top

/- warning: first_order.language.elementary_substructure.coe_top -> FirstOrder.Language.ElementarySubstructure.coe_top is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], Eq.{succ u3} (Set.{u3} M) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)))) (Top.top.{u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.ElementarySubstructure.instTop.{u1, u2, u3} L M _inst_1))) (Set.univ.{u3} M)
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u1}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u2, u1, u3} L M], Eq.{succ u3} (Set.{u3} M) (SetLike.coe.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u2, u1, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u2, u1, u3} L M _inst_1) (Top.top.{u3} (FirstOrder.Language.ElementarySubstructure.{u2, u1, u3} L M _inst_1) (FirstOrder.Language.ElementarySubstructure.instTop.{u2, u1, u3} L M _inst_1))) (Set.univ.{u3} M)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_substructure.coe_top FirstOrder.Language.ElementarySubstructure.coe_topₓ'. -/
@[simp]
theorem coe_top : ((⊤ : L.ElementarySubstructure M) : Set M) = Set.univ :=
  rfl
#align first_order.language.elementary_substructure.coe_top FirstOrder.Language.ElementarySubstructure.coe_top

/- warning: first_order.language.elementary_substructure.realize_sentence -> FirstOrder.Language.ElementarySubstructure.realize_sentence is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (S : FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (φ : FirstOrder.Language.Sentence.{u1, u2} L), Iff (FirstOrder.Language.Sentence.Realize.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) φ) (FirstOrder.Language.Sentence.Realize.{u1, u2, u3} L M _inst_1 φ)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] (S : FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (φ : FirstOrder.Language.Sentence.{u3, u2} L), Iff (FirstOrder.Language.Sentence.Realize.{u3, u2, u1} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u3, u2, u1} L M _inst_1 S) φ) (FirstOrder.Language.Sentence.Realize.{u3, u2, u1} L M _inst_1 φ)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_substructure.realize_sentence FirstOrder.Language.ElementarySubstructure.realize_sentenceₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem realize_sentence (S : L.ElementarySubstructure M) (φ : L.Sentence) : S ⊨ φ ↔ M ⊨ φ :=
  S.Subtype.map_sentence φ
#align first_order.language.elementary_substructure.realize_sentence FirstOrder.Language.ElementarySubstructure.realize_sentence

/- warning: first_order.language.elementary_substructure.Theory_model_iff -> FirstOrder.Language.ElementarySubstructure.theory_model_iff is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (S : FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) (T : FirstOrder.Language.Theory.{u1, u2} L), Iff (FirstOrder.Language.Theory.Model.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) T) (FirstOrder.Language.Theory.Model.{u1, u2, u3} L M _inst_1 T)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] (S : FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (T : FirstOrder.Language.Theory.{u3, u2} L), Iff (FirstOrder.Language.Theory.Model.{u3, u2, u1} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u3, u2, u1} L M _inst_1 S) T) (FirstOrder.Language.Theory.Model.{u3, u2, u1} L M _inst_1 T)
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_substructure.Theory_model_iff FirstOrder.Language.ElementarySubstructure.theory_model_iffₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem theory_model_iff (S : L.ElementarySubstructure M) (T : L.Theory) : S ⊨ T ↔ M ⊨ T := by
  simp only [Theory.model_iff, realize_sentence]
#align first_order.language.elementary_substructure.Theory_model_iff FirstOrder.Language.ElementarySubstructure.theory_model_iff

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
#print FirstOrder.Language.ElementarySubstructure.theory_model /-
instance theory_model {T : L.Theory} [h : M ⊨ T] {S : L.ElementarySubstructure M} : S ⊨ T :=
  (theory_model_iff S T).2 h
#align first_order.language.elementary_substructure.Theory_model FirstOrder.Language.ElementarySubstructure.theory_model
-/

instance [h : Nonempty M] {S : L.ElementarySubstructure M} : Nonempty S :=
  (model_nonemptyTheory_iff L).1 inferInstance

/- warning: first_order.language.elementary_substructure.elementarily_equivalent -> FirstOrder.Language.ElementarySubstructure.elementarilyEquivalent is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (S : FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1), FirstOrder.Language.ElementarilyEquivalent.{u1, u2, u3, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u1, u2, u3} L M _inst_1 S) _inst_1
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] (S : FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1), FirstOrder.Language.ElementarilyEquivalent.{u3, u2, u1, u1} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.ElementarySubstructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.ElementarySubstructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) M (FirstOrder.Language.ElementarySubstructure.inducedStructure.{u3, u2, u1} L M _inst_1 S) _inst_1
Case conversion may be inaccurate. Consider using '#align first_order.language.elementary_substructure.elementarily_equivalent FirstOrder.Language.ElementarySubstructure.elementarilyEquivalentₓ'. -/
theorem elementarilyEquivalent (S : L.ElementarySubstructure M) : S ≅[L] M :=
  S.Subtype.ElementarilyEquivalent
#align first_order.language.elementary_substructure.elementarily_equivalent FirstOrder.Language.ElementarySubstructure.elementarilyEquivalent

end ElementarySubstructure

namespace Substructure

/- warning: first_order.language.substructure.is_elementary_of_exists -> FirstOrder.Language.Substructure.isElementary_of_exists is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), (forall (n : Nat) (φ : FirstOrder.Language.BoundedFormula.{u1, u2, 0} L Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (x : (Fin n) -> (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S)) (a : M), (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u3, 0} L M _inst_1 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) φ (Inhabited.default.{succ u3} (Empty -> M) (Unique.inhabited.{succ u3} (Empty -> M) (Pi.uniqueOfIsEmpty.{1, succ u3} Empty Empty.isEmpty (fun (ᾰ : Empty) => M)))) (Fin.snoc.{u3} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => M) (Function.comp.{1, succ u3, succ u3} (Fin n) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)))))) x) a)) -> (Exists.{succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (fun (b : coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) => FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u3, 0} L M _inst_1 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) φ (Inhabited.default.{succ u3} (Empty -> M) (Unique.inhabited.{succ u3} (Empty -> M) (Pi.uniqueOfIsEmpty.{1, succ u3} Empty Empty.isEmpty (fun (ᾰ : Empty) => M)))) (Fin.snoc.{u3} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => M) (Function.comp.{1, succ u3, succ u3} (Fin n) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)))))) x) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S))))) b))))) -> (FirstOrder.Language.Substructure.IsElementary.{u1, u2, u3} L M _inst_1 S)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] (S : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1), (forall (n : Nat) (φ : FirstOrder.Language.BoundedFormula.{u3, u2, 0} L Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x : (Fin n) -> (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S))) (a : M), (FirstOrder.Language.BoundedFormula.Realize.{u3, u2, u1, 0} L M _inst_1 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) φ (Inhabited.default.{succ u1} (Empty -> M) (Unique.instInhabited.{succ u1} (Empty -> M) (Pi.uniqueOfIsEmpty.{succ u1, 1} Empty instIsEmptyEmpty (fun (ᾰ : Empty) => M)))) (Fin.snoc.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => M) (Function.comp.{1, succ u1, succ u1} (Fin n) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) S))) x) a)) -> (Exists.{succ u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) (fun (b : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) => FirstOrder.Language.BoundedFormula.Realize.{u3, u2, u1, 0} L M _inst_1 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) φ (Inhabited.default.{succ u1} (Empty -> M) (Unique.instInhabited.{succ u1} (Empty -> M) (Pi.uniqueOfIsEmpty.{succ u1, 1} Empty instIsEmptyEmpty (fun (ᾰ : Empty) => M)))) (Fin.snoc.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => M) (Function.comp.{1, succ u1, succ u1} (Fin n) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) S))) x) (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) S)) b))))) -> (FirstOrder.Language.Substructure.IsElementary.{u3, u2, u1} L M _inst_1 S)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.is_elementary_of_exists FirstOrder.Language.Substructure.isElementary_of_existsₓ'. -/
/-- The Tarski-Vaught test for elementarity of a substructure. -/
theorem isElementary_of_exists (S : L.Substructure M)
    (htv :
      ∀ (n : ℕ) (φ : L.BoundedFormula Empty (n + 1)) (x : Fin n → S) (a : M),
        φ.realize default (Fin.snoc (coe ∘ x) a : _ → M) →
          ∃ b : S, φ.realize default (Fin.snoc (coe ∘ x) b : _ → M)) :
    S.IsElementary := fun n => S.Subtype.isElementary_of_exists htv
#align first_order.language.substructure.is_elementary_of_exists FirstOrder.Language.Substructure.isElementary_of_exists

/- warning: first_order.language.substructure.to_elementary_substructure -> FirstOrder.Language.Substructure.toElementarySubstructure is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), (forall (n : Nat) (φ : FirstOrder.Language.BoundedFormula.{u1, u2, 0} L Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (x : (Fin n) -> (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S)) (a : M), (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u3, 0} L M _inst_1 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) φ (Inhabited.default.{succ u3} (Empty -> M) (Unique.inhabited.{succ u3} (Empty -> M) (Pi.uniqueOfIsEmpty.{1, succ u3} Empty Empty.isEmpty (fun (ᾰ : Empty) => M)))) (Fin.snoc.{u3} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => M) (Function.comp.{1, succ u3, succ u3} (Fin n) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)))))) x) a)) -> (Exists.{succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (fun (b : coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) => FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u3, 0} L M _inst_1 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) φ (Inhabited.default.{succ u3} (Empty -> M) (Unique.inhabited.{succ u3} (Empty -> M) (Pi.uniqueOfIsEmpty.{1, succ u3} Empty Empty.isEmpty (fun (ᾰ : Empty) => M)))) (Fin.snoc.{u3} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => M) (Function.comp.{1, succ u3, succ u3} (Fin n) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)))))) x) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.hasMem.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S))))) b))))) -> (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1)
but is expected to have type
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), (forall (n : Nat) (φ : FirstOrder.Language.BoundedFormula.{u1, u2, 0} L Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x : (Fin n) -> (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S))) (a : M), (FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u3, 0} L M _inst_1 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) φ (Inhabited.default.{succ u3} (Empty -> M) (Unique.instInhabited.{succ u3} (Empty -> M) (Pi.uniqueOfIsEmpty.{succ u3, 1} Empty instIsEmptyEmpty (fun (ᾰ : Empty) => M)))) (Fin.snoc.{u3} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => M) (Function.comp.{1, succ u3, succ u3} (Fin n) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) M (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) S))) x) a)) -> (Exists.{succ u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) (fun (b : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) => FirstOrder.Language.BoundedFormula.Realize.{u1, u2, u3, 0} L M _inst_1 Empty (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) φ (Inhabited.default.{succ u3} (Empty -> M) (Unique.instInhabited.{succ u3} (Empty -> M) (Pi.uniqueOfIsEmpty.{succ u3, 1} Empty instIsEmptyEmpty (fun (ᾰ : Empty) => M)))) (Fin.snoc.{u3} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => M) (Function.comp.{1, succ u3, succ u3} (Fin n) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.instMembership.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) x S)) M (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) S))) x) (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1) S)) b))))) -> (FirstOrder.Language.ElementarySubstructure.{u1, u2, u3} L M _inst_1)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.to_elementary_substructure FirstOrder.Language.Substructure.toElementarySubstructureₓ'. -/
/-- Bundles a substructure satisfying the Tarski-Vaught test as an elementary substructure. -/
@[simps]
def toElementarySubstructure (S : L.Substructure M)
    (htv :
      ∀ (n : ℕ) (φ : L.BoundedFormula Empty (n + 1)) (x : Fin n → S) (a : M),
        φ.realize default (Fin.snoc (coe ∘ x) a : _ → M) →
          ∃ b : S, φ.realize default (Fin.snoc (coe ∘ x) b : _ → M)) :
    L.ElementarySubstructure M :=
  ⟨S, S.isElementary_of_exists htv⟩
#align first_order.language.substructure.to_elementary_substructure FirstOrder.Language.Substructure.toElementarySubstructure

end Substructure

end Language

end FirstOrder

