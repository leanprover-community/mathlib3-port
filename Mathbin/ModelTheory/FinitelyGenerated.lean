/-
Copyright (c) 2022 Aaron Anderson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Anderson

! This file was ported from Lean 3 source module model_theory.finitely_generated
! leanprover-community/mathlib commit 0602c59878ff3d5f71dea69c2d32ccf2e93e5398
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.ModelTheory.Substructures

/-!
# Finitely Generated First-Order Structures
This file defines what it means for a first-order (sub)structure to be finitely or countably
generated, similarly to other finitely-generated objects in the algebra library.

## Main Definitions
* `first_order.language.substructure.fg` indicates that a substructure is finitely generated.
* `first_order.language.Structure.fg` indicates that a structure is finitely generated.
* `first_order.language.substructure.cg` indicates that a substructure is countably generated.
* `first_order.language.Structure.cg` indicates that a structure is countably generated.


## TODO
Develop a more unified definition of finite generation using the theory of closure operators, or use
this definition of finite generation to define the others.

-/


open FirstOrder

open Set

namespace FirstOrder

namespace Language

open Structure

variable {L : Language} {M : Type _} [L.Structure M]

namespace Substructure

#print FirstOrder.Language.Substructure.FG /-
/-- A substructure of `M` is finitely generated if it is the closure of a finite subset of `M`. -/
def FG (N : L.Substructure M) : Prop :=
  ∃ S : Finset M, closure L ↑S = N
#align first_order.language.substructure.fg FirstOrder.Language.Substructure.FG
-/

/- warning: first_order.language.substructure.fg_def -> FirstOrder.Language.Substructure.fg_def is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, Iff (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 N) (Exists.{succ u3} (Set.{u3} M) (fun (S : Set.{u3} M) => And (Set.Finite.{u3} M S) (Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) S) N)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, Iff (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 N) (Exists.{succ u1} (Set.{u1} M) (fun (S : Set.{u1} M) => And (Set.Finite.{u1} M S) (Eq.{succ u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (LowerAdjoint.toFun.{u1, u1} (Set.{u1} M) (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} M) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} M) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} M) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} M) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} M) (Set.instCompleteBooleanAlgebraSet.{u1} M))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u3, u2, u1} L M _inst_1) S) N)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg_def FirstOrder.Language.Substructure.fg_defₓ'. -/
theorem fg_def {N : L.Substructure M} : N.FG ↔ ∃ S : Set M, S.Finite ∧ closure L S = N :=
  ⟨fun ⟨t, h⟩ => ⟨_, Finset.finite_toSet t, h⟩,
    by
    rintro ⟨t', h, rfl⟩
    rcases finite.exists_finset_coe h with ⟨t, rfl⟩
    exact ⟨t, rfl⟩⟩
#align first_order.language.substructure.fg_def FirstOrder.Language.Substructure.fg_def

/- warning: first_order.language.substructure.fg_iff_exists_fin_generating_family -> FirstOrder.Language.Substructure.fg_iff_exists_fin_generating_family is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, Iff (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 N) (Exists.{1} Nat (fun (n : Nat) => Exists.{succ u3} ((Fin n) -> M) (fun (s : (Fin n) -> M) => Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Set.range.{u3, 1} M (Fin n) s)) N)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, Iff (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 N) (Exists.{1} Nat (fun (n : Nat) => Exists.{succ u1} ((Fin n) -> M) (fun (s : (Fin n) -> M) => Eq.{succ u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (LowerAdjoint.toFun.{u1, u1} (Set.{u1} M) (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} M) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} M) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} M) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} M) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} M) (Set.instCompleteBooleanAlgebraSet.{u1} M))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u3, u2, u1} L M _inst_1) (Set.range.{u1, 1} M (Fin n) s)) N)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg_iff_exists_fin_generating_family FirstOrder.Language.Substructure.fg_iff_exists_fin_generating_familyₓ'. -/
theorem fg_iff_exists_fin_generating_family {N : L.Substructure M} :
    N.FG ↔ ∃ (n : ℕ)(s : Fin n → M), closure L (range s) = N :=
  by
  rw [fg_def]
  constructor
  · rintro ⟨S, Sfin, hS⟩
    obtain ⟨n, f, rfl⟩ := Sfin.fin_embedding
    exact ⟨n, f, hS⟩
  · rintro ⟨n, s, hs⟩
    refine' ⟨range s, finite_range s, hs⟩
#align first_order.language.substructure.fg_iff_exists_fin_generating_family FirstOrder.Language.Substructure.fg_iff_exists_fin_generating_family

/- warning: first_order.language.substructure.fg_bot -> FirstOrder.Language.Substructure.fg_bot is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 (Bot.bot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toHasBot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M], FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 (Bot.bot.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toBot.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg_bot FirstOrder.Language.Substructure.fg_botₓ'. -/
theorem fg_bot : (⊥ : L.Substructure M).FG :=
  ⟨∅, by rw [Finset.coe_empty, closure_empty]⟩
#align first_order.language.substructure.fg_bot FirstOrder.Language.Substructure.fg_bot

/- warning: first_order.language.substructure.fg_closure -> FirstOrder.Language.Substructure.fg_closure is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {s : Set.{u3} M}, (Set.Finite.{u3} M s) -> (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u1}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u2, u1, u3} L M] {s : Set.{u3} M}, (Set.Finite.{u3} M s) -> (FirstOrder.Language.Substructure.FG.{u2, u1, u3} L M _inst_1 (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u1, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u2, u1, u3} L M _inst_1) s))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg_closure FirstOrder.Language.Substructure.fg_closureₓ'. -/
theorem fg_closure {s : Set M} (hs : s.Finite) : FG (closure L s) :=
  ⟨hs.toFinset, by rw [hs.coe_to_finset]⟩
#align first_order.language.substructure.fg_closure FirstOrder.Language.Substructure.fg_closure

/- warning: first_order.language.substructure.fg_closure_singleton -> FirstOrder.Language.Substructure.fg_closure_singleton is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (x : M), FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Singleton.singleton.{u3, u3} M (Set.{u3} M) (Set.hasSingleton.{u3} M) x))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] (x : M), FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 (LowerAdjoint.toFun.{u1, u1} (Set.{u1} M) (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} M) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} M) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} M) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} M) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} M) (Set.instCompleteBooleanAlgebraSet.{u1} M))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u3, u2, u1} L M _inst_1) (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) x))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg_closure_singleton FirstOrder.Language.Substructure.fg_closure_singletonₓ'. -/
theorem fg_closure_singleton (x : M) : FG (closure L ({x} : Set M)) :=
  fg_closure (finite_singleton x)
#align first_order.language.substructure.fg_closure_singleton FirstOrder.Language.Substructure.fg_closure_singleton

/- warning: first_order.language.substructure.fg.sup -> FirstOrder.Language.Substructure.FG.sup is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N₁ : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {N₂ : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 N₁) -> (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 N₂) -> (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 (Sup.sup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SemilatticeSup.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Lattice.toSemilatticeSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) N₁ N₂))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N₁ : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1} {N₂ : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 N₁) -> (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 N₂) -> (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 (Sup.sup.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SemilatticeSup.toSup.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (Lattice.toSemilatticeSup.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1))))) N₁ N₂))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg.sup FirstOrder.Language.Substructure.FG.supₓ'. -/
theorem FG.sup {N₁ N₂ : L.Substructure M} (hN₁ : N₁.FG) (hN₂ : N₂.FG) : (N₁ ⊔ N₂).FG :=
  let ⟨t₁, ht₁⟩ := fg_def.1 hN₁
  let ⟨t₂, ht₂⟩ := fg_def.1 hN₂
  fg_def.2 ⟨t₁ ∪ t₂, ht₁.1.union ht₂.1, by rw [closure_union, ht₁.2, ht₂.2]⟩
#align first_order.language.substructure.fg.sup FirstOrder.Language.Substructure.FG.sup

/- warning: first_order.language.substructure.fg.map -> FirstOrder.Language.Substructure.FG.map is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {s : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 s) -> (FirstOrder.Language.Substructure.FG.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f s))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N] (f : FirstOrder.Language.Hom.{u3, u2, u1, u4} L M N _inst_1 _inst_2) {s : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 s) -> (FirstOrder.Language.Substructure.FG.{u3, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u3, u2, u1, u4} L M N _inst_1 _inst_2 f s))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg.map FirstOrder.Language.Substructure.FG.mapₓ'. -/
theorem FG.map {N : Type _} [L.Structure N] (f : M →[L] N) {s : L.Substructure M} (hs : s.FG) :
    (s.map f).FG :=
  let ⟨t, ht⟩ := fg_def.1 hs
  fg_def.2 ⟨f '' t, ht.1.image _, by rw [closure_image, ht.2]⟩
#align first_order.language.substructure.fg.map FirstOrder.Language.Substructure.FG.map

/- warning: first_order.language.substructure.fg.of_map_embedding -> FirstOrder.Language.Substructure.FG.of_map_embedding is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {s : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, (FirstOrder.Language.Substructure.FG.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) s)) -> (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 s)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u3, u2, u1, u4} L M N _inst_1 _inst_2) {s : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, (FirstOrder.Language.Substructure.FG.{u3, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u3, u2, u1, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u3, u2, u1, u4} L M N _inst_1 _inst_2 f) s)) -> (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 s)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg.of_map_embedding FirstOrder.Language.Substructure.FG.of_map_embeddingₓ'. -/
theorem FG.of_map_embedding {N : Type _} [L.Structure N] (f : M ↪[L] N) {s : L.Substructure M}
    (hs : (s.map f.toHom).FG) : s.FG :=
  by
  rcases hs with ⟨t, h⟩
  rw [fg_def]
  refine' ⟨f ⁻¹' t, t.finite_to_set.preimage (f.injective.inj_on _), _⟩
  have hf : Function.Injective f.to_hom := f.injective
  refine' map_injective_of_injective hf _
  rw [← h, map_closure, embedding.coe_to_hom, image_preimage_eq_of_subset]
  intro x hx
  have h' := subset_closure hx
  rw [h] at h'
  exact hom.map_le_range h'
#align first_order.language.substructure.fg.of_map_embedding FirstOrder.Language.Substructure.FG.of_map_embedding

#print FirstOrder.Language.Substructure.CG /-
/-- A substructure of `M` is countably generated if it is the closure of a countable subset of `M`.
-/
def CG (N : L.Substructure M) : Prop :=
  ∃ S : Set M, S.Countable ∧ closure L S = N
#align first_order.language.substructure.cg FirstOrder.Language.Substructure.CG
-/

/- warning: first_order.language.substructure.cg_def -> FirstOrder.Language.Substructure.cg_def is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, Iff (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 N) (Exists.{succ u3} (Set.{u3} M) (fun (S : Set.{u3} M) => And (Set.Countable.{u3} M S) (Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) S) N)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, Iff (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 N) (Exists.{succ u1} (Set.{u1} M) (fun (S : Set.{u1} M) => And (Set.Countable.{u1} M S) (Eq.{succ u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (LowerAdjoint.toFun.{u1, u1} (Set.{u1} M) (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} M) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} M) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} M) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} M) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} M) (Set.instCompleteBooleanAlgebraSet.{u1} M))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u3, u2, u1} L M _inst_1) S) N)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg_def FirstOrder.Language.Substructure.cg_defₓ'. -/
theorem cg_def {N : L.Substructure M} : N.CG ↔ ∃ S : Set M, S.Countable ∧ closure L S = N :=
  Iff.refl _
#align first_order.language.substructure.cg_def FirstOrder.Language.Substructure.cg_def

/- warning: first_order.language.substructure.fg.cg -> FirstOrder.Language.Substructure.FG.cg is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 N) -> (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 N)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 N) -> (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 N)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg.cg FirstOrder.Language.Substructure.FG.cgₓ'. -/
theorem FG.cg {N : L.Substructure M} (h : N.FG) : N.CG :=
  by
  obtain ⟨s, hf, rfl⟩ := fg_def.1 h
  refine' ⟨s, hf.countable, rfl⟩
#align first_order.language.substructure.fg.cg FirstOrder.Language.Substructure.FG.cg

/- warning: first_order.language.substructure.cg_iff_empty_or_exists_nat_generating_family -> FirstOrder.Language.Substructure.cg_iff_empty_or_exists_nat_generating_family is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, Iff (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 N) (Or (Eq.{succ u3} (Set.{u3} M) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))) N) (EmptyCollection.emptyCollection.{u3} (Set.{u3} M) (Set.hasEmptyc.{u3} M))) (Exists.{succ u3} (Nat -> M) (fun (s : Nat -> M) => Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Set.range.{u3, 1} M Nat s)) N)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, Iff (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 N) (Or (Eq.{succ u1} (Set.{u1} M) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1) N) (EmptyCollection.emptyCollection.{u1} (Set.{u1} M) (Set.instEmptyCollectionSet.{u1} M))) (Exists.{succ u1} (Nat -> M) (fun (s : Nat -> M) => Eq.{succ u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (LowerAdjoint.toFun.{u1, u1} (Set.{u1} M) (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} M) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} M) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} M) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} M) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} M) (Set.instCompleteBooleanAlgebraSet.{u1} M))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u3, u2, u1} L M _inst_1) (Set.range.{u1, 1} M Nat s)) N)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg_iff_empty_or_exists_nat_generating_family FirstOrder.Language.Substructure.cg_iff_empty_or_exists_nat_generating_familyₓ'. -/
theorem cg_iff_empty_or_exists_nat_generating_family {N : L.Substructure M} :
    N.CG ↔ ↑N = (∅ : Set M) ∨ ∃ s : ℕ → M, closure L (range s) = N :=
  by
  rw [cg_def]
  constructor
  · rintro ⟨S, Scount, hS⟩
    cases' eq_empty_or_nonempty ↑N with h h
    · exact Or.intro_left _ h
    obtain ⟨f, h'⟩ :=
      (Scount.union (Set.countable_singleton h.some)).exists_eq_range
        (singleton_nonempty h.some).inr
    refine' Or.intro_right _ ⟨f, _⟩
    rw [← h', closure_union, hS, sup_eq_left, closure_le]
    exact singleton_subset_iff.2 h.some_mem
  · intro h
    cases' h with h h
    · refine' ⟨∅, countable_empty, closure_eq_of_le (empty_subset _) _⟩
      rw [← SetLike.coe_subset_coe, h]
      exact empty_subset _
    · obtain ⟨f, rfl⟩ := h
      exact ⟨range f, countable_range _, rfl⟩
#align first_order.language.substructure.cg_iff_empty_or_exists_nat_generating_family FirstOrder.Language.Substructure.cg_iff_empty_or_exists_nat_generating_family

/- warning: first_order.language.substructure.cg_bot -> FirstOrder.Language.Substructure.cg_bot is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 (Bot.bot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toHasBot.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M], FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 (Bot.bot.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toBot.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg_bot FirstOrder.Language.Substructure.cg_botₓ'. -/
theorem cg_bot : (⊥ : L.Substructure M).CG :=
  fg_bot.CG
#align first_order.language.substructure.cg_bot FirstOrder.Language.Substructure.cg_bot

/- warning: first_order.language.substructure.cg_closure -> FirstOrder.Language.Substructure.cg_closure is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {s : Set.{u3} M}, (Set.Countable.{u3} M s) -> (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) s))
but is expected to have type
  forall {L : FirstOrder.Language.{u2, u1}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u2, u1, u3} L M] {s : Set.{u3} M}, (Set.Countable.{u3} M s) -> (FirstOrder.Language.Substructure.CG.{u2, u1, u3} L M _inst_1 (LowerAdjoint.toFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.instCompleteBooleanAlgebraSet.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u3} (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u3} (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u2, u1, u3} L M _inst_1)))) (SetLike.coe.{u3, u3} (FirstOrder.Language.Substructure.{u2, u1, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u2, u1, u3} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u2, u1, u3} L M _inst_1) s))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg_closure FirstOrder.Language.Substructure.cg_closureₓ'. -/
theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=
  ⟨s, hs, rfl⟩
#align first_order.language.substructure.cg_closure FirstOrder.Language.Substructure.cg_closure

/- warning: first_order.language.substructure.cg_closure_singleton -> FirstOrder.Language.Substructure.cg_closure_singleton is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (x : M), FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) (Singleton.singleton.{u3, u3} M (Set.{u3} M) (Set.hasSingleton.{u3} M) x))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] (x : M), FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 (LowerAdjoint.toFun.{u1, u1} (Set.{u1} M) (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} M) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} M) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} M) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} M) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} M) (Set.instCompleteBooleanAlgebraSet.{u1} M))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u3, u2, u1} L M _inst_1) (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) x))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg_closure_singleton FirstOrder.Language.Substructure.cg_closure_singletonₓ'. -/
theorem cg_closure_singleton (x : M) : CG (closure L ({x} : Set M)) :=
  (fg_closure_singleton x).CG
#align first_order.language.substructure.cg_closure_singleton FirstOrder.Language.Substructure.cg_closure_singleton

/- warning: first_order.language.substructure.cg.sup -> FirstOrder.Language.Substructure.CG.sup is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N₁ : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1} {N₂ : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 N₁) -> (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 N₂) -> (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 (Sup.sup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SemilatticeSup.toHasSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Lattice.toSemilatticeSup.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u1, u2, u3} L M _inst_1))))) N₁ N₂))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N₁ : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1} {N₂ : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 N₁) -> (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 N₂) -> (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 (Sup.sup.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SemilatticeSup.toSup.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (Lattice.toSemilatticeSup.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (ConditionallyCompleteLattice.toLattice.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toConditionallyCompleteLattice.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1))))) N₁ N₂))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg.sup FirstOrder.Language.Substructure.CG.supₓ'. -/
theorem CG.sup {N₁ N₂ : L.Substructure M} (hN₁ : N₁.CG) (hN₂ : N₂.CG) : (N₁ ⊔ N₂).CG :=
  let ⟨t₁, ht₁⟩ := cg_def.1 hN₁
  let ⟨t₂, ht₂⟩ := cg_def.1 hN₂
  cg_def.2 ⟨t₁ ∪ t₂, ht₁.1.union ht₂.1, by rw [closure_union, ht₁.2, ht₂.2]⟩
#align first_order.language.substructure.cg.sup FirstOrder.Language.Substructure.CG.sup

/- warning: first_order.language.substructure.cg.map -> FirstOrder.Language.Substructure.CG.map is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {s : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 s) -> (FirstOrder.Language.Substructure.CG.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f s))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N] (f : FirstOrder.Language.Hom.{u3, u2, u1, u4} L M N _inst_1 _inst_2) {s : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 s) -> (FirstOrder.Language.Substructure.CG.{u3, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u3, u2, u1, u4} L M N _inst_1 _inst_2 f s))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg.map FirstOrder.Language.Substructure.CG.mapₓ'. -/
theorem CG.map {N : Type _} [L.Structure N] (f : M →[L] N) {s : L.Substructure M} (hs : s.CG) :
    (s.map f).CG :=
  let ⟨t, ht⟩ := cg_def.1 hs
  cg_def.2 ⟨f '' t, ht.1.image _, by rw [closure_image, ht.2]⟩
#align first_order.language.substructure.cg.map FirstOrder.Language.Substructure.CG.map

/- warning: first_order.language.substructure.cg.of_map_embedding -> FirstOrder.Language.Substructure.CG.of_map_embedding is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u1, u2, u3, u4} L M N _inst_1 _inst_2) {s : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, (FirstOrder.Language.Substructure.CG.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u1, u2, u3, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f) s)) -> (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 s)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N] (f : FirstOrder.Language.Embedding.{u3, u2, u1, u4} L M N _inst_1 _inst_2) {s : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, (FirstOrder.Language.Substructure.CG.{u3, u2, u4} L N _inst_2 (FirstOrder.Language.Substructure.map.{u3, u2, u1, u4} L M N _inst_1 _inst_2 (FirstOrder.Language.Embedding.toHom.{u3, u2, u1, u4} L M N _inst_1 _inst_2 f) s)) -> (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 s)
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg.of_map_embedding FirstOrder.Language.Substructure.CG.of_map_embeddingₓ'. -/
theorem CG.of_map_embedding {N : Type _} [L.Structure N] (f : M ↪[L] N) {s : L.Substructure M}
    (hs : (s.map f.toHom).CG) : s.CG :=
  by
  rcases hs with ⟨t, h1, h2⟩
  rw [cg_def]
  refine' ⟨f ⁻¹' t, h1.preimage f.injective, _⟩
  have hf : Function.Injective f.to_hom := f.injective
  refine' map_injective_of_injective hf _
  rw [← h2, map_closure, embedding.coe_to_hom, image_preimage_eq_of_subset]
  intro x hx
  have h' := subset_closure hx
  rw [h2] at h'
  exact hom.map_le_range h'
#align first_order.language.substructure.cg.of_map_embedding FirstOrder.Language.Substructure.CG.of_map_embedding

/- warning: first_order.language.substructure.cg_iff_countable -> FirstOrder.Language.Substructure.cg_iff_countable is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : Countable.{succ u1} (Sigma.{0, u1} Nat (fun (l : Nat) => FirstOrder.Language.Functions.{u1, u2} L l))] {s : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1}, Iff (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 s) (Countable.{succ u3} (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) s))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] [_inst_2 : Countable.{succ u3} (Sigma.{0, u3} Nat (fun (l : Nat) => FirstOrder.Language.Functions.{u3, u2} L l))] {s : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1}, Iff (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 s) (Countable.{succ u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x s)))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg_iff_countable FirstOrder.Language.Substructure.cg_iff_countableₓ'. -/
theorem cg_iff_countable [Countable (Σl, L.Functions l)] {s : L.Substructure M} :
    s.CG ↔ Countable s :=
  by
  refine' ⟨_, fun h => ⟨s, h.to_set, s.closure_eq⟩⟩
  rintro ⟨s, h, rfl⟩
  exact h.substructure_closure L
#align first_order.language.substructure.cg_iff_countable FirstOrder.Language.Substructure.cg_iff_countable

end Substructure

open Substructure

namespace Structure

variable (L) (M)

#print FirstOrder.Language.Structure.FG /-
/-- A structure is finitely generated if it is the closure of a finite subset. -/
class FG : Prop where
  out : (⊤ : L.Substructure M).FG
#align first_order.language.Structure.fg FirstOrder.Language.Structure.FG
-/

#print FirstOrder.Language.Structure.CG /-
/-- A structure is countably generated if it is the closure of a countable subset. -/
class CG : Prop where
  out : (⊤ : L.Substructure M).CG
#align first_order.language.Structure.cg FirstOrder.Language.Structure.CG
-/

variable {L M}

/- warning: first_order.language.Structure.fg_def -> FirstOrder.Language.Structure.fg_def is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], Iff (FirstOrder.Language.Structure.FG.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M], Iff (FirstOrder.Language.Structure.FG.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1)))
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.fg_def FirstOrder.Language.Structure.fg_defₓ'. -/
theorem fg_def : FG L M ↔ (⊤ : L.Substructure M).FG :=
  ⟨fun h => h.1, fun h => ⟨h⟩⟩
#align first_order.language.Structure.fg_def FirstOrder.Language.Structure.fg_def

/- warning: first_order.language.Structure.fg_iff -> FirstOrder.Language.Structure.fg_iff is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], Iff (FirstOrder.Language.Structure.FG.{u1, u2, u3} L M _inst_1) (Exists.{succ u3} (Set.{u3} M) (fun (S : Set.{u3} M) => And (Set.Finite.{u3} M S) (Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) S) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M], Iff (FirstOrder.Language.Structure.FG.{u3, u2, u1} L M _inst_1) (Exists.{succ u1} (Set.{u1} M) (fun (S : Set.{u1} M) => And (Set.Finite.{u1} M S) (Eq.{succ u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (LowerAdjoint.toFun.{u1, u1} (Set.{u1} M) (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} M) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} M) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} M) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} M) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} M) (Set.instCompleteBooleanAlgebraSet.{u1} M))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u3, u2, u1} L M _inst_1) S) (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1)))))
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.fg_iff FirstOrder.Language.Structure.fg_iffₓ'. -/
/-- An equivalent expression of `Structure.fg` in terms of `set.finite` instead of `finset`. -/
theorem fg_iff : FG L M ↔ ∃ S : Set M, S.Finite ∧ closure L S = (⊤ : L.Substructure M) := by
  rw [fg_def, substructure.fg_def]
#align first_order.language.Structure.fg_iff FirstOrder.Language.Structure.fg_iff

/- warning: first_order.language.Structure.fg.range -> FirstOrder.Language.Structure.FG.range is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], (FirstOrder.Language.Structure.FG.{u1, u2, u3} L M _inst_1) -> (forall (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), FirstOrder.Language.Substructure.FG.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N], (FirstOrder.Language.Structure.FG.{u3, u2, u1} L M _inst_1) -> (forall (f : FirstOrder.Language.Hom.{u3, u2, u1, u4} L M N _inst_1 _inst_2), FirstOrder.Language.Substructure.FG.{u3, u2, u4} L N _inst_2 (FirstOrder.Language.Hom.range.{u3, u2, u1, u4} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.fg.range FirstOrder.Language.Structure.FG.rangeₓ'. -/
theorem FG.range {N : Type _} [L.Structure N] (h : FG L M) (f : M →[L] N) : f.range.FG :=
  by
  rw [hom.range_eq_map]
  exact (fg_def.1 h).map f
#align first_order.language.Structure.fg.range FirstOrder.Language.Structure.FG.range

/- warning: first_order.language.Structure.fg.map_of_surjective -> FirstOrder.Language.Structure.FG.map_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], (FirstOrder.Language.Structure.FG.{u1, u2, u3} L M _inst_1) -> (forall (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (FirstOrder.Language.Structure.FG.{u1, u2, u4} L N _inst_2))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N], (FirstOrder.Language.Structure.FG.{u3, u2, u1} L M _inst_1) -> (forall (f : FirstOrder.Language.Hom.{u3, u2, u1, u4} L M N _inst_1 _inst_2), (Function.Surjective.{succ u1, succ u4} M N (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (FirstOrder.Language.Hom.{u3, u2, u1, u4} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u3, u2, u1, u4} L M N _inst_1 _inst_2) f)) -> (FirstOrder.Language.Structure.FG.{u3, u2, u4} L N _inst_2))
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.fg.map_of_surjective FirstOrder.Language.Structure.FG.map_of_surjectiveₓ'. -/
theorem FG.map_of_surjective {N : Type _} [L.Structure N] (h : FG L M) (f : M →[L] N)
    (hs : Function.Surjective f) : FG L N :=
  by
  rw [← hom.range_eq_top] at hs
  rw [fg_def, ← hs]
  exact h.range f
#align first_order.language.Structure.fg.map_of_surjective FirstOrder.Language.Structure.FG.map_of_surjective

/- warning: first_order.language.Structure.cg_def -> FirstOrder.Language.Structure.cg_def is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], Iff (FirstOrder.Language.Structure.CG.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M], Iff (FirstOrder.Language.Structure.CG.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1)))
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.cg_def FirstOrder.Language.Structure.cg_defₓ'. -/
theorem cg_def : CG L M ↔ (⊤ : L.Substructure M).CG :=
  ⟨fun h => h.1, fun h => ⟨h⟩⟩
#align first_order.language.Structure.cg_def FirstOrder.Language.Structure.cg_def

/- warning: first_order.language.Structure.cg_iff -> FirstOrder.Language.Structure.cg_iff is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], Iff (FirstOrder.Language.Structure.CG.{u1, u2, u3} L M _inst_1) (Exists.{succ u3} (Set.{u3} M) (fun (S : Set.{u3} M) => And (Set.Countable.{u3} M S) (Eq.{succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (coeFn.{succ u3, succ u3} (LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (fun (_x : LowerAdjoint.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) => (Set.{u3} M) -> (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1)) (LowerAdjoint.hasCoeToFun.{u3, u3} (Set.{u3} M) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (PartialOrder.toPreorder.{u3} (Set.{u3} M) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} M) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} M) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} M) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} M) (Set.completeBooleanAlgebra.{u3} M))))))) (PartialOrder.toPreorder.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (SetLike.partialOrder.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)))))) (FirstOrder.Language.Substructure.closure.{u1, u2, u3} L M _inst_1) S) (Top.top.{u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u1, u2, u3} L M _inst_1)))))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M], Iff (FirstOrder.Language.Structure.CG.{u3, u2, u1} L M _inst_1) (Exists.{succ u1} (Set.{u1} M) (fun (S : Set.{u1} M) => And (Set.Countable.{u1} M S) (Eq.{succ u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (LowerAdjoint.toFun.{u1, u1} (Set.{u1} M) (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (PartialOrder.toPreorder.{u1} (Set.{u1} M) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} M) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} M) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} M) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} M) (Set.instCompleteBooleanAlgebraSet.{u1} M))))))) (PartialOrder.toPreorder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instCompleteLattice.{u3, u2, u1} L M _inst_1)))) (SetLike.coe.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) (FirstOrder.Language.Substructure.closure.{u3, u2, u1} L M _inst_1) S) (Top.top.{u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Substructure.instTop.{u3, u2, u1} L M _inst_1)))))
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.cg_iff FirstOrder.Language.Structure.cg_iffₓ'. -/
/-- An equivalent expression of `Structure.cg`. -/
theorem cg_iff : CG L M ↔ ∃ S : Set M, S.Countable ∧ closure L S = (⊤ : L.Substructure M) := by
  rw [cg_def, substructure.cg_def]
#align first_order.language.Structure.cg_iff FirstOrder.Language.Structure.cg_iff

/- warning: first_order.language.Structure.cg.range -> FirstOrder.Language.Structure.CG.range is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], (FirstOrder.Language.Structure.CG.{u1, u2, u3} L M _inst_1) -> (forall (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), FirstOrder.Language.Substructure.CG.{u1, u2, u4} L N _inst_2 (FirstOrder.Language.Hom.range.{u1, u2, u3, u4} L M N _inst_1 _inst_2 f))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N], (FirstOrder.Language.Structure.CG.{u3, u2, u1} L M _inst_1) -> (forall (f : FirstOrder.Language.Hom.{u3, u2, u1, u4} L M N _inst_1 _inst_2), FirstOrder.Language.Substructure.CG.{u3, u2, u4} L N _inst_2 (FirstOrder.Language.Hom.range.{u3, u2, u1, u4} L M N _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.cg.range FirstOrder.Language.Structure.CG.rangeₓ'. -/
theorem CG.range {N : Type _} [L.Structure N] (h : CG L M) (f : M →[L] N) : f.range.CG :=
  by
  rw [hom.range_eq_map]
  exact (cg_def.1 h).map f
#align first_order.language.Structure.cg.range FirstOrder.Language.Structure.CG.range

/- warning: first_order.language.Structure.cg.map_of_surjective -> FirstOrder.Language.Structure.CG.map_of_surjective is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], (FirstOrder.Language.Structure.CG.{u1, u2, u3} L M _inst_1) -> (forall (f : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2), (Function.Surjective.{succ u3, succ u4} M N (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) (fun (_x : FirstOrder.Language.Hom.{u1, u2, u3, u4} L M N _inst_1 _inst_2) => M -> N) (FirstOrder.Language.Hom.hasCoeToFun.{u1, u2, u3, u4} L M N _inst_1 _inst_2) f)) -> (FirstOrder.Language.Structure.CG.{u1, u2, u4} L N _inst_2))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N], (FirstOrder.Language.Structure.CG.{u3, u2, u1} L M _inst_1) -> (forall (f : FirstOrder.Language.Hom.{u3, u2, u1, u4} L M N _inst_1 _inst_2), (Function.Surjective.{succ u1, succ u4} M N (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (FirstOrder.Language.Hom.{u3, u2, u1, u4} L M N _inst_1 _inst_2) M (fun (_x : M) => (fun (a._@.Mathlib.ModelTheory.Basic._hyg.5742 : M) => N) _x) (FirstOrder.Language.Hom.funLike.{u3, u2, u1, u4} L M N _inst_1 _inst_2) f)) -> (FirstOrder.Language.Structure.CG.{u3, u2, u4} L N _inst_2))
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.cg.map_of_surjective FirstOrder.Language.Structure.CG.map_of_surjectiveₓ'. -/
theorem CG.map_of_surjective {N : Type _} [L.Structure N] (h : CG L M) (f : M →[L] N)
    (hs : Function.Surjective f) : CG L N :=
  by
  rw [← hom.range_eq_top] at hs
  rw [cg_def, ← hs]
  exact h.range f
#align first_order.language.Structure.cg.map_of_surjective FirstOrder.Language.Structure.CG.map_of_surjective

/- warning: first_order.language.Structure.cg_iff_countable -> FirstOrder.Language.Structure.cg_iff_countable is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] [_inst_2 : Countable.{succ u1} (Sigma.{0, u1} Nat (fun (l : Nat) => FirstOrder.Language.Functions.{u1, u2} L l))], Iff (FirstOrder.Language.Structure.CG.{u1, u2, u3} L M _inst_1) (Countable.{succ u3} M)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] [_inst_2 : Countable.{succ u3} (Sigma.{0, u3} Nat (fun (l : Nat) => FirstOrder.Language.Functions.{u3, u2} L l))], Iff (FirstOrder.Language.Structure.CG.{u3, u2, u1} L M _inst_1) (Countable.{succ u1} M)
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.cg_iff_countable FirstOrder.Language.Structure.cg_iff_countableₓ'. -/
theorem cg_iff_countable [Countable (Σl, L.Functions l)] : CG L M ↔ Countable M := by
  rw [cg_def, cg_iff_countable, top_equiv.to_equiv.countable_iff]
#align first_order.language.Structure.cg_iff_countable FirstOrder.Language.Structure.cg_iff_countable

/- warning: first_order.language.Structure.fg.cg -> FirstOrder.Language.Structure.FG.cg is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M], (FirstOrder.Language.Structure.FG.{u1, u2, u3} L M _inst_1) -> (FirstOrder.Language.Structure.CG.{u1, u2, u3} L M _inst_1)
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M], (FirstOrder.Language.Structure.FG.{u3, u2, u1} L M _inst_1) -> (FirstOrder.Language.Structure.CG.{u3, u2, u1} L M _inst_1)
Case conversion may be inaccurate. Consider using '#align first_order.language.Structure.fg.cg FirstOrder.Language.Structure.FG.cgₓ'. -/
theorem FG.cg (h : FG L M) : CG L M :=
  cg_def.2 (fg_def.1 h).CG
#align first_order.language.Structure.fg.cg FirstOrder.Language.Structure.FG.cg

#print FirstOrder.Language.Structure.cg_of_fg /-
instance (priority := 100) cg_of_fg [h : FG L M] : CG L M :=
  h.CG
#align first_order.language.Structure.cg_of_fg FirstOrder.Language.Structure.cg_of_fg
-/

end Structure

/- warning: first_order.language.equiv.fg_iff -> FirstOrder.Language.Equiv.fg_iff is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], (FirstOrder.Language.Equiv.{u1, u2, u3, u4} L M N _inst_1 _inst_2) -> (Iff (FirstOrder.Language.Structure.FG.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Structure.FG.{u1, u2, u4} L N _inst_2))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N], (FirstOrder.Language.Equiv.{u3, u2, u1, u4} L M N _inst_1 _inst_2) -> (Iff (FirstOrder.Language.Structure.FG.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Structure.FG.{u3, u2, u4} L N _inst_2))
Case conversion may be inaccurate. Consider using '#align first_order.language.equiv.fg_iff FirstOrder.Language.Equiv.fg_iffₓ'. -/
theorem Equiv.fg_iff {N : Type _} [L.Structure N] (f : M ≃[L] N) :
    Structure.FG L M ↔ Structure.FG L N :=
  ⟨fun h => h.mapOfSurjective f.toHom f.toEquiv.Surjective, fun h =>
    h.mapOfSurjective f.symm.toHom f.toEquiv.symm.Surjective⟩
#align first_order.language.equiv.fg_iff FirstOrder.Language.Equiv.fg_iff

/- warning: first_order.language.substructure.fg_iff_Structure_fg -> FirstOrder.Language.Substructure.fg_iff_structure_fg is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), Iff (FirstOrder.Language.Substructure.FG.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Structure.FG.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] (S : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1), Iff (FirstOrder.Language.Substructure.FG.{u3, u2, u1} L M _inst_1 S) (FirstOrder.Language.Structure.FG.{u3, u2, u1} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) (FirstOrder.Language.Substructure.inducedStructure.{u3, u2, u1} L M _inst_1 S))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.fg_iff_Structure_fg FirstOrder.Language.Substructure.fg_iff_structure_fgₓ'. -/
theorem Substructure.fg_iff_structure_fg (S : L.Substructure M) : S.FG ↔ Structure.FG L S :=
  by
  rw [Structure.fg_def]
  refine' ⟨fun h => fg.of_map_embedding S.subtype _, fun h => _⟩
  · rw [← hom.range_eq_map, range_subtype]
    exact h
  · have h := h.map S.subtype.to_hom
    rw [← hom.range_eq_map, range_subtype] at h
    exact h
#align first_order.language.substructure.fg_iff_Structure_fg FirstOrder.Language.Substructure.fg_iff_structure_fg

/- warning: first_order.language.equiv.cg_iff -> FirstOrder.Language.Equiv.cg_iff is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u1, u2, u4} L N], (FirstOrder.Language.Equiv.{u1, u2, u3, u4} L M N _inst_1 _inst_2) -> (Iff (FirstOrder.Language.Structure.CG.{u1, u2, u3} L M _inst_1) (FirstOrder.Language.Structure.CG.{u1, u2, u4} L N _inst_2))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] {N : Type.{u4}} [_inst_2 : FirstOrder.Language.Structure.{u3, u2, u4} L N], (FirstOrder.Language.Equiv.{u3, u2, u1, u4} L M N _inst_1 _inst_2) -> (Iff (FirstOrder.Language.Structure.CG.{u3, u2, u1} L M _inst_1) (FirstOrder.Language.Structure.CG.{u3, u2, u4} L N _inst_2))
Case conversion may be inaccurate. Consider using '#align first_order.language.equiv.cg_iff FirstOrder.Language.Equiv.cg_iffₓ'. -/
theorem Equiv.cg_iff {N : Type _} [L.Structure N] (f : M ≃[L] N) :
    Structure.CG L M ↔ Structure.CG L N :=
  ⟨fun h => h.mapOfSurjective f.toHom f.toEquiv.Surjective, fun h =>
    h.mapOfSurjective f.symm.toHom f.toEquiv.symm.Surjective⟩
#align first_order.language.equiv.cg_iff FirstOrder.Language.Equiv.cg_iff

/- warning: first_order.language.substructure.cg_iff_Structure_cg -> FirstOrder.Language.Substructure.cg_iff_structure_cg is a dubious translation:
lean 3 declaration is
  forall {L : FirstOrder.Language.{u1, u2}} {M : Type.{u3}} [_inst_1 : FirstOrder.Language.Structure.{u1, u2, u3} L M] (S : FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1), Iff (FirstOrder.Language.Substructure.CG.{u1, u2, u3} L M _inst_1 S) (FirstOrder.Language.Structure.CG.{u1, u2, u3} L (coeSort.{succ u3, succ (succ u3)} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (FirstOrder.Language.Substructure.{u1, u2, u3} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u1, u2, u3} L M _inst_1)) S) (FirstOrder.Language.Substructure.inducedStructure.{u1, u2, u3} L M _inst_1 S))
but is expected to have type
  forall {L : FirstOrder.Language.{u3, u2}} {M : Type.{u1}} [_inst_1 : FirstOrder.Language.Structure.{u3, u2, u1} L M] (S : FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1), Iff (FirstOrder.Language.Substructure.CG.{u3, u2, u1} L M _inst_1 S) (FirstOrder.Language.Structure.CG.{u3, u2, u1} L (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) (SetLike.instMembership.{u1, u1} (FirstOrder.Language.Substructure.{u3, u2, u1} L M _inst_1) M (FirstOrder.Language.Substructure.instSetLike.{u3, u2, u1} L M _inst_1)) x S)) (FirstOrder.Language.Substructure.inducedStructure.{u3, u2, u1} L M _inst_1 S))
Case conversion may be inaccurate. Consider using '#align first_order.language.substructure.cg_iff_Structure_cg FirstOrder.Language.Substructure.cg_iff_structure_cgₓ'. -/
theorem Substructure.cg_iff_structure_cg (S : L.Substructure M) : S.CG ↔ Structure.CG L S :=
  by
  rw [Structure.cg_def]
  refine' ⟨fun h => cg.of_map_embedding S.subtype _, fun h => _⟩
  · rw [← hom.range_eq_map, range_subtype]
    exact h
  · have h := h.map S.subtype.to_hom
    rw [← hom.range_eq_map, range_subtype] at h
    exact h
#align first_order.language.substructure.cg_iff_Structure_cg FirstOrder.Language.Substructure.cg_iff_structure_cg

end Language

end FirstOrder

