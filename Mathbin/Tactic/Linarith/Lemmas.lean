/-
Copyright (c) 2020 Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robert Y. Lewis
-/
import Mathbin.Algebra.Order.Ring.Defs

/-!
# Lemmas for `linarith`

This file contains auxiliary lemmas that `linarith` uses to construct proofs.
If you find yourself looking for a theorem here, you might be in the wrong place.
-/


namespace Linarith

theorem zero_lt_one {α} [OrderedSemiring α] [Nontrivial α] : (0 : α) < 1 :=
  zero_lt_one
#align linarith.zero_lt_one Linarith.zero_lt_one

/- warning: linarith.eq_of_eq_of_eq -> Linarith.eq_of_eq_of_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} [_inst_1 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (Eq.{succ u_1} α a (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (Eq.{succ u_1} α b (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (Eq.{succ u_1} α (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toHasAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))) a b) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u_1}} [inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.23 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (Eq.{succ u_1} α a (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.23)))))) -> (Eq.{succ u_1} α b (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.23)))))) -> (Eq.{succ u_1} α (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.23)))))) a b) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.23))))))
Case conversion may be inaccurate. Consider using '#align linarith.eq_of_eq_of_eq Linarith.eq_of_eq_of_eqₓ'. -/
theorem eq_of_eq_of_eq {α} [OrderedSemiring α] {a b : α} (ha : a = 0) (hb : b = 0) : a + b = 0 := by
  simp [*]
#align linarith.eq_of_eq_of_eq Linarith.eq_of_eq_of_eq

/- warning: linarith.le_of_eq_of_le -> Linarith.le_of_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} [_inst_1 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (Eq.{succ u_1} α a (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommMonoid.toPartialOrder.{u_1} α (OrderedSemiring.toOrderedAddCommMonoid.{u_1} α _inst_1)))) b (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommMonoid.toPartialOrder.{u_1} α (OrderedSemiring.toOrderedAddCommMonoid.{u_1} α _inst_1)))) (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toHasAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))) a b) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u_1}} [inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.51 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (Eq.{succ u_1} α a (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.51)))))) -> (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedSemiring.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.51))) b (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.51)))))) -> (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedSemiring.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.51))) (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.51)))))) a b) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.51))))))
Case conversion may be inaccurate. Consider using '#align linarith.le_of_eq_of_le Linarith.le_of_eq_of_leₓ'. -/
theorem le_of_eq_of_le {α} [OrderedSemiring α] {a b : α} (ha : a = 0) (hb : b ≤ 0) : a + b ≤ 0 := by
  simp [*]
#align linarith.le_of_eq_of_le Linarith.le_of_eq_of_le

/- warning: linarith.lt_of_eq_of_lt -> Linarith.lt_of_eq_of_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} [_inst_1 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (Eq.{succ u_1} α a (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommMonoid.toPartialOrder.{u_1} α (OrderedSemiring.toOrderedAddCommMonoid.{u_1} α _inst_1)))) b (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommMonoid.toPartialOrder.{u_1} α (OrderedSemiring.toOrderedAddCommMonoid.{u_1} α _inst_1)))) (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toHasAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))) a b) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u_1}} [inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.79 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (Eq.{succ u_1} α a (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.79)))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedSemiring.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.79))) b (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.79)))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedSemiring.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.79))) (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.79)))))) a b) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.79))))))
Case conversion may be inaccurate. Consider using '#align linarith.lt_of_eq_of_lt Linarith.lt_of_eq_of_ltₓ'. -/
theorem lt_of_eq_of_lt {α} [OrderedSemiring α] {a b : α} (ha : a = 0) (hb : b < 0) : a + b < 0 := by
  simp [*]
#align linarith.lt_of_eq_of_lt Linarith.lt_of_eq_of_lt

/- warning: linarith.le_of_le_of_eq -> Linarith.le_of_le_of_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} [_inst_1 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommMonoid.toPartialOrder.{u_1} α (OrderedSemiring.toOrderedAddCommMonoid.{u_1} α _inst_1)))) a (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (Eq.{succ u_1} α b (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommMonoid.toPartialOrder.{u_1} α (OrderedSemiring.toOrderedAddCommMonoid.{u_1} α _inst_1)))) (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toHasAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))) a b) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u_1}} [inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.107 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedSemiring.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.107))) a (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.107)))))) -> (Eq.{succ u_1} α b (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.107)))))) -> (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedSemiring.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.107))) (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.107)))))) a b) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.107))))))
Case conversion may be inaccurate. Consider using '#align linarith.le_of_le_of_eq Linarith.le_of_le_of_eqₓ'. -/
theorem le_of_le_of_eq {α} [OrderedSemiring α] {a b : α} (ha : a ≤ 0) (hb : b = 0) : a + b ≤ 0 := by
  simp [*]
#align linarith.le_of_le_of_eq Linarith.le_of_le_of_eq

/- warning: linarith.lt_of_lt_of_eq -> Linarith.lt_of_lt_of_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} [_inst_1 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommMonoid.toPartialOrder.{u_1} α (OrderedSemiring.toOrderedAddCommMonoid.{u_1} α _inst_1)))) a (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (Eq.{succ u_1} α b (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommMonoid.toPartialOrder.{u_1} α (OrderedSemiring.toOrderedAddCommMonoid.{u_1} α _inst_1)))) (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toHasAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))) a b) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u_1}} [inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.135 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedSemiring.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.135))) a (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.135)))))) -> (Eq.{succ u_1} α b (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.135)))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedSemiring.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.135))) (HAdd.hAdd.{u_1, u_1, u_1} α α α (instHAdd.{u_1} α (Distrib.toAdd.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.135)))))) a b) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.135))))))
Case conversion may be inaccurate. Consider using '#align linarith.lt_of_lt_of_eq Linarith.lt_of_lt_of_eqₓ'. -/
theorem lt_of_lt_of_eq {α} [OrderedSemiring α] {a b : α} (ha : a < 0) (hb : b = 0) : a + b < 0 := by
  simp [*]
#align linarith.lt_of_lt_of_eq Linarith.lt_of_lt_of_eq

/- warning: linarith.mul_neg -> Linarith.mul_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} [_inst_1 : StrictOrderedRing.{u_1} α] {a : α} {b : α}, (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommGroup.toPartialOrder.{u_1} α (StrictOrderedRing.toOrderedAddCommGroup.{u_1} α _inst_1)))) a (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u_1} α (NonAssocRing.toNonUnitalNonAssocRing.{u_1} α (Ring.toNonAssocRing.{u_1} α (StrictOrderedRing.toRing.{u_1} α _inst_1)))))))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommGroup.toPartialOrder.{u_1} α (StrictOrderedRing.toOrderedAddCommGroup.{u_1} α _inst_1)))) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u_1} α (NonAssocRing.toNonUnitalNonAssocRing.{u_1} α (Ring.toNonAssocRing.{u_1} α (StrictOrderedRing.toRing.{u_1} α _inst_1))))))))) b) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommGroup.toPartialOrder.{u_1} α (StrictOrderedRing.toOrderedAddCommGroup.{u_1} α _inst_1)))) (HMul.hMul.{u_1, u_1, u_1} α α α (instHMul.{u_1} α (Distrib.toHasMul.{u_1} α (Ring.toDistrib.{u_1} α (StrictOrderedRing.toRing.{u_1} α _inst_1)))) b a) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u_1} α (NonAssocRing.toNonUnitalNonAssocRing.{u_1} α (Ring.toNonAssocRing.{u_1} α (StrictOrderedRing.toRing.{u_1} α _inst_1))))))))))
but is expected to have type
  forall {α : Type.{u_1}} [inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.163 : StrictOrderedRing.{u_1} α] {a : α} {b : α}, (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (StrictOrderedRing.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.163))) a (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (StrictOrderedSemiring.toSemiring.{u_1} α (StrictOrderedRing.toStrictOrderedSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.163))))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (StrictOrderedRing.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.163))) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (StrictOrderedSemiring.toSemiring.{u_1} α (StrictOrderedRing.toStrictOrderedSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.163)))))) b) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (StrictOrderedRing.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.163))) (HMul.hMul.{u_1, u_1, u_1} α α α (instHMul.{u_1} α (NonUnitalNonAssocRing.toMul.{u_1} α (NonAssocRing.toNonUnitalNonAssocRing.{u_1} α (Ring.toNonAssocRing.{u_1} α (StrictOrderedRing.toRing.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.163))))) b a) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (StrictOrderedSemiring.toSemiring.{u_1} α (StrictOrderedRing.toStrictOrderedSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.163)))))))
Case conversion may be inaccurate. Consider using '#align linarith.mul_neg Linarith.mul_negₓ'. -/
theorem mul_neg {α} [StrictOrderedRing α] {a b : α} (ha : a < 0) (hb : 0 < b) : b * a < 0 :=
  have : -b * a > 0 := mul_pos_of_neg_of_neg (neg_neg_of_pos hb) ha
  neg_of_neg_pos (by simpa)
#align linarith.mul_neg Linarith.mul_neg

/- warning: linarith.mul_nonpos -> Linarith.mul_nonpos is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} [_inst_1 : OrderedRing.{u_1} α] {a : α} {b : α}, (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommGroup.toPartialOrder.{u_1} α (OrderedRing.toOrderedAddCommGroup.{u_1} α _inst_1)))) a (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u_1} α (NonAssocRing.toNonUnitalNonAssocRing.{u_1} α (Ring.toNonAssocRing.{u_1} α (OrderedRing.toRing.{u_1} α _inst_1)))))))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommGroup.toPartialOrder.{u_1} α (OrderedRing.toOrderedAddCommGroup.{u_1} α _inst_1)))) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u_1} α (NonAssocRing.toNonUnitalNonAssocRing.{u_1} α (Ring.toNonAssocRing.{u_1} α (OrderedRing.toRing.{u_1} α _inst_1))))))))) b) -> (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommGroup.toPartialOrder.{u_1} α (OrderedRing.toOrderedAddCommGroup.{u_1} α _inst_1)))) (HMul.hMul.{u_1, u_1, u_1} α α α (instHMul.{u_1} α (Distrib.toHasMul.{u_1} α (Ring.toDistrib.{u_1} α (OrderedRing.toRing.{u_1} α _inst_1)))) b a) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u_1} α (NonAssocRing.toNonUnitalNonAssocRing.{u_1} α (Ring.toNonAssocRing.{u_1} α (OrderedRing.toRing.{u_1} α _inst_1))))))))))
but is expected to have type
  forall {α : Type.{u_1}} [inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.191 : OrderedRing.{u_1} α] {a : α} {b : α}, (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedRing.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.191))) a (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α (OrderedRing.toOrderedSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.191))))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedRing.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.191))) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α (OrderedRing.toOrderedSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.191)))))) b) -> (LE.le.{u_1} α (Preorder.toLE.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedRing.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.191))) (HMul.hMul.{u_1, u_1, u_1} α α α (instHMul.{u_1} α (NonUnitalNonAssocRing.toMul.{u_1} α (NonAssocRing.toNonUnitalNonAssocRing.{u_1} α (Ring.toNonAssocRing.{u_1} α (OrderedRing.toRing.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.191))))) b a) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α (OrderedRing.toOrderedSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.191)))))))
Case conversion may be inaccurate. Consider using '#align linarith.mul_nonpos Linarith.mul_nonposₓ'. -/
theorem mul_nonpos {α} [OrderedRing α] {a b : α} (ha : a ≤ 0) (hb : 0 < b) : b * a ≤ 0 := by
  have : -b * a ≥ 0 := mul_nonneg_of_nonpos_of_nonpos (le_of_lt (neg_neg_of_pos hb)) ha
  simpa
#align linarith.mul_nonpos Linarith.mul_nonpos

/- warning: linarith.mul_eq -> Linarith.mul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} [_inst_1 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (Eq.{succ u_1} α a (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1))))))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedAddCommMonoid.toPartialOrder.{u_1} α (OrderedSemiring.toOrderedAddCommMonoid.{u_1} α _inst_1)))) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))))) b) -> (Eq.{succ u_1} α (HMul.hMul.{u_1, u_1, u_1} α α α (instHMul.{u_1} α (Distrib.toHasMul.{u_1} α (NonUnitalNonAssocSemiring.toDistrib.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))) b a) (OfNat.ofNat.{u_1} α 0 (OfNat.mk.{u_1} α 0 (Zero.zero.{u_1} α (MulZeroClass.toHasZero.{u_1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u_1}} [inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.219 : OrderedSemiring.{u_1} α] {a : α} {b : α}, (Eq.{succ u_1} α a (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.219)))))) -> (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (OrderedSemiring.toPartialOrder.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.219))) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.219))))) b) -> (Eq.{succ u_1} α (HMul.hMul.{u_1, u_1, u_1} α α α (instHMul.{u_1} α (NonUnitalNonAssocSemiring.toMul.{u_1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} α (Semiring.toNonAssocSemiring.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.219))))) b a) (OfNat.ofNat.{u_1} α 0 (Zero.toOfNat0.{u_1} α (MonoidWithZero.toZero.{u_1} α (Semiring.toMonoidWithZero.{u_1} α (OrderedSemiring.toSemiring.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.219))))))
Case conversion may be inaccurate. Consider using '#align linarith.mul_eq Linarith.mul_eqₓ'. -/
-- used alongside `mul_neg` and `mul_nonpos`, so has the same argument pattern for uniformity
@[nolint unused_arguments]
theorem mul_eq {α} [OrderedSemiring α] {a b : α} (ha : a = 0) (hb : 0 < b) : b * a = 0 := by
  simp [*]
#align linarith.mul_eq Linarith.mul_eq

/- warning: linarith.eq_of_not_lt_of_not_gt -> Linarith.eq_of_not_lt_of_not_gt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} [_inst_1 : LinearOrder.{u_1} α] (a : α) (b : α), (Not (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (SemilatticeInf.toPartialOrder.{u_1} α (Lattice.toSemilatticeInf.{u_1} α (LinearOrder.toLattice.{u_1} α _inst_1))))) a b)) -> (Not (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (SemilatticeInf.toPartialOrder.{u_1} α (Lattice.toSemilatticeInf.{u_1} α (LinearOrder.toLattice.{u_1} α _inst_1))))) b a)) -> (Eq.{succ u_1} α a b)
but is expected to have type
  forall {α : Type.{u_1}} [inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.250 : LinearOrder.{u_1} α] (a : α) (b : α), (Not (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (SemilatticeInf.toPartialOrder.{u_1} α (Lattice.toSemilatticeInf.{u_1} α (DistribLattice.toLattice.{u_1} α (instDistribLattice.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.250)))))) a b)) -> (Not (LT.lt.{u_1} α (Preorder.toLT.{u_1} α (PartialOrder.toPreorder.{u_1} α (SemilatticeInf.toPartialOrder.{u_1} α (Lattice.toSemilatticeInf.{u_1} α (DistribLattice.toLattice.{u_1} α (instDistribLattice.{u_1} α inst._@.Mathlib.Tactic.Linarith.Lemmas._hyg.250)))))) b a)) -> (Eq.{succ u_1} α a b)
Case conversion may be inaccurate. Consider using '#align linarith.eq_of_not_lt_of_not_gt Linarith.eq_of_not_lt_of_not_gtₓ'. -/
theorem eq_of_not_lt_of_not_gt {α} [LinearOrder α] (a b : α) (h1 : ¬a < b) (h2 : ¬b < a) : a = b :=
  le_antisymm (le_of_not_gt h2) (le_of_not_gt h1)
#align linarith.eq_of_not_lt_of_not_gt Linarith.eq_of_not_lt_of_not_gt

-- used in the `nlinarith` normalization steps. The `_` argument is for uniformity.
@[nolint unused_arguments]
theorem mul_zero_eq {α} {R : α → α → Prop} [Semiring α] {a b : α} (_ : R a 0) (h : b = 0) :
    a * b = 0 := by simp [h]
#align linarith.mul_zero_eq Linarith.mul_zero_eq

-- used in the `nlinarith` normalization steps. The `_` argument is for uniformity.
@[nolint unused_arguments]
theorem zero_mul_eq {α} {R : α → α → Prop} [Semiring α] {a b : α} (h : a = 0) (_ : R b 0) :
    a * b = 0 := by simp [h]
#align linarith.zero_mul_eq Linarith.zero_mul_eq

end Linarith

