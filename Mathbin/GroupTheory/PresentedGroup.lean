/-
Copyright (c) 2019 Michael Howes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael Howes

! This file was ported from Lean 3 source module group_theory.presented_group
! leanprover-community/mathlib commit 0ebfdb71919ac6ca5d7fbc61a082fa2519556818
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.GroupTheory.FreeGroup
import Mathbin.GroupTheory.QuotientGroup

/-!
# Defining a group given by generators and relations

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Given a subset `rels` of relations of the free group on a type `α`, this file constructs the group
given by generators `x : α` and relations `r ∈ rels`.

## Main definitions

* `presented_group rels`: the quotient group of the free group on a type `α` by a subset `rels` of
  relations of the free group on `α`.
* `of`: The canonical map from `α` to a presented group with generators `α`.
* `to_group f`: the canonical group homomorphism `presented_group rels → G`, given a function
  `f : α → G` from a type `α` to a group `G` which satisfies the relations `rels`.

## Tags

generators, relations, group presentations
-/


variable {α : Type _}

#print PresentedGroup /-
/-- Given a set of relations, rels, over a type `α`, presented_group constructs the group with
generators `x : α` and relations `rels` as a quotient of free_group `α`.-/
def PresentedGroup (rels : Set (FreeGroup α)) :=
  FreeGroup α ⧸ Subgroup.normalClosure rels
#align presented_group PresentedGroup
-/

namespace PresentedGroup

instance (rels : Set (FreeGroup α)) : Group (PresentedGroup rels) :=
  QuotientGroup.Quotient.group _

#print PresentedGroup.of /-
/-- `of` is the canonical map from `α` to a presented group with generators `x : α`. The term `x` is
mapped to the equivalence class of the image of `x` in `free_group α`. -/
def of {rels : Set (FreeGroup α)} (x : α) : PresentedGroup rels :=
  QuotientGroup.mk (FreeGroup.of x)
#align presented_group.of PresentedGroup.of
-/

section ToGroup

/-
Presented groups satisfy a universal property. If `G` is a group and `f : α → G` is a map such that
the images of `f` satisfy all the given relations, then `f` extends uniquely to a group homomorphism
from `presented_group rels` to `G`.
-/
variable {G : Type _} [Group G] {f : α → G} {rels : Set (FreeGroup α)}

-- mathport name: exprF
local notation "F" => FreeGroup.lift f

variable (h : ∀ r ∈ rels, F r = 1)

/- warning: presented_group.closure_rels_subset_ker -> PresentedGroup.closure_rels_subset_ker is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] {f : α -> G} {rels : Set.{u1} (FreeGroup.{u1} α)}, (forall (r : FreeGroup.{u1} α), (Membership.Mem.{u1, u1} (FreeGroup.{u1} α) (Set.{u1} (FreeGroup.{u1} α)) (Set.hasMem.{u1} (FreeGroup.{u1} α)) r rels) -> (Eq.{succ u2} G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (FreeGroup.{u1} α) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) => (α -> G) -> (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (FreeGroup.lift.{u1, u2} α G _inst_1) f) r) (OfNat.ofNat.{u2} G 1 (OfNat.mk.{u2} G 1 (One.one.{u2} G (MulOneClass.toHasOne.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))))))) -> (LE.le.{u1} (Subgroup.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)) (Preorder.toLE.{u1} (Subgroup.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)) (FreeGroup.{u1} α) (Subgroup.setLike.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α))))) (Subgroup.normalClosure.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α) rels) (MonoidHom.ker.{u1, u2} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α) G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) => (α -> G) -> (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (FreeGroup.lift.{u1, u2} α G _inst_1) f)))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] {f : α -> G} {rels : Set.{u2} (FreeGroup.{u2} α)}, (forall (r : FreeGroup.{u2} α), (Membership.mem.{u2, u2} (FreeGroup.{u2} α) (Set.{u2} (FreeGroup.{u2} α)) (Set.instMembershipSet.{u2} (FreeGroup.{u2} α)) r rels) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) (fun (_x : FreeGroup.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) G (MulOneClass.toMul.{u2} (FreeGroup.{u2} α) (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (α -> G) (fun (_x : α -> G) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (FreeGroup.lift.{u2, u1} α G _inst_1) f) r) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (InvOneClass.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (Group.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) _inst_1)))))))) -> (LE.le.{u2} (Subgroup.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)) (Preorder.toLE.{u2} (Subgroup.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subgroup.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subgroup.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)) (Subgroup.instCompleteLatticeSubgroup.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))))) (Subgroup.normalClosure.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α) rels) (MonoidHom.ker.{u2, u1} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α) G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (α -> G) (fun (_x : α -> G) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (FreeGroup.lift.{u2, u1} α G _inst_1) f)))
Case conversion may be inaccurate. Consider using '#align presented_group.closure_rels_subset_ker PresentedGroup.closure_rels_subset_kerₓ'. -/
theorem closure_rels_subset_ker : Subgroup.normalClosure rels ≤ MonoidHom.ker F :=
  Subgroup.normalClosure_le_normal fun x w => (MonoidHom.mem_ker _).2 (h x w)
#align presented_group.closure_rels_subset_ker PresentedGroup.closure_rels_subset_ker

/- warning: presented_group.to_group_eq_one_of_mem_closure -> PresentedGroup.to_group_eq_one_of_mem_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] {f : α -> G} {rels : Set.{u1} (FreeGroup.{u1} α)}, (forall (r : FreeGroup.{u1} α), (Membership.Mem.{u1, u1} (FreeGroup.{u1} α) (Set.{u1} (FreeGroup.{u1} α)) (Set.hasMem.{u1} (FreeGroup.{u1} α)) r rels) -> (Eq.{succ u2} G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (FreeGroup.{u1} α) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) => (α -> G) -> (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (FreeGroup.lift.{u1, u2} α G _inst_1) f) r) (OfNat.ofNat.{u2} G 1 (OfNat.mk.{u2} G 1 (One.one.{u2} G (MulOneClass.toHasOne.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))))))) -> (forall (x : FreeGroup.{u1} α), (Membership.Mem.{u1, u1} (FreeGroup.{u1} α) (Subgroup.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)) (FreeGroup.{u1} α) (Subgroup.setLike.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α))) x (Subgroup.normalClosure.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α) rels)) -> (Eq.{succ u2} G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (FreeGroup.{u1} α) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) => (α -> G) -> (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (FreeGroup.lift.{u1, u2} α G _inst_1) f) x) (OfNat.ofNat.{u2} G 1 (OfNat.mk.{u2} G 1 (One.one.{u2} G (MulOneClass.toHasOne.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] {f : α -> G} {rels : Set.{u2} (FreeGroup.{u2} α)}, (forall (r : FreeGroup.{u2} α), (Membership.mem.{u2, u2} (FreeGroup.{u2} α) (Set.{u2} (FreeGroup.{u2} α)) (Set.instMembershipSet.{u2} (FreeGroup.{u2} α)) r rels) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) (fun (_x : FreeGroup.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) G (MulOneClass.toMul.{u2} (FreeGroup.{u2} α) (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (α -> G) (fun (_x : α -> G) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (FreeGroup.lift.{u2, u1} α G _inst_1) f) r) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (InvOneClass.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (Group.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) _inst_1)))))))) -> (forall (x : FreeGroup.{u2} α), (Membership.mem.{u2, u2} (FreeGroup.{u2} α) (Subgroup.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)) (SetLike.instMembership.{u2, u2} (Subgroup.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)) (FreeGroup.{u2} α) (Subgroup.instSetLikeSubgroup.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α))) x (Subgroup.normalClosure.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α) rels)) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) (fun (_x : FreeGroup.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) G (MulOneClass.toMul.{u2} (FreeGroup.{u2} α) (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (α -> G) (fun (_x : α -> G) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (FreeGroup.lift.{u2, u1} α G _inst_1) f) x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) x) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) x) (InvOneClass.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) x) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) x) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) x) (Group.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) x) _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align presented_group.to_group_eq_one_of_mem_closure PresentedGroup.to_group_eq_one_of_mem_closureₓ'. -/
theorem to_group_eq_one_of_mem_closure : ∀ x ∈ Subgroup.normalClosure rels, F x = 1 := fun x w =>
  (MonoidHom.mem_ker _).1 <| closure_rels_subset_ker h w
#align presented_group.to_group_eq_one_of_mem_closure PresentedGroup.to_group_eq_one_of_mem_closure

/- warning: presented_group.to_group -> PresentedGroup.toGroup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] {f : α -> G} {rels : Set.{u1} (FreeGroup.{u1} α)}, (forall (r : FreeGroup.{u1} α), (Membership.Mem.{u1, u1} (FreeGroup.{u1} α) (Set.{u1} (FreeGroup.{u1} α)) (Set.hasMem.{u1} (FreeGroup.{u1} α)) r rels) -> (Eq.{succ u2} G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (FreeGroup.{u1} α) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) => (α -> G) -> (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (FreeGroup.lift.{u1, u2} α G _inst_1) f) r) (OfNat.ofNat.{u2} G 1 (OfNat.mk.{u2} G 1 (One.one.{u2} G (MulOneClass.toHasOne.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))))))) -> (MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] {f : α -> G} {rels : Set.{u1} (FreeGroup.{u1} α)}, (forall (r : FreeGroup.{u1} α), (Membership.mem.{u1, u1} (FreeGroup.{u1} α) (Set.{u1} (FreeGroup.{u1} α)) (Set.instMembershipSet.{u1} (FreeGroup.{u1} α)) r rels) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) f) (FreeGroup.{u1} α) (fun (_x : FreeGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) f) (FreeGroup.{u1} α) G (MulOneClass.toMul.{u1} (FreeGroup.{u1} α) (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α))))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) f) (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (α -> G) (fun (_x : α -> G) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (FreeGroup.lift.{u1, u2} α G _inst_1) f) r) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (Group.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) _inst_1)))))))) -> (MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.instGroupPresentedGroup.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))
Case conversion may be inaccurate. Consider using '#align presented_group.to_group PresentedGroup.toGroupₓ'. -/
/-- The extension of a map `f : α → G` that satisfies the given relations to a group homomorphism
from `presented_group rels → G`. -/
def toGroup : PresentedGroup rels →* G :=
  QuotientGroup.lift (Subgroup.normalClosure rels) F (to_group_eq_one_of_mem_closure h)
#align presented_group.to_group PresentedGroup.toGroup

/- warning: presented_group.to_group.of -> PresentedGroup.toGroup.of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] {f : α -> G} {rels : Set.{u1} (FreeGroup.{u1} α)} (h : forall (r : FreeGroup.{u1} α), (Membership.Mem.{u1, u1} (FreeGroup.{u1} α) (Set.{u1} (FreeGroup.{u1} α)) (Set.hasMem.{u1} (FreeGroup.{u1} α)) r rels) -> (Eq.{succ u2} G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (FreeGroup.{u1} α) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) => (α -> G) -> (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (FreeGroup.lift.{u1, u2} α G _inst_1) f) r) (OfNat.ofNat.{u2} G 1 (OfNat.mk.{u2} G 1 (One.one.{u2} G (MulOneClass.toHasOne.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))))))) {x : α}, Eq.{succ u2} G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (PresentedGroup.{u1} α rels) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (PresentedGroup.toGroup.{u1, u2} α G _inst_1 f rels h) (PresentedGroup.of.{u1} α rels x)) (f x)
but is expected to have type
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] {f : α -> G} {rels : Set.{u1} (FreeGroup.{u1} α)} (h : forall (r : FreeGroup.{u1} α), (Membership.mem.{u1, u1} (FreeGroup.{u1} α) (Set.{u1} (FreeGroup.{u1} α)) (Set.instMembershipSet.{u1} (FreeGroup.{u1} α)) r rels) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) f) (FreeGroup.{u1} α) (fun (_x : FreeGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) f) (FreeGroup.{u1} α) G (MulOneClass.toMul.{u1} (FreeGroup.{u1} α) (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α))))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) f) (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (α -> G) (fun (_x : α -> G) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.instGroupFreeGroup.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (FreeGroup.lift.{u1, u2} α G _inst_1) f) r) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (InvOneClass.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (DivInvOneMonoid.toInvOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (DivisionMonoid.toDivInvOneMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) (Group.toDivisionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u1} α) => G) r) _inst_1)))))))) {x : α}, Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PresentedGroup.{u1} α rels) => G) (PresentedGroup.of.{u1} α rels x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.instGroupPresentedGroup.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (PresentedGroup.{u1} α rels) (fun (_x : PresentedGroup.{u1} α rels) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PresentedGroup.{u1} α rels) => G) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.instGroupPresentedGroup.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (PresentedGroup.{u1} α rels) G (MulOneClass.toMul.{u1} (PresentedGroup.{u1} α rels) (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.instGroupPresentedGroup.{u1} α rels))))) (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.instGroupPresentedGroup.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.instGroupPresentedGroup.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.instGroupPresentedGroup.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))))) (PresentedGroup.toGroup.{u1, u2} α G _inst_1 f rels h) (PresentedGroup.of.{u1} α rels x)) (f x)
Case conversion may be inaccurate. Consider using '#align presented_group.to_group.of PresentedGroup.toGroup.ofₓ'. -/
@[simp]
theorem toGroup.of {x : α} : toGroup h (of x) = f x :=
  FreeGroup.lift.of
#align presented_group.to_group.of PresentedGroup.toGroup.of

/- warning: presented_group.to_group.unique -> PresentedGroup.toGroup.unique is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {G : Type.{u2}} [_inst_1 : Group.{u2} G] {f : α -> G} {rels : Set.{u1} (FreeGroup.{u1} α)} (h : forall (r : FreeGroup.{u1} α), (Membership.Mem.{u1, u1} (FreeGroup.{u1} α) (Set.{u1} (FreeGroup.{u1} α)) (Set.hasMem.{u1} (FreeGroup.{u1} α)) r rels) -> (Eq.{succ u2} G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (FreeGroup.{u1} α) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) => (α -> G) -> (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> G) (MonoidHom.{u1, u2} (FreeGroup.{u1} α) G (Monoid.toMulOneClass.{u1} (FreeGroup.{u1} α) (DivInvMonoid.toMonoid.{u1} (FreeGroup.{u1} α) (Group.toDivInvMonoid.{u1} (FreeGroup.{u1} α) (FreeGroup.group.{u1} α)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))) (FreeGroup.lift.{u1, u2} α G _inst_1) f) r) (OfNat.ofNat.{u2} G 1 (OfNat.mk.{u2} G 1 (One.one.{u2} G (MulOneClass.toHasOne.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))))))))) (g : MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))), (forall (x : α), Eq.{succ u2} G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (PresentedGroup.{u1} α rels) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) g (PresentedGroup.of.{u1} α rels x)) (f x)) -> (forall {x : PresentedGroup.{u1} α rels}, Eq.{succ u2} G (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (PresentedGroup.{u1} α rels) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) g x) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (fun (_x : MonoidHom.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) => (PresentedGroup.{u1} α rels) -> G) (MonoidHom.hasCoeToFun.{u1, u2} (PresentedGroup.{u1} α rels) G (Monoid.toMulOneClass.{u1} (PresentedGroup.{u1} α rels) (DivInvMonoid.toMonoid.{u1} (PresentedGroup.{u1} α rels) (Group.toDivInvMonoid.{u1} (PresentedGroup.{u1} α rels) (PresentedGroup.group.{u1} α rels)))) (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (PresentedGroup.toGroup.{u1, u2} α G _inst_1 f rels h) x))
but is expected to have type
  forall {α : Type.{u2}} {G : Type.{u1}} [_inst_1 : Group.{u1} G] {f : α -> G} {rels : Set.{u2} (FreeGroup.{u2} α)} (h : forall (r : FreeGroup.{u2} α), (Membership.mem.{u2, u2} (FreeGroup.{u2} α) (Set.{u2} (FreeGroup.{u2} α)) (Set.instMembershipSet.{u2} (FreeGroup.{u2} α)) r rels) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) (fun (_x : FreeGroup.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) G (MulOneClass.toMul.{u2} (FreeGroup.{u2} α) (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f) (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (α -> G) (fun (_x : α -> G) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> G) => MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> G) (MonoidHom.{u2, u1} (FreeGroup.{u2} α) G (Monoid.toMulOneClass.{u2} (FreeGroup.{u2} α) (DivInvMonoid.toMonoid.{u2} (FreeGroup.{u2} α) (Group.toDivInvMonoid.{u2} (FreeGroup.{u2} α) (FreeGroup.instGroupFreeGroup.{u2} α)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (FreeGroup.lift.{u2, u1} α G _inst_1) f) r) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (InvOneClass.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) (Group.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeGroup.{u2} α) => G) r) _inst_1)))))))) (g : MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))), (forall (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PresentedGroup.{u2} α rels) => G) (PresentedGroup.of.{u2} α rels x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PresentedGroup.{u2} α rels) (fun (_x : PresentedGroup.{u2} α rels) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PresentedGroup.{u2} α rels) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PresentedGroup.{u2} α rels) G (MulOneClass.toMul.{u2} (PresentedGroup.{u2} α rels) (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) g (PresentedGroup.of.{u2} α rels x)) (f x)) -> (forall {x : PresentedGroup.{u2} α rels}, Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PresentedGroup.{u2} α rels) => G) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PresentedGroup.{u2} α rels) (fun (_x : PresentedGroup.{u2} α rels) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PresentedGroup.{u2} α rels) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PresentedGroup.{u2} α rels) G (MulOneClass.toMul.{u2} (PresentedGroup.{u2} α rels) (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) g x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PresentedGroup.{u2} α rels) (fun (_x : PresentedGroup.{u2} α rels) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PresentedGroup.{u2} α rels) => G) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PresentedGroup.{u2} α rels) G (MulOneClass.toMul.{u2} (PresentedGroup.{u2} α rels) (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u2, u1} (PresentedGroup.{u2} α rels) G (Monoid.toMulOneClass.{u2} (PresentedGroup.{u2} α rels) (DivInvMonoid.toMonoid.{u2} (PresentedGroup.{u2} α rels) (Group.toDivInvMonoid.{u2} (PresentedGroup.{u2} α rels) (PresentedGroup.instGroupPresentedGroup.{u2} α rels)))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (PresentedGroup.toGroup.{u2, u1} α G _inst_1 f rels h) x))
Case conversion may be inaccurate. Consider using '#align presented_group.to_group.unique PresentedGroup.toGroup.uniqueₓ'. -/
theorem toGroup.unique (g : PresentedGroup rels →* G) (hg : ∀ x : α, g (of x) = f x) :
    ∀ {x}, g x = toGroup h x := fun x =>
  QuotientGroup.induction_on x fun _ => FreeGroup.lift.unique (g.comp (QuotientGroup.mk' _)) hg
#align presented_group.to_group.unique PresentedGroup.toGroup.unique

end ToGroup

instance (rels : Set (FreeGroup α)) : Inhabited (PresentedGroup rels) :=
  ⟨1⟩

end PresentedGroup

