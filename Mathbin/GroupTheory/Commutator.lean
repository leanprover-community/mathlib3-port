/-
Copyright (c) 2021 Jordan Brown, Thomas Browning, Patrick Lutz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jordan Brown, Thomas Browning, Patrick Lutz

! This file was ported from Lean 3 source module group_theory.commutator
! leanprover-community/mathlib commit 34ee86e6a59d911a8e4f89b68793ee7577ae79c7
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Bracket
import Mathbin.GroupTheory.Subgroup.Finite
import Mathbin.Tactic.Group

/-!
# Commutators of Subgroups

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

If `G` is a group and `H₁ H₂ : subgroup G` then the commutator `⁅H₁, H₂⁆ : subgroup G`
is the subgroup of `G` generated by the commutators `h₁ * h₂ * h₁⁻¹ * h₂⁻¹`.

## Main definitions

* `⁅g₁, g₂⁆` : the commutator of the elements `g₁` and `g₂`
    (defined by `commutator_element` elsewhere).
* `⁅H₁, H₂⁆` : the commutator of the subgroups `H₁` and `H₂`.
-/


variable {G G' F : Type _} [Group G] [Group G'] [MonoidHomClass F G G'] (f : F) {g₁ g₂ g₃ g : G}

/- warning: commutator_element_eq_one_iff_mul_comm -> commutatorElement_eq_one_iff_mul_comm is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g₁ : G} {g₂ : G}, Iff (Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₁ g₂) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₂ g₁))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g₁ : G} {g₂ : G}, Iff (Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) (Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₁ g₂) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₂ g₁))
Case conversion may be inaccurate. Consider using '#align commutator_element_eq_one_iff_mul_comm commutatorElement_eq_one_iff_mul_commₓ'. -/
theorem commutatorElement_eq_one_iff_mul_comm : ⁅g₁, g₂⁆ = 1 ↔ g₁ * g₂ = g₂ * g₁ := by
  rw [commutatorElement_def, mul_inv_eq_one, mul_inv_eq_iff_eq_mul]
#align commutator_element_eq_one_iff_mul_comm commutatorElement_eq_one_iff_mul_comm

/- warning: commutator_element_eq_one_iff_commute -> commutatorElement_eq_one_iff_commute is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g₁ : G} {g₂ : G}, Iff (Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g₁ g₂)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g₁ : G} {g₂ : G}, Iff (Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) (Commute.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g₁ g₂)
Case conversion may be inaccurate. Consider using '#align commutator_element_eq_one_iff_commute commutatorElement_eq_one_iff_commuteₓ'. -/
theorem commutatorElement_eq_one_iff_commute : ⁅g₁, g₂⁆ = 1 ↔ Commute g₁ g₂ :=
  commutatorElement_eq_one_iff_mul_comm
#align commutator_element_eq_one_iff_commute commutatorElement_eq_one_iff_commute

/- warning: commute.commutator_eq -> Commute.commutator_eq is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g₁ : G} {g₂ : G}, (Commute.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g₁ g₂) -> (Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g₁ : G} {g₂ : G}, (Commute.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) g₁ g₂) -> (Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align commute.commutator_eq Commute.commutator_eqₓ'. -/
theorem Commute.commutator_eq (h : Commute g₁ g₂) : ⁅g₁, g₂⁆ = 1 :=
  commutatorElement_eq_one_iff_commute.mpr h
#align commute.commutator_eq Commute.commutator_eq

variable (g₁ g₂ g₃ g)

/- warning: commutator_element_one_right -> commutatorElement_one_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g : G), Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g : G), Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))
Case conversion may be inaccurate. Consider using '#align commutator_element_one_right commutatorElement_one_rightₓ'. -/
@[simp]
theorem commutatorElement_one_right : ⁅g, (1 : G)⁆ = 1 :=
  (Commute.one_right g).commutator_eq
#align commutator_element_one_right commutatorElement_one_right

/- warning: commutator_element_one_left -> commutatorElement_one_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g : G), Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) g) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g : G), Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))) g) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))
Case conversion may be inaccurate. Consider using '#align commutator_element_one_left commutatorElement_one_leftₓ'. -/
@[simp]
theorem commutatorElement_one_left : ⁅(1 : G), g⁆ = 1 :=
  (Commute.one_left g).commutator_eq
#align commutator_element_one_left commutatorElement_one_left

/- warning: commutator_element_self -> commutatorElement_self is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g : G), Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g g) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g : G), Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g g) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))
Case conversion may be inaccurate. Consider using '#align commutator_element_self commutatorElement_selfₓ'. -/
@[simp]
theorem commutatorElement_self : ⁅g, g⁆ = 1 :=
  (Commute.refl g).commutator_eq
#align commutator_element_self commutatorElement_self

/- warning: commutator_element_inv -> commutatorElement_inv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g₁ : G) (g₂ : G), Eq.{succ u1} G (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂)) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₂ g₁)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g₁ : G) (g₂ : G), Eq.{succ u1} G (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂)) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₂ g₁)
Case conversion may be inaccurate. Consider using '#align commutator_element_inv commutatorElement_invₓ'. -/
@[simp]
theorem commutatorElement_inv : ⁅g₁, g₂⁆⁻¹ = ⁅g₂, g₁⁆ := by
  simp_rw [commutatorElement_def, mul_inv_rev, inv_inv, mul_assoc]
#align commutator_element_inv commutatorElement_inv

/- warning: map_commutator_element -> map_commutatorElement is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} {F : Type.{u3}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] [_inst_3 : MonoidHomClass.{u3, u1, u2} F G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))] (f : F) (g₁ : G) (g₂ : G), Eq.{succ u2} G' (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => G -> G') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F G (fun (_x : G) => G') (MulHomClass.toFunLike.{u3, u1, u2} F G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) _inst_3))) f (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂)) (Bracket.bracket.{u2, u2} G' G' (commutatorElement.{u2} G' _inst_2) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => G -> G') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F G (fun (_x : G) => G') (MulHomClass.toFunLike.{u3, u1, u2} F G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) _inst_3))) f g₁) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => G -> G') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F G (fun (_x : G) => G') (MulHomClass.toFunLike.{u3, u1, u2} F G G' (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} G' (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2))) _inst_3))) f g₂))
but is expected to have type
  forall {G : Type.{u2}} {G' : Type.{u3}} {F : Type.{u1}} [_inst_1 : Group.{u2} G] [_inst_2 : Group.{u3} G'] [_inst_3 : MonoidHomClass.{u1, u2, u3} F G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_2)))] (f : F) (g₁ : G) (g₂ : G), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => G') (Bracket.bracket.{u2, u2} G G (commutatorElement.{u2} G _inst_1) g₁ g₂)) (FunLike.coe.{succ u1, succ u2, succ u3} F G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => G') _x) (MulHomClass.toFunLike.{u1, u2, u3} F G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u3} G' (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_2))) _inst_3)) f (Bracket.bracket.{u2, u2} G G (commutatorElement.{u2} G _inst_1) g₁ g₂)) (Bracket.bracket.{u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => G') g₁) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => G') g₂) (commutatorElement.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => G') g₁) _inst_2) (FunLike.coe.{succ u1, succ u2, succ u3} F G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => G') _x) (MulHomClass.toFunLike.{u1, u2, u3} F G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u3} G' (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_2))) _inst_3)) f g₁) (FunLike.coe.{succ u1, succ u2, succ u3} F G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => G') _x) (MulHomClass.toFunLike.{u1, u2, u3} F G G' (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1)))) (MulOneClass.toMul.{u3} G' (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u3} G' (DivInvMonoid.toMonoid.{u3} G' (Group.toDivInvMonoid.{u3} G' _inst_2))) _inst_3)) f g₂))
Case conversion may be inaccurate. Consider using '#align map_commutator_element map_commutatorElementₓ'. -/
theorem map_commutatorElement : (f ⁅g₁, g₂⁆ : G') = ⁅f g₁, f g₂⁆ := by
  simp_rw [commutatorElement_def, map_mul f, map_inv f]
#align map_commutator_element map_commutatorElement

/- warning: conjugate_commutator_element -> conjugate_commutatorElement is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g₁ : G) (g₂ : G) (g₃ : G), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₃ (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂)) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g₃)) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₃ g₁) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g₃)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₃ g₂) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g₃)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (g₁ : G) (g₂ : G) (g₃ : G), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₃ (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) g₃)) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₃ g₁) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) g₃)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g₃ g₂) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) g₃)))
Case conversion may be inaccurate. Consider using '#align conjugate_commutator_element conjugate_commutatorElementₓ'. -/
theorem conjugate_commutatorElement : g₃ * ⁅g₁, g₂⁆ * g₃⁻¹ = ⁅g₃ * g₁ * g₃⁻¹, g₃ * g₂ * g₃⁻¹⁆ :=
  map_commutatorElement (MulAut.conj g₃).toMonoidHom g₁ g₂
#align conjugate_commutator_element conjugate_commutatorElement

namespace Subgroup

#print Subgroup.commutator /-
/-- The commutator of two subgroups `H₁` and `H₂`. -/
instance commutator : Bracket (Subgroup G) (Subgroup G) :=
  ⟨fun H₁ H₂ => closure { g | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, ⁅g₁, g₂⁆ = g }⟩
#align subgroup.commutator Subgroup.commutator
-/

/- warning: subgroup.commutator_def -> Subgroup.commutator_def is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Subgroup.closure.{u1} G _inst_1 (setOf.{u1} G (fun (g : G) => Exists.{succ u1} G (fun (g₁ : G) => Exists.{0} (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g₁ H₁) (fun (H : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g₁ H₁) => Exists.{succ u1} G (fun (g₂ : G) => Exists.{0} (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g₂ H₂) (fun (H : Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g₂ H₂) => Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) g)))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Subgroup.closure.{u1} G _inst_1 (setOf.{u1} G (fun (g : G) => Exists.{succ u1} G (fun (g₁ : G) => And (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g₁ H₁) (Exists.{succ u1} G (fun (g₂ : G) => And (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g₂ H₂) (Eq.{succ u1} G (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) g)))))))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_def Subgroup.commutator_defₓ'. -/
theorem commutator_def (H₁ H₂ : Subgroup G) :
    ⁅H₁, H₂⁆ = closure { g | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, ⁅g₁, g₂⁆ = g } :=
  rfl
#align subgroup.commutator_def Subgroup.commutator_def

variable {g₁ g₂ g₃} {H₁ H₂ H₃ K₁ K₂ : Subgroup G}

/- warning: subgroup.commutator_mem_commutator -> Subgroup.commutator_mem_commutator is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g₁ : G} {g₂ : G} {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g₁ H₁) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g₂ H₂) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g₁ : G} {g₂ : G} {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g₁ H₁) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g₂ H₂) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_mem_commutator Subgroup.commutator_mem_commutatorₓ'. -/
theorem commutator_mem_commutator (h₁ : g₁ ∈ H₁) (h₂ : g₂ ∈ H₂) : ⁅g₁, g₂⁆ ∈ ⁅H₁, H₂⁆ :=
  subset_closure ⟨g₁, h₁, g₂, h₂, rfl⟩
#align subgroup.commutator_mem_commutator Subgroup.commutator_mem_commutator

/- warning: subgroup.commutator_le -> Subgroup.commutator_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1} {H₃ : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) H₃) (forall (g₁ : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g₁ H₁) -> (forall (g₂ : G), (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) g₂ H₂) -> (Membership.Mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) H₃)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1} {H₃ : Subgroup.{u1} G _inst_1}, Iff (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) H₃) (forall (g₁ : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g₁ H₁) -> (forall (g₂ : G), (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) g₂ H₂) -> (Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) (Bracket.bracket.{u1, u1} G G (commutatorElement.{u1} G _inst_1) g₁ g₂) H₃)))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_le Subgroup.commutator_leₓ'. -/
theorem commutator_le : ⁅H₁, H₂⁆ ≤ H₃ ↔ ∀ g₁ ∈ H₁, ∀ g₂ ∈ H₂, ⁅g₁, g₂⁆ ∈ H₃ :=
  H₃.closure_le.trans
    ⟨fun h a b c d => h ⟨a, b, c, d, rfl⟩, fun h g ⟨a, b, c, d, h_eq⟩ => h_eq ▸ h a b c d⟩
#align subgroup.commutator_le Subgroup.commutator_le

/- warning: subgroup.commutator_mono -> Subgroup.commutator_mono is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1} {K₁ : Subgroup.{u1} G _inst_1} {K₂ : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H₁ K₁) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H₂ K₂) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) K₁ K₂))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1} {K₁ : Subgroup.{u1} G _inst_1} {K₂ : Subgroup.{u1} G _inst_1}, (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H₁ K₁) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H₂ K₂) -> (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) K₁ K₂))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_mono Subgroup.commutator_monoₓ'. -/
theorem commutator_mono (h₁ : H₁ ≤ K₁) (h₂ : H₂ ≤ K₂) : ⁅H₁, H₂⁆ ≤ ⁅K₁, K₂⁆ :=
  commutator_le.mpr fun g₁ hg₁ g₂ hg₂ => commutator_mem_commutator (h₁ hg₁) (h₂ hg₂)
#align subgroup.commutator_mono Subgroup.commutator_mono

/- warning: subgroup.commutator_eq_bot_iff_le_centralizer -> Subgroup.commutator_eq_bot_iff_le_centralizer is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) H₁ (Subgroup.centralizer.{u1} G _inst_1 H₂))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1}, Iff (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) H₁ (Subgroup.centralizer.{u1} G _inst_1 H₂))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_eq_bot_iff_le_centralizer Subgroup.commutator_eq_bot_iff_le_centralizerₓ'. -/
theorem commutator_eq_bot_iff_le_centralizer : ⁅H₁, H₂⁆ = ⊥ ↔ H₁ ≤ H₂.centralizer :=
  by
  rw [eq_bot_iff, commutator_le]
  refine'
    forall_congr' fun p => forall_congr' fun hp => forall_congr' fun q => forall_congr' fun hq => _
  rw [mem_bot, commutatorElement_eq_one_iff_mul_comm, eq_comm]
#align subgroup.commutator_eq_bot_iff_le_centralizer Subgroup.commutator_eq_bot_iff_le_centralizer

/- warning: subgroup.commutator_commutator_eq_bot_of_rotate -> Subgroup.commutator_commutator_eq_bot_of_rotate is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1} {H₃ : Subgroup.{u1} G _inst_1}, (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₂ H₃) H₁) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₃ H₁) H₂) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) H₃) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1} {H₃ : Subgroup.{u1} G _inst_1}, (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₂ H₃) H₁) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₃ H₁) H₂) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) -> (Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) H₃) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_commutator_eq_bot_of_rotate Subgroup.commutator_commutator_eq_bot_of_rotateₓ'. -/
/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/
theorem commutator_commutator_eq_bot_of_rotate (h1 : ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥) (h2 : ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥) :
    ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥ :=
  by
  simp_rw [commutator_eq_bot_iff_le_centralizer, commutator_le,
    mem_centralizer_iff_commutator_eq_one, ← commutatorElement_def] at h1 h2⊢
  intro x hx y hy z hz
  trans x * z * ⁅y, ⁅z⁻¹, x⁻¹⁆⁆⁻¹ * z⁻¹ * y * ⁅x⁻¹, ⁅y⁻¹, z⁆⁆⁻¹ * y⁻¹ * x⁻¹
  · group
  · rw [h1 _ (H₂.inv_mem hy) _ hz _ (H₁.inv_mem hx), h2 _ (H₃.inv_mem hz) _ (H₁.inv_mem hx) _ hy]
    group
#align subgroup.commutator_commutator_eq_bot_of_rotate Subgroup.commutator_commutator_eq_bot_of_rotate

variable (H₁ H₂)

/- warning: subgroup.commutator_comm_le -> Subgroup.commutator_comm_le is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₂ H₁)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₂ H₁)
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_comm_le Subgroup.commutator_comm_leₓ'. -/
theorem commutator_comm_le : ⁅H₁, H₂⁆ ≤ ⁅H₂, H₁⁆ :=
  commutator_le.mpr fun g₁ h₁ g₂ h₂ =>
    commutatorElement_inv g₂ g₁ ▸ ⁅H₂, H₁⁆.inv_mem_iff.mpr (commutator_mem_commutator h₂ h₁)
#align subgroup.commutator_comm_le Subgroup.commutator_comm_le

#print Subgroup.commutator_comm /-
theorem commutator_comm : ⁅H₁, H₂⁆ = ⁅H₂, H₁⁆ :=
  le_antisymm (commutator_comm_le H₁ H₂) (commutator_comm_le H₂ H₁)
#align subgroup.commutator_comm Subgroup.commutator_comm
-/

section Normal

#print Subgroup.commutator_normal /-
instance commutator_normal [h₁ : H₁.Normal] [h₂ : H₂.Normal] : Normal ⁅H₁, H₂⁆ :=
  by
  let base : Set G := { x | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, ⁅g₁, g₂⁆ = x }
  change (closure base).Normal
  suffices h_base : base = Group.conjugatesOfSet base
  · rw [h_base]
    exact Subgroup.normalClosure_normal
  refine' Set.Subset.antisymm Group.subset_conjugatesOfSet fun a h => _
  simp_rw [Group.mem_conjugatesOfSet_iff, isConj_iff] at h
  rcases h with ⟨b, ⟨c, hc, e, he, rfl⟩, d, rfl⟩
  exact ⟨_, h₁.conj_mem c hc d, _, h₂.conj_mem e he d, (conjugate_commutatorElement c e d).symm⟩
#align subgroup.commutator_normal Subgroup.commutator_normal
-/

#print Subgroup.commutator_def' /-
theorem commutator_def' [H₁.Normal] [H₂.Normal] :
    ⁅H₁, H₂⁆ = normalClosure { g | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, ⁅g₁, g₂⁆ = g } :=
  le_antisymm closure_le_normalClosure (normalClosure_le_normal subset_closure)
#align subgroup.commutator_def' Subgroup.commutator_def'
-/

/- warning: subgroup.commutator_le_right -> Subgroup.commutator_le_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1) [h : Subgroup.Normal.{u1} G _inst_1 H₂], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) H₂
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1) [h : Subgroup.Normal.{u1} G _inst_1 H₂], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) H₂
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_le_right Subgroup.commutator_le_rightₓ'. -/
theorem commutator_le_right [h : H₂.Normal] : ⁅H₁, H₂⁆ ≤ H₂ :=
  commutator_le.mpr fun g₁ h₁ g₂ h₂ => H₂.mul_mem (h.conj_mem g₂ h₂ g₁) (H₂.inv_mem h₂)
#align subgroup.commutator_le_right Subgroup.commutator_le_right

/- warning: subgroup.commutator_le_left -> Subgroup.commutator_le_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1) [_inst_4 : Subgroup.Normal.{u1} G _inst_1 H₁], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) H₁
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1) [_inst_4 : Subgroup.Normal.{u1} G _inst_1 H₁], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) H₁
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_le_left Subgroup.commutator_le_leftₓ'. -/
theorem commutator_le_left [H₁.Normal] : ⁅H₁, H₂⁆ ≤ H₁ :=
  commutator_comm H₂ H₁ ▸ commutator_le_right H₂ H₁
#align subgroup.commutator_le_left Subgroup.commutator_le_left

/- warning: subgroup.commutator_bot_left -> Subgroup.commutator_bot_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1)) H₁) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1)) H₁) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_bot_left Subgroup.commutator_bot_leftₓ'. -/
@[simp]
theorem commutator_bot_left : ⁅(⊥ : Subgroup G), H₁⁆ = ⊥ :=
  le_bot_iff.mp (commutator_le_left ⊥ H₁)
#align subgroup.commutator_bot_left Subgroup.commutator_bot_left

/- warning: subgroup.commutator_bot_right -> Subgroup.commutator_bot_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasBot.{u1} G _inst_1))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1), Eq.{succ u1} (Subgroup.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))) (Bot.bot.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instBotSubgroup.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_bot_right Subgroup.commutator_bot_rightₓ'. -/
@[simp]
theorem commutator_bot_right : ⁅H₁, ⊥⁆ = (⊥ : Subgroup G) :=
  le_bot_iff.mp (commutator_le_right H₁ ⊥)
#align subgroup.commutator_bot_right Subgroup.commutator_bot_right

/- warning: subgroup.commutator_le_inf -> Subgroup.commutator_le_inf is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1) [_inst_4 : Subgroup.Normal.{u1} G _inst_1 H₁] [_inst_5 : Subgroup.Normal.{u1} G _inst_1 H₂], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasInf.{u1} G _inst_1) H₁ H₂)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1) [_inst_4 : Subgroup.Normal.{u1} G _inst_1 H₁] [_inst_5 : Subgroup.Normal.{u1} G _inst_1 H₂], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Inf.inf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instInfSubgroup.{u1} G _inst_1) H₁ H₂)
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_le_inf Subgroup.commutator_le_infₓ'. -/
theorem commutator_le_inf [Normal H₁] [Normal H₂] : ⁅H₁, H₂⁆ ≤ H₁ ⊓ H₂ :=
  le_inf (commutator_le_left H₁ H₂) (commutator_le_right H₁ H₂)
#align subgroup.commutator_le_inf Subgroup.commutator_le_inf

end Normal

/- warning: subgroup.map_commutator -> Subgroup.map_commutator is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1) (f : MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))), Eq.{succ u2} (Subgroup.{u2} G' _inst_2) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂)) (Bracket.bracket.{u2, u2} (Subgroup.{u2} G' _inst_2) (Subgroup.{u2} G' _inst_2) (Subgroup.commutator.{u2} G' _inst_2) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H₁) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H₂))
but is expected to have type
  forall {G : Type.{u2}} {G' : Type.{u1}} [_inst_1 : Group.{u2} G] [_inst_2 : Group.{u1} G'] (H₁ : Subgroup.{u2} G _inst_1) (H₂ : Subgroup.{u2} G _inst_1) (f : MonoidHom.{u2, u1} G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))), Eq.{succ u1} (Subgroup.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f (Bracket.bracket.{u2, u2} (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (Subgroup.commutator.{u2} G _inst_1) H₁ H₂)) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G' _inst_2) (Subgroup.{u1} G' _inst_2) (Subgroup.commutator.{u1} G' _inst_2) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H₁) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H₂))
Case conversion may be inaccurate. Consider using '#align subgroup.map_commutator Subgroup.map_commutatorₓ'. -/
theorem map_commutator (f : G →* G') : map f ⁅H₁, H₂⁆ = ⁅map f H₁, map f H₂⁆ :=
  by
  simp_rw [le_antisymm_iff, map_le_iff_le_comap, commutator_le, mem_comap, map_commutatorElement]
  constructor
  · intro p hp q hq
    exact commutator_mem_commutator (mem_map_of_mem _ hp) (mem_map_of_mem _ hq)
  · rintro _ ⟨p, hp, rfl⟩ _ ⟨q, hq, rfl⟩
    rw [← map_commutatorElement]
    exact mem_map_of_mem _ (commutator_mem_commutator hp hq)
#align subgroup.map_commutator Subgroup.map_commutator

variable {H₁ H₂}

/- warning: subgroup.commutator_le_map_commutator -> Subgroup.commutator_le_map_commutator is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] {H₁ : Subgroup.{u1} G _inst_1} {H₂ : Subgroup.{u1} G _inst_1} {f : MonoidHom.{u1, u2} G G' (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} G' (DivInvMonoid.toMonoid.{u2} G' (Group.toDivInvMonoid.{u2} G' _inst_2)))} {K₁ : Subgroup.{u2} G' _inst_2} {K₂ : Subgroup.{u2} G' _inst_2}, (LE.le.{u2} (Subgroup.{u2} G' _inst_2) (Preorder.toLE.{u2} (Subgroup.{u2} G' _inst_2) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G' _inst_2) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)))) K₁ (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H₁)) -> (LE.le.{u2} (Subgroup.{u2} G' _inst_2) (Preorder.toLE.{u2} (Subgroup.{u2} G' _inst_2) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G' _inst_2) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)))) K₂ (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f H₂)) -> (LE.le.{u2} (Subgroup.{u2} G' _inst_2) (Preorder.toLE.{u2} (Subgroup.{u2} G' _inst_2) (PartialOrder.toPreorder.{u2} (Subgroup.{u2} G' _inst_2) (SetLike.partialOrder.{u2, u2} (Subgroup.{u2} G' _inst_2) G' (Subgroup.setLike.{u2} G' _inst_2)))) (Bracket.bracket.{u2, u2} (Subgroup.{u2} G' _inst_2) (Subgroup.{u2} G' _inst_2) (Subgroup.commutator.{u2} G' _inst_2) K₁ K₂) (Subgroup.map.{u1, u2} G _inst_1 G' _inst_2 f (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂)))
but is expected to have type
  forall {G : Type.{u2}} {G' : Type.{u1}} [_inst_1 : Group.{u2} G] [_inst_2 : Group.{u1} G'] {H₁ : Subgroup.{u2} G _inst_1} {H₂ : Subgroup.{u2} G _inst_1} {f : MonoidHom.{u2, u1} G G' (Monoid.toMulOneClass.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_1))) (Monoid.toMulOneClass.{u1} G' (DivInvMonoid.toMonoid.{u1} G' (Group.toDivInvMonoid.{u1} G' _inst_2)))} {K₁ : Subgroup.{u1} G' _inst_2} {K₂ : Subgroup.{u1} G' _inst_2}, (LE.le.{u1} (Subgroup.{u1} G' _inst_2) (Preorder.toLE.{u1} (Subgroup.{u1} G' _inst_2) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G' _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G' _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G' _inst_2) (Subgroup.instCompleteLatticeSubgroup.{u1} G' _inst_2))))) K₁ (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H₁)) -> (LE.le.{u1} (Subgroup.{u1} G' _inst_2) (Preorder.toLE.{u1} (Subgroup.{u1} G' _inst_2) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G' _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G' _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G' _inst_2) (Subgroup.instCompleteLatticeSubgroup.{u1} G' _inst_2))))) K₂ (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f H₂)) -> (LE.le.{u1} (Subgroup.{u1} G' _inst_2) (Preorder.toLE.{u1} (Subgroup.{u1} G' _inst_2) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G' _inst_2) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G' _inst_2) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G' _inst_2) (Subgroup.instCompleteLatticeSubgroup.{u1} G' _inst_2))))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G' _inst_2) (Subgroup.{u1} G' _inst_2) (Subgroup.commutator.{u1} G' _inst_2) K₁ K₂) (Subgroup.map.{u2, u1} G _inst_1 G' _inst_2 f (Bracket.bracket.{u2, u2} (Subgroup.{u2} G _inst_1) (Subgroup.{u2} G _inst_1) (Subgroup.commutator.{u2} G _inst_1) H₁ H₂)))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_le_map_commutator Subgroup.commutator_le_map_commutatorₓ'. -/
theorem commutator_le_map_commutator {f : G →* G'} {K₁ K₂ : Subgroup G'} (h₁ : K₁ ≤ H₁.map f)
    (h₂ : K₂ ≤ H₂.map f) : ⁅K₁, K₂⁆ ≤ ⁅H₁, H₂⁆.map f :=
  (commutator_mono h₁ h₂).trans (ge_of_eq (map_commutator H₁ H₂ f))
#align subgroup.commutator_le_map_commutator Subgroup.commutator_le_map_commutator

variable (H₁ H₂)

#print Subgroup.commutator_characteristic /-
instance commutator_characteristic [h₁ : Characteristic H₁] [h₂ : Characteristic H₂] :
    Characteristic ⁅H₁, H₂⁆ :=
  characteristic_iff_le_map.mpr fun ϕ =>
    commutator_le_map_commutator (characteristic_iff_le_map.mp h₁ ϕ)
      (characteristic_iff_le_map.mp h₂ ϕ)
#align subgroup.commutator_characteristic Subgroup.commutator_characteristic
-/

/- warning: subgroup.commutator_prod_prod -> Subgroup.commutator_prod_prod is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1) (K₁ : Subgroup.{u2} G' _inst_2) (K₂ : Subgroup.{u2} G' _inst_2), Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (Prod.{u1, u2} G G') (Prod.group.{u1, u2} G G' _inst_1 _inst_2)) (Bracket.bracket.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (Prod.{u1, u2} G G') (Prod.group.{u1, u2} G G' _inst_1 _inst_2)) (Subgroup.{max u1 u2} (Prod.{u1, u2} G G') (Prod.group.{u1, u2} G G' _inst_1 _inst_2)) (Subgroup.commutator.{max u1 u2} (Prod.{u1, u2} G G') (Prod.group.{u1, u2} G G' _inst_1 _inst_2)) (Subgroup.prod.{u1, u2} G _inst_1 G' _inst_2 H₁ K₁) (Subgroup.prod.{u1, u2} G _inst_1 G' _inst_2 H₂ K₂)) (Subgroup.prod.{u1, u2} G _inst_1 G' _inst_2 (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Bracket.bracket.{u2, u2} (Subgroup.{u2} G' _inst_2) (Subgroup.{u2} G' _inst_2) (Subgroup.commutator.{u2} G' _inst_2) K₁ K₂))
but is expected to have type
  forall {G : Type.{u1}} {G' : Type.{u2}} [_inst_1 : Group.{u1} G] [_inst_2 : Group.{u2} G'] (H₁ : Subgroup.{u1} G _inst_1) (H₂ : Subgroup.{u1} G _inst_1) (K₁ : Subgroup.{u2} G' _inst_2) (K₂ : Subgroup.{u2} G' _inst_2), Eq.{max (succ u1) (succ u2)} (Subgroup.{max u2 u1} (Prod.{u1, u2} G G') (Prod.instGroupProd.{u1, u2} G G' _inst_1 _inst_2)) (Bracket.bracket.{max u1 u2, max u1 u2} (Subgroup.{max u2 u1} (Prod.{u1, u2} G G') (Prod.instGroupProd.{u1, u2} G G' _inst_1 _inst_2)) (Subgroup.{max u2 u1} (Prod.{u1, u2} G G') (Prod.instGroupProd.{u1, u2} G G' _inst_1 _inst_2)) (Subgroup.commutator.{max u1 u2} (Prod.{u1, u2} G G') (Prod.instGroupProd.{u1, u2} G G' _inst_1 _inst_2)) (Subgroup.prod.{u1, u2} G _inst_1 G' _inst_2 H₁ K₁) (Subgroup.prod.{u1, u2} G _inst_1 G' _inst_2 H₂ K₂)) (Subgroup.prod.{u1, u2} G _inst_1 G' _inst_2 (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) H₁ H₂) (Bracket.bracket.{u2, u2} (Subgroup.{u2} G' _inst_2) (Subgroup.{u2} G' _inst_2) (Subgroup.commutator.{u2} G' _inst_2) K₁ K₂))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_prod_prod Subgroup.commutator_prod_prodₓ'. -/
theorem commutator_prod_prod (K₁ K₂ : Subgroup G') :
    ⁅H₁.Prod K₁, H₂.Prod K₂⁆ = ⁅H₁, H₂⁆.Prod ⁅K₁, K₂⁆ :=
  by
  apply le_antisymm
  · rw [commutator_le]
    rintro ⟨p₁, p₂⟩ ⟨hp₁, hp₂⟩ ⟨q₁, q₂⟩ ⟨hq₁, hq₂⟩
    exact ⟨commutator_mem_commutator hp₁ hq₁, commutator_mem_commutator hp₂ hq₂⟩
  · rw [prod_le_iff]
    constructor <;>
      · rw [map_commutator]
        apply commutator_mono <;>
          simp [le_prod_iff, map_map, MonoidHom.fst_comp_inl, MonoidHom.snd_comp_inl,
            MonoidHom.fst_comp_inr, MonoidHom.snd_comp_inr]
#align subgroup.commutator_prod_prod Subgroup.commutator_prod_prod

/- warning: subgroup.commutator_pi_pi_le -> Subgroup.commutator_pi_pi_le is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} {Gs : η -> Type.{u2}} [_inst_4 : forall (i : η), Group.{u2} (Gs i)] (H : forall (i : η), Subgroup.{u2} (Gs i) (_inst_4 i)) (K : forall (i : η), Subgroup.{u2} (Gs i) (_inst_4 i)), LE.le.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (Preorder.toLE.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (PartialOrder.toPreorder.{max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (forall (i : η), Gs i) (Subgroup.setLike.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i)))))) (Bracket.bracket.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (Subgroup.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (Subgroup.commutator.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (Subgroup.pi.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i) (Set.univ.{u1} η) H) (Subgroup.pi.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i) (Set.univ.{u1} η) K)) (Subgroup.pi.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i) (Set.univ.{u1} η) (fun (i : η) => Bracket.bracket.{u2, u2} (Subgroup.{u2} (Gs i) (_inst_4 i)) (Subgroup.{u2} (Gs i) (_inst_4 i)) (Subgroup.commutator.{u2} (Gs i) (_inst_4 i)) (H i) (K i)))
but is expected to have type
  forall {η : Type.{u2}} {Gs : η -> Type.{u1}} [_inst_4 : forall (i : η), Group.{u1} (Gs i)] (H : forall (i : η), Subgroup.{u1} (Gs i) (_inst_4 i)) (K : forall (i : η), Subgroup.{u1} (Gs i) (_inst_4 i)), LE.le.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (Preorder.toLE.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (PartialOrder.toPreorder.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (CompleteSemilatticeInf.toPartialOrder.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u1} (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (Subgroup.instCompleteLatticeSubgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))))))) (Bracket.bracket.{max u1 u2, max u1 u2} (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (Subgroup.commutator.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i))) (Subgroup.pi.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i) (Set.univ.{u2} η) H) (Subgroup.pi.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i) (Set.univ.{u2} η) K)) (Subgroup.pi.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_4 i) (Set.univ.{u2} η) (fun (i : η) => Bracket.bracket.{u1, u1} (Subgroup.{u1} (Gs i) (_inst_4 i)) (Subgroup.{u1} (Gs i) (_inst_4 i)) (Subgroup.commutator.{u1} (Gs i) (_inst_4 i)) (H i) (K i)))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_pi_pi_le Subgroup.commutator_pi_pi_leₓ'. -/
/-- The commutator of direct product is contained in the direct product of the commutators.

See `commutator_pi_pi_of_finite` for equality given `fintype η`.
-/
theorem commutator_pi_pi_le {η : Type _} {Gs : η → Type _} [∀ i, Group (Gs i)]
    (H K : ∀ i, Subgroup (Gs i)) :
    ⁅Subgroup.pi Set.univ H, Subgroup.pi Set.univ K⁆ ≤ Subgroup.pi Set.univ fun i => ⁅H i, K i⁆ :=
  commutator_le.mpr fun p hp q hq i hi => commutator_mem_commutator (hp i hi) (hq i hi)
#align subgroup.commutator_pi_pi_le Subgroup.commutator_pi_pi_le

/- warning: subgroup.commutator_pi_pi_of_finite -> Subgroup.commutator_pi_pi_of_finite is a dubious translation:
lean 3 declaration is
  forall {η : Type.{u1}} [_inst_4 : Finite.{succ u1} η] {Gs : η -> Type.{u2}} [_inst_5 : forall (i : η), Group.{u2} (Gs i)] (H : forall (i : η), Subgroup.{u2} (Gs i) (_inst_5 i)) (K : forall (i : η), Subgroup.{u2} (Gs i) (_inst_5 i)), Eq.{succ (max u1 u2)} (Subgroup.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i))) (Bracket.bracket.{max u1 u2, max u1 u2} (Subgroup.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i))) (Subgroup.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i))) (Subgroup.commutator.{max u1 u2} (forall (i : η), Gs i) (Pi.group.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i))) (Subgroup.pi.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i) (Set.univ.{u1} η) H) (Subgroup.pi.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i) (Set.univ.{u1} η) K)) (Subgroup.pi.{u1, u2} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i) (Set.univ.{u1} η) (fun (i : η) => Bracket.bracket.{u2, u2} (Subgroup.{u2} (Gs i) (_inst_5 i)) (Subgroup.{u2} (Gs i) (_inst_5 i)) (Subgroup.commutator.{u2} (Gs i) (_inst_5 i)) (H i) (K i)))
but is expected to have type
  forall {η : Type.{u2}} [_inst_4 : Finite.{succ u2} η] {Gs : η -> Type.{u1}} [_inst_5 : forall (i : η), Group.{u1} (Gs i)] (H : forall (i : η), Subgroup.{u1} (Gs i) (_inst_5 i)) (K : forall (i : η), Subgroup.{u1} (Gs i) (_inst_5 i)), Eq.{max (succ u2) (succ u1)} (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i))) (Bracket.bracket.{max u1 u2, max u1 u2} (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i))) (Subgroup.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i))) (Subgroup.commutator.{max u2 u1} (forall (i : η), Gs i) (Pi.group.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i))) (Subgroup.pi.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i) (Set.univ.{u2} η) H) (Subgroup.pi.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i) (Set.univ.{u2} η) K)) (Subgroup.pi.{u2, u1} η (fun (i : η) => Gs i) (fun (i : η) => _inst_5 i) (Set.univ.{u2} η) (fun (i : η) => Bracket.bracket.{u1, u1} (Subgroup.{u1} (Gs i) (_inst_5 i)) (Subgroup.{u1} (Gs i) (_inst_5 i)) (Subgroup.commutator.{u1} (Gs i) (_inst_5 i)) (H i) (K i)))
Case conversion may be inaccurate. Consider using '#align subgroup.commutator_pi_pi_of_finite Subgroup.commutator_pi_pi_of_finiteₓ'. -/
/-- The commutator of a finite direct product is contained in the direct product of the commutators.
-/
theorem commutator_pi_pi_of_finite {η : Type _} [Finite η] {Gs : η → Type _} [∀ i, Group (Gs i)]
    (H K : ∀ i, Subgroup (Gs i)) :
    ⁅Subgroup.pi Set.univ H, Subgroup.pi Set.univ K⁆ = Subgroup.pi Set.univ fun i => ⁅H i, K i⁆ :=
  by
  classical
    apply le_antisymm (commutator_pi_pi_le H K)
    · rw [pi_le_iff]
      intro i hi
      rw [map_commutator]
      apply commutator_mono <;>
        · rw [le_pi_iff]
          intro j hj
          rintro _ ⟨_, ⟨x, hx, rfl⟩, rfl⟩
          by_cases h : j = i
          · subst h
            simpa using hx
          · simp [h, one_mem]
#align subgroup.commutator_pi_pi_of_finite Subgroup.commutator_pi_pi_of_finite

end Subgroup

variable (G)

#print commutatorSet /-
/-- The set of commutator elements `⁅g₁, g₂⁆` in `G`. -/
def commutatorSet : Set G :=
  { g | ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g }
#align commutator_set commutatorSet
-/

#print commutatorSet_def /-
theorem commutatorSet_def : commutatorSet G = { g | ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g } :=
  rfl
#align commutator_set_def commutatorSet_def
-/

/- warning: one_mem_commutator_set -> one_mem_commutatorSet is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Membership.Mem.{u1, u1} G (Set.{u1} G) (Set.hasMem.{u1} G) (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))))) (commutatorSet.{u1} G _inst_1)
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Membership.mem.{u1, u1} G (Set.{u1} G) (Set.instMembershipSet.{u1} G) (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))))) (commutatorSet.{u1} G _inst_1)
Case conversion may be inaccurate. Consider using '#align one_mem_commutator_set one_mem_commutatorSetₓ'. -/
theorem one_mem_commutatorSet : (1 : G) ∈ commutatorSet G :=
  ⟨1, 1, commutatorElement_self 1⟩
#align one_mem_commutator_set one_mem_commutatorSet

instance : Nonempty (commutatorSet G) :=
  ⟨⟨1, one_mem_commutatorSet G⟩⟩

variable {G g}

#print mem_commutatorSet_iff /-
theorem mem_commutatorSet_iff : g ∈ commutatorSet G ↔ ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g :=
  Iff.rfl
#align mem_commutator_set_iff mem_commutatorSet_iff
-/

#print commutator_mem_commutatorSet /-
theorem commutator_mem_commutatorSet : ⁅g₁, g₂⁆ ∈ commutatorSet G :=
  ⟨g₁, g₂, rfl⟩
#align commutator_mem_commutator_set commutator_mem_commutatorSet
-/

