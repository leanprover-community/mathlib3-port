/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Michael Howes

! This file was ported from Lean 3 source module group_theory.abelianization
! leanprover-community/mathlib commit 2738d2ca56cbc63be80c3bd48e9ed90ad94e947d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Finite.Card
import Mathbin.GroupTheory.Commutator
import Mathbin.GroupTheory.Finiteness

/-!
# The abelianization of a group

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the commutator and the abelianization of a group. It furthermore prepares for the
result that the abelianization is left adjoint to the forgetful functor from abelian groups to
groups, which can be found in `algebra/category/Group/adjunctions`.

## Main definitions

* `commutator`: defines the commutator of a group `G` as a subgroup of `G`.
* `abelianization`: defines the abelianization of a group `G` as the quotient of a group by its
  commutator subgroup.
* `abelianization.map`: lifts a group homomorphism to a homomorphism between the abelianizations
* `mul_equiv.abelianization_congr`: Equivalent groups have equivalent abelianizations

-/


universe u v w

-- Let G be a group.
variable (G : Type u) [Group G]

#print commutator /-
/-- The commutator subgroup of a group G is the normal subgroup
  generated by the commutators [p,q]=`p*q*p⁻¹*q⁻¹`. -/
def commutator : Subgroup G :=
  ⁅(⊤ : Subgroup G), ⊤⁆deriving Subgroup.Normal
#align commutator commutator
-/

/- warning: commutator_def -> commutator_def is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (commutator.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1)) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.hasTop.{u1} G _inst_1)))
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{succ u1} (Subgroup.{u1} G _inst_1) (commutator.{u1} G _inst_1) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1)) (Top.top.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instTopSubgroup.{u1} G _inst_1)))
Case conversion may be inaccurate. Consider using '#align commutator_def commutator_defₓ'. -/
theorem commutator_def : commutator G = ⁅(⊤ : Subgroup G), ⊤⁆ :=
  rfl
#align commutator_def commutator_def

#print commutator_eq_closure /-
theorem commutator_eq_closure : commutator G = Subgroup.closure (commutatorSet G) := by
  simp [commutator, Subgroup.commutator_def, commutatorSet]
#align commutator_eq_closure commutator_eq_closure
-/

#print commutator_eq_normalClosure /-
theorem commutator_eq_normalClosure : commutator G = Subgroup.normalClosure (commutatorSet G) := by
  simp [commutator, Subgroup.commutator_def', commutatorSet]
#align commutator_eq_normal_closure commutator_eq_normalClosure
-/

#print commutator_characteristic /-
instance commutator_characteristic : (commutator G).Characteristic :=
  Subgroup.commutator_characteristic ⊤ ⊤
#align commutator_characteristic commutator_characteristic
-/

instance [Finite (commutatorSet G)] : Group.Fg (commutator G) :=
  by
  rw [commutator_eq_closure]
  apply Group.closure_finite_fg

#print rank_commutator_le_card /-
theorem rank_commutator_le_card [Finite (commutatorSet G)] :
    Group.rank (commutator G) ≤ Nat.card (commutatorSet G) :=
  by
  rw [Subgroup.rank_congr (commutator_eq_closure G)]
  apply Subgroup.rank_closure_finite_le_nat_card
#align rank_commutator_le_card rank_commutator_le_card
-/

/- warning: commutator_centralizer_commutator_le_center -> commutator_centralizer_commutator_le_center is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Subgroup.centralizer.{u1} G _inst_1 (commutator.{u1} G _inst_1)) (Subgroup.centralizer.{u1} G _inst_1 (commutator.{u1} G _inst_1))) (Subgroup.center.{u1} G _inst_1)
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (Bracket.bracket.{u1, u1} (Subgroup.{u1} G _inst_1) (Subgroup.{u1} G _inst_1) (Subgroup.commutator.{u1} G _inst_1) (Subgroup.centralizer.{u1} G _inst_1 (commutator.{u1} G _inst_1)) (Subgroup.centralizer.{u1} G _inst_1 (commutator.{u1} G _inst_1))) (Subgroup.center.{u1} G _inst_1)
Case conversion may be inaccurate. Consider using '#align commutator_centralizer_commutator_le_center commutator_centralizer_commutator_le_centerₓ'. -/
theorem commutator_centralizer_commutator_le_center :
    ⁅(commutator G).centralizer, (commutator G).centralizer⁆ ≤ Subgroup.center G :=
  by
  rw [← Subgroup.centralizer_top, ← Subgroup.commutator_eq_bot_iff_le_centralizer]
  suffices ⁅⁅⊤, (commutator G).centralizer⁆, (commutator G).centralizer⁆ = ⊥
    by
    refine' Subgroup.commutator_commutator_eq_bot_of_rotate _ this
    rwa [Subgroup.commutator_comm (commutator G).centralizer]
  rw [Subgroup.commutator_comm, Subgroup.commutator_eq_bot_iff_le_centralizer]
  exact Set.centralizer_subset (Subgroup.commutator_mono le_top le_top)
#align commutator_centralizer_commutator_le_center commutator_centralizer_commutator_le_center

#print Abelianization /-
/-- The abelianization of G is the quotient of G by its commutator subgroup. -/
def Abelianization : Type u :=
  G ⧸ commutator G
#align abelianization Abelianization
-/

namespace Abelianization

attribute [local instance] QuotientGroup.leftRel

instance : CommGroup (Abelianization G) :=
  { QuotientGroup.Quotient.group _ with
    mul_comm := fun x y =>
      Quotient.inductionOn₂' x y fun a b =>
        Quotient.sound' <|
          QuotientGroup.leftRel_apply.mpr <|
            Subgroup.subset_closure
              ⟨b⁻¹, Subgroup.mem_top b⁻¹, a⁻¹, Subgroup.mem_top a⁻¹, by group⟩ }

instance : Inhabited (Abelianization G) :=
  ⟨1⟩

instance [Fintype G] [DecidablePred (· ∈ commutator G)] : Fintype (Abelianization G) :=
  QuotientGroup.fintype (commutator G)

instance [Finite G] : Finite (Abelianization G) :=
  Quotient.finite _

variable {G}

/- warning: abelianization.of -> Abelianization.of is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))
Case conversion may be inaccurate. Consider using '#align abelianization.of Abelianization.ofₓ'. -/
/-- `of` is the canonical projection from G to its abelianization. -/
def of : G →* Abelianization G where
  toFun := QuotientGroup.mk
  map_one' := rfl
  map_mul' x y := rfl
#align abelianization.of Abelianization.of

/- warning: abelianization.mk_eq_of -> Abelianization.mk_eq_of is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G), Eq.{succ u1} (Quot.{succ u1} G (Setoid.r.{succ u1} G (QuotientGroup.leftRel.{u1} G _inst_1 (commutator.{u1} G _inst_1)))) (Quot.mk.{succ u1} G (Setoid.r.{succ u1} G (QuotientGroup.leftRel.{u1} G _inst_1 (commutator.{u1} G _inst_1))) a) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (fun (_x : MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) => G -> (Abelianization.{u1} G _inst_1)) (MonoidHom.hasCoeToFun.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (Abelianization.of.{u1} G _inst_1) a)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G), Eq.{succ u1} (Quot.{succ u1} G (Setoid.r.{succ u1} G (QuotientGroup.leftRel.{u1} G _inst_1 (commutator.{u1} G _inst_1)))) (Quot.mk.{succ u1} G (Setoid.r.{succ u1} G (QuotientGroup.leftRel.{u1} G _inst_1 (commutator.{u1} G _inst_1))) a) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Abelianization.{u1} G _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))) (Abelianization.of.{u1} G _inst_1) a)
Case conversion may be inaccurate. Consider using '#align abelianization.mk_eq_of Abelianization.mk_eq_ofₓ'. -/
@[simp]
theorem mk_eq_of (a : G) : Quot.mk _ a = of a :=
  rfl
#align abelianization.mk_eq_of Abelianization.mk_eq_of

section lift

-- So far we have built Gᵃᵇ and proved it's an abelian group.
-- Furthremore we defined the canonical projection `of : G → Gᵃᵇ`
-- Let `A` be an abelian group and let `f` be a group homomorphism from `G` to `A`.
variable {A : Type v} [CommGroup A] (f : G →* A)

/- warning: abelianization.commutator_subset_ker -> Abelianization.commutator_subset_ker is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : CommGroup.{u2} A] (f : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (SetLike.partialOrder.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)))) (commutator.{u1} G _inst_1) (MonoidHom.ker.{u1, u2} G _inst_1 A (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))) f)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : CommGroup.{u2} A] (f : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))), LE.le.{u1} (Subgroup.{u1} G _inst_1) (Preorder.toLE.{u1} (Subgroup.{u1} G _inst_1) (PartialOrder.toPreorder.{u1} (Subgroup.{u1} G _inst_1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subgroup.{u1} G _inst_1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subgroup.{u1} G _inst_1) (Subgroup.instCompleteLatticeSubgroup.{u1} G _inst_1))))) (commutator.{u1} G _inst_1) (MonoidHom.ker.{u1, u2} G _inst_1 A (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))) f)
Case conversion may be inaccurate. Consider using '#align abelianization.commutator_subset_ker Abelianization.commutator_subset_kerₓ'. -/
theorem commutator_subset_ker : commutator G ≤ f.ker :=
  by
  rw [commutator_eq_closure, Subgroup.closure_le]
  rintro x ⟨p, q, rfl⟩
  simp [MonoidHom.mem_ker, mul_right_comm (f p) (f q), commutatorElement_def]
#align abelianization.commutator_subset_ker Abelianization.commutator_subset_ker

/- warning: abelianization.lift -> Abelianization.lift is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : CommGroup.{u2} A], Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : CommGroup.{u2} A], Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))
Case conversion may be inaccurate. Consider using '#align abelianization.lift Abelianization.liftₓ'. -/
/-- If `f : G → A` is a group homomorphism to an abelian group, then `lift f` is the unique map from
  the abelianization of a `G` to `A` that factors through `f`. -/
def lift : (G →* A) ≃ (Abelianization G →* A)
    where
  toFun f := QuotientGroup.lift _ f fun x h => f.mem_ker.2 <| commutator_subset_ker _ h
  invFun F := F.comp of
  left_inv f := MonoidHom.ext fun x => rfl
  right_inv F := MonoidHom.ext fun x => QuotientGroup.induction_on x fun z => rfl
#align abelianization.lift Abelianization.lift

/- warning: abelianization.lift.of -> Abelianization.lift.of is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : CommGroup.{u2} A] (f : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (x : G), Eq.{succ u2} A (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (fun (_x : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => (Abelianization.{u1} G _inst_1) -> A) (MonoidHom.hasCoeToFun.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (coeFn.{max 1 (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (fun (_x : Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) => (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) -> (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (Equiv.hasCoeToFun.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (Abelianization.lift.{u1, u2} G _inst_1 A _inst_2) f) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (fun (_x : MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) => G -> (Abelianization.{u1} G _inst_1)) (MonoidHom.hasCoeToFun.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (Abelianization.of.{u1} G _inst_1) x)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (fun (_x : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => G -> A) (MonoidHom.hasCoeToFun.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) f x)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : CommGroup.{u2} A] (f : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (x : G), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => A) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Abelianization.{u1} G _inst_1) a) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))) (Abelianization.of.{u1} G _inst_1) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) f) (Abelianization.{u1} G _inst_1) (fun (_x : Abelianization.{u1} G _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) f) (Abelianization.{u1} G _inst_1) A (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} A (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) f) (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (fun (_x : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (Abelianization.lift.{u1, u2} G _inst_1 A _inst_2) f) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Abelianization.{u1} G _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))) (Abelianization.of.{u1} G _inst_1) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) G A (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} A (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))))) f x)
Case conversion may be inaccurate. Consider using '#align abelianization.lift.of Abelianization.lift.ofₓ'. -/
@[simp]
theorem lift.of (x : G) : lift f (of x) = f x :=
  rfl
#align abelianization.lift.of Abelianization.lift.of

/- warning: abelianization.lift.unique -> Abelianization.lift.unique is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : CommGroup.{u2} A] (f : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (φ : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))), (forall (x : G), Eq.{succ u2} A (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (fun (_x : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => (Abelianization.{u1} G _inst_1) -> A) (MonoidHom.hasCoeToFun.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) φ (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (fun (_x : MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) => G -> (Abelianization.{u1} G _inst_1)) (MonoidHom.hasCoeToFun.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (Abelianization.of.{u1} G _inst_1) x)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (fun (_x : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => G -> A) (MonoidHom.hasCoeToFun.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) f x)) -> (forall {x : Abelianization.{u1} G _inst_1}, Eq.{succ u2} A (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (fun (_x : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => (Abelianization.{u1} G _inst_1) -> A) (MonoidHom.hasCoeToFun.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) φ x) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (fun (_x : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => (Abelianization.{u1} G _inst_1) -> A) (MonoidHom.hasCoeToFun.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (coeFn.{max 1 (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (fun (_x : Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) => (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) -> (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (Equiv.hasCoeToFun.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (Abelianization.lift.{u1, u2} G _inst_1 A _inst_2) f) x))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : CommGroup.{u2} A] (f : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (φ : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))), (forall (x : G), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => A) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Abelianization.{u1} G _inst_1) a) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))) (Abelianization.of.{u1} G _inst_1) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (Abelianization.{u1} G _inst_1) (fun (_x : Abelianization.{u1} G _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (Abelianization.{u1} G _inst_1) A (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} A (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))))) φ (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Abelianization.{u1} G _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))) (Abelianization.of.{u1} G _inst_1) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) G A (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} A (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))))) f x)) -> (forall {x : Abelianization.{u1} G _inst_1}, Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => A) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (Abelianization.{u1} G _inst_1) (fun (_x : Abelianization.{u1} G _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (Abelianization.{u1} G _inst_1) A (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} A (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))))) φ x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) f) (Abelianization.{u1} G _inst_1) (fun (_x : Abelianization.{u1} G _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) f) (Abelianization.{u1} G _inst_1) A (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} A (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) f) (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (fun (_x : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) => MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2))))) (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A (DivInvMonoid.toMonoid.{u2} A (Group.toDivInvMonoid.{u2} A (CommGroup.toGroup.{u2} A _inst_2)))))) (Abelianization.lift.{u1, u2} G _inst_1 A _inst_2) f) x))
Case conversion may be inaccurate. Consider using '#align abelianization.lift.unique Abelianization.lift.uniqueₓ'. -/
theorem lift.unique (φ : Abelianization G →* A)
    -- hφ : φ agrees with f on the image of G in Gᵃᵇ
    (hφ : ∀ x : G, φ (of x) = f x)
    {x : Abelianization G} : φ x = lift f x :=
  QuotientGroup.induction_on x hφ
#align abelianization.lift.unique Abelianization.lift.unique

/- warning: abelianization.lift_of -> Abelianization.lift_of is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))))) (fun (_x : Equiv.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))))) => (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) -> (MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))))) (Equiv.hasCoeToFun.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))))) (Abelianization.lift.{u1, u1} G _inst_1 (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)) (Abelianization.of.{u1} G _inst_1)) (MonoidHom.id.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) => MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (Abelianization.of.{u1} G _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))))) (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (fun (_x : MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) => MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))))) (Abelianization.lift.{u1, u1} G _inst_1 (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)) (Abelianization.of.{u1} G _inst_1)) (MonoidHom.id.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))))
Case conversion may be inaccurate. Consider using '#align abelianization.lift_of Abelianization.lift_ofₓ'. -/
@[simp]
theorem lift_of : lift of = MonoidHom.id (Abelianization G) :=
  lift.apply_symm_apply <| MonoidHom.id _
#align abelianization.lift_of Abelianization.lift_of

end lift

variable {A : Type v} [Monoid A]

/- warning: abelianization.hom_ext -> Abelianization.hom_ext is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : Monoid.{u2} A] (φ : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2)) (ψ : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2)), (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A _inst_2)) (MonoidHom.comp.{u1, u1, u2} G (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2) φ (Abelianization.of.{u1} G _inst_1)) (MonoidHom.comp.{u1, u1, u2} G (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2) ψ (Abelianization.of.{u1} G _inst_1))) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2)) φ ψ)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {A : Type.{u2}} [_inst_2 : Monoid.{u2} A] (φ : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2)) (ψ : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2)), (Eq.{max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} A _inst_2)) (MonoidHom.comp.{u1, u1, u2} G (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2) φ (Abelianization.of.{u1} G _inst_1)) (MonoidHom.comp.{u1, u1, u2} G (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2) ψ (Abelianization.of.{u1} G _inst_1))) -> (Eq.{max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) A (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} A _inst_2)) φ ψ)
Case conversion may be inaccurate. Consider using '#align abelianization.hom_ext Abelianization.hom_extₓ'. -/
/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem hom_ext (φ ψ : Abelianization G →* A) (h : φ.comp of = ψ.comp of) : φ = ψ :=
  MonoidHom.ext fun x => QuotientGroup.induction_on x <| MonoidHom.congr_fun h
#align abelianization.hom_ext Abelianization.hom_ext

section Map

variable {H : Type v} [Group H] (f : G →* H)

/- warning: abelianization.map -> Abelianization.map is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_3 : Group.{u2} H], (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) -> (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_3 : Group.{u2} H], (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) -> (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))))
Case conversion may be inaccurate. Consider using '#align abelianization.map Abelianization.mapₓ'. -/
/-- The map operation of the `abelianization` functor -/
def map : Abelianization G →* Abelianization H :=
  lift (of.comp f)
#align abelianization.map Abelianization.map

/- warning: abelianization.map_of -> Abelianization.map_of is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_3 : Group.{u2} H] (f : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) (x : G), Eq.{succ u2} (Abelianization.{u2} H _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3)))))) (fun (_x : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3)))))) => (Abelianization.{u1} G _inst_1) -> (Abelianization.{u2} H _inst_3)) (MonoidHom.hasCoeToFun.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3)))))) (Abelianization.map.{u1, u2} G _inst_1 H _inst_3 f) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (fun (_x : MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) => G -> (Abelianization.{u1} G _inst_1)) (MonoidHom.hasCoeToFun.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (Abelianization.of.{u1} G _inst_1) x)) (coeFn.{succ u2, succ u2} (MonoidHom.{u2, u2} H (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3)))))) (fun (_x : MonoidHom.{u2, u2} H (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3)))))) => H -> (Abelianization.{u2} H _inst_3)) (MonoidHom.hasCoeToFun.{u2, u2} H (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3)))))) (Abelianization.of.{u2} H _inst_3) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) (fun (_x : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) => G -> H) (MonoidHom.hasCoeToFun.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) f x))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_3 : Group.{u2} H] (f : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) (x : G), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => Abelianization.{u2} H _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Abelianization.{u1} G _inst_1) a) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))) (Abelianization.of.{u1} G _inst_1) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (Abelianization.{u1} G _inst_1) (fun (_x : Abelianization.{u1} G _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => Abelianization.{u2} H _inst_3) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))) (MonoidHom.monoidHomClass.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))))) (Abelianization.map.{u1, u2} G _inst_1 H _inst_3 f) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Abelianization.{u1} G _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))) (Abelianization.of.{u1} G _inst_1) x)) (FunLike.coe.{succ u2, succ u2, succ u2} (MonoidHom.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3)))))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (fun (_x : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) => Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) _x) (MulHomClass.toFunLike.{u2, u2, u2} (MonoidHom.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3)))))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (MulOneClass.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3)))) (MulOneClass.toMul.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3)))))) (MonoidHomClass.toMulHomClass.{u2, u2, u2} (MonoidHom.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3)))))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3))))) (MonoidHom.monoidHomClass.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3)))))))) (Abelianization.of.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) x) _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => H) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (MonoidHom.monoidHomClass.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))))) f x))
Case conversion may be inaccurate. Consider using '#align abelianization.map_of Abelianization.map_ofₓ'. -/
@[simp]
theorem map_of (x : G) : map f (of x) = of (f x) :=
  rfl
#align abelianization.map_of Abelianization.map_of

/- warning: abelianization.map_id -> Abelianization.map_id is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (Abelianization.map.{u1, u1} G _inst_1 G _inst_1 (MonoidHom.id.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MonoidHom.id.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (MonoidHom.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (Abelianization.map.{u1, u1} G _inst_1 G _inst_1 (MonoidHom.id.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (MonoidHom.id.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))))
Case conversion may be inaccurate. Consider using '#align abelianization.map_id Abelianization.map_idₓ'. -/
@[simp]
theorem map_id : map (MonoidHom.id G) = MonoidHom.id (Abelianization G) :=
  hom_ext _ _ rfl
#align abelianization.map_id Abelianization.map_id

/- warning: abelianization.map_comp -> Abelianization.map_comp is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_3 : Group.{u2} H] (f : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) {I : Type.{u3}} [_inst_4 : Group.{u3} I] (g : MonoidHom.{u2, u3} H I (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u3} I (DivInvMonoid.toMonoid.{u3} I (Group.toDivInvMonoid.{u3} I _inst_4)))), Eq.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.commGroup.{u3} I _inst_4)))))) (MonoidHom.comp.{u1, u2, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.commGroup.{u3} I _inst_4))))) (Abelianization.map.{u2, u3} H _inst_3 I _inst_4 g) (Abelianization.map.{u1, u2} G _inst_1 H _inst_3 f)) (Abelianization.map.{u1, u3} G _inst_1 I _inst_4 (MonoidHom.comp.{u1, u2, u3} G H I (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u3} I (DivInvMonoid.toMonoid.{u3} I (Group.toDivInvMonoid.{u3} I _inst_4))) g f))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_3 : Group.{u2} H] (f : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) {I : Type.{u3}} [_inst_4 : Group.{u3} I] (g : MonoidHom.{u2, u3} H I (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u3} I (DivInvMonoid.toMonoid.{u3} I (Group.toDivInvMonoid.{u3} I _inst_4)))), Eq.{max (succ u1) (succ u3)} (MonoidHom.{u1, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))) (MonoidHom.comp.{u1, u2, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4))))) (Abelianization.map.{u2, u3} H _inst_3 I _inst_4 g) (Abelianization.map.{u1, u2} G _inst_1 H _inst_3 f)) (Abelianization.map.{u1, u3} G _inst_1 I _inst_4 (MonoidHom.comp.{u1, u2, u3} G H I (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u3} I (DivInvMonoid.toMonoid.{u3} I (Group.toDivInvMonoid.{u3} I _inst_4))) g f))
Case conversion may be inaccurate. Consider using '#align abelianization.map_comp Abelianization.map_compₓ'. -/
@[simp]
theorem map_comp {I : Type w} [Group I] (g : H →* I) : (map g).comp (map f) = map (g.comp f) :=
  hom_ext _ _ rfl
#align abelianization.map_comp Abelianization.map_comp

/- warning: abelianization.map_map_apply -> Abelianization.map_map_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_3 : Group.{u2} H] (f : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) {I : Type.{u3}} [_inst_4 : Group.{u3} I] {g : MonoidHom.{u2, u3} H I (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u3} I (DivInvMonoid.toMonoid.{u3} I (Group.toDivInvMonoid.{u3} I _inst_4)))} {x : Abelianization.{u1} G _inst_1}, Eq.{succ u3} (Abelianization.{u3} I _inst_4) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidHom.{u2, u3} (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.commGroup.{u3} I _inst_4)))))) (fun (_x : MonoidHom.{u2, u3} (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.commGroup.{u3} I _inst_4)))))) => (Abelianization.{u2} H _inst_3) -> (Abelianization.{u3} I _inst_4)) (MonoidHom.hasCoeToFun.{u2, u3} (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.commGroup.{u3} I _inst_4)))))) (Abelianization.map.{u2, u3} H _inst_3 I _inst_4 g) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3)))))) (fun (_x : MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3)))))) => (Abelianization.{u1} G _inst_1) -> (Abelianization.{u2} H _inst_3)) (MonoidHom.hasCoeToFun.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.commGroup.{u2} H _inst_3)))))) (Abelianization.map.{u1, u2} G _inst_1 H _inst_3 f) x)) (coeFn.{max (succ u3) (succ u1), max (succ u1) (succ u3)} (MonoidHom.{u1, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.commGroup.{u3} I _inst_4)))))) (fun (_x : MonoidHom.{u1, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.commGroup.{u3} I _inst_4)))))) => (Abelianization.{u1} G _inst_1) -> (Abelianization.{u3} I _inst_4)) (MonoidHom.hasCoeToFun.{u1, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.commGroup.{u3} I _inst_4)))))) (Abelianization.map.{u1, u3} G _inst_1 I _inst_4 (MonoidHom.comp.{u1, u2, u3} G H I (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u3} I (DivInvMonoid.toMonoid.{u3} I (Group.toDivInvMonoid.{u3} I _inst_4))) g f)) x)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_3 : Group.{u2} H] (f : MonoidHom.{u1, u2} G H (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3)))) {I : Type.{u3}} [_inst_4 : Group.{u3} I] {g : MonoidHom.{u2, u3} H I (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u3} I (DivInvMonoid.toMonoid.{u3} I (Group.toDivInvMonoid.{u3} I _inst_4)))} {x : Abelianization.{u1} G _inst_1}, Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u2} H _inst_3) => Abelianization.{u3} I _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (Abelianization.{u1} G _inst_1) (fun (a : Abelianization.{u1} G _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => Abelianization.{u2} H _inst_3) a) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))) (MonoidHom.monoidHomClass.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))))) (Abelianization.map.{u1, u2} G _inst_1 H _inst_3 f) x)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (MonoidHom.{u2, u3} (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))) (Abelianization.{u2} H _inst_3) (fun (_x : Abelianization.{u2} H _inst_3) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u2} H _inst_3) => Abelianization.{u3} I _inst_4) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (MonoidHom.{u2, u3} (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))) (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (MulOneClass.toMul.{u3} (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u2 u3, u2, u3} (MonoidHom.{u2, u3} (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))) (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4))))) (MonoidHom.monoidHomClass.{u2, u3} (Abelianization.{u2} H _inst_3) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))))) (Abelianization.map.{u2, u3} H _inst_3 I _inst_4 g) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (Abelianization.{u1} G _inst_1) (fun (_x : Abelianization.{u1} G _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => Abelianization.{u2} H _inst_3) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3))))) (MonoidHom.monoidHomClass.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_3) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_3) (Abelianization.instCommGroupAbelianization.{u2} H _inst_3)))))))) (Abelianization.map.{u1, u2} G _inst_1 H _inst_3 f) x)) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (MonoidHom.{u1, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))) (Abelianization.{u1} G _inst_1) (fun (_x : Abelianization.{u1} G _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Abelianization.{u1} G _inst_1) => Abelianization.{u3} I _inst_4) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (MonoidHom.{u1, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u3} (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} (MonoidHom.{u1, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4))))) (MonoidHom.monoidHomClass.{u1, u3} (Abelianization.{u1} G _inst_1) (Abelianization.{u3} I _inst_4) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u3} (Abelianization.{u3} I _inst_4) (DivInvMonoid.toMonoid.{u3} (Abelianization.{u3} I _inst_4) (Group.toDivInvMonoid.{u3} (Abelianization.{u3} I _inst_4) (CommGroup.toGroup.{u3} (Abelianization.{u3} I _inst_4) (Abelianization.instCommGroupAbelianization.{u3} I _inst_4)))))))) (Abelianization.map.{u1, u3} G _inst_1 I _inst_4 (MonoidHom.comp.{u1, u2, u3} G H I (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_3))) (Monoid.toMulOneClass.{u3} I (DivInvMonoid.toMonoid.{u3} I (Group.toDivInvMonoid.{u3} I _inst_4))) g f)) x)
Case conversion may be inaccurate. Consider using '#align abelianization.map_map_apply Abelianization.map_map_applyₓ'. -/
@[simp]
theorem map_map_apply {I : Type w} [Group I] {g : H →* I} {x : Abelianization G} :
    map g (map f x) = map (g.comp f) x :=
  MonoidHom.congr_fun (map_comp _ _) x
#align abelianization.map_map_apply Abelianization.map_map_apply

end Map

end Abelianization

section AbelianizationCongr

variable {G} {H : Type v} [Group H] (e : G ≃* H)

/- warning: mul_equiv.abelianization_congr -> MulEquiv.abelianizationCongr is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_2 : Group.{u2} H], (MulEquiv.{u1, u2} G H (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) -> (MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MulOneClass.toHasMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2)))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_2 : Group.{u2} H], (MulEquiv.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) -> (MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align mul_equiv.abelianization_congr MulEquiv.abelianizationCongrₓ'. -/
/-- Equivalent groups have equivalent abelianizations -/
def MulEquiv.abelianizationCongr : Abelianization G ≃* Abelianization H
    where
  toFun := Abelianization.map e.toMonoidHom
  invFun := Abelianization.map e.symm.toMonoidHom
  left_inv := by
    rintro ⟨a⟩
    simp
  right_inv := by
    rintro ⟨a⟩
    simp
  map_mul' := MonoidHom.map_mul _
#align mul_equiv.abelianization_congr MulEquiv.abelianizationCongr

/- warning: abelianization_congr_of -> abelianizationCongr_of is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_2 : Group.{u2} H] (e : MulEquiv.{u1, u2} G H (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) (x : G), Eq.{succ u2} (Abelianization.{u2} H _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MulOneClass.toHasMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2))))))) (fun (_x : MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MulOneClass.toHasMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2))))))) => (Abelianization.{u1} G _inst_1) -> (Abelianization.{u2} H _inst_2)) (MulEquiv.hasCoeToFun.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MulOneClass.toHasMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2))))))) (MulEquiv.abelianizationCongr.{u1, u2} G _inst_1 H _inst_2 e) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (fun (_x : MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) => G -> (Abelianization.{u1} G _inst_1)) (MonoidHom.hasCoeToFun.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (Abelianization.of.{u1} G _inst_1) x)) (coeFn.{succ u2, succ u2} (MonoidHom.{u2, u2} H (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2)))))) (fun (_x : MonoidHom.{u2, u2} H (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2)))))) => H -> (Abelianization.{u2} H _inst_2)) (MonoidHom.hasCoeToFun.{u2, u2} H (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2)))))) (Abelianization.of.{u2} H _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MulEquiv.{u1, u2} G H (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) (fun (_x : MulEquiv.{u1, u2} G H (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) => G -> H) (MulEquiv.hasCoeToFun.{u1, u2} G H (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) e x))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_2 : Group.{u2} H] (e : MulEquiv.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) (x : G), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Abelianization.{u1} G _inst_1) => Abelianization.{u2} H _inst_2) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Abelianization.{u1} G _inst_1) a) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))) (Abelianization.of.{u1} G _inst_1) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2))))))) (Abelianization.{u1} G _inst_1) (fun (_x : Abelianization.{u1} G _inst_1) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Abelianization.{u1} G _inst_1) => Abelianization.{u2} H _inst_2) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2))))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2))))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2))))))) (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2)))))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2)))))))))) (MulEquiv.abelianizationCongr.{u1, u2} G _inst_1 H _inst_2 e) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => Abelianization.{u1} G _inst_1) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} G (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))) (Abelianization.of.{u1} G _inst_1) x)) (FunLike.coe.{succ u2, succ u2, succ u2} (MonoidHom.{u2, u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2)))))) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (fun (_x : (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) => Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) _x) (MulHomClass.toFunLike.{u2, u2, u2} (MonoidHom.{u2, u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2)))))) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (MulOneClass.toMul.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2)))) (MulOneClass.toMul.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2)))))) (MonoidHomClass.toMulHomClass.{u2, u2, u2} (MonoidHom.{u2, u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2)))))) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2))))) (MonoidHom.monoidHomClass.{u2, u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Monoid.toMulOneClass.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (DivInvMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) (Group.toDivInvMonoid.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2))) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (Abelianization.instCommGroupAbelianization.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2)))))))) (Abelianization.of.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) x) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MulEquiv.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => H) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (MulEquiv.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) G H (EquivLike.toEmbeddingLike.{max (succ u1) (succ u2), succ u1, succ u2} (MulEquiv.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) G H (MulEquivClass.toEquivLike.{max u1 u2, u1, u2} (MulEquiv.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2)))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2)))))))) e x))
Case conversion may be inaccurate. Consider using '#align abelianization_congr_of abelianizationCongr_ofₓ'. -/
@[simp]
theorem abelianizationCongr_of (x : G) :
    e.abelianizationCongr (Abelianization.of x) = Abelianization.of (e x) :=
  rfl
#align abelianization_congr_of abelianizationCongr_of

/- warning: abelianization_congr_refl -> abelianizationCongr_refl is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (MulEquiv.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))))) (MulEquiv.abelianizationCongr.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.refl.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (MulEquiv.refl.{u1} (Abelianization.{u1} G _inst_1) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G], Eq.{succ u1} (MulEquiv.{u1, u1} (Abelianization.{u1} G _inst_1) (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))))) (MulEquiv.abelianizationCongr.{u1, u1} G _inst_1 G _inst_1 (MulEquiv.refl.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (MulEquiv.refl.{u1} (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align abelianization_congr_refl abelianizationCongr_reflₓ'. -/
@[simp]
theorem abelianizationCongr_refl :
    (MulEquiv.refl G).abelianizationCongr = MulEquiv.refl (Abelianization G) :=
  MulEquiv.toMonoidHom_injective Abelianization.lift_of
#align abelianization_congr_refl abelianizationCongr_refl

/- warning: abelianization_congr_symm -> abelianizationCongr_symm is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_2 : Group.{u2} H] (e : MulEquiv.{u1, u2} G H (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))), Eq.{max (succ u2) (succ u1)} (MulEquiv.{u2, u1} (Abelianization.{u2} H _inst_2) (Abelianization.{u1} G _inst_1) (MulOneClass.toHasMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2)))))) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1))))))) (MulEquiv.symm.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MulOneClass.toHasMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2)))))) (MulEquiv.abelianizationCongr.{u1, u2} G _inst_1 H _inst_2 e)) (MulEquiv.abelianizationCongr.{u2, u1} H _inst_2 G _inst_1 (MulEquiv.symm.{u1, u2} G H (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2)))) e))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_2 : Group.{u2} H] (e : MulEquiv.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))), Eq.{max (succ u1) (succ u2)} (MulEquiv.{u2, u1} (Abelianization.{u2} H _inst_2) (Abelianization.{u1} G _inst_1) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2)))))) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1))))))) (MulEquiv.symm.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2)))))) (MulEquiv.abelianizationCongr.{u1, u2} G _inst_1 H _inst_2 e)) (MulEquiv.abelianizationCongr.{u2, u1} H _inst_2 G _inst_1 (MulEquiv.symm.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2)))) e))
Case conversion may be inaccurate. Consider using '#align abelianization_congr_symm abelianizationCongr_symmₓ'. -/
@[simp]
theorem abelianizationCongr_symm : e.abelianizationCongr.symm = e.symm.abelianizationCongr :=
  rfl
#align abelianization_congr_symm abelianizationCongr_symm

/- warning: abelianization_congr_trans -> abelianizationCongr_trans is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_2 : Group.{u2} H] (e : MulEquiv.{u1, u2} G H (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) {I : Type.{u2}} [_inst_3 : Group.{u2} I] (e₂ : MulEquiv.{u2, u2} H I (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2)))) (MulOneClass.toHasMul.{u2} I (Monoid.toMulOneClass.{u2} I (DivInvMonoid.toMonoid.{u2} I (Group.toDivInvMonoid.{u2} I _inst_3))))), Eq.{max (succ u1) (succ u2)} (MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} I _inst_3) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MulOneClass.toHasMul.{u2} (Abelianization.{u2} I _inst_3) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} I _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} I _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} I _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} I _inst_3) (Abelianization.commGroup.{u2} I _inst_3))))))) (MulEquiv.trans.{u1, u2, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (Abelianization.{u2} I _inst_3) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.commGroup.{u1} G _inst_1)))))) (MulOneClass.toHasMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.commGroup.{u2} H _inst_2)))))) (MulOneClass.toHasMul.{u2} (Abelianization.{u2} I _inst_3) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} I _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} I _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} I _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} I _inst_3) (Abelianization.commGroup.{u2} I _inst_3)))))) (MulEquiv.abelianizationCongr.{u1, u2} G _inst_1 H _inst_2 e) (MulEquiv.abelianizationCongr.{u2, u2} H _inst_2 I _inst_3 e₂)) (MulEquiv.abelianizationCongr.{u1, u2} G _inst_1 I _inst_3 (MulEquiv.trans.{u1, u2, u2} G H I (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toHasMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2)))) (MulOneClass.toHasMul.{u2} I (Monoid.toMulOneClass.{u2} I (DivInvMonoid.toMonoid.{u2} I (Group.toDivInvMonoid.{u2} I _inst_3)))) e e₂))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {H : Type.{u2}} [_inst_2 : Group.{u2} H] (e : MulEquiv.{u1, u2} G H (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2))))) {I : Type.{u2}} [_inst_3 : Group.{u2} I] (e₂ : MulEquiv.{u2, u2} H I (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2)))) (MulOneClass.toMul.{u2} I (Monoid.toMulOneClass.{u2} I (DivInvMonoid.toMonoid.{u2} I (Group.toDivInvMonoid.{u2} I _inst_3))))), Eq.{max (succ u1) (succ u2)} (MulEquiv.{u1, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} I _inst_3) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} I _inst_3) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} I _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} I _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} I _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} I _inst_3) (Abelianization.instCommGroupAbelianization.{u2} I _inst_3))))))) (MulEquiv.trans.{u1, u2, u2} (Abelianization.{u1} G _inst_1) (Abelianization.{u2} H _inst_2) (Abelianization.{u2} I _inst_3) (MulOneClass.toMul.{u1} (Abelianization.{u1} G _inst_1) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} G _inst_1) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} G _inst_1) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} G _inst_1) (CommGroup.toGroup.{u1} (Abelianization.{u1} G _inst_1) (Abelianization.instCommGroupAbelianization.{u1} G _inst_1)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} H _inst_2) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} H _inst_2) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} H _inst_2) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} H _inst_2) (CommGroup.toGroup.{u2} (Abelianization.{u2} H _inst_2) (Abelianization.instCommGroupAbelianization.{u2} H _inst_2)))))) (MulOneClass.toMul.{u2} (Abelianization.{u2} I _inst_3) (Monoid.toMulOneClass.{u2} (Abelianization.{u2} I _inst_3) (DivInvMonoid.toMonoid.{u2} (Abelianization.{u2} I _inst_3) (Group.toDivInvMonoid.{u2} (Abelianization.{u2} I _inst_3) (CommGroup.toGroup.{u2} (Abelianization.{u2} I _inst_3) (Abelianization.instCommGroupAbelianization.{u2} I _inst_3)))))) (MulEquiv.abelianizationCongr.{u1, u2} G _inst_1 H _inst_2 e) (MulEquiv.abelianizationCongr.{u2, u2} H _inst_2 I _inst_3 e₂)) (MulEquiv.abelianizationCongr.{u1, u2} G _inst_1 I _inst_3 (MulEquiv.trans.{u1, u2, u2} G H I (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MulOneClass.toMul.{u2} H (Monoid.toMulOneClass.{u2} H (DivInvMonoid.toMonoid.{u2} H (Group.toDivInvMonoid.{u2} H _inst_2)))) (MulOneClass.toMul.{u2} I (Monoid.toMulOneClass.{u2} I (DivInvMonoid.toMonoid.{u2} I (Group.toDivInvMonoid.{u2} I _inst_3)))) e e₂))
Case conversion may be inaccurate. Consider using '#align abelianization_congr_trans abelianizationCongr_transₓ'. -/
@[simp]
theorem abelianizationCongr_trans {I : Type v} [Group I] (e₂ : H ≃* I) :
    e.abelianizationCongr.trans e₂.abelianizationCongr = (e.trans e₂).abelianizationCongr :=
  MulEquiv.toMonoidHom_injective (Abelianization.hom_ext _ _ rfl)
#align abelianization_congr_trans abelianizationCongr_trans

end AbelianizationCongr

/- warning: abelianization.equiv_of_comm -> Abelianization.equivOfComm is a dubious translation:
lean 3 declaration is
  forall {H : Type.{u1}} [_inst_2 : CommGroup.{u1} H], MulEquiv.{u1, u1} H (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (MulOneClass.toHasMul.{u1} H (Monoid.toMulOneClass.{u1} H (DivInvMonoid.toMonoid.{u1} H (Group.toDivInvMonoid.{u1} H (CommGroup.toGroup.{u1} H _inst_2))))) (MulOneClass.toHasMul.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (CommGroup.toGroup.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (Abelianization.commGroup.{u1} H (CommGroup.toGroup.{u1} H _inst_2)))))))
but is expected to have type
  forall {H : Type.{u1}} [_inst_2 : CommGroup.{u1} H], MulEquiv.{u1, u1} H (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (MulOneClass.toMul.{u1} H (Monoid.toMulOneClass.{u1} H (DivInvMonoid.toMonoid.{u1} H (Group.toDivInvMonoid.{u1} H (CommGroup.toGroup.{u1} H _inst_2))))) (MulOneClass.toMul.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (Monoid.toMulOneClass.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (DivInvMonoid.toMonoid.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (Group.toDivInvMonoid.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (CommGroup.toGroup.{u1} (Abelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)) (Abelianization.instCommGroupAbelianization.{u1} H (CommGroup.toGroup.{u1} H _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align abelianization.equiv_of_comm Abelianization.equivOfCommₓ'. -/
/-- An Abelian group is equivalent to its own abelianization. -/
@[simps]
def Abelianization.equivOfComm {H : Type _} [CommGroup H] : H ≃* Abelianization H :=
  { Abelianization.of with
    toFun := Abelianization.of
    invFun := Abelianization.lift (MonoidHom.id H)
    left_inv := fun a => rfl
    right_inv := by
      rintro ⟨a⟩
      rfl }
#align abelianization.equiv_of_comm Abelianization.equivOfComm

section commutatorRepresentatives

open Subgroup

#print commutatorRepresentatives /-
/-- Representatives `(g₁, g₂) : G × G` of commutator_set `⁅g₁, g₂⁆ ∈ G`. -/
def commutatorRepresentatives : Set (G × G) :=
  Set.range fun g : commutatorSet G => (g.2.some, g.2.choose_spec.some)
#align commutator_representatives commutatorRepresentatives
-/

instance [Finite (commutatorSet G)] : Finite (commutatorRepresentatives G) :=
  Set.finite_coe_iff.mpr (Set.finite_range _)

#print closureCommutatorRepresentatives /-
/-- Subgroup generated by representatives `g₁ g₂ : G` of commutators `⁅g₁, g₂⁆ ∈ G`. -/
def closureCommutatorRepresentatives : Subgroup G :=
  closure (Prod.fst '' commutatorRepresentatives G ∪ Prod.snd '' commutatorRepresentatives G)
#align closure_commutator_representatives closureCommutatorRepresentatives
-/

/- warning: closure_commutator_representatives_fg -> closureCommutatorRepresentatives_fg is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G] [_inst_2 : Finite.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} G) Type.{u1} (Set.hasCoeToSort.{u1} G) (commutatorSet.{u1} G _inst_1))], Group.Fg.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G] [_inst_2 : Finite.{succ u1} (Set.Elem.{u1} G (commutatorSet.{u1} G _inst_1))], Group.Fg.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align closure_commutator_representatives_fg closureCommutatorRepresentatives_fgₓ'. -/
instance closureCommutatorRepresentatives_fg [Finite (commutatorSet G)] :
    Group.Fg (closureCommutatorRepresentatives G) :=
  Group.closure_finite_fg _
#align closure_commutator_representatives_fg closureCommutatorRepresentatives_fg

/- warning: rank_closure_commutator_representations_le -> rank_closureCommutatorRepresentatives_le is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G] [_inst_2 : Finite.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} G) Type.{u1} (Set.hasCoeToSort.{u1} G) (commutatorSet.{u1} G _inst_1))], LE.le.{0} Nat Nat.hasLe (Group.rank.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1)) (closureCommutatorRepresentatives_fg.{u1} G _inst_1 _inst_2)) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) (Nat.card.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} G) Type.{u1} (Set.hasCoeToSort.{u1} G) (commutatorSet.{u1} G _inst_1))))
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G] [_inst_2 : Finite.{succ u1} (Set.Elem.{u1} G (commutatorSet.{u1} G _inst_1))], LE.le.{0} Nat instLENat (Group.rank.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1)) (closureCommutatorRepresentatives_fg.{u1} G _inst_1 _inst_2)) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) (Nat.card.{u1} (Set.Elem.{u1} G (commutatorSet.{u1} G _inst_1))))
Case conversion may be inaccurate. Consider using '#align rank_closure_commutator_representations_le rank_closureCommutatorRepresentatives_leₓ'. -/
theorem rank_closureCommutatorRepresentatives_le [Finite (commutatorSet G)] :
    Group.rank (closureCommutatorRepresentatives G) ≤ 2 * Nat.card (commutatorSet G) :=
  by
  rw [two_mul]
  exact
    (Subgroup.rank_closure_finite_le_nat_card _).trans
      ((Set.card_union_le _ _).trans
        (add_le_add ((Finite.card_image_le _).trans (Finite.card_range_le _))
          ((Finite.card_image_le _).trans (Finite.card_range_le _))))
#align rank_closure_commutator_representations_le rank_closureCommutatorRepresentatives_le

/- warning: image_commutator_set_closure_commutator_representatives -> image_commutatorSet_closureCommutatorRepresentatives is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{succ u1} (Set.{u1} G) (Set.image.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) G (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) -> G) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) G (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subgroup.subtype.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (commutatorSet.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1)))) (commutatorSet.{u1} G _inst_1)
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{succ u1} (Set.{u1} G) (Set.image.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) G (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (fun (_x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) => G) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) G (MulOneClass.toMul.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) G (Submonoid.toMulOneClass.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (Subgroup.toSubmonoid.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (Subgroup.subtype.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (commutatorSet.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1)))) (commutatorSet.{u1} G _inst_1)
Case conversion may be inaccurate. Consider using '#align image_commutator_set_closure_commutator_representatives image_commutatorSet_closureCommutatorRepresentativesₓ'. -/
theorem image_commutatorSet_closureCommutatorRepresentatives :
    (closureCommutatorRepresentatives G).Subtype ''
        commutatorSet (closureCommutatorRepresentatives G) =
      commutatorSet G :=
  by
  apply Set.Subset.antisymm
  · rintro - ⟨-, ⟨g₁, g₂, rfl⟩, rfl⟩
    exact ⟨g₁, g₂, rfl⟩
  ·
    exact fun g hg =>
      ⟨_,
        ⟨⟨_, subset_closure (Or.inl ⟨_, ⟨⟨g, hg⟩, rfl⟩, rfl⟩)⟩,
          ⟨_, subset_closure (Or.inr ⟨_, ⟨⟨g, hg⟩, rfl⟩, rfl⟩)⟩, rfl⟩,
        hg.some_spec.some_spec⟩
#align image_commutator_set_closure_commutator_representatives image_commutatorSet_closureCommutatorRepresentatives

/- warning: card_commutator_set_closure_commutator_representatives -> card_commutatorSet_closureCommutatorRepresentatives is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{1} Nat (Nat.card.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1))) Type.{u1} (Set.hasCoeToSort.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1))) (commutatorSet.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))))) (Nat.card.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} G) Type.{u1} (Set.hasCoeToSort.{u1} G) (commutatorSet.{u1} G _inst_1)))
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{1} Nat (Nat.card.{u1} (Set.Elem.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (commutatorSet.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))))) (Nat.card.{u1} (Set.Elem.{u1} G (commutatorSet.{u1} G _inst_1)))
Case conversion may be inaccurate. Consider using '#align card_commutator_set_closure_commutator_representatives card_commutatorSet_closureCommutatorRepresentativesₓ'. -/
theorem card_commutatorSet_closureCommutatorRepresentatives :
    Nat.card (commutatorSet (closureCommutatorRepresentatives G)) = Nat.card (commutatorSet G) :=
  by
  rw [← image_commutatorSet_closureCommutatorRepresentatives G]
  exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))
#align card_commutator_set_closure_commutator_representatives card_commutatorSet_closureCommutatorRepresentatives

/- warning: card_commutator_closure_commutator_representatives -> card_commutator_closureCommutatorRepresentatives is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{1} Nat (Nat.card.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.setLike.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1)))) (commutator.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (closureCommutatorRepresentatives.{u1} G _inst_1)) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))))) (Nat.card.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} G _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.setLike.{u1} G _inst_1)) (commutator.{u1} G _inst_1)))
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Eq.{1} Nat (Nat.card.{u1} (Subtype.{succ u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (fun (x : Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) => Membership.mem.{u1, u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.instSetLikeSubgroup.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1)))) x (commutator.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (closureCommutatorRepresentatives.{u1} G _inst_1))) (Subgroup.toGroup.{u1} G _inst_1 (closureCommutatorRepresentatives.{u1} G _inst_1)))))) (Nat.card.{u1} (Subtype.{succ u1} G (fun (x : G) => Membership.mem.{u1, u1} G (Subgroup.{u1} G _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} G _inst_1) G (Subgroup.instSetLikeSubgroup.{u1} G _inst_1)) x (commutator.{u1} G _inst_1))))
Case conversion may be inaccurate. Consider using '#align card_commutator_closure_commutator_representatives card_commutator_closureCommutatorRepresentativesₓ'. -/
theorem card_commutator_closureCommutatorRepresentatives :
    Nat.card (commutator (closureCommutatorRepresentatives G)) = Nat.card (commutator G) :=
  by
  rw [commutator_eq_closure G, ← image_commutatorSet_closureCommutatorRepresentatives, ←
    MonoidHom.map_closure, ← commutator_eq_closure]
  exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))
#align card_commutator_closure_commutator_representatives card_commutator_closureCommutatorRepresentatives

instance [Finite (commutatorSet G)] : Finite (commutatorSet (closureCommutatorRepresentatives G)) :=
  by
  apply Nat.finite_of_card_ne_zero
  rw [card_commutatorSet_closureCommutatorRepresentatives]
  exact finite.card_pos.ne'

end commutatorRepresentatives

