/-
Copyright (c) 2021 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin

! This file was ported from Lean 3 source module group_theory.free_abelian_group_finsupp
! leanprover-community/mathlib commit ce38d86c0b2d427ce208c3cee3159cb421d2b3c4
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Hom.Equiv.TypeTags
import Mathbin.Algebra.Module.Equiv
import Mathbin.Data.Finsupp.Defs
import Mathbin.GroupTheory.FreeAbelianGroup
import Mathbin.GroupTheory.IsFreeGroup
import Mathbin.LinearAlgebra.Dimension

/-!
# Isomorphism between `free_abelian_group X` and `X →₀ ℤ`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we construct the canonical isomorphism between `free_abelian_group X` and `X →₀ ℤ`.
We use this to transport the notion of `support` from `finsupp` to `free_abelian_group`.

## Main declarations

- `free_abelian_group.equiv_finsupp`: group isomorphism between `free_abelian_group X` and `X →₀ ℤ`
- `free_abelian_group.coeff`: the multiplicity of `x : X` in `a : free_abelian_group X`
- `free_abelian_group.support`: the finset of `x : X` that occur in `a : free_abelian_group X`

-/


noncomputable section

open BigOperators

variable {X : Type _}

/- warning: free_abelian_group.to_finsupp -> FreeAbelianGroup.toFinsupp is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}}, AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))
but is expected to have type
  forall {X : Type.{u1}}, AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.to_finsupp FreeAbelianGroup.toFinsuppₓ'. -/
/-- The group homomorphism `free_abelian_group X →+ (X →₀ ℤ)`. -/
def FreeAbelianGroup.toFinsupp : FreeAbelianGroup X →+ X →₀ ℤ :=
  FreeAbelianGroup.lift fun x => Finsupp.single x (1 : ℤ)
#align free_abelian_group.to_finsupp FreeAbelianGroup.toFinsupp

/- warning: finsupp.to_free_abelian_group -> Finsupp.toFreeAbelianGroup is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}}, AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int Int.hasZero) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))
but is expected to have type
  forall {X : Type.{u1}}, AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))
Case conversion may be inaccurate. Consider using '#align finsupp.to_free_abelian_group Finsupp.toFreeAbelianGroupₓ'. -/
/-- The group homomorphism `(X →₀ ℤ) →+ free_abelian_group X`. -/
def Finsupp.toFreeAbelianGroup : (X →₀ ℤ) →+ FreeAbelianGroup X :=
  Finsupp.liftAddHom fun x => (smulAddHom ℤ (FreeAbelianGroup X)).flip (FreeAbelianGroup.of x)
#align finsupp.to_free_abelian_group Finsupp.toFreeAbelianGroup

open Finsupp FreeAbelianGroup

/- warning: finsupp.to_free_abelian_group_comp_single_add_hom -> Finsupp.toFreeAbelianGroup_comp_singleAddHom is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} (x : X), Eq.{succ u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddMonoidHom.comp.{0, u1, u1} Int (Finsupp.{u1, 0} X Int Int.hasZero) (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.toFreeAbelianGroup.{u1} X) (Finsupp.singleAddHom.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) x)) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddMonoid.toAddZeroClass.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddCommMonoid.toAddMonoid.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addCommMonoid.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (fun (_x : AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddMonoid.toAddZeroClass.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddCommMonoid.toAddMonoid.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addCommMonoid.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) => (FreeAbelianGroup.{u1} X) -> (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddMonoidHom.hasCoeToFun.{u1, u1} (FreeAbelianGroup.{u1} X) (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddMonoid.toAddZeroClass.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddCommMonoid.toAddMonoid.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addCommMonoid.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddMonoidHom.flip.{0, u1, u1} Int (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)) (smulAddHom.{0, u1} Int (FreeAbelianGroup.{u1} X) Int.semiring (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)) (AddCommGroup.intModule.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (FreeAbelianGroup.of.{u1} X x))
but is expected to have type
  forall {X : Type.{u1}} (x : X), Eq.{succ u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddMonoidHom.comp.{0, u1, u1} Int (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.toFreeAbelianGroup.{u1} X) (Finsupp.singleAddHom.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) x)) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddMonoid.toAddZeroClass.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddCommMonoid.toAddMonoid.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addCommMonoid.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (FreeAbelianGroup.{u1} X) (fun (_x : FreeAbelianGroup.{u1} X) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddMonoid.toAddZeroClass.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddCommMonoid.toAddMonoid.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addCommMonoid.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (FreeAbelianGroup.{u1} X) (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddZeroClass.toAdd.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddCommMonoid.toAddMonoid.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addCommMonoid.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddMonoid.toAddZeroClass.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddCommMonoid.toAddMonoid.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addCommMonoid.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (FreeAbelianGroup.{u1} X) (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddMonoid.toAddZeroClass.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddCommMonoid.toAddMonoid.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addCommMonoid.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} X) (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddMonoid.toAddZeroClass.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddCommMonoid.toAddMonoid.{u1} (AddMonoidHom.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addCommMonoid.{0, u1} Int (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))))) (AddMonoidHom.flip.{0, u1, u1} Int (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{0} Int (AddMonoidWithOne.toAddMonoid.{0} Int (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Int (NonAssocSemiring.toAddCommMonoidWithOne.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (AddCommMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)) (smulAddHom.{0, u1} Int (FreeAbelianGroup.{u1} X) Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)) (AddCommGroup.intModule.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) (FreeAbelianGroup.of.{u1} X x))
Case conversion may be inaccurate. Consider using '#align finsupp.to_free_abelian_group_comp_single_add_hom Finsupp.toFreeAbelianGroup_comp_singleAddHomₓ'. -/
@[simp]
theorem Finsupp.toFreeAbelianGroup_comp_singleAddHom (x : X) :
    Finsupp.toFreeAbelianGroup.comp (Finsupp.singleAddHom x) =
      (smulAddHom ℤ (FreeAbelianGroup X)).flip (of x) :=
  by
  ext
  simp only [AddMonoidHom.coe_comp, Finsupp.singleAddHom_apply, Function.comp_apply, one_smul,
    to_free_abelian_group, Finsupp.liftAddHom_apply_single]
#align finsupp.to_free_abelian_group_comp_single_add_hom Finsupp.toFreeAbelianGroup_comp_singleAddHom

/- warning: free_abelian_group.to_finsupp_comp_to_free_abelian_group -> FreeAbelianGroup.toFinsupp_comp_toFreeAbelianGroup is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}}, Eq.{succ u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int Int.hasZero) (Finsupp.{u1, 0} X Int Int.hasZero) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) (AddMonoidHom.comp.{u1, u1, u1} (Finsupp.{u1, 0} X Int Int.hasZero) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (FreeAbelianGroup.toFinsupp.{u1} X) (Finsupp.toFreeAbelianGroup.{u1} X)) (AddMonoidHom.id.{u1} (Finsupp.{u1, 0} X Int Int.hasZero) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)))
but is expected to have type
  forall {X : Type.{u1}}, Eq.{succ u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (AddMonoidHom.comp.{u1, u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (FreeAbelianGroup.toFinsupp.{u1} X) (Finsupp.toFreeAbelianGroup.{u1} X)) (AddMonoidHom.id.{u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.to_finsupp_comp_to_free_abelian_group FreeAbelianGroup.toFinsupp_comp_toFreeAbelianGroupₓ'. -/
@[simp]
theorem FreeAbelianGroup.toFinsupp_comp_toFreeAbelianGroup :
    toFinsupp.comp toFreeAbelianGroup = AddMonoidHom.id (X →₀ ℤ) :=
  by
  ext (x y); simp only [AddMonoidHom.id_comp]
  rw [AddMonoidHom.comp_assoc, Finsupp.toFreeAbelianGroup_comp_singleAddHom]
  simp only [to_finsupp, AddMonoidHom.coe_comp, Finsupp.singleAddHom_apply, Function.comp_apply,
    one_smul, lift.of, AddMonoidHom.flip_apply, smulAddHom_apply, AddMonoidHom.id_apply]
#align free_abelian_group.to_finsupp_comp_to_free_abelian_group FreeAbelianGroup.toFinsupp_comp_toFreeAbelianGroup

#print Finsupp.toFreeAbelianGroup_comp_toFinsupp /-
@[simp]
theorem Finsupp.toFreeAbelianGroup_comp_toFinsupp :
    toFreeAbelianGroup.comp toFinsupp = AddMonoidHom.id (FreeAbelianGroup X) :=
  by
  ext
  rw [to_free_abelian_group, to_finsupp, AddMonoidHom.comp_apply, lift.of,
    lift_add_hom_apply_single, AddMonoidHom.flip_apply, smulAddHom_apply, one_smul,
    AddMonoidHom.id_apply]
#align finsupp.to_free_abelian_group_comp_to_finsupp Finsupp.toFreeAbelianGroup_comp_toFinsupp
-/

/- warning: finsupp.to_free_abelian_group_to_finsupp -> Finsupp.toFreeAbelianGroup_toFinsupp is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} (x : FreeAbelianGroup.{u1} X), Eq.{succ u1} (FreeAbelianGroup.{u1} X) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int Int.hasZero) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (fun (_x : AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int Int.hasZero) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) => (Finsupp.{u1, 0} X Int Int.hasZero) -> (FreeAbelianGroup.{u1} X)) (AddMonoidHom.hasCoeToFun.{u1, u1} (Finsupp.{u1, 0} X Int Int.hasZero) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.toFreeAbelianGroup.{u1} X) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) (fun (_x : AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) => (FreeAbelianGroup.{u1} X) -> (Finsupp.{u1, 0} X Int Int.hasZero)) (AddMonoidHom.hasCoeToFun.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) (FreeAbelianGroup.toFinsupp.{u1} X) x)) x
but is expected to have type
  forall {X : Type.{u1}} (x : FreeAbelianGroup.{u1} X), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) => FreeAbelianGroup.{u1} X) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (fun (a : FreeAbelianGroup.{u1} X) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddZeroClass.toAdd.{u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))))) (FreeAbelianGroup.toFinsupp.{u1} X) x)) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (fun (_x : Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) => FreeAbelianGroup.{u1} X) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (AddZeroClass.toAdd.{u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))))) (Finsupp.toFreeAbelianGroup.{u1} X) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (fun (_x : FreeAbelianGroup.{u1} X) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddZeroClass.toAdd.{u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))))) (FreeAbelianGroup.toFinsupp.{u1} X) x)) x
Case conversion may be inaccurate. Consider using '#align finsupp.to_free_abelian_group_to_finsupp Finsupp.toFreeAbelianGroup_toFinsuppₓ'. -/
@[simp]
theorem Finsupp.toFreeAbelianGroup_toFinsupp {X} (x : FreeAbelianGroup X) :
    x.toFinsupp.toFreeAbelianGroup = x := by
  rw [← AddMonoidHom.comp_apply, Finsupp.toFreeAbelianGroup_comp_toFinsupp, AddMonoidHom.id_apply]
#align finsupp.to_free_abelian_group_to_finsupp Finsupp.toFreeAbelianGroup_toFinsupp

namespace FreeAbelianGroup

open Finsupp

variable {X}

/- warning: free_abelian_group.to_finsupp_of -> FreeAbelianGroup.toFinsupp_of is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} (x : X), Eq.{succ u1} (Finsupp.{u1, 0} X Int Int.hasZero) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) (fun (_x : AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) => (FreeAbelianGroup.{u1} X) -> (Finsupp.{u1, 0} X Int Int.hasZero)) (AddMonoidHom.hasCoeToFun.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) (FreeAbelianGroup.toFinsupp.{u1} X) (FreeAbelianGroup.of.{u1} X x)) (Finsupp.single.{u1, 0} X Int Int.hasZero x (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))
but is expected to have type
  forall {X : Type.{u1}} (x : X), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.of.{u1} X x)) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (fun (_x : FreeAbelianGroup.{u1} X) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddZeroClass.toAdd.{u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))))) (FreeAbelianGroup.toFinsupp.{u1} X) (FreeAbelianGroup.of.{u1} X x)) (Finsupp.single.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) x (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.to_finsupp_of FreeAbelianGroup.toFinsupp_ofₓ'. -/
@[simp]
theorem toFinsupp_of (x : X) : toFinsupp (of x) = Finsupp.single x 1 := by
  simp only [to_finsupp, lift.of]
#align free_abelian_group.to_finsupp_of FreeAbelianGroup.toFinsupp_of

/- warning: free_abelian_group.to_finsupp_to_free_abelian_group -> FreeAbelianGroup.toFinsupp_toFreeAbelianGroup is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} (f : Finsupp.{u1, 0} X Int Int.hasZero), Eq.{succ u1} (Finsupp.{u1, 0} X Int Int.hasZero) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) (fun (_x : AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) => (FreeAbelianGroup.{u1} X) -> (Finsupp.{u1, 0} X Int Int.hasZero)) (AddMonoidHom.hasCoeToFun.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))) (FreeAbelianGroup.toFinsupp.{u1} X) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int Int.hasZero) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (fun (_x : AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int Int.hasZero) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) => (Finsupp.{u1, 0} X Int Int.hasZero) -> (FreeAbelianGroup.{u1} X)) (AddMonoidHom.hasCoeToFun.{u1, u1} (Finsupp.{u1, 0} X Int Int.hasZero) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.toFreeAbelianGroup.{u1} X) f)) f
but is expected to have type
  forall {X : Type.{u1}} (f : Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (fun (a : Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) => FreeAbelianGroup.{u1} X) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (AddZeroClass.toAdd.{u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))))) (Finsupp.toFreeAbelianGroup.{u1} X) f)) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (fun (_x : FreeAbelianGroup.{u1} X) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddZeroClass.toAdd.{u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))))) (FreeAbelianGroup.toFinsupp.{u1} X) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (fun (_x : Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) => FreeAbelianGroup.{u1} X) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (AddZeroClass.toAdd.{u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (FreeAbelianGroup.{u1} X) (Finsupp.addZeroClass.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))))) (Finsupp.toFreeAbelianGroup.{u1} X) f)) f
Case conversion may be inaccurate. Consider using '#align free_abelian_group.to_finsupp_to_free_abelian_group FreeAbelianGroup.toFinsupp_toFreeAbelianGroupₓ'. -/
@[simp]
theorem toFinsupp_toFreeAbelianGroup (f : X →₀ ℤ) : f.toFreeAbelianGroup.toFinsupp = f := by
  rw [← AddMonoidHom.comp_apply, to_finsupp_comp_to_free_abelian_group, AddMonoidHom.id_apply]
#align free_abelian_group.to_finsupp_to_free_abelian_group FreeAbelianGroup.toFinsupp_toFreeAbelianGroup

variable (X)

/- warning: free_abelian_group.equiv_finsupp -> FreeAbelianGroup.equivFinsupp is a dubious translation:
lean 3 declaration is
  forall (X : Type.{u1}), AddEquiv.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int Int.hasZero) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.add.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))
but is expected to have type
  forall (X : Type.{u1}), AddEquiv.{u1, u1} (FreeAbelianGroup.{u1} X) (Finsupp.{u1, 0} X Int (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (Finsupp.add.{u1, 0} X Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.equiv_finsupp FreeAbelianGroup.equivFinsuppₓ'. -/
/-- The additive equivalence between `free_abelian_group X` and `(X →₀ ℤ)`. -/
@[simps]
def equivFinsupp : FreeAbelianGroup X ≃+ (X →₀ ℤ)
    where
  toFun := toFinsupp
  invFun := toFreeAbelianGroup
  left_inv := toFreeAbelianGroup_toFinsupp
  right_inv := toFinsupp_toFreeAbelianGroup
  map_add' := toFinsupp.map_add
#align free_abelian_group.equiv_finsupp FreeAbelianGroup.equivFinsupp

/- warning: free_abelian_group.basis -> FreeAbelianGroup.basis is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}), Basis.{u1, 0, u1} α Int (FreeAbelianGroup.{u1} α) Int.semiring (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)) (AddCommGroup.intModule.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))
but is expected to have type
  forall (α : Type.{u1}), Basis.{u1, 0, u1} α Int (FreeAbelianGroup.{u1} α) Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)) (AddCommGroup.intModule.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.basis FreeAbelianGroup.basisₓ'. -/
/-- `A` is a basis of the ℤ-module `free_abelian_group A`. -/
noncomputable def basis (α : Type _) : Basis α ℤ (FreeAbelianGroup α) :=
  ⟨(FreeAbelianGroup.equivFinsupp α).toIntLinearEquiv⟩
#align free_abelian_group.basis FreeAbelianGroup.basis

/- warning: free_abelian_group.equiv.of_free_abelian_group_linear_equiv -> FreeAbelianGroup.Equiv.ofFreeAbelianGroupLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} {β : Type.{u_2}}, (LinearEquiv.{0, 0, u_1, u_2} Int Int Int.semiring Int.semiring (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.semiring)) (RingHomInvPair.ids.{0} Int Int.semiring) (RingHomInvPair.ids.{0} Int Int.semiring) (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.{u_2} β) (AddCommGroup.toAddCommMonoid.{u_1} (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.addCommGroup.{u_1} α)) (AddCommGroup.toAddCommMonoid.{u_2} (FreeAbelianGroup.{u_2} β) (FreeAbelianGroup.addCommGroup.{u_2} β)) (AddCommGroup.intModule.{u_1} (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.addCommGroup.{u_1} α)) (AddCommGroup.intModule.{u_2} (FreeAbelianGroup.{u_2} β) (FreeAbelianGroup.addCommGroup.{u_2} β))) -> (Equiv.{succ u_1, succ u_2} α β)
but is expected to have type
  forall {α : Type.{u_1}} {β : Type.{u_2}}, (LinearEquiv.{0, 0, u_1, u_2} Int Int Int.instSemiringInt Int.instSemiringInt (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHom.id.{0} Int (Semiring.toNonAssocSemiring.{0} Int Int.instSemiringInt)) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (RingHomInvPair.ids.{0} Int Int.instSemiringInt) (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.{u_2} β) (AddCommGroup.toAddCommMonoid.{u_1} (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.addCommGroup.{u_1} α)) (AddCommGroup.toAddCommMonoid.{u_2} (FreeAbelianGroup.{u_2} β) (FreeAbelianGroup.addCommGroup.{u_2} β)) (AddCommGroup.intModule.{u_1} (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.addCommGroup.{u_1} α)) (AddCommGroup.intModule.{u_2} (FreeAbelianGroup.{u_2} β) (FreeAbelianGroup.addCommGroup.{u_2} β))) -> (Equiv.{succ u_1, succ u_2} α β)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.equiv.of_free_abelian_group_linear_equiv FreeAbelianGroup.Equiv.ofFreeAbelianGroupLinearEquivₓ'. -/
/-- Isomorphic free ablian groups (as modules) have equivalent bases. -/
def Equiv.ofFreeAbelianGroupLinearEquiv {α β : Type _}
    (e : FreeAbelianGroup α ≃ₗ[ℤ] FreeAbelianGroup β) : α ≃ β :=
  let t : Basis α ℤ (FreeAbelianGroup β) := (FreeAbelianGroup.basis α).map e
  t.indexEquiv <| FreeAbelianGroup.basis _
#align free_abelian_group.equiv.of_free_abelian_group_linear_equiv FreeAbelianGroup.Equiv.ofFreeAbelianGroupLinearEquiv

/- warning: free_abelian_group.equiv.of_free_abelian_group_equiv -> FreeAbelianGroup.Equiv.ofFreeAbelianGroupEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} {β : Type.{u_2}}, (AddEquiv.{u_1, u_2} (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.{u_2} β) (AddZeroClass.toHasAdd.{u_1} (FreeAbelianGroup.{u_1} α) (AddMonoid.toAddZeroClass.{u_1} (FreeAbelianGroup.{u_1} α) (SubNegMonoid.toAddMonoid.{u_1} (FreeAbelianGroup.{u_1} α) (AddGroup.toSubNegMonoid.{u_1} (FreeAbelianGroup.{u_1} α) (AddCommGroup.toAddGroup.{u_1} (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.addCommGroup.{u_1} α)))))) (AddZeroClass.toHasAdd.{u_2} (FreeAbelianGroup.{u_2} β) (AddMonoid.toAddZeroClass.{u_2} (FreeAbelianGroup.{u_2} β) (SubNegMonoid.toAddMonoid.{u_2} (FreeAbelianGroup.{u_2} β) (AddGroup.toSubNegMonoid.{u_2} (FreeAbelianGroup.{u_2} β) (AddCommGroup.toAddGroup.{u_2} (FreeAbelianGroup.{u_2} β) (FreeAbelianGroup.addCommGroup.{u_2} β))))))) -> (Equiv.{succ u_1, succ u_2} α β)
but is expected to have type
  forall {α : Type.{u_1}} {β : Type.{u_2}}, (AddEquiv.{u_1, u_2} (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.{u_2} β) (AddZeroClass.toAdd.{u_1} (FreeAbelianGroup.{u_1} α) (AddMonoid.toAddZeroClass.{u_1} (FreeAbelianGroup.{u_1} α) (SubNegMonoid.toAddMonoid.{u_1} (FreeAbelianGroup.{u_1} α) (AddGroup.toSubNegMonoid.{u_1} (FreeAbelianGroup.{u_1} α) (AddCommGroup.toAddGroup.{u_1} (FreeAbelianGroup.{u_1} α) (FreeAbelianGroup.addCommGroup.{u_1} α)))))) (AddZeroClass.toAdd.{u_2} (FreeAbelianGroup.{u_2} β) (AddMonoid.toAddZeroClass.{u_2} (FreeAbelianGroup.{u_2} β) (SubNegMonoid.toAddMonoid.{u_2} (FreeAbelianGroup.{u_2} β) (AddGroup.toSubNegMonoid.{u_2} (FreeAbelianGroup.{u_2} β) (AddCommGroup.toAddGroup.{u_2} (FreeAbelianGroup.{u_2} β) (FreeAbelianGroup.addCommGroup.{u_2} β))))))) -> (Equiv.{succ u_1, succ u_2} α β)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.equiv.of_free_abelian_group_equiv FreeAbelianGroup.Equiv.ofFreeAbelianGroupEquivₓ'. -/
/-- Isomorphic free abelian groups (as additive groups) have equivalent bases. -/
def Equiv.ofFreeAbelianGroupEquiv {α β : Type _} (e : FreeAbelianGroup α ≃+ FreeAbelianGroup β) :
    α ≃ β :=
  Equiv.ofFreeAbelianGroupLinearEquiv e.toIntLinearEquiv
#align free_abelian_group.equiv.of_free_abelian_group_equiv FreeAbelianGroup.Equiv.ofFreeAbelianGroupEquiv

/- warning: free_abelian_group.equiv.of_free_group_equiv -> FreeAbelianGroup.Equiv.ofFreeGroupEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_1}} {β : Type.{u_2}}, (MulEquiv.{u_1, u_2} (FreeGroup.{u_1} α) (FreeGroup.{u_2} β) (FreeGroup.hasMul.{u_1} α) (FreeGroup.hasMul.{u_2} β)) -> (Equiv.{succ u_1, succ u_2} α β)
but is expected to have type
  forall {α : Type.{u_1}} {β : Type.{u_2}}, (MulEquiv.{u_1, u_2} (FreeGroup.{u_1} α) (FreeGroup.{u_2} β) (FreeGroup.instMulFreeGroup.{u_1} α) (FreeGroup.instMulFreeGroup.{u_2} β)) -> (Equiv.{succ u_1, succ u_2} α β)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.equiv.of_free_group_equiv FreeAbelianGroup.Equiv.ofFreeGroupEquivₓ'. -/
/-- Isomorphic free groups have equivalent bases. -/
def Equiv.ofFreeGroupEquiv {α β : Type _} (e : FreeGroup α ≃* FreeGroup β) : α ≃ β :=
  Equiv.ofFreeAbelianGroupEquiv e.abelianizationCongr.toAdditive
#align free_abelian_group.equiv.of_free_group_equiv FreeAbelianGroup.Equiv.ofFreeGroupEquiv

open IsFreeGroup

/- warning: free_abelian_group.equiv.of_is_free_group_equiv -> FreeAbelianGroup.Equiv.ofIsFreeGroupEquiv is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u_1}} {H : Type.{u_2}} [_inst_1 : Group.{u_1} G] [_inst_2 : Group.{u_2} H] [_inst_3 : IsFreeGroup.{u_1} G _inst_1] [_inst_4 : IsFreeGroup.{u_2} H _inst_2], (MulEquiv.{u_1, u_2} G H (MulOneClass.toHasMul.{u_1} G (Monoid.toMulOneClass.{u_1} G (DivInvMonoid.toMonoid.{u_1} G (Group.toDivInvMonoid.{u_1} G _inst_1)))) (MulOneClass.toHasMul.{u_2} H (Monoid.toMulOneClass.{u_2} H (DivInvMonoid.toMonoid.{u_2} H (Group.toDivInvMonoid.{u_2} H _inst_2))))) -> (Equiv.{succ u_1, succ u_2} (IsFreeGroup.Generators.{u_1} G _inst_1 _inst_3) (IsFreeGroup.Generators.{u_2} H _inst_2 _inst_4))
but is expected to have type
  forall {G : Type.{u_1}} {H : Type.{u_2}} [_inst_1 : Group.{u_1} G] [_inst_2 : Group.{u_2} H] [_inst_3 : IsFreeGroup.{u_1} G _inst_1] [_inst_4 : IsFreeGroup.{u_2} H _inst_2], (MulEquiv.{u_1, u_2} G H (MulOneClass.toMul.{u_1} G (Monoid.toMulOneClass.{u_1} G (DivInvMonoid.toMonoid.{u_1} G (Group.toDivInvMonoid.{u_1} G _inst_1)))) (MulOneClass.toMul.{u_2} H (Monoid.toMulOneClass.{u_2} H (DivInvMonoid.toMonoid.{u_2} H (Group.toDivInvMonoid.{u_2} H _inst_2))))) -> (Equiv.{succ u_1, succ u_2} (IsFreeGroup.Generators.{u_1} G _inst_1 _inst_3) (IsFreeGroup.Generators.{u_2} H _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.equiv.of_is_free_group_equiv FreeAbelianGroup.Equiv.ofIsFreeGroupEquivₓ'. -/
/-- Isomorphic free groups have equivalent bases (`is_free_group` variant`). -/
def Equiv.ofIsFreeGroupEquiv {G H : Type _} [Group G] [Group H] [IsFreeGroup G] [IsFreeGroup H]
    (e : G ≃* H) : Generators G ≃ Generators H :=
  Equiv.ofFreeGroupEquiv <| MulEquiv.trans (toFreeGroup G).symm <| MulEquiv.trans e <| toFreeGroup H
#align free_abelian_group.equiv.of_is_free_group_equiv FreeAbelianGroup.Equiv.ofIsFreeGroupEquiv

variable {X}

/- warning: free_abelian_group.coeff -> FreeAbelianGroup.coeff is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}}, X -> (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid))
but is expected to have type
  forall {X : Type.{u1}}, X -> (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.coeff FreeAbelianGroup.coeffₓ'. -/
/-- `coeff x` is the additive group homomorphism `free_abelian_group X →+ ℤ`
that sends `a` to the multiplicity of `x : X` in `a`. -/
def coeff (x : X) : FreeAbelianGroup X →+ ℤ :=
  (Finsupp.applyAddHom x).comp toFinsupp
#align free_abelian_group.coeff FreeAbelianGroup.coeff

#print FreeAbelianGroup.support /-
/-- `support a` for `a : free_abelian_group X` is the finite set of `x : X`
that occur in the formal sum `a`. -/
def support (a : FreeAbelianGroup X) : Finset X :=
  a.toFinsupp.support
#align free_abelian_group.support FreeAbelianGroup.support
-/

/- warning: free_abelian_group.mem_support_iff -> FreeAbelianGroup.mem_support_iff is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} (x : X) (a : FreeAbelianGroup.{u1} X), Iff (Membership.Mem.{u1, u1} X (Finset.{u1} X) (Finset.hasMem.{u1} X) x (FreeAbelianGroup.support.{u1} X a)) (Ne.{1} Int (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) => (FreeAbelianGroup.{u1} X) -> Int) (AddMonoidHom.hasCoeToFun.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (FreeAbelianGroup.coeff.{u1} X x) a) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))))
but is expected to have type
  forall {X : Type.{u1}} (x : X) (a : FreeAbelianGroup.{u1} X), Iff (Membership.mem.{u1, u1} X (Finset.{u1} X) (Finset.instMembershipFinset.{u1} X) x (FreeAbelianGroup.support.{u1} X a)) (Ne.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Int) a) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (FreeAbelianGroup.{u1} X) (fun (_x : FreeAbelianGroup.{u1} X) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Int) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (FreeAbelianGroup.{u1} X) Int (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddZeroClass.toAdd.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoidHom.addMonoidHomClass.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)))) (FreeAbelianGroup.coeff.{u1} X x) a) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Int) a) 0 (instOfNatInt 0)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.mem_support_iff FreeAbelianGroup.mem_support_iffₓ'. -/
theorem mem_support_iff (x : X) (a : FreeAbelianGroup X) : x ∈ a.support ↔ coeff x a ≠ 0 :=
  by
  rw [support, Finsupp.mem_support_iff]
  exact Iff.rfl
#align free_abelian_group.mem_support_iff FreeAbelianGroup.mem_support_iff

/- warning: free_abelian_group.not_mem_support_iff -> FreeAbelianGroup.not_mem_support_iff is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} (x : X) (a : FreeAbelianGroup.{u1} X), Iff (Not (Membership.Mem.{u1, u1} X (Finset.{u1} X) (Finset.hasMem.{u1} X) x (FreeAbelianGroup.support.{u1} X a))) (Eq.{1} Int (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) => (FreeAbelianGroup.{u1} X) -> Int) (AddMonoidHom.hasCoeToFun.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (FreeAbelianGroup.coeff.{u1} X x) a) (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))))
but is expected to have type
  forall {X : Type.{u1}} (x : X) (a : FreeAbelianGroup.{u1} X), Iff (Not (Membership.mem.{u1, u1} X (Finset.{u1} X) (Finset.instMembershipFinset.{u1} X) x (FreeAbelianGroup.support.{u1} X a))) (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Int) a) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (FreeAbelianGroup.{u1} X) (fun (_x : FreeAbelianGroup.{u1} X) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Int) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (FreeAbelianGroup.{u1} X) Int (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) (AddZeroClass.toAdd.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoidHom.addMonoidHomClass.{u1, 0} (FreeAbelianGroup.{u1} X) Int (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))) (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)))) (FreeAbelianGroup.coeff.{u1} X x) a) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} X) => Int) a) 0 (instOfNatInt 0)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.not_mem_support_iff FreeAbelianGroup.not_mem_support_iffₓ'. -/
theorem not_mem_support_iff (x : X) (a : FreeAbelianGroup X) : x ∉ a.support ↔ coeff x a = 0 :=
  by
  rw [support, Finsupp.not_mem_support_iff]
  exact Iff.rfl
#align free_abelian_group.not_mem_support_iff FreeAbelianGroup.not_mem_support_iff

/- warning: free_abelian_group.support_zero -> FreeAbelianGroup.support_zero is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}}, Eq.{succ u1} (Finset.{u1} X) (FreeAbelianGroup.support.{u1} X (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} X) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} X) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} X) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))))))) (EmptyCollection.emptyCollection.{u1} (Finset.{u1} X) (Finset.hasEmptyc.{u1} X))
but is expected to have type
  forall {X : Type.{u1}}, Eq.{succ u1} (Finset.{u1} X) (FreeAbelianGroup.support.{u1} X (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} X) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} X) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} X) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} X) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))))))) (EmptyCollection.emptyCollection.{u1} (Finset.{u1} X) (Finset.instEmptyCollectionFinset.{u1} X))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.support_zero FreeAbelianGroup.support_zeroₓ'. -/
@[simp]
theorem support_zero : support (0 : FreeAbelianGroup X) = ∅ := by
  simp only [support, Finsupp.support_zero, AddMonoidHom.map_zero]
#align free_abelian_group.support_zero FreeAbelianGroup.support_zero

#print FreeAbelianGroup.support_of /-
@[simp]
theorem support_of (x : X) : support (of x) = {x} := by
  simp only [support, to_finsupp_of, Finsupp.support_single_ne_zero _ one_ne_zero]
#align free_abelian_group.support_of FreeAbelianGroup.support_of
-/

/- warning: free_abelian_group.support_neg -> FreeAbelianGroup.support_neg is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} (a : FreeAbelianGroup.{u1} X), Eq.{succ u1} (Finset.{u1} X) (FreeAbelianGroup.support.{u1} X (Neg.neg.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))) a)) (FreeAbelianGroup.support.{u1} X a)
but is expected to have type
  forall {X : Type.{u1}} (a : FreeAbelianGroup.{u1} X), Eq.{succ u1} (Finset.{u1} X) (FreeAbelianGroup.support.{u1} X (Neg.neg.{u1} (FreeAbelianGroup.{u1} X) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} X) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} X) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X)))))) a)) (FreeAbelianGroup.support.{u1} X a)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.support_neg FreeAbelianGroup.support_negₓ'. -/
@[simp]
theorem support_neg (a : FreeAbelianGroup X) : support (-a) = support a := by
  simp only [support, AddMonoidHom.map_neg, Finsupp.support_neg]
#align free_abelian_group.support_neg FreeAbelianGroup.support_neg

#print FreeAbelianGroup.support_zsmul /-
@[simp]
theorem support_zsmul (k : ℤ) (h : k ≠ 0) (a : FreeAbelianGroup X) : support (k • a) = support a :=
  by
  ext x
  simp only [mem_support_iff, AddMonoidHom.map_zsmul]
  simp only [h, zsmul_int_int, false_or_iff, Ne.def, mul_eq_zero]
#align free_abelian_group.support_zsmul FreeAbelianGroup.support_zsmul
-/

#print FreeAbelianGroup.support_nsmul /-
@[simp]
theorem support_nsmul (k : ℕ) (h : k ≠ 0) (a : FreeAbelianGroup X) : support (k • a) = support a :=
  by
  apply support_zsmul k _ a
  exact_mod_cast h
#align free_abelian_group.support_nsmul FreeAbelianGroup.support_nsmul
-/

open Classical

/- warning: free_abelian_group.support_add -> FreeAbelianGroup.support_add is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} (a : FreeAbelianGroup.{u1} X) (b : FreeAbelianGroup.{u1} X), HasSubset.Subset.{u1} (Finset.{u1} X) (Finset.hasSubset.{u1} X) (FreeAbelianGroup.support.{u1} X (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.{u1} X) (instHAdd.{u1} (FreeAbelianGroup.{u1} X) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))))) a b)) (Union.union.{u1} (Finset.{u1} X) (Finset.hasUnion.{u1} X (fun (a : X) (b : X) => Classical.propDecidable (Eq.{succ u1} X a b))) (FreeAbelianGroup.support.{u1} X a) (FreeAbelianGroup.support.{u1} X b))
but is expected to have type
  forall {X : Type.{u1}} (a : FreeAbelianGroup.{u1} X) (b : FreeAbelianGroup.{u1} X), HasSubset.Subset.{u1} (Finset.{u1} X) (Finset.instHasSubsetFinset.{u1} X) (FreeAbelianGroup.support.{u1} X (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.{u1} X) (instHAdd.{u1} (FreeAbelianGroup.{u1} X) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} X) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} X) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} X) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} X) (FreeAbelianGroup.addCommGroup.{u1} X))))))) a b)) (Union.union.{u1} (Finset.{u1} X) (Finset.instUnionFinset.{u1} X (fun (a : X) (b : X) => Classical.propDecidable (Eq.{succ u1} X a b))) (FreeAbelianGroup.support.{u1} X a) (FreeAbelianGroup.support.{u1} X b))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.support_add FreeAbelianGroup.support_addₓ'. -/
theorem support_add (a b : FreeAbelianGroup X) : support (a + b) ⊆ a.support ∪ b.support :=
  by
  simp only [support, AddMonoidHom.map_add]
  apply Finsupp.support_add
#align free_abelian_group.support_add FreeAbelianGroup.support_add

end FreeAbelianGroup

