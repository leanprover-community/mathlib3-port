/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau

! This file was ported from Lean 3 source module group_theory.free_abelian_group
! leanprover-community/mathlib commit 70fd9563a21e7b963887c9360bd29b2393e6225a
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Group.Pi
import Mathbin.GroupTheory.FreeGroup
import Mathbin.GroupTheory.Abelianization
import Mathbin.Algebra.Module.Basic

/-!
# Free abelian groups

The free abelian group on a type `α`, defined as the abelianisation of
the free group on `α`.

The free abelian group on `α` can be abstractly defined as the left adjoint of the
forgetful functor from abelian groups to types. Alternatively, one could define
it as the functions `α → ℤ` which send all but finitely many `(a : α)` to `0`,
under pointwise addition. In this file, it is defined as the abelianisation
of the free group on `α`. All the constructions and theorems required to show
the adjointness of the construction and the forgetful functor are proved in this
file, but the category-theoretic adjunction statement is in
`algebra.category.Group.adjunctions` .

## Main definitions

Here we use the following variables: `(α β : Type*) (A : Type*) [add_comm_group A]`

* `free_abelian_group α` : the free abelian group on a type `α`. As an abelian
group it is `α →₀ ℤ`, the functions from `α` to `ℤ` such that all but finitely
many elements get mapped to zero, however this is not how it is implemented.

* `lift f : free_abelian_group α →+ A` : the group homomorphism induced
  by the map `f : α → A`.

* `map (f : α → β) : free_abelian_group α →+ free_abelian_group β` : functoriality
    of `free_abelian_group`

* `instance [monoid α] : semigroup (free_abelian_group α)`

* `instance [comm_monoid α] : comm_ring (free_abelian_group α)`

It has been suggested that we would be better off refactoring this file
and using `finsupp` instead.

## Implementation issues

The definition is `def free_abelian_group : Type u :=
additive $ abelianization $ free_group α`

Chris Hughes has suggested that this all be rewritten in terms of `finsupp`.
Johan Commelin has written all the API relating the definition to `finsupp`
in the lean-liquid repo.

The lemmas `map_pure`, `map_of`, `map_zero`, `map_add`, `map_neg` and `map_sub`
are proved about the `functor.map` `<$>` construction, and need `α` and `β` to
be in the same universe. But
`free_abelian_group.map (f : α → β)` is defined to be the `add_group`
homomorphism `free_abelian_group α →+ free_abelian_group β` (with `α` and `β` now
allowed to be in different universes), so `(map f).map_add`
etc can be used to prove that `free_abelian_group.map` preserves addition. The
functions `map_id`, `map_id_apply`, `map_comp`, `map_comp_apply` and `map_of_apply`
are about `free_abelian_group.map`.

-/


universe u v

variable (α : Type u)

#print FreeAbelianGroup /-
/-- The free abelian group on a type. -/
def FreeAbelianGroup : Type u :=
  Additive <| Abelianization <| FreeGroup α
#align free_abelian_group FreeAbelianGroup
-/

instance : AddCommGroup (FreeAbelianGroup α) :=
  @Additive.addCommGroup _ <| Abelianization.commGroup _

instance : Inhabited (FreeAbelianGroup α) :=
  ⟨0⟩

variable {α}

namespace FreeAbelianGroup

#print FreeAbelianGroup.of /-
/-- The canonical map from α to `free_abelian_group α` -/
def of (x : α) : FreeAbelianGroup α :=
  Abelianization.of <| FreeGroup.of x
#align free_abelian_group.of FreeAbelianGroup.of
-/

#print FreeAbelianGroup.lift /-
/-- The map `free_abelian_group α →+ A` induced by a map of types `α → A`. -/
def lift {β : Type v} [AddCommGroup β] : (α → β) ≃ (FreeAbelianGroup α →+ β) :=
  (@FreeGroup.lift _ (Multiplicative β) _).trans <|
    (@Abelianization.lift _ _ (Multiplicative β) _).trans MonoidHom.toAdditive
#align free_abelian_group.lift FreeAbelianGroup.lift
-/

namespace lift

variable {β : Type v} [AddCommGroup β] (f : α → β)

open FreeAbelianGroup

/- warning: free_abelian_group.lift.of -> FreeAbelianGroup.lift.of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : AddCommGroup.{u2} β] (f : α -> β) (x : α), Eq.{succ u2} β (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) => (α -> β) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_1) f) (FreeAbelianGroup.of.{u1} α x)) (f x)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : AddCommGroup.{u2} β] (f : α -> β) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) (FreeAbelianGroup.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) f) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) f) (FreeAbelianGroup.{u1} α) β (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) f) (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_1) f) (FreeAbelianGroup.of.{u1} α x)) (f x)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift.of FreeAbelianGroup.lift.ofₓ'. -/
@[simp]
protected theorem of (x : α) : lift f (of x) = f x :=
  by
  convert @Abelianization.lift.of (FreeGroup α) _ (Multiplicative β) _ _ _
  convert free_group.lift.of.symm
#align free_abelian_group.lift.of FreeAbelianGroup.lift.of

/- warning: free_abelian_group.lift.unique -> FreeAbelianGroup.lift.unique is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : AddCommGroup.{u2} β] (f : α -> β) (g : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))), (forall (x : α), Eq.{succ u2} β (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) g (FreeAbelianGroup.of.{u1} α x)) (f x)) -> (forall {x : FreeAbelianGroup.{u1} α}, Eq.{succ u2} β (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) g x) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) => (α -> β) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_1) f) x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : AddCommGroup.{u2} β] (f : α -> β) (g : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))), (forall (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) (FreeAbelianGroup.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) β (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))))) g (FreeAbelianGroup.of.{u1} α x)) (f x)) -> (forall {x : FreeAbelianGroup.{u1} α}, Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) β (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))))) g x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) f) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) f) (FreeAbelianGroup.{u1} α) β (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) f) (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_1) f) x))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift.unique FreeAbelianGroup.lift.uniqueₓ'. -/
protected theorem unique (g : FreeAbelianGroup α →+ β) (hg : ∀ x, g (of x) = f x) {x} :
    g x = lift f x :=
  AddMonoidHom.congr_fun (lift.symm_apply_eq.mp (funext hg : g ∘ of = f)) _
#align free_abelian_group.lift.unique FreeAbelianGroup.lift.unique

/- warning: free_abelian_group.lift.ext -> FreeAbelianGroup.lift.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : AddCommGroup.{u2} β] (g : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (h : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))), (forall (x : α), Eq.{succ u2} β (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) g (FreeAbelianGroup.of.{u1} α x)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) h (FreeAbelianGroup.of.{u1} α x))) -> (Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) g h)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : AddCommGroup.{u2} β] (g : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (h : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))), (forall (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) (FreeAbelianGroup.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) β (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))))) g (FreeAbelianGroup.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) β (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))))) h (FreeAbelianGroup.of.{u1} α x))) -> (Eq.{max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) g h)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift.ext FreeAbelianGroup.lift.extₓ'. -/
/-- See note [partially-applied ext lemmas]. -/
@[ext]
protected theorem ext (g h : FreeAbelianGroup α →+ β) (H : ∀ x, g (of x) = h (of x)) : g = h :=
  lift.symm.Injective <| funext H
#align free_abelian_group.lift.ext FreeAbelianGroup.lift.ext

/- warning: free_abelian_group.lift.map_hom -> FreeAbelianGroup.lift.map_hom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_2 : AddCommGroup.{u2} β] [_inst_3 : AddCommGroup.{u3} γ] (a : FreeAbelianGroup.{u1} α) (f : α -> β) (g : AddMonoidHom.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))), Eq.{succ u3} γ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))) (fun (_x : AddMonoidHom.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))) => β -> γ) (AddMonoidHom.hasCoeToFun.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))) g (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))))) => (α -> β) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_2) f) a)) (coeFn.{max (succ u3) (succ u1), max (succ u1) (succ u3)} (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))) (fun (_x : AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))) => (FreeAbelianGroup.{u1} α) -> γ) (AddMonoidHom.hasCoeToFun.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))) (coeFn.{max 1 (max (max (succ u1) (succ u3)) (succ u3) (succ u1)) (max (succ u3) (succ u1)) (succ u1) (succ u3), max (max (succ u1) (succ u3)) (succ u3) (succ u1)} (Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> γ) (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3)))))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> γ) (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3)))))) => (α -> γ) -> (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> γ) (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3)))))) (FreeAbelianGroup.lift.{u1, u3} α γ _inst_3) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))) (fun (_x : AddMonoidHom.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))) => β -> γ) (AddMonoidHom.hasCoeToFun.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_3))))) g) f)) a)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_2 : AddCommGroup.{u2} β] [_inst_3 : AddCommGroup.{u1} γ] (a : FreeAbelianGroup.{u3} α) (f : α -> β) (g : AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β) => γ) (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) f) (FreeAbelianGroup.{u3} α) (fun (a : FreeAbelianGroup.{u3} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u3} α) => β) a) (AddHomClass.toFunLike.{max u2 u3, u3, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) f) (FreeAbelianGroup.{u3} α) β (AddZeroClass.toAdd.{u3} (FreeAbelianGroup.{u3} α) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α)))))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) f) (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoidHom.addMonoidHomClass.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))))) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (α -> β) (AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))))) (α -> β) (fun (a : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) a) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (α -> β) (AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))))) (FreeAbelianGroup.lift.{u3, u2} α β _inst_2) f) a)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β) => γ) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))))) g (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) f) (FreeAbelianGroup.{u3} α) (fun (_x : FreeAbelianGroup.{u3} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u3} α) => β) _x) (AddHomClass.toFunLike.{max u2 u3, u3, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) f) (FreeAbelianGroup.{u3} α) β (AddZeroClass.toAdd.{u3} (FreeAbelianGroup.{u3} α) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α)))))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) f) (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoidHom.addMonoidHomClass.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))))) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (α -> β) (AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))))) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (α -> β) (AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) β (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))))) (FreeAbelianGroup.lift.{u3, u2} α β _inst_2) f) a)) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> γ) => AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) (Function.comp.{succ u3, succ u2, succ u1} α β γ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β (fun (a : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β) => γ) a) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))))) g) f)) (FreeAbelianGroup.{u3} α) (fun (_x : FreeAbelianGroup.{u3} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u3} α) => γ) _x) (AddHomClass.toFunLike.{max u1 u3, u3, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> γ) => AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) (Function.comp.{succ u3, succ u2, succ u1} α β γ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β (fun (a : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β) => γ) a) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))))) g) f)) (FreeAbelianGroup.{u3} α) γ (AddZeroClass.toAdd.{u3} (FreeAbelianGroup.{u3} α) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α)))))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> γ) => AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) (Function.comp.{succ u3, succ u2, succ u1} α β γ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β (fun (a : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β) => γ) a) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))))) g) f)) (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))))) (FunLike.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u3) (succ u1), max (succ u1) (succ u3)} (α -> γ) (AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3)))))) (α -> γ) (fun (_x : α -> γ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> γ) => AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (α -> γ) (AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3)))))) (FreeAbelianGroup.lift.{u3, u1} α γ _inst_3) (Function.comp.{succ u3, succ u2, succ u1} α β γ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β) => γ) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2))))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))) β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} β γ (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_2)))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_3))))))) g) f)) a)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift.map_hom FreeAbelianGroup.lift.map_homₓ'. -/
theorem map_hom {α β γ} [AddCommGroup β] [AddCommGroup γ] (a : FreeAbelianGroup α) (f : α → β)
    (g : β →+ γ) : g (lift f a) = lift (g ∘ f) a :=
  by
  suffices : (g.comp (lift f)) a = lift (g ∘ f) a
  exact this
  apply @lift.unique
  intro a
  show g ((lift f) (of a)) = g (f a)
  simp only [(· ∘ ·), lift.of]
#align free_abelian_group.lift.map_hom FreeAbelianGroup.lift.map_hom

end lift

section

open Classical

#print FreeAbelianGroup.of_injective /-
theorem of_injective : Function.Injective (of : α → FreeAbelianGroup α) := fun x y hoxy =>
  by_contradiction fun hxy : x ≠ y =>
    let f : FreeAbelianGroup α →+ ℤ := lift fun z => if x = z then (1 : ℤ) else 0
    have hfx1 : f (of x) = 1 := (lift.of _ _).trans <| if_pos rfl
    have hfy1 : f (of y) = 1 := hoxy ▸ hfx1
    have hfy0 : f (of y) = 0 := (lift.of _ _).trans <| if_neg hxy
    one_ne_zero <| hfy1.symm.trans hfy0
#align free_abelian_group.of_injective FreeAbelianGroup.of_injective
-/

end

attribute [local instance] QuotientGroup.leftRel

/- warning: free_abelian_group.induction_on -> FreeAbelianGroup.induction_on is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {C : (FreeAbelianGroup.{u1} α) -> Prop} (z : FreeAbelianGroup.{u1} α), (C (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))))) -> (forall (x : α), C (FreeAbelianGroup.of.{u1} α x)) -> (forall (x : α), (C (FreeAbelianGroup.of.{u1} α x)) -> (C (Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))) (FreeAbelianGroup.of.{u1} α x)))) -> (forall (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), (C x) -> (C y) -> (C (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y))) -> (C z)
but is expected to have type
  forall {α : Type.{u1}} {C : (FreeAbelianGroup.{u1} α) -> Prop} (z : FreeAbelianGroup.{u1} α), (C (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))))) -> (forall (x : α), C (FreeAbelianGroup.of.{u1} α x)) -> (forall (x : α), (C (FreeAbelianGroup.of.{u1} α x)) -> (C (Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (FreeAbelianGroup.of.{u1} α x)))) -> (forall (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), (C x) -> (C y) -> (C (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y))) -> (C z)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.induction_on FreeAbelianGroup.induction_onₓ'. -/
@[elab_as_elim]
protected theorem induction_on {C : FreeAbelianGroup α → Prop} (z : FreeAbelianGroup α) (C0 : C 0)
    (C1 : ∀ x, C <| of x) (Cn : ∀ x, C (of x) → C (-of x)) (Cp : ∀ x y, C x → C y → C (x + y)) :
    C z :=
  Quotient.inductionOn' z fun x =>
    Quot.inductionOn x fun L =>
      List.recOn L C0 fun ⟨x, b⟩ tl ih => Bool.recOn b (Cp _ _ (Cn _ (C1 x)) ih) (Cp _ _ (C1 x) ih)
#align free_abelian_group.induction_on FreeAbelianGroup.induction_on

/- warning: free_abelian_group.lift.add' -> FreeAbelianGroup.lift.add' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : AddCommGroup.{u2} β] (a : FreeAbelianGroup.{u1} α) (f : α -> β) (g : α -> β), Eq.{succ u2} β (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) => (α -> β) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_1) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHAdd.{max u1 u2} (α -> β) (Pi.instAdd.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))))) f g)) a) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) => (α -> β) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_1) f) a) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) => (FreeAbelianGroup.{u1} α) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) => (α -> β) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_1) g) a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : AddCommGroup.{u1} β] (a : FreeAbelianGroup.{u2} α) (f : α -> β) (g : α -> β), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHAdd.{max u1 u2} (α -> β) (Pi.instAdd.{u2, u1} α (fun (a._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.751 : α) => β) (fun (i : α) => AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))))) f g)) (FreeAbelianGroup.{u2} α) (fun (_x : FreeAbelianGroup.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHAdd.{max u1 u2} (α -> β) (Pi.instAdd.{u2, u1} α (fun (a._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.751 : α) => β) (fun (i : α) => AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))))) f g)) (FreeAbelianGroup.{u2} α) β (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} α) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α)))))) (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHAdd.{max u1 u2} (α -> β) (Pi.instAdd.{u2, u1} α (fun (a._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.751 : α) => β) (fun (i : α) => AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))))) f g)) (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (FreeAbelianGroup.lift.{u2, u1} α β _inst_1) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHAdd.{max u1 u2} (α -> β) (Pi.instAdd.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))))) f g)) a) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) (AddZeroClass.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) a) _inst_1)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) f) (FreeAbelianGroup.{u2} α) (fun (_x : FreeAbelianGroup.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) f) (FreeAbelianGroup.{u2} α) β (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} α) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α)))))) (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) f) (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (FreeAbelianGroup.lift.{u2, u1} α β _inst_1) f) a) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) g) (FreeAbelianGroup.{u2} α) (fun (_x : FreeAbelianGroup.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) g) (FreeAbelianGroup.{u2} α) β (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} α) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α)))))) (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) g) (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (FreeAbelianGroup.lift.{u2, u1} α β _inst_1) g) a))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift.add' FreeAbelianGroup.lift.add'ₓ'. -/
theorem lift.add' {α β} [AddCommGroup β] (a : FreeAbelianGroup α) (f g : α → β) :
    lift (f + g) a = lift f a + lift g a :=
  by
  refine' FreeAbelianGroup.induction_on a _ _ _ _
  · simp only [(lift _).map_zero, zero_add]
  · intro x
    simp only [lift.of, Pi.add_apply]
  · intro x h
    simp only [map_neg, lift.of, Pi.add_apply, neg_add]
  · intro x y hx hy
    simp only [(lift _).map_add, hx, hy, add_add_add_comm]
#align free_abelian_group.lift.add' FreeAbelianGroup.lift.add'

#print FreeAbelianGroup.liftAddGroupHom /-
/-- If `g : free_abelian_group X` and `A` is an abelian group then `lift_add_group_hom g`
is the additive group homomorphism sending a function `X → A` to the term of type `A`
corresponding to the evaluation of the induced map `free_abelian_group X → A` at `g`. -/
@[simps]
def liftAddGroupHom {α} (β) [AddCommGroup β] (a : FreeAbelianGroup α) : (α → β) →+ β :=
  AddMonoidHom.mk' (fun f => lift f a) (lift.add' a)
#align free_abelian_group.lift_add_group_hom FreeAbelianGroup.liftAddGroupHom
-/

/- warning: free_abelian_group.lift_neg' -> FreeAbelianGroup.lift_neg' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : AddCommGroup.{u2} β] (f : α -> β), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) => (α -> β) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_1) (Neg.neg.{max u1 u2} (α -> β) (Pi.instNeg.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))) f)) (Neg.neg.{max u2 u1} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1))))) (AddMonoidHom.hasNeg.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) _inst_1) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) => (α -> β) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> β) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) β (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β _inst_1)))))) (FreeAbelianGroup.lift.{u1, u2} α β _inst_1) f))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : AddCommGroup.{u1} β] (f : α -> β), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) (Neg.neg.{max u2 u1} (α -> β) (Pi.instNeg.{u2, u1} α (fun (a._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.876 : α) => β) (fun (i : α) => NegZeroClass.toNeg.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β _inst_1)))))) f)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (FreeAbelianGroup.lift.{u2, u1} α β _inst_1) (Neg.neg.{max u2 u1} (α -> β) (Pi.instNeg.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => NegZeroClass.toNeg.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β _inst_1)))))) f)) (Neg.neg.{max u2 u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) f) (AddMonoidHom.instNegAddMonoidHomToAddZeroClassToAddMonoidToSubNegAddMonoidToAddGroup.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) _inst_1) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (α -> β) (fun (_x : α -> β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> β) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> β) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) β (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (AddCommGroup.toAddGroup.{u1} β _inst_1)))))) (FreeAbelianGroup.lift.{u2, u1} α β _inst_1) f))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift_neg' FreeAbelianGroup.lift_neg'ₓ'. -/
theorem lift_neg' {β} [AddCommGroup β] (f : α → β) : lift (-f) = -lift f :=
  AddMonoidHom.ext fun _ => (liftAddGroupHom _ _ : (α → β) →+ β).map_neg _
#align free_abelian_group.lift_neg' FreeAbelianGroup.lift_neg'

section Monad

variable {β : Type u}

instance : Monad FreeAbelianGroup.{u} where
  pure α := of
  bind α β x f := lift f x

/- warning: free_abelian_group.induction_on' -> FreeAbelianGroup.induction_on' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {C : (FreeAbelianGroup.{u1} α) -> Prop} (z : FreeAbelianGroup.{u1} α), (C (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))))) -> (forall (x : α), C (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α x)) -> (forall (x : α), (C (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α x)) -> (C (Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))) (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α x)))) -> (forall (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), (C x) -> (C y) -> (C (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y))) -> (C z)
but is expected to have type
  forall {α : Type.{u1}} {C : (FreeAbelianGroup.{u1} α) -> Prop} (z : FreeAbelianGroup.{u1} α), (C (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))))) -> (forall (x : α), C (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α x)) -> (forall (x : α), (C (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α x)) -> (C (Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α x)))) -> (forall (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), (C x) -> (C y) -> (C (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y))) -> (C z)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.induction_on' FreeAbelianGroup.induction_on'ₓ'. -/
@[elab_as_elim]
protected theorem induction_on' {C : FreeAbelianGroup α → Prop} (z : FreeAbelianGroup α) (C0 : C 0)
    (C1 : ∀ x, C <| pure x) (Cn : ∀ x, C (pure x) → C (-pure x))
    (Cp : ∀ x y, C x → C y → C (x + y)) : C z :=
  FreeAbelianGroup.induction_on z C0 C1 Cn Cp
#align free_abelian_group.induction_on' FreeAbelianGroup.induction_on'

/- warning: free_abelian_group.map_pure -> FreeAbelianGroup.map_pure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Applicative.toFunctor.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Monad.toApplicative.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) FreeAbelianGroup.monad.{u1})) α β f (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α x)) (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) β (f x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α x)) (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) β (f x))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.map_pure FreeAbelianGroup.map_pureₓ'. -/
@[simp]
theorem map_pure (f : α → β) (x : α) : f <$> (pure x : FreeAbelianGroup α) = pure (f x) :=
  rfl
#align free_abelian_group.map_pure FreeAbelianGroup.map_pure

/- warning: free_abelian_group.map_zero -> FreeAbelianGroup.map_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Applicative.toFunctor.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Monad.toApplicative.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) FreeAbelianGroup.monad.{u1})) α β f (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))))) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} β) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} β) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))))) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} β) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} β) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} β) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} β) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.map_zero FreeAbelianGroup.map_zeroₓ'. -/
@[simp]
protected theorem map_zero (f : α → β) : f <$> (0 : FreeAbelianGroup α) = 0 :=
  (lift (of ∘ f)).map_zero
#align free_abelian_group.map_zero FreeAbelianGroup.map_zero

/- warning: free_abelian_group.map_add -> FreeAbelianGroup.map_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Applicative.toFunctor.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Monad.toApplicative.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) FreeAbelianGroup.monad.{u1})) α β f (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y)) (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHAdd.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f y))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y)) (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHAdd.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f x) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f y))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.map_add FreeAbelianGroup.map_addₓ'. -/
@[simp]
protected theorem map_add (f : α → β) (x y : FreeAbelianGroup α) :
    f <$> (x + y) = f <$> x + f <$> y :=
  (lift _).map_add _ _
#align free_abelian_group.map_add FreeAbelianGroup.map_add

/- warning: free_abelian_group.map_neg -> FreeAbelianGroup.map_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Applicative.toFunctor.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Monad.toApplicative.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) FreeAbelianGroup.monad.{u1})) α β f (Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))) x)) (Neg.neg.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) x)) (Neg.neg.{u1} (FreeAbelianGroup.{u1} β) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} β) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} β) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))))) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f x))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.map_neg FreeAbelianGroup.map_negₓ'. -/
@[simp]
protected theorem map_neg (f : α → β) (x : FreeAbelianGroup α) : f <$> (-x) = -f <$> x :=
  map_neg (lift <| of ∘ f) _
#align free_abelian_group.map_neg FreeAbelianGroup.map_neg

/- warning: free_abelian_group.map_sub -> FreeAbelianGroup.map_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Applicative.toFunctor.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Monad.toApplicative.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) FreeAbelianGroup.monad.{u1})) α β f (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHSub.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toHasSub.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) x y)) (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHSub.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toHasSub.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f y))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHSub.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toSub.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) x y)) (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHSub.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toSub.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f x) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f y))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.map_sub FreeAbelianGroup.map_subₓ'. -/
@[simp]
protected theorem map_sub (f : α → β) (x y : FreeAbelianGroup α) :
    f <$> (x - y) = f <$> x - f <$> y :=
  map_sub (lift <| of ∘ f) _ _
#align free_abelian_group.map_sub FreeAbelianGroup.map_sub

/- warning: free_abelian_group.map_of -> FreeAbelianGroup.map_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (y : α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f (FreeAbelianGroup.of.{u1} α y)) (FreeAbelianGroup.of.{u1} β (f y))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (y : α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (FreeAbelianGroup.of.{u1} α y)) (FreeAbelianGroup.of.{u1} β (f y))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.map_of FreeAbelianGroup.map_ofₓ'. -/
@[simp]
theorem map_of (f : α → β) (y : α) : f <$> of y = of (f y) :=
  rfl
#align free_abelian_group.map_of FreeAbelianGroup.map_of

/- warning: free_abelian_group.pure_bind -> FreeAbelianGroup.pure_bind is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)) (x : α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α x) f) (f x)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)) (x : α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α x) f) (f x)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.pure_bind FreeAbelianGroup.pure_bindₓ'. -/
@[simp]
theorem pure_bind (f : α → FreeAbelianGroup β) (x) : pure x >>= f = f x :=
  lift.of _ _
#align free_abelian_group.pure_bind FreeAbelianGroup.pure_bind

/- warning: free_abelian_group.zero_bind -> FreeAbelianGroup.zero_bind is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))))) f) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} β) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} β) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))) f) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} β) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} β) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} β) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} β) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.zero_bind FreeAbelianGroup.zero_bindₓ'. -/
@[simp]
theorem zero_bind (f : α → FreeAbelianGroup β) : 0 >>= f = 0 :=
  (lift f).map_zero
#align free_abelian_group.zero_bind FreeAbelianGroup.zero_bind

/- warning: free_abelian_group.add_bind -> FreeAbelianGroup.add_bind is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y) f) (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHAdd.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β x f) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β y f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y) f) (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHAdd.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β x f) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β y f))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.add_bind FreeAbelianGroup.add_bindₓ'. -/
@[simp]
theorem add_bind (f : α → FreeAbelianGroup β) (x y : FreeAbelianGroup α) :
    x + y >>= f = (x >>= f) + (y >>= f) :=
  (lift _).map_add _ _
#align free_abelian_group.add_bind FreeAbelianGroup.add_bind

/- warning: free_abelian_group.neg_bind -> FreeAbelianGroup.neg_bind is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β (Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))) x) f) (Neg.neg.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β x f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β (Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) x) f) (Neg.neg.{u1} (FreeAbelianGroup.{u1} β) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} β) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} β) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))))) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β x f))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.neg_bind FreeAbelianGroup.neg_bindₓ'. -/
@[simp]
theorem neg_bind (f : α → FreeAbelianGroup β) (x : FreeAbelianGroup α) : -x >>= f = -(x >>= f) :=
  map_neg (lift f) _
#align free_abelian_group.neg_bind FreeAbelianGroup.neg_bind

/- warning: free_abelian_group.sub_bind -> FreeAbelianGroup.sub_bind is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHSub.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toHasSub.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) x y) f) (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHSub.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toHasSub.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β x f) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toHasBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1}) α β y f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> (FreeAbelianGroup.{u1} β)) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHSub.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toSub.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) x y) f) (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHSub.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toSub.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β x f) (Bind.bind.{u1, u1} FreeAbelianGroup.{u1} (Monad.toBind.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1}) α β y f))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.sub_bind FreeAbelianGroup.sub_bindₓ'. -/
@[simp]
theorem sub_bind (f : α → FreeAbelianGroup β) (x y : FreeAbelianGroup α) :
    x - y >>= f = (x >>= f) - (y >>= f) :=
  map_sub (lift f) _ _
#align free_abelian_group.sub_bind FreeAbelianGroup.sub_bind

/- warning: free_abelian_group.pure_seq -> FreeAbelianGroup.pure_seq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Applicative.toHasSeq.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Monad.toApplicative.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) FreeAbelianGroup.monad.{u1})) α β (Pure.pure.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Applicative.toHasPure.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) (Monad.toApplicative.{u1, u1} (fun {α : Type.{u1}} => FreeAbelianGroup.{u1} α) FreeAbelianGroup.monad.{u1})) (α -> β) f) x) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β (Pure.pure.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toPure.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) (α -> β) f) (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1634 : Unit) => x)) (Functor.map.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toFunctor.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f x)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.pure_seq FreeAbelianGroup.pure_seqₓ'. -/
@[simp]
theorem pure_seq (f : α → β) (x : FreeAbelianGroup α) : pure f <*> x = f <$> x :=
  pure_bind _ _
#align free_abelian_group.pure_seq FreeAbelianGroup.pure_seq

/- warning: free_abelian_group.zero_seq -> FreeAbelianGroup.zero_seq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} (α -> β)) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} (α -> β)) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.addCommGroup.{u1} (α -> β)))))))))) x) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} β) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} β) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} (α -> β)) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} (α -> β)) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.addCommGroup.{u1} (α -> β))))))))) (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1668 : Unit) => x)) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} β) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} β) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} β) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} β) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.zero_seq FreeAbelianGroup.zero_seqₓ'. -/
@[simp]
theorem zero_seq (x : FreeAbelianGroup α) : (0 : FreeAbelianGroup (α → β)) <*> x = 0 :=
  zero_bind _
#align free_abelian_group.zero_seq FreeAbelianGroup.zero_seq

/- warning: free_abelian_group.add_seq -> FreeAbelianGroup.add_seq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (g : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.{u1} (α -> β)) (instHAdd.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.addCommGroup.{u1} (α -> β)))))))) f g) x) (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHAdd.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β g x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (g : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.{u1} (α -> β)) (instHAdd.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.addCommGroup.{u1} (α -> β)))))))) f g) (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1706 : Unit) => x)) (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHAdd.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1717 : Unit) => x)) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β g (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1727 : Unit) => x)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.add_seq FreeAbelianGroup.add_seqₓ'. -/
@[simp]
theorem add_seq (f g : FreeAbelianGroup (α → β)) (x : FreeAbelianGroup α) :
    f + g <*> x = (f <*> x) + (g <*> x) :=
  add_bind _ _ _
#align free_abelian_group.add_seq FreeAbelianGroup.add_seq

/- warning: free_abelian_group.neg_seq -> FreeAbelianGroup.neg_seq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β (Neg.neg.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.addCommGroup.{u1} (α -> β))))) f) x) (Neg.neg.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β (Neg.neg.{u1} (FreeAbelianGroup.{u1} (α -> β)) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.addCommGroup.{u1} (α -> β))))))) f) (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1759 : Unit) => x)) (Neg.neg.{u1} (FreeAbelianGroup.{u1} β) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} β) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} β) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1770 : Unit) => x)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.neg_seq FreeAbelianGroup.neg_seqₓ'. -/
@[simp]
theorem neg_seq (f : FreeAbelianGroup (α → β)) (x : FreeAbelianGroup α) : -f <*> x = -(f <*> x) :=
  neg_bind _ _
#align free_abelian_group.neg_seq FreeAbelianGroup.neg_seq

/- warning: free_abelian_group.sub_seq -> FreeAbelianGroup.sub_seq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (g : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.{u1} (α -> β)) (instHSub.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubNegMonoid.toHasSub.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.addCommGroup.{u1} (α -> β)))))) f g) x) (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHSub.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toHasSub.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β g x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (g : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.{u1} (α -> β)) (instHSub.{u1} (FreeAbelianGroup.{u1} (α -> β)) (SubNegMonoid.toSub.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} (α -> β)) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} (α -> β)) (FreeAbelianGroup.addCommGroup.{u1} (α -> β)))))) f g) (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1808 : Unit) => x)) (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHSub.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toSub.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1819 : Unit) => x)) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β g (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1829 : Unit) => x)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.sub_seq FreeAbelianGroup.sub_seqₓ'. -/
@[simp]
theorem sub_seq (f g : FreeAbelianGroup (α → β)) (x : FreeAbelianGroup α) :
    f - g <*> x = (f <*> x) - (g <*> x) :=
  sub_bind _ _ _
#align free_abelian_group.sub_seq FreeAbelianGroup.sub_seq

#print FreeAbelianGroup.seqAddGroupHom /-
/-- If `f : free_abelian_group (α → β)`, then `f <*>` is an additive morphism
`free_abelian_group α →+ free_abelian_group β`. -/
def seqAddGroupHom (f : FreeAbelianGroup (α → β)) : FreeAbelianGroup α →+ FreeAbelianGroup β :=
  AddMonoidHom.mk' ((· <*> ·) f) fun x y =>
    show lift (· <$> (x + y)) _ = _
      by
      simp only [FreeAbelianGroup.map_add]
      exact lift.add' f _ _
#align free_abelian_group.seq_add_group_hom FreeAbelianGroup.seqAddGroupHom
-/

/- warning: free_abelian_group.seq_zero -> FreeAbelianGroup.seq_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))))) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} β) 0 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} β) 0 (Zero.zero.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toHasZero.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.1978 : Unit) => OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))))) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} β) 0 (Zero.toOfNat0.{u1} (FreeAbelianGroup.{u1} β) (NegZeroClass.toZero.{u1} (FreeAbelianGroup.{u1} β) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} β) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.seq_zero FreeAbelianGroup.seq_zeroₓ'. -/
@[simp]
theorem seq_zero (f : FreeAbelianGroup (α → β)) : f <*> 0 = 0 :=
  (seqAddGroupHom f).map_zero
#align free_abelian_group.seq_zero FreeAbelianGroup.seq_zero

/- warning: free_abelian_group.seq_add -> FreeAbelianGroup.seq_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y)) (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHAdd.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f y))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.2011 : Unit) => HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHAdd.{u1} (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) x y)) (HAdd.hAdd.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHAdd.{u1} (FreeAbelianGroup.{u1} β) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.2026 : Unit) => x)) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.2036 : Unit) => y)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.seq_add FreeAbelianGroup.seq_addₓ'. -/
@[simp]
theorem seq_add (f : FreeAbelianGroup (α → β)) (x y : FreeAbelianGroup α) :
    f <*> x + y = (f <*> x) + (f <*> y) :=
  (seqAddGroupHom f).map_add x y
#align free_abelian_group.seq_add FreeAbelianGroup.seq_add

/- warning: free_abelian_group.seq_neg -> FreeAbelianGroup.seq_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f (Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))) x)) (Neg.neg.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toHasNeg.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.2068 : Unit) => Neg.neg.{u1} (FreeAbelianGroup.{u1} α) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} α) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} α) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) x)) (Neg.neg.{u1} (FreeAbelianGroup.{u1} β) (NegZeroClass.toNeg.{u1} (FreeAbelianGroup.{u1} β) (SubNegZeroMonoid.toNegZeroClass.{u1} (FreeAbelianGroup.{u1} β) (SubtractionMonoid.toSubNegZeroMonoid.{u1} (FreeAbelianGroup.{u1} β) (SubtractionCommMonoid.toSubtractionMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toDivisionAddCommMonoid.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β)))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.2082 : Unit) => x)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.seq_neg FreeAbelianGroup.seq_negₓ'. -/
@[simp]
theorem seq_neg (f : FreeAbelianGroup (α → β)) (x : FreeAbelianGroup α) : f <*> -x = -(f <*> x) :=
  (seqAddGroupHom f).map_neg x
#align free_abelian_group.seq_neg FreeAbelianGroup.seq_neg

/- warning: free_abelian_group.seq_sub -> FreeAbelianGroup.seq_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHSub.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toHasSub.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) x y)) (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHSub.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toHasSub.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f x) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toHasSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.monad.{u1})) α β f y))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u1}} (f : FreeAbelianGroup.{u1} (α -> β)) (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} β) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.2115 : Unit) => HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHSub.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toSub.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) x y)) (HSub.hSub.{u1, u1, u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.{u1} β) (instHSub.{u1} (FreeAbelianGroup.{u1} β) (SubNegMonoid.toSub.{u1} (FreeAbelianGroup.{u1} β) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} β) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} β) (FreeAbelianGroup.addCommGroup.{u1} β))))) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.2130 : Unit) => x)) (Seq.seq.{u1, u1} FreeAbelianGroup.{u1} (Applicative.toSeq.{u1, u1} FreeAbelianGroup.{u1} (Monad.toApplicative.{u1, u1} FreeAbelianGroup.{u1} FreeAbelianGroup.instMonadFreeAbelianGroup.{u1})) α β f (fun (x._@.Mathlib.GroupTheory.FreeAbelianGroup._hyg.2140 : Unit) => y)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.seq_sub FreeAbelianGroup.seq_subₓ'. -/
@[simp]
theorem seq_sub (f : FreeAbelianGroup (α → β)) (x y : FreeAbelianGroup α) :
    f <*> x - y = (f <*> x) - (f <*> y) :=
  (seqAddGroupHom f).map_sub x y
#align free_abelian_group.seq_sub FreeAbelianGroup.seq_sub

instance : LawfulMonad FreeAbelianGroup.{u}
    where
  id_map α x :=
    FreeAbelianGroup.induction_on' x (FreeAbelianGroup.map_zero id) (map_pure id)
      (fun x ih => by rw [FreeAbelianGroup.map_neg, ih]) fun x y ihx ihy => by
      rw [FreeAbelianGroup.map_add, ihx, ihy]
  pure_bind α β x f := pure_bind f x
  bind_assoc α β γ x f g :=
    FreeAbelianGroup.induction_on' x (by iterate 3 rw [zero_bind])
      (fun x => by iterate 2 rw [pure_bind]) (fun x ih => by iterate 3 rw [neg_bind] <;> rw [ih])
      fun x y ihx ihy => by iterate 3 rw [add_bind] <;> rw [ihx, ihy]

instance : CommApplicative FreeAbelianGroup.{u}
    where commutative_prod α β x y :=
    FreeAbelianGroup.induction_on' x (by rw [FreeAbelianGroup.map_zero, zero_seq, seq_zero])
      (fun p => by
        rw [map_pure, pure_seq] <;>
          exact
            FreeAbelianGroup.induction_on' y
              (by rw [FreeAbelianGroup.map_zero, FreeAbelianGroup.map_zero, zero_seq])
              (fun q => by rw [map_pure, map_pure, pure_seq, map_pure])
              (fun q ih => by rw [FreeAbelianGroup.map_neg, FreeAbelianGroup.map_neg, neg_seq, ih])
              fun y₁ y₂ ih1 ih2 => by
              rw [FreeAbelianGroup.map_add, FreeAbelianGroup.map_add, add_seq, ih1, ih2])
      (fun p ih => by rw [FreeAbelianGroup.map_neg, neg_seq, seq_neg, ih]) fun x₁ x₂ ih1 ih2 => by
      rw [FreeAbelianGroup.map_add, add_seq, seq_add, ih1, ih2]

end Monad

universe w

variable {β : Type v} {γ : Type w}

#print FreeAbelianGroup.map /-
/-- The additive group homomorphism `free_abelian_group α →+ free_abelian_group β` induced from a
  map `α → β` -/
def map (f : α → β) : FreeAbelianGroup α →+ FreeAbelianGroup β :=
  lift (of ∘ f)
#align free_abelian_group.map FreeAbelianGroup.map
-/

/- warning: free_abelian_group.lift_comp -> FreeAbelianGroup.lift_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : AddCommGroup.{u3} γ] (f : α -> β) (g : β -> γ) (x : FreeAbelianGroup.{u1} α), Eq.{succ u3} γ (coeFn.{max (succ u3) (succ u1), max (succ u1) (succ u3)} (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1))))) (fun (_x : AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1))))) => (FreeAbelianGroup.{u1} α) -> γ) (AddMonoidHom.hasCoeToFun.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1))))) (coeFn.{max 1 (max (max (succ u1) (succ u3)) (succ u3) (succ u1)) (max (succ u3) (succ u1)) (succ u1) (succ u3), max (max (succ u1) (succ u3)) (succ u3) (succ u1)} (Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> γ) (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1)))))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> γ) (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1)))))) => (α -> γ) -> (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> γ) (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) γ (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1)))))) (FreeAbelianGroup.lift.{u1, u3} α γ _inst_1) (Function.comp.{succ u1, succ u2, succ u3} α β γ g f)) x) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1))))) (fun (_x : AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1))))) => (FreeAbelianGroup.{u2} β) -> γ) (AddMonoidHom.hasCoeToFun.{u2, u3} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1))))) (coeFn.{max 1 (max (max (succ u2) (succ u3)) (succ u3) (succ u2)) (max (succ u3) (succ u2)) (succ u2) (succ u3), max (max (succ u2) (succ u3)) (succ u3) (succ u2)} (Equiv.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (β -> γ) (AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1)))))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (β -> γ) (AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1)))))) => (β -> γ) -> (AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1)))))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (β -> γ) (AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} γ (SubNegMonoid.toAddMonoid.{u3} γ (AddGroup.toSubNegMonoid.{u3} γ (AddCommGroup.toAddGroup.{u3} γ _inst_1)))))) (FreeAbelianGroup.lift.{u2, u3} β γ _inst_1) g) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) => (FreeAbelianGroup.{u1} α) -> (FreeAbelianGroup.{u2} β)) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.map.{u1, u2} α β f) x))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : AddCommGroup.{u1} γ] (f : α -> β) (g : β -> γ) (x : FreeAbelianGroup.{u3} α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u3} α) => γ) x) (FunLike.coe.{max (succ u1) (succ u3), succ u3, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> γ) => AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) (Function.comp.{succ u3, succ u2, succ u1} α β γ g f)) (FreeAbelianGroup.{u3} α) (fun (_x : FreeAbelianGroup.{u3} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u3} α) => γ) _x) (AddHomClass.toFunLike.{max u1 u3, u3, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> γ) => AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) (Function.comp.{succ u3, succ u2, succ u1} α β γ g f)) (FreeAbelianGroup.{u3} α) γ (AddZeroClass.toAdd.{u3} (FreeAbelianGroup.{u3} α) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α)))))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> γ) => AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) (Function.comp.{succ u3, succ u2, succ u1} α β γ g f)) (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))))) (FunLike.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u3) (succ u1), max (succ u1) (succ u3)} (α -> γ) (AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1)))))) (α -> γ) (fun (_x : α -> γ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> γ) => AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (α -> γ) (AddMonoidHom.{u3, u1} (FreeAbelianGroup.{u3} α) γ (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1)))))) (FreeAbelianGroup.lift.{u3, u1} α γ _inst_1) (Function.comp.{succ u3, succ u2, succ u1} α β γ g f)) x) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : β -> γ) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) g) (FreeAbelianGroup.{u2} β) (fun (_x : FreeAbelianGroup.{u2} β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} β) => γ) _x) (AddHomClass.toFunLike.{max u1 u2, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : β -> γ) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) g) (FreeAbelianGroup.{u2} β) γ (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (AddZeroClass.toAdd.{u1} γ (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : β -> γ) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) g) (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1)))) (AddMonoidHom.addMonoidHomClass.{u2, u1} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (β -> γ) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1)))))) (β -> γ) (fun (_x : β -> γ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : β -> γ) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (β -> γ) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} β) γ (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u1} γ (SubNegMonoid.toAddMonoid.{u1} γ (AddGroup.toSubNegMonoid.{u1} γ (AddCommGroup.toAddGroup.{u1} γ _inst_1)))))) (FreeAbelianGroup.lift.{u2, u1} β γ _inst_1) g) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.{u3} α) (fun (_x : FreeAbelianGroup.{u3} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u3} α) => FreeAbelianGroup.{u2} β) _x) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.{u2} β) (AddZeroClass.toAdd.{u3} (FreeAbelianGroup.{u3} α) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α)))))) (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoidHom.addMonoidHomClass.{u3, u2} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} α) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} α) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} α) (FreeAbelianGroup.addCommGroup.{u3} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))))) (FreeAbelianGroup.map.{u3, u2} α β f) x))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift_comp FreeAbelianGroup.lift_compₓ'. -/
theorem lift_comp {α} {β} {γ} [AddCommGroup γ] (f : α → β) (g : β → γ) (x : FreeAbelianGroup α) :
    lift (g ∘ f) x = lift g (map f x) :=
  by
  apply FreeAbelianGroup.induction_on x
  · exact AddMonoidHom.map_zero _
  · intro y
    rfl
  · intro x h
    simp only [h, AddMonoidHom.map_neg]
  · intro x y h₁ h₂
    simp only [h₁, h₂, AddMonoidHom.map_add]
#align free_abelian_group.lift_comp FreeAbelianGroup.lift_comp

#print FreeAbelianGroup.map_id /-
theorem map_id : map id = AddMonoidHom.id (FreeAbelianGroup α) :=
  Eq.symm <|
    lift.ext _ _ fun x => lift.unique of (AddMonoidHom.id _) fun y => AddMonoidHom.id_apply _ _
#align free_abelian_group.map_id FreeAbelianGroup.map_id
-/

/- warning: free_abelian_group.map_id_apply -> FreeAbelianGroup.map_id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} α) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (_x : AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) => (FreeAbelianGroup.{u1} α) -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.hasCoeToFun.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (FreeAbelianGroup.map.{u1, u1} α α (id.{succ u1} α)) x) x
but is expected to have type
  forall {α : Type.{u1}} (x : FreeAbelianGroup.{u1} α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))) (FreeAbelianGroup.map.{u1, u1} α α (id.{succ u1} α)) x) x
Case conversion may be inaccurate. Consider using '#align free_abelian_group.map_id_apply FreeAbelianGroup.map_id_applyₓ'. -/
theorem map_id_apply (x : FreeAbelianGroup α) : map id x = x :=
  by
  rw [map_id]
  rfl
#align free_abelian_group.map_id_apply FreeAbelianGroup.map_id_apply

#print FreeAbelianGroup.map_comp /-
theorem map_comp {f : α → β} {g : β → γ} : map (g ∘ f) = (map g).comp (map f) :=
  Eq.symm <| lift.ext _ _ fun x => Eq.symm <| lift_comp _ _ _
#align free_abelian_group.map_comp FreeAbelianGroup.map_comp
-/

/- warning: free_abelian_group.map_comp_apply -> FreeAbelianGroup.map_comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {g : β -> γ} (x : FreeAbelianGroup.{u1} α), Eq.{succ u3} (FreeAbelianGroup.{u3} γ) (coeFn.{max (succ u3) (succ u1), max (succ u1) (succ u3)} (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (fun (_x : AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) => (FreeAbelianGroup.{u1} α) -> (FreeAbelianGroup.{u3} γ)) (AddMonoidHom.hasCoeToFun.{u1, u3} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (FreeAbelianGroup.map.{u1, u3} α γ (Function.comp.{succ u1, succ u2, succ u3} α β γ g f)) x) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (fun (_x : AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) => (FreeAbelianGroup.{u2} β) -> (FreeAbelianGroup.{u3} γ)) (AddMonoidHom.hasCoeToFun.{u2, u3} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (FreeAbelianGroup.map.{u2, u3} β γ g) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) => (FreeAbelianGroup.{u1} α) -> (FreeAbelianGroup.{u2} β)) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.map.{u1, u2} α β f) x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {g : β -> γ} (x : FreeAbelianGroup.{u1} α), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u3} γ) x) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u3} γ) _x) (AddHomClass.toFunLike.{max u1 u3, u1, u3} (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u3} γ) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u3} (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u1, u3} (AddMonoidHom.{u1, u3} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ))))) (AddMonoidHom.addMonoidHomClass.{u1, u3} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))))) (FreeAbelianGroup.map.{u1, u3} α γ (Function.comp.{succ u1, succ u2, succ u3} α β γ g f)) x) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (FreeAbelianGroup.{u2} β) (fun (_x : FreeAbelianGroup.{u2} β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} β) => FreeAbelianGroup.{u3} γ) _x) (AddHomClass.toFunLike.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.{u3} γ) (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (AddZeroClass.toAdd.{u3} (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u2, u3} (AddMonoidHom.{u2, u3} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))) (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ))))) (AddMonoidHom.addMonoidHomClass.{u2, u3} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.{u3} γ) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoid.toAddZeroClass.{u3} (FreeAbelianGroup.{u3} γ) (SubNegMonoid.toAddMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddGroup.toSubNegMonoid.{u3} (FreeAbelianGroup.{u3} γ) (AddCommGroup.toAddGroup.{u3} (FreeAbelianGroup.{u3} γ) (FreeAbelianGroup.addCommGroup.{u3} γ)))))))) (FreeAbelianGroup.map.{u2, u3} β γ g) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u2} β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))))) (FreeAbelianGroup.map.{u1, u2} α β f) x))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.map_comp_apply FreeAbelianGroup.map_comp_applyₓ'. -/
theorem map_comp_apply {f : α → β} {g : β → γ} (x : FreeAbelianGroup α) :
    map (g ∘ f) x = (map g) ((map f) x) := by
  rw [map_comp]
  rfl
#align free_abelian_group.map_comp_apply FreeAbelianGroup.map_comp_apply

/- warning: free_abelian_group.map_of_apply -> FreeAbelianGroup.map_of_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} (a : α), Eq.{succ u2} (FreeAbelianGroup.{u2} β) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) => (FreeAbelianGroup.{u1} α) -> (FreeAbelianGroup.{u2} β)) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.map.{u1, u2} α β f) (FreeAbelianGroup.of.{u1} α a)) (FreeAbelianGroup.of.{u2} β (f a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u2} β) (FreeAbelianGroup.of.{u1} α a)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u2} β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))))) (FreeAbelianGroup.map.{u1, u2} α β f) (FreeAbelianGroup.of.{u1} α a)) (FreeAbelianGroup.of.{u2} β (f a))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.map_of_apply FreeAbelianGroup.map_of_applyₓ'. -/
-- version of map_of which uses `map`
@[simp]
theorem map_of_apply {f : α → β} (a : α) : map f (of a) = of (f a) :=
  rfl
#align free_abelian_group.map_of_apply FreeAbelianGroup.map_of_apply

variable (α)

section Mul

variable [Mul α]

instance : Mul (FreeAbelianGroup α) :=
  ⟨fun x => lift fun x₂ => lift (fun x₁ => of <| x₁ * x₂) x⟩

variable {α}

/- warning: free_abelian_group.mul_def -> FreeAbelianGroup.mul_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Mul.{u1} α] (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} α) (HMul.hMul.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHMul.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.hasMul.{u1} α _inst_1)) x y) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (_x : AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) => (FreeAbelianGroup.{u1} α) -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.hasCoeToFun.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (fun (_x : Equiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) => (α -> (FreeAbelianGroup.{u1} α)) -> (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (Equiv.hasCoeToFun.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (FreeAbelianGroup.lift.{u1, u1} α (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)) (fun (x₂ : α) => coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (_x : AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) => (FreeAbelianGroup.{u1} α) -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.hasCoeToFun.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (fun (_x : Equiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) => (α -> (FreeAbelianGroup.{u1} α)) -> (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (Equiv.hasCoeToFun.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (FreeAbelianGroup.lift.{u1, u1} α (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) x)) y)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Mul.{u1} α] (x : FreeAbelianGroup.{u1} α) (y : FreeAbelianGroup.{u1} α), Eq.{succ u1} (FreeAbelianGroup.{u1} α) (HMul.hMul.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHMul.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.mul.{u1} α _inst_1)) x y) (FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₂ : α) => FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (fun (a : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) a) (AddHomClass.toFunLike.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (α -> (FreeAbelianGroup.{u1} α)) (fun (a : α -> (FreeAbelianGroup.{u1} α)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (FreeAbelianGroup.lift.{u1, u1} α (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) x)) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) _x) (AddHomClass.toFunLike.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₂ : α) => FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (fun (a : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) a) (AddHomClass.toFunLike.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (α -> (FreeAbelianGroup.{u1} α)) (fun (a : α -> (FreeAbelianGroup.{u1} α)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (FreeAbelianGroup.lift.{u1, u1} α (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) x)) (FreeAbelianGroup.{u1} α) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₂ : α) => FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (fun (a : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) a) (AddHomClass.toFunLike.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (α -> (FreeAbelianGroup.{u1} α)) (fun (a : α -> (FreeAbelianGroup.{u1} α)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) a) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (FreeAbelianGroup.lift.{u1, u1} α (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) x)) (FreeAbelianGroup.{u1} α) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} α) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α)))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (α -> ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (α -> ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x)) (fun (_x : α -> ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α)))))) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (α -> ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (FreeAbelianGroup.lift.{u1, u1} α ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) x) (FreeAbelianGroup.addCommGroup.{u1} α)) (fun (x₂ : α) => FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (fun (_x : FreeAbelianGroup.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u1} α) => FreeAbelianGroup.{u1} α) _x) (AddHomClass.toFunLike.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (α -> (FreeAbelianGroup.{u1} α)) (fun (_x : α -> (FreeAbelianGroup.{u1} α)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> (FreeAbelianGroup.{u1} α)) => AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (α -> (FreeAbelianGroup.{u1} α)) (AddMonoidHom.{u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))))) (FreeAbelianGroup.lift.{u1, u1} α (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)) (fun (x₁ : α) => FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x₁ x₂))) x)) y)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.mul_def FreeAbelianGroup.mul_defₓ'. -/
theorem mul_def (x y : FreeAbelianGroup α) :
    x * y = lift (fun x₂ => lift (fun x₁ => of (x₁ * x₂)) x) y :=
  rfl
#align free_abelian_group.mul_def FreeAbelianGroup.mul_def

/- warning: free_abelian_group.of_mul_of -> FreeAbelianGroup.of_mul_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Mul.{u1} α] (x : α) (y : α), Eq.{succ u1} (FreeAbelianGroup.{u1} α) (HMul.hMul.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHMul.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.hasMul.{u1} α _inst_1)) (FreeAbelianGroup.of.{u1} α x) (FreeAbelianGroup.of.{u1} α y)) (FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Mul.{u1} α] (x : α) (y : α), Eq.{succ u1} (FreeAbelianGroup.{u1} α) (HMul.hMul.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHMul.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.mul.{u1} α _inst_1)) (FreeAbelianGroup.of.{u1} α x) (FreeAbelianGroup.of.{u1} α y)) (FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x y))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.of_mul_of FreeAbelianGroup.of_mul_ofₓ'. -/
@[simp]
theorem of_mul_of (x y : α) : of x * of y = of (x * y) :=
  rfl
#align free_abelian_group.of_mul_of FreeAbelianGroup.of_mul_of

/- warning: free_abelian_group.of_mul -> FreeAbelianGroup.of_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Mul.{u1} α] (x : α) (y : α), Eq.{succ u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x y)) (HMul.hMul.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHMul.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.hasMul.{u1} α _inst_1)) (FreeAbelianGroup.of.{u1} α x) (FreeAbelianGroup.of.{u1} α y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Mul.{u1} α] (x : α) (y : α), Eq.{succ u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.of.{u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_1) x y)) (HMul.hMul.{u1, u1, u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u1} α) (instHMul.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.mul.{u1} α _inst_1)) (FreeAbelianGroup.of.{u1} α x) (FreeAbelianGroup.of.{u1} α y))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.of_mul FreeAbelianGroup.of_mulₓ'. -/
theorem of_mul (x y : α) : of (x * y) = of x * of y :=
  rfl
#align free_abelian_group.of_mul FreeAbelianGroup.of_mul

instance : Distrib (FreeAbelianGroup α) :=
  { FreeAbelianGroup.hasMul _ with
    add := (· + ·)
    left_distrib := fun x y z => (lift _).map_add _ _
    right_distrib := fun x y z => by simp only [(· * ·), map_add, ← Pi.add_def, lift.add'] }

instance : NonUnitalNonAssocRing (FreeAbelianGroup α) :=
  { FreeAbelianGroup.distrib,
    FreeAbelianGroup.addCommGroup
      _ with
    zero_mul := fun a => by
      have h : 0 * a + 0 * a = 0 * a := by simp [← add_mul]
      simpa using h
    mul_zero := fun a => rfl }

end Mul

instance [One α] : One (FreeAbelianGroup α) :=
  ⟨of 1⟩

instance [Semigroup α] : NonUnitalRing (FreeAbelianGroup α) :=
  {
    FreeAbelianGroup.nonUnitalNonAssocRing with
    mul := (· * ·)
    mul_assoc := fun x y z =>
      by
      refine'
        FreeAbelianGroup.induction_on z (by simp) (fun L3 => _) (fun L3 ih => _)
          fun z₁ z₂ ih₁ ih₂ => _
      · refine'
          FreeAbelianGroup.induction_on y (by simp) (fun L2 => _) (fun L2 ih => _)
            fun y₁ y₂ ih₁ ih₂ => _
        · refine'
            FreeAbelianGroup.induction_on x (by simp) (fun L1 => _) (fun L1 ih => _)
              fun x₁ x₂ ih₁ ih₂ => _
          · rw [of_mul_of, of_mul_of, of_mul_of, of_mul_of, mul_assoc]
          · rw [neg_mul, neg_mul, neg_mul, ih]
          · rw [add_mul, add_mul, add_mul, ih₁, ih₂]
        · rw [neg_mul, mul_neg, mul_neg, neg_mul, ih]
        · rw [add_mul, mul_add, mul_add, add_mul, ih₁, ih₂]
      · rw [mul_neg, mul_neg, mul_neg, ih]
      · rw [mul_add, mul_add, mul_add, ih₁, ih₂] }

section Monoid

variable {R : Type _} [Monoid α] [Ring R]

instance : Ring (FreeAbelianGroup α) :=
  { FreeAbelianGroup.nonUnitalRing _,
    FreeAbelianGroup.hasOne _ with
    mul := (· * ·)
    mul_one := fun x => by
      unfold Mul.mul Semigroup.mul One.one
      rw [lift.of]
      refine'
        FreeAbelianGroup.induction_on x rfl (fun L => _) (fun L ih => _) fun x1 x2 ih1 ih2 => _
      · erw [lift.of]
        congr 1
        exact mul_one L
      · rw [map_neg, ih]
      · rw [map_add, ih1, ih2]
    one_mul := fun x => by
      unfold Mul.mul Semigroup.mul One.one
      refine' FreeAbelianGroup.induction_on x rfl _ _ _
      · intro L
        rw [lift.of, lift.of]
        congr 1
        exact one_mul L
      · intro L ih
        rw [map_neg, ih]
      · intro x1 x2 ih1 ih2
        rw [map_add, ih1, ih2] }

variable {α}

#print FreeAbelianGroup.ofMulHom /-
/-- `free_abelian_group.of` is a `monoid_hom` when `α` is a `monoid`. -/
def ofMulHom : α →* FreeAbelianGroup α where
  toFun := of
  map_one' := rfl
  map_mul' := of_mul
#align free_abelian_group.of_mul_hom FreeAbelianGroup.ofMulHom
-/

/- warning: free_abelian_group.of_mul_hom_coe -> FreeAbelianGroup.ofMulHom_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Monoid.{u1} α], Eq.{succ u1} ((fun (_x : MonoidHom.{u1, u1} α (FreeAbelianGroup.{u1} α) (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1)))))) => α -> (FreeAbelianGroup.{u1} α)) (FreeAbelianGroup.ofMulHom.{u1} α _inst_1)) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} α (FreeAbelianGroup.{u1} α) (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1)))))) (fun (_x : MonoidHom.{u1, u1} α (FreeAbelianGroup.{u1} α) (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1)))))) => α -> (FreeAbelianGroup.{u1} α)) (MonoidHom.hasCoeToFun.{u1, u1} α (FreeAbelianGroup.{u1} α) (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1)))))) (FreeAbelianGroup.ofMulHom.{u1} α _inst_1)) (FreeAbelianGroup.of.{u1} α)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Monoid.{u1} α], Eq.{succ u1} (forall (a : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => FreeAbelianGroup.{u1} α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} α (FreeAbelianGroup.{u1} α) (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1)))))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => FreeAbelianGroup.{u1} α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} α (FreeAbelianGroup.{u1} α) (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1)))))) α (FreeAbelianGroup.{u1} α) (MulOneClass.toMul.{u1} α (Monoid.toMulOneClass.{u1} α _inst_1)) (MulOneClass.toMul.{u1} (FreeAbelianGroup.{u1} α) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} α (FreeAbelianGroup.{u1} α) (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1)))))) α (FreeAbelianGroup.{u1} α) (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))))) (MonoidHom.monoidHomClass.{u1, u1} α (FreeAbelianGroup.{u1} α) (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocSemiring.toMulZeroOneClass.{u1} (FreeAbelianGroup.{u1} α) (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1)))))))) (FreeAbelianGroup.ofMulHom.{u1} α _inst_1)) (FreeAbelianGroup.of.{u1} α)
Case conversion may be inaccurate. Consider using '#align free_abelian_group.of_mul_hom_coe FreeAbelianGroup.ofMulHom_coeₓ'. -/
@[simp]
theorem ofMulHom_coe : (ofMulHom : α → FreeAbelianGroup α) = of :=
  rfl
#align free_abelian_group.of_mul_hom_coe FreeAbelianGroup.ofMulHom_coe

#print FreeAbelianGroup.liftMonoid /-
/-- If `f` preserves multiplication, then so does `lift f`. -/
def liftMonoid : (α →* R) ≃ (FreeAbelianGroup α →+* R)
    where
  toFun f :=
    { lift f with
      toFun := lift f
      map_one' := (lift.of f _).trans f.map_one
      map_mul' := fun x y =>
        by
        refine'
          FreeAbelianGroup.induction_on y (MulZeroClass.mul_zero _).symm (fun L2 => _)
            (fun L2 ih => _) _
        · refine'
            FreeAbelianGroup.induction_on x (MulZeroClass.zero_mul _).symm (fun L1 => _)
              (fun L1 ih => _) _
          · simp_rw [of_mul_of, lift.of]
            exact f.map_mul _ _
          · simp_rw [neg_mul, map_neg, neg_mul]
            exact congr_arg Neg.neg ih
          · intro x1 x2 ih1 ih2
            simp only [add_mul, map_add, ih1, ih2]
        · rw [mul_neg, map_neg, map_neg, mul_neg, ih]
        · intro y1 y2 ih1 ih2
          rw [mul_add, map_add, map_add, mul_add, ih1, ih2] }
  invFun F := MonoidHom.comp (↑F) ofMulHom
  left_inv f := MonoidHom.ext <| lift.of _
  right_inv F :=
    RingHom.coe_addMonoidHom_injective <| lift.apply_symm_apply (↑F : FreeAbelianGroup α →+ R)
#align free_abelian_group.lift_monoid FreeAbelianGroup.liftMonoid
-/

/- warning: free_abelian_group.lift_monoid_coe_add_monoid_hom -> FreeAbelianGroup.liftMonoid_coe_addMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} α] [_inst_2 : Ring.{u2} R] (f : MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (AddMonoidHom.hasCoeT.{u1, u2, max u1 u2} (FreeAbelianGroup.{u1} α) R (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))) (RingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)) (RingHom.ringHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))) (coeFn.{max 1 (max (max (succ u2) (succ u1)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ u2) (succ u1), max (max (succ u2) (succ u1)) (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (fun (_x : Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) => (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) -> (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (Equiv.hasCoeToFun.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (FreeAbelianGroup.liftMonoid.{u1, u2} α R _inst_1 _inst_2) f)) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> R) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> R) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))))) => (α -> R) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> R) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))))) (FreeAbelianGroup.lift.{u1, u2} α R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (fun (_x : MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) => α -> R) (MonoidHom.hasCoeToFun.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) f))
but is expected to have type
  forall {α : Type.{u2}} {R : Type.{u1}} [_inst_1 : Monoid.{u2} α] [_inst_2 : Ring.{u1} R] (f : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> R) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => R) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (MulOneClass.toMul.{u2} α (Monoid.toMulOneClass.{u2} α _inst_1)) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MonoidHom.monoidHomClass.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))))) f)) (AddMonoidHomClass.toAddMonoidHom.{u2, u1, max u2 u1} (FreeAbelianGroup.{u2} α) R ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) f) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2))))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) f) (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (fun (_x : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (FreeAbelianGroup.liftMonoid.{u2, u1} α R _inst_1 _inst_2) f)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> R) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2))))))) (α -> R) (fun (_x : α -> R) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> R) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> R) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2))))))) (FreeAbelianGroup.lift.{u2, u1} α R (Ring.toAddCommGroup.{u1} R _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => R) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (MulOneClass.toMul.{u2} α (Monoid.toMulOneClass.{u2} α _inst_1)) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MonoidHom.monoidHomClass.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))))) f))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift_monoid_coe_add_monoid_hom FreeAbelianGroup.liftMonoid_coe_addMonoidHomₓ'. -/
@[simp]
theorem liftMonoid_coe_addMonoidHom (f : α →* R) : ↑(liftMonoid f) = lift f :=
  rfl
#align free_abelian_group.lift_monoid_coe_add_monoid_hom FreeAbelianGroup.liftMonoid_coe_addMonoidHom

/- warning: free_abelian_group.lift_monoid_coe -> FreeAbelianGroup.liftMonoid_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} α] [_inst_2 : Ring.{u2} R] (f : MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))), Eq.{max (succ u1) (succ u2)} ((FreeAbelianGroup.{u1} α) -> R) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (fun (_x : RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) => (FreeAbelianGroup.{u1} α) -> R) (RingHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (coeFn.{max 1 (max (max (succ u2) (succ u1)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ u2) (succ u1), max (max (succ u2) (succ u1)) (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (fun (_x : Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) => (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) -> (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (Equiv.hasCoeToFun.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (FreeAbelianGroup.liftMonoid.{u1, u2} α R _inst_1 _inst_2) f)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (fun (_x : AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) => (FreeAbelianGroup.{u1} α) -> R) (AddMonoidHom.hasCoeToFun.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> R) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> R) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))))) => (α -> R) -> (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> R) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))))) (FreeAbelianGroup.lift.{u1, u2} α R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (fun (_x : MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) => α -> R) (MonoidHom.hasCoeToFun.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) f)))
but is expected to have type
  forall {α : Type.{u2}} {R : Type.{u1}} [_inst_1 : Monoid.{u2} α] [_inst_2 : Ring.{u1} R] (f : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : FreeAbelianGroup.{u2} α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeAbelianGroup.{u2} α) => R) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) f) (FreeAbelianGroup.{u2} α) (fun (_x : FreeAbelianGroup.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : FreeAbelianGroup.{u2} α) => R) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) f) (FreeAbelianGroup.{u2} α) R (NonUnitalNonAssocSemiring.toMul.{u2} (FreeAbelianGroup.{u2} α) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) f) (FreeAbelianGroup.{u2} α) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) f) (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (fun (_x : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) => RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (FreeAbelianGroup.liftMonoid.{u2, u1} α R _inst_1 _inst_2) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> R) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => R) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (MulOneClass.toMul.{u2} α (Monoid.toMulOneClass.{u2} α _inst_1)) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MonoidHom.monoidHomClass.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))))) f)) (FreeAbelianGroup.{u2} α) (fun (_x : FreeAbelianGroup.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : FreeAbelianGroup.{u2} α) => R) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> R) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => R) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (MulOneClass.toMul.{u2} α (Monoid.toMulOneClass.{u2} α _inst_1)) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MonoidHom.monoidHomClass.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))))) f)) (FreeAbelianGroup.{u2} α) R (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} α) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α)))))) (AddZeroClass.toAdd.{u1} R (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> R) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => R) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (MulOneClass.toMul.{u2} α (Monoid.toMulOneClass.{u2} α _inst_1)) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MonoidHom.monoidHomClass.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))))) f)) (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> R) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2))))))) (α -> R) (fun (_x : α -> R) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α -> R) => AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> R) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2))))))) (FreeAbelianGroup.lift.{u2, u1} α R (Ring.toAddCommGroup.{u1} R _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => R) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (MulOneClass.toMul.{u2} α (Monoid.toMulOneClass.{u2} α _inst_1)) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MonoidHom.monoidHomClass.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))))) f)))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift_monoid_coe FreeAbelianGroup.liftMonoid_coeₓ'. -/
@[simp]
theorem liftMonoid_coe (f : α →* R) : ⇑(liftMonoid f) = lift f :=
  rfl
#align free_abelian_group.lift_monoid_coe FreeAbelianGroup.liftMonoid_coe

/- warning: free_abelian_group.lift_monoid_symm_coe -> FreeAbelianGroup.liftMonoid_symm_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : Monoid.{u1} α] [_inst_2 : Ring.{u2} R] (f : RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))), Eq.{max (succ u1) (succ u2)} (α -> R) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (fun (_x : MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) => α -> R) (MonoidHom.hasCoeToFun.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) => (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) -> (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) (Equiv.symm.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α R (Monoid.toMulOneClass.{u1} α _inst_1) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (FreeAbelianGroup.liftMonoid.{u1, u2} α R _inst_1 _inst_2)) f)) (coeFn.{max 1 (max (max (succ u2) (succ u1)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ u2) (succ u1), max (max (succ u2) (succ u1)) (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (α -> R)) (fun (_x : Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (α -> R)) => (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) -> α -> R) (Equiv.hasCoeToFun.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (α -> R)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> R) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (FreeAbelianGroup.lift.{u1, u2} α R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (AddMonoidHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))))) (AddMonoidHom.hasCoeT.{u1, u2, max u1 u2} (FreeAbelianGroup.{u1} α) R (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α))))) (AddMonoid.toAddZeroClass.{u2} R (SubNegMonoid.toAddMonoid.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddCommGroup.toAddGroup.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))) (RingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))) (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)) (RingHom.ringHomClass.{u1, u2} (FreeAbelianGroup.{u1} α) R (NonAssocRing.toNonAssocSemiring.{u1} (FreeAbelianGroup.{u1} α) (Ring.toNonAssocRing.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.ring.{u1} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))))) f))
but is expected to have type
  forall {α : Type.{u2}} {R : Type.{u1}} [_inst_1 : Monoid.{u2} α] [_inst_2 : Ring.{u1} R] (f : RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => R) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) => MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) f) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => R) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) => MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) f) α R (MulOneClass.toMul.{u2} α (Monoid.toMulOneClass.{u2} α _inst_1)) (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) => MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) f) α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) (MonoidHom.monoidHomClass.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))))) (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (fun (_x : RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) => MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MonoidHom.{u2, u1} α R (Monoid.toMulOneClass.{u2} α _inst_1) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))))) (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (FreeAbelianGroup.liftMonoid.{u2, u1} α R _inst_1 _inst_2)) f)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) (α -> R)) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) (fun (_x : AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) => α -> R) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) (α -> R)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> R) (AddMonoidHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.addCommGroup.{u2} α))))) (AddMonoid.toAddZeroClass.{u1} R (SubNegMonoid.toAddMonoid.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (Ring.toAddCommGroup.{u1} R _inst_2)))))) (FreeAbelianGroup.lift.{u2, u1} α R (Ring.toAddCommGroup.{u1} R _inst_2))) (AddMonoidHomClass.toAddMonoidHom.{u2, u1, max u2 u1} (FreeAbelianGroup.{u2} α) R (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} α) (AddMonoidWithOne.toAddMonoid.{u2} (FreeAbelianGroup.{u2} α) (AddGroupWithOne.toAddMonoidWithOne.{u2} (FreeAbelianGroup.{u2} α) (Ring.toAddGroupWithOne.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))))) (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_2)))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2))) (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} (FreeAbelianGroup.{u2} α) R (NonAssocRing.toNonAssocSemiring.{u2} (FreeAbelianGroup.{u2} α) (Ring.toNonAssocRing.{u2} (FreeAbelianGroup.{u2} α) (FreeAbelianGroup.ring.{u2} α _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_2)))) f))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.lift_monoid_symm_coe FreeAbelianGroup.liftMonoid_symm_coeₓ'. -/
@[simp]
theorem liftMonoid_symm_coe (f : FreeAbelianGroup α →+* R) : ⇑(liftMonoid.symm f) = lift.symm ↑f :=
  rfl
#align free_abelian_group.lift_monoid_symm_coe FreeAbelianGroup.liftMonoid_symm_coe

/- warning: free_abelian_group.one_def -> FreeAbelianGroup.one_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Monoid.{u1} α], Eq.{succ u1} (FreeAbelianGroup.{u1} α) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 1 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} α) 1 (One.one.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.hasOne.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α _inst_1)))))) (FreeAbelianGroup.of.{u1} α (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α _inst_1))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Monoid.{u1} α], Eq.{succ u1} (FreeAbelianGroup.{u1} α) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 1 (One.toOfNat1.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.one.{u1} α (Monoid.toOne.{u1} α _inst_1)))) (FreeAbelianGroup.of.{u1} α (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Monoid.toOne.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.one_def FreeAbelianGroup.one_defₓ'. -/
theorem one_def : (1 : FreeAbelianGroup α) = of 1 :=
  rfl
#align free_abelian_group.one_def FreeAbelianGroup.one_def

/- warning: free_abelian_group.of_one -> FreeAbelianGroup.of_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Monoid.{u1} α], Eq.{succ u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.of.{u1} α (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 1 (OfNat.mk.{u1} (FreeAbelianGroup.{u1} α) 1 (One.one.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.hasOne.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α _inst_1))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Monoid.{u1} α], Eq.{succ u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.of.{u1} α (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Monoid.toOne.{u1} α _inst_1)))) (OfNat.ofNat.{u1} (FreeAbelianGroup.{u1} α) 1 (One.toOfNat1.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.one.{u1} α (Monoid.toOne.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.of_one FreeAbelianGroup.of_oneₓ'. -/
theorem of_one : (of 1 : FreeAbelianGroup α) = 1 :=
  rfl
#align free_abelian_group.of_one FreeAbelianGroup.of_one

end Monoid

instance [CommMonoid α] : CommRing (FreeAbelianGroup α) :=
  { FreeAbelianGroup.ring α with
    mul_comm := fun x y =>
      by
      refine' FreeAbelianGroup.induction_on x (MulZeroClass.zero_mul y) _ _ _
      · intro s
        refine' FreeAbelianGroup.induction_on y (MulZeroClass.zero_mul _).symm _ _ _
        · intro t
          unfold Mul.mul Semigroup.mul Ring.mul
          iterate 4 rw [lift.of]
          congr 1
          exact mul_comm _ _
        · intro t ih
          rw [mul_neg, ih, neg_mul_eq_neg_mul]
        · intro y1 y2 ih1 ih2
          rw [mul_add, add_mul, ih1, ih2]
      · intro s ih
        rw [neg_mul, ih, neg_mul_eq_mul_neg]
      · intro x1 x2 ih1 ih2
        rw [add_mul, mul_add, ih1, ih2] }

#print FreeAbelianGroup.pemptyUnique /-
instance pemptyUnique : Unique (FreeAbelianGroup PEmpty)
    where
  default := 0
  uniq x :=
    FreeAbelianGroup.induction_on x rfl (fun x => PEmpty.elim x) (fun x => PEmpty.elim x)
      (by
        rintro - - rfl rfl
        simp)
#align free_abelian_group.pempty_unique FreeAbelianGroup.pemptyUnique
-/

/- warning: free_abelian_group.punit_equiv -> FreeAbelianGroup.punitEquiv is a dubious translation:
lean 3 declaration is
  forall (T : Type.{u1}) [_inst_1 : Unique.{succ u1} T], AddEquiv.{u1, 0} (FreeAbelianGroup.{u1} T) Int (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} T) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} T) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} T) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} T) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} T) (FreeAbelianGroup.addCommGroup.{u1} T)))))) Int.hasAdd
but is expected to have type
  forall (T : Type.{u1}) [_inst_1 : Unique.{succ u1} T], AddEquiv.{u1, 0} (FreeAbelianGroup.{u1} T) Int (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} T) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} T) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} T) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} T) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} T) (FreeAbelianGroup.addCommGroup.{u1} T)))))) Int.instAddInt
Case conversion may be inaccurate. Consider using '#align free_abelian_group.punit_equiv FreeAbelianGroup.punitEquivₓ'. -/
/-- The free abelian group on a type with one term is isomorphic to `ℤ`. -/
def punitEquiv (T : Type _) [Unique T] : FreeAbelianGroup T ≃+ ℤ
    where
  toFun := FreeAbelianGroup.lift fun _ => (1 : ℤ)
  invFun n := n • of Inhabited.default
  left_inv z :=
    FreeAbelianGroup.induction_on z (by simp only [zero_smul, AddMonoidHom.map_zero])
      (Unique.forall_iff.2 <| by simp only [one_smul, lift.of]) (Unique.forall_iff.2 <| by simp)
      fun x y hx hy => by
      simp only [AddMonoidHom.map_add, add_smul] at *
      rw [hx, hy]
  right_inv n := by
    rw [AddMonoidHom.map_zsmul, lift.of]
    exact zsmul_int_one n
  map_add' := AddMonoidHom.map_add _
#align free_abelian_group.punit_equiv FreeAbelianGroup.punitEquiv

/- warning: free_abelian_group.equiv_of_equiv -> FreeAbelianGroup.equivOfEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}}, (Equiv.{succ u1, succ u2} α β) -> (AddEquiv.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddZeroClass.toHasAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toHasAdd.{u2} (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}}, (Equiv.{succ u1, succ u2} α β) -> (AddEquiv.{u1, u2} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.{u2} β) (AddZeroClass.toAdd.{u1} (FreeAbelianGroup.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAbelianGroup.{u1} α) (SubNegMonoid.toAddMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddGroup.toSubNegMonoid.{u1} (FreeAbelianGroup.{u1} α) (AddCommGroup.toAddGroup.{u1} (FreeAbelianGroup.{u1} α) (FreeAbelianGroup.addCommGroup.{u1} α)))))) (AddZeroClass.toAdd.{u2} (FreeAbelianGroup.{u2} β) (AddMonoid.toAddZeroClass.{u2} (FreeAbelianGroup.{u2} β) (SubNegMonoid.toAddMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddGroup.toSubNegMonoid.{u2} (FreeAbelianGroup.{u2} β) (AddCommGroup.toAddGroup.{u2} (FreeAbelianGroup.{u2} β) (FreeAbelianGroup.addCommGroup.{u2} β)))))))
Case conversion may be inaccurate. Consider using '#align free_abelian_group.equiv_of_equiv FreeAbelianGroup.equivOfEquivₓ'. -/
/-- Isomorphic types have isomorphic free abelian groups. -/
def equivOfEquiv {α β : Type _} (f : α ≃ β) : FreeAbelianGroup α ≃+ FreeAbelianGroup β
    where
  toFun := map f
  invFun := map f.symm
  left_inv := by
    intro x
    rw [← map_comp_apply, Equiv.symm_comp_self, map_id]
    rfl
  right_inv := by
    intro x
    rw [← map_comp_apply, Equiv.self_comp_symm, map_id]
    rfl
  map_add' := AddMonoidHom.map_add _
#align free_abelian_group.equiv_of_equiv FreeAbelianGroup.equivOfEquiv

end FreeAbelianGroup

