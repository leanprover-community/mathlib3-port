import Mathbin.Data.Equiv.Fintype 
import Mathbin.Data.Finset.NoncommProd 
import Mathbin.GroupTheory.Perm.Sign

/-!
# Cyclic permutations

## Main definitions

In the following, `f : equiv.perm β`.

* `equiv.perm.is_cycle`: `f.is_cycle` when two nonfixed points of `β`
  are related by repeated application of `f`.
* `equiv.perm.same_cycle`: `f.same_cycle x y` when `x` and `y` are in the same cycle of `f`.

The following two definitions require that `β` is a `fintype`:

* `equiv.perm.cycle_of`: `f.cycle_of x` is the cycle of `f` that `x` belongs to.
* `equiv.perm.cycle_factors`: `f.cycle_factors` is a list of disjoint cyclic permutations that
  multiply to `f`.

## Main results

* This file contains several closure results:
  - `closure_is_cycle` : The symmetric group is generated by cycles
  - `closure_cycle_adjacent_swap` : The symmetric group is generated by
    a cycle and an adjacent transposition
  - `closure_cycle_coprime_swap` : The symmetric group is generated by
    a cycle and a coprime transposition
  - `closure_prime_cycle_swap` : The symmetric group is generated by
    a prime cycle and a transposition

-/


namespace Equiv.Perm

open Equiv Function Finset

variable{α : Type _}{β : Type _}[DecidableEq α]

section SignCycle

/-!
### `is_cycle`
-/


variable[Fintype α]

/-- A permutation is a cycle when any two nonfixed points of the permutation are related by repeated
  application of the permutation. -/
def is_cycle (f : perm β) : Prop :=
  ∃ x, f x ≠ x ∧ ∀ y, f y ≠ y → ∃ i : ℤ, (f ^ i) x = y

theorem is_cycle.ne_one {f : perm β} (h : is_cycle f) : f ≠ 1 :=
  fun hf =>
    by 
      simpa [hf, is_cycle] using h

@[simp]
theorem not_is_cycle_one : ¬(1 : perm β).IsCycle :=
  fun H => H.ne_one rfl

theorem is_cycle.two_le_card_support {f : perm α} (h : is_cycle f) : 2 ≤ f.support.card :=
  two_le_card_support_of_ne_one h.ne_one

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem is_cycle_swap {α : Type*} [decidable_eq α] {x y : α} (hxy : «expr ≠ »(x, y)) : is_cycle (swap x y) :=
⟨y, by rwa [expr swap_apply_right] [], λ
 (a)
 (ha : «expr ≠ »(ite «expr = »(a, x) y (ite «expr = »(a, y) x a), a)), if hya : «expr = »(y, a) then ⟨0, hya⟩ else ⟨1, by { rw ["[", expr zpow_one, ",", expr swap_apply_def, "]"] [],
    split_ifs ["at", "*"] []; cc }⟩⟩

theorem is_swap.is_cycle {α : Type _} [DecidableEq α] {f : perm α} (hf : is_swap f) : is_cycle f :=
  by 
    obtain ⟨x, y, hxy, rfl⟩ := hf 
    exact is_cycle_swap hxy

theorem is_cycle.inv {f : perm β} (hf : is_cycle f) : is_cycle (f⁻¹) :=
  let ⟨x, hx⟩ := hf
  ⟨x,
    by 
      simp_all only [inv_eq_iff_eq, forall_prop_of_true, Ne.def]
      cc,
    fun y hy =>
      let ⟨i, hi⟩ :=
        hx.2 y
          (by 
            simp_all only [inv_eq_iff_eq, forall_prop_of_true, Ne.def]
            cc)
      ⟨-i,
        by 
          rwa [zpow_neg, inv_zpow, inv_invₓ]⟩⟩

theorem is_cycle.is_cycle_conj {f g : perm β} (hf : is_cycle f) : is_cycle ((g*f)*g⁻¹) :=
  by 
    obtain ⟨a, ha1, ha2⟩ := hf 
    refine'
      ⟨g a,
        by 
          simp [ha1],
        fun b hb => _⟩
    obtain ⟨i, hi⟩ := ha2 ((g⁻¹) b) _
    ·
      refine' ⟨i, _⟩
      rw [conj_zpow]
      simp [hi]
    ·
      contrapose! hb 
      rw [perm.mul_apply, perm.mul_apply, hb, apply_inv_self]

theorem is_cycle.exists_zpow_eq {f : perm β} (hf : is_cycle f) {x y : β} (hx : f x ≠ x) (hy : f y ≠ y) :
  ∃ i : ℤ, (f ^ i) x = y :=
  let ⟨g, hg⟩ := hf 
  let ⟨a, ha⟩ := hg.2 x hx 
  let ⟨b, hb⟩ := hg.2 y hy
  ⟨b - a,
    by 
      rw [←ha, ←mul_apply, ←zpow_add, sub_add_cancel, hb]⟩

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_cycle.exists_pow_eq
[fintype β]
{f : perm β}
(hf : is_cycle f)
{x y : β}
(hx : «expr ≠ »(f x, x))
(hy : «expr ≠ »(f y, y)) : «expr∃ , »((i : exprℕ()), «expr = »(«expr ^ »(f, i) x, y)) :=
let ⟨n, hn⟩ := hf.exists_zpow_eq hx hy in
by classical; exact [expr ⟨«expr % »(n, order_of f).to_nat, by { have [] [] [":=", expr n.mod_nonneg (int.coe_nat_ne_zero.mpr (ne_of_gt (order_of_pos f)))],
    rwa ["[", "<-", expr zpow_coe_nat, ",", expr int.to_nat_of_nonneg this, ",", "<-", expr zpow_eq_mod_order_of, "]"] [] }⟩]

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_cycle.exists_pow_eq_one
[fintype β]
{f : perm β}
(hf : is_cycle f) : «expr∃ , »((k : exprℕ()) (hk : «expr < »(1, k)), «expr = »(«expr ^ »(f, k), 1)) :=
begin
  classical,
  have [] [":", expr is_of_fin_order f] [":=", expr exists_pow_eq_one f],
  rw [expr is_of_fin_order_iff_pow_eq_one] ["at", ident this],
  obtain ["⟨", ident x, ",", ident hx, ",", ident hx', "⟩", ":=", expr hf],
  obtain ["⟨", "_", "|", "_", "|", ident k, ",", ident hk, ",", ident hk', "⟩", ":=", expr this],
  { exact [expr absurd hk (lt_asymm hk)] },
  { rw [expr pow_one] ["at", ident hk'],
    simpa [] [] [] ["[", expr hk', "]"] [] ["using", expr hx] },
  { exact [expr ⟨«expr + »(k, 2), by simp [] [] [] [] [] [], hk'⟩] }
end

/-- The subgroup generated by a cycle is in bijection with its support -/
noncomputable def is_cycle.zpowers_equiv_support {σ : perm α} (hσ : is_cycle σ) :
  («expr↑ » (Subgroup.zpowers σ) : Set (perm α)) ≃ («expr↑ » σ.support : Set α) :=
  Equiv.ofBijective
    (fun τ =>
      ⟨τ (Classical.some hσ),
        by 
          obtain ⟨τ, n, rfl⟩ := τ 
          rw [Finset.mem_coe, coe_fn_coe_base', Subtype.coe_mk, zpow_apply_mem_support, mem_support]
          exact (Classical.some_spec hσ).1⟩)
    (by 
      split 
      ·
        rintro ⟨a, m, rfl⟩ ⟨b, n, rfl⟩ h 
        ext y 
        byCases' hy : σ y = y
        ·
          simpRw [Subtype.coe_mk, zpow_apply_eq_self_of_apply_eq_self hy]
        ·
          obtain ⟨i, rfl⟩ := (Classical.some_spec hσ).2 y hy 
          rw [Subtype.coe_mk, Subtype.coe_mk, zpow_apply_comm σ m i, zpow_apply_comm σ n i]
          exact congr_argₓ _ (subtype.ext_iff.mp h)
      ·
        ·
          rintro ⟨y, hy⟩
          rw [Finset.mem_coe, mem_support] at hy 
          obtain ⟨n, rfl⟩ := (Classical.some_spec hσ).2 y hy 
          exact ⟨⟨σ ^ n, n, rfl⟩, rfl⟩)

@[simp]
theorem is_cycle.zpowers_equiv_support_apply {σ : perm α} (hσ : is_cycle σ) {n : ℕ} :
  hσ.zpowers_equiv_support ⟨σ ^ n, n, rfl⟩ =
    ⟨(σ ^ n) (Classical.some hσ), pow_apply_mem_support.2 (mem_support.2 (Classical.some_spec hσ).1)⟩ :=
  rfl

@[simp]
theorem is_cycle.zpowers_equiv_support_symm_apply {σ : perm α} (hσ : is_cycle σ) (n : ℕ) :
  hσ.zpowers_equiv_support.symm
      ⟨(σ ^ n) (Classical.some hσ), pow_apply_mem_support.2 (mem_support.2 (Classical.some_spec hσ).1)⟩ =
    ⟨σ ^ n, n, rfl⟩ :=
  (Equiv.symm_apply_eq _).2 hσ.zpowers_equiv_support_apply

theorem order_of_is_cycle {σ : perm α} (hσ : is_cycle σ) : orderOf σ = σ.support.card :=
  by 
    rw [order_eq_card_zpowers, ←Fintype.card_coe]
    convert Fintype.card_congr (is_cycle.zpowers_equiv_support hσ)

theorem is_cycle_swap_mul_aux₁ {α : Type _} [DecidableEq α] :
  ∀ (n : ℕ) {b x : α} {f : perm α} (hb : (swap x (f x)*f) b ≠ b) (h : (f ^ n) (f x) = b),
    ∃ i : ℤ, ((swap x (f x)*f) ^ i) (f x) = b
| 0 => fun b x f hb h => ⟨0, h⟩
| (n+1 : ℕ) =>
  fun b x f hb h =>
    if hfbx : f x = b then ⟨0, hfbx⟩ else
      have  : f b ≠ b ∧ b ≠ x := ne_and_ne_of_swap_mul_apply_ne_self hb 
      have hb' : (swap x (f x)*f) ((f⁻¹) b) ≠ (f⁻¹) b :=
        by 
          rw [mul_apply, apply_inv_self, swap_apply_of_ne_of_ne this.2 (Ne.symm hfbx), Ne.def, ←f.injective.eq_iff,
            apply_inv_self]
          exact this.1
      let ⟨i, hi⟩ :=
        is_cycle_swap_mul_aux₁ n hb'
          (f.injective$
            by 
              rw [apply_inv_self]
              rwa [pow_succₓ, mul_apply] at h)
      ⟨i+1,
        by 
          rw [add_commₓ, zpow_add, mul_apply, hi, zpow_one, mul_apply, apply_inv_self,
            swap_apply_of_ne_of_ne (ne_and_ne_of_swap_mul_apply_ne_self hb).2 (Ne.symm hfbx)]⟩

theorem is_cycle_swap_mul_aux₂ {α : Type _} [DecidableEq α] :
  ∀ (n : ℤ) {b x : α} {f : perm α} (hb : (swap x (f x)*f) b ≠ b) (h : (f ^ n) (f x) = b),
    ∃ i : ℤ, ((swap x (f x)*f) ^ i) (f x) = b
| (n : ℕ) => fun b x f => is_cycle_swap_mul_aux₁ n
| -[1+ n] =>
  fun b x f hb h =>
    if hfbx : (f⁻¹) x = b then
      ⟨-1,
        by 
          rwa [zpow_neg, zpow_one, mul_inv_rev, mul_apply, swap_inv, swap_apply_right]⟩
    else
      if hfbx' : f x = b then ⟨0, hfbx'⟩ else
        have  : f b ≠ b ∧ b ≠ x := ne_and_ne_of_swap_mul_apply_ne_self hb 
        have hb : (swap x ((f⁻¹) x)*f⁻¹) ((f⁻¹) b) ≠ (f⁻¹) b :=
          by 
            rw [mul_apply, swap_apply_def]
            splitIfs <;>
              simp only [inv_eq_iff_eq, perm.mul_apply, zpow_neg_succ_of_nat, Ne.def, perm.apply_inv_self] at * <;> cc 
        let ⟨i, hi⟩ :=
          is_cycle_swap_mul_aux₁ n hb
            (show (f⁻¹ ^ n) ((f⁻¹) x) = (f⁻¹) b by 
              rw [←zpow_coe_nat, ←h, ←mul_apply, ←mul_apply, ←mul_apply, zpow_neg_succ_of_nat, ←inv_pow, pow_succ'ₓ,
                mul_assocₓ, mul_assocₓ, inv_mul_selfₓ, mul_oneₓ, zpow_coe_nat, ←pow_succ'ₓ, ←pow_succₓ])
        have h : (swap x ((f⁻¹) x)*f⁻¹) (f x) = (f⁻¹) x :=
          by 
            rw [mul_apply, inv_apply_self, swap_apply_left]
        ⟨-i,
          by 
            rw [←add_sub_cancel i 1, neg_sub, sub_eq_add_neg, zpow_add, zpow_one, zpow_neg, ←inv_zpow, mul_inv_rev,
              swap_inv, mul_swap_eq_swap_mul, inv_apply_self, swap_comm _ x, zpow_add, zpow_one, mul_apply,
              mul_apply (_ ^ i), h, hi, mul_apply, apply_inv_self, swap_apply_of_ne_of_ne this.2 (Ne.symm hfbx')]⟩

theorem is_cycle.eq_swap_of_apply_apply_eq_self {α : Type _} [DecidableEq α] {f : perm α} (hf : is_cycle f) {x : α}
  (hfx : f x ≠ x) (hffx : f (f x) = x) : f = swap x (f x) :=
  Equiv.ext$
    fun y =>
      let ⟨z, hz⟩ := hf 
      let ⟨i, hi⟩ := hz.2 x hfx 
      if hyx : y = x then
        by 
          simp [hyx]
      else
        if hfyx : y = f x then
          by 
            simp [hfyx, hffx]
        else
          by 
            rw [swap_apply_of_ne_of_ne hyx hfyx]
            refine' by_contradiction fun hy => _ 
            cases' hz.2 y hy with j hj 
            rw [←sub_add_cancel j i, zpow_add, mul_apply, hi] at hj 
            cases' zpow_apply_eq_of_apply_apply_eq_self hffx (j - i) with hji hji
            ·
              rw [←hj, hji] at hyx 
              cc
            ·
              rw [←hj, hji] at hfyx 
              cc

theorem is_cycle.swap_mul {α : Type _} [DecidableEq α] {f : perm α} (hf : is_cycle f) {x : α} (hx : f x ≠ x)
  (hffx : f (f x) ≠ x) : is_cycle (swap x (f x)*f) :=
  ⟨f x,
    by 
      simp only [swap_apply_def, mul_apply]
      splitIfs <;> simp [f.injective.eq_iff] at * <;> cc,
    fun y hy =>
      let ⟨i, hi⟩ := hf.exists_zpow_eq hx (ne_and_ne_of_swap_mul_apply_ne_self hy).1
      have hi : (f ^ (i - 1)) (f x) = y :=
        calc (f ^ (i - 1)) (f x) = ((f ^ (i - 1))*f ^ (1 : ℤ)) x :=
          by 
            rw [zpow_one, mul_apply]
          _ = y :=
          by 
            rwa [←zpow_add, sub_add_cancel]
          
      is_cycle_swap_mul_aux₂ (i - 1) hy hi⟩

theorem is_cycle.sign : ∀ {f : perm α} (hf : is_cycle f), sign f = -(-1 ^ f.support.card)
| f =>
  fun hf =>
    let ⟨x, hx⟩ := hf 
    calc sign f = sign (swap x (f x)*swap x (f x)*f) :=
      by 
        rw [←mul_assocₓ, mul_def, mul_def, swap_swap, trans_refl]
      _ = -(-1 ^ f.support.card) :=
      if h1 : f (f x) = x then
        have h : (swap x (f x)*f) = 1 :=
          by 
            rw [hf.eq_swap_of_apply_apply_eq_self hx.1 h1]
            simp only [perm.mul_def, perm.one_def, swap_apply_left, swap_swap]
        by 
          rw [sign_mul, sign_swap hx.1.symm, h, sign_one, hf.eq_swap_of_apply_apply_eq_self hx.1 h1,
            card_support_swap hx.1.symm]
          rfl
      else
        have h : (card (support (swap x (f x)*f))+1) = card (support f) :=
          by 
            rw [←insert_erase (mem_support.2 hx.1), support_swap_mul_eq _ _ h1,
              card_insert_of_not_mem (not_mem_erase _ _), sdiff_singleton_eq_erase]
        have wf : card (support (swap x (f x)*f)) < card (support f) := card_support_swap_mul hx.1
        by 
          rw [sign_mul, sign_swap hx.1.symm, (hf.swap_mul hx.1 h1).sign, ←h]
          simp only [pow_addₓ, mul_oneₓ, Units.neg_neg, one_mulₓ, Units.mul_neg, eq_self_iff_true, pow_oneₓ,
            Units.neg_mul_neg]
      

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_cycle_of_is_cycle_pow
{σ : perm α}
{n : exprℕ()}
(h1 : is_cycle «expr ^ »(σ, n))
(h2 : «expr ≤ »(σ.support, «expr ^ »(σ, n).support)) : is_cycle σ :=
begin
  have [ident key] [":", expr ∀ x : α, «expr ↔ »(«expr ≠ »(«expr ^ »(σ, n) x, x), «expr ≠ »(σ x, x))] [],
  { simp_rw ["[", "<-", expr mem_support, "]"] [],
    exact [expr finset.ext_iff.mp (le_antisymm (support_pow_le σ n) h2)] },
  obtain ["⟨", ident x, ",", ident hx1, ",", ident hx2, "⟩", ":=", expr h1],
  refine [expr ⟨x, (key x).mp hx1, λ y hy, _⟩],
  cases [expr hx2 y ((key y).mpr hy)] ["with", ident i, "_"],
  exact [expr ⟨«expr * »(n, i), by rwa [expr zpow_mul] []⟩]
end

theorem is_cycle_of_is_cycle_zpow {σ : perm α} {n : ℤ} (h1 : is_cycle (σ ^ n)) (h2 : σ.support ≤ (σ ^ n).support) :
  is_cycle σ :=
  by 
    cases n
    ·
      exact is_cycle_of_is_cycle_pow h1 h2
    ·
      simp only [le_eq_subset, zpow_neg_succ_of_nat, perm.support_inv] at h1 h2 
      simpa using is_cycle_of_is_cycle_pow h1.inv h2

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_cycle.extend_domain
{α : Type*}
{p : β → exprProp()}
[decidable_pred p]
(f : «expr ≃ »(α, subtype p))
{g : perm α}
(h : is_cycle g) : is_cycle (g.extend_domain f) :=
begin
  obtain ["⟨", ident a, ",", ident ha, ",", ident ha', "⟩", ":=", expr h],
  refine [expr ⟨f a, _, λ b hb, _⟩],
  { rw [expr extend_domain_apply_image] [],
    exact [expr λ con, ha (f.injective (subtype.coe_injective con))] },
  by_cases [expr pb, ":", expr p b],
  { obtain ["⟨", ident i, ",", ident hi, "⟩", ":=", expr ha' (f.symm ⟨b, pb⟩) (λ con, hb _)],
    { refine [expr ⟨i, _⟩],
      have [ident hnat] [":", expr ∀
       (k : exprℕ())
       (a : α), «expr = »(«expr ^ »(g.extend_domain f, k) «expr↑ »(f a), f («expr ^ »(g, k) a))] [],
      { intros [ident k, ident a],
        induction [expr k] [] ["with", ident k, ident ih] [],
        { refl },
        rw ["[", expr pow_succ, ",", expr perm.mul_apply, ",", expr ih, ",", expr extend_domain_apply_image, ",", expr pow_succ, ",", expr perm.mul_apply, "]"] [] },
      have [ident hint] [":", expr ∀
       (k : exprℤ())
       (a : α), «expr = »(«expr ^ »(g.extend_domain f, k) «expr↑ »(f a), f («expr ^ »(g, k) a))] [],
      { intros [ident k, ident a],
        induction [expr k] [] ["with", ident k, ident k] [],
        { rw ["[", expr zpow_of_nat, ",", expr zpow_of_nat, ",", expr hnat, "]"] [] },
        rw ["[", expr zpow_neg_succ_of_nat, ",", expr zpow_neg_succ_of_nat, ",", expr inv_eq_iff_eq, ",", expr hnat, ",", expr apply_inv_self, "]"] [] },
      rw ["[", expr hint, ",", expr hi, ",", expr apply_symm_apply, ",", expr subtype.coe_mk, "]"] [] },
    { rw ["[", expr extend_domain_apply_subtype _ _ pb, ",", expr con, ",", expr apply_symm_apply, ",", expr subtype.coe_mk, "]"] [] } },
  { exact [expr (hb (extend_domain_apply_not_subtype _ _ pb)).elim] }
end

theorem nodup_of_pairwise_disjoint_cycles {l : List (perm β)} (h1 : ∀ f (_ : f ∈ l), is_cycle f)
  (h2 : l.pairwise Disjoint) : l.nodup :=
  nodup_of_pairwise_disjoint (fun h => (h1 1 h).ne_one rfl) h2

end SignCycle

/-!
### `same_cycle`
-/


/-- The equivalence relation indicating that two points are in the same cycle of a permutation. -/
def same_cycle (f : perm β) (x y : β) : Prop :=
  ∃ i : ℤ, (f ^ i) x = y

@[refl]
theorem same_cycle.refl (f : perm β) (x : β) : same_cycle f x x :=
  ⟨0, rfl⟩

@[symm]
theorem same_cycle.symm {f : perm β} {x y : β} : same_cycle f x y → same_cycle f y x :=
  fun ⟨i, hi⟩ =>
    ⟨-i,
      by 
        rw [zpow_neg, ←hi, inv_apply_self]⟩

@[trans]
theorem same_cycle.trans {f : perm β} {x y z : β} : same_cycle f x y → same_cycle f y z → same_cycle f x z :=
  fun ⟨i, hi⟩ ⟨j, hj⟩ =>
    ⟨j+i,
      by 
        rw [zpow_add, mul_apply, hi, hj]⟩

theorem same_cycle.apply_eq_self_iff {f : perm β} {x y : β} : same_cycle f x y → (f x = x ↔ f y = y) :=
  fun ⟨i, hi⟩ =>
    by 
      rw [←hi, ←mul_apply, ←zpow_one_add, add_commₓ, zpow_add_one, mul_apply, (f ^ i).Injective.eq_iff]

theorem is_cycle.same_cycle {f : perm β} (hf : is_cycle f) {x y : β} (hx : f x ≠ x) (hy : f y ≠ y) : same_cycle f x y :=
  hf.exists_zpow_eq hx hy

theorem same_cycle.nat' [Fintype β] {f : perm β} {x y : β} (h : same_cycle f x y) :
  ∃ (i : ℕ)(h : i < orderOf f), (f ^ i) x = y :=
  by 
    classical 
    obtain ⟨k, rfl⟩ := id h 
    byCases' hk : k % orderOf f = 0
    ·
      use 0
      rw [←Int.dvd_iff_mod_eq_zero] at hk 
      obtain ⟨m, rfl⟩ := hk 
      simp [pow_order_of_eq_one, order_of_pos, zpow_mul]
    ·
      use (k % orderOf f).natAbs 
      rw [←zpow_coe_nat, Int.nat_abs_of_nonneg, ←zpow_eq_mod_order_of]
      ·
        refine' ⟨_, rfl⟩
        rw [←Int.coe_nat_lt, Int.nat_abs_of_nonneg]
        ·
          refine' Int.mod_lt_of_pos _ _ 
          simpa using order_of_pos _
        ·
          refine' Int.mod_nonneg _ _ 
          simpa using ne_of_gtₓ (order_of_pos _)
      ·
        refine' Int.mod_nonneg _ _ 
        simpa using (order_of_pos _).ne'

theorem same_cycle.nat'' [Fintype β] {f : perm β} {x y : β} (h : same_cycle f x y) :
  ∃ (i : ℕ)(hpos : 0 < i)(h : i ≤ orderOf f), (f ^ i) x = y :=
  by 
    classical 
    obtain ⟨_ | i, hi, rfl⟩ := h.nat'
    ·
      refine' ⟨orderOf f, order_of_pos f, le_rfl, _⟩
      rw [pow_order_of_eq_one, pow_zeroₓ]
    ·
      exact ⟨i.succ, i.zero_lt_succ, hi.le, rfl⟩

instance  [Fintype α] (f : perm α) : DecidableRel (same_cycle f) :=
  fun x y =>
    decidableOfIff (∃ (n : _)(_ : n ∈ List.range (Fintype.card (perm α))), (f ^ n) x = y)
      ⟨fun ⟨n, _, hn⟩ => ⟨n, hn⟩,
        fun ⟨i, hi⟩ =>
          ⟨(i % orderOf f).natAbs,
            List.mem_range.2
              (Int.coe_nat_lt.1$
                by 
                  rw [Int.nat_abs_of_nonneg (Int.mod_nonneg _ (Int.coe_nat_ne_zero_iff_pos.2 (order_of_pos _)))]
                  ·
                    apply lt_of_lt_of_leₓ (Int.mod_lt _ (Int.coe_nat_ne_zero_iff_pos.2 (order_of_pos _)))
                    ·
                      simp [order_of_le_card_univ]
                    exact fintypePerm 
                  exact fintypePerm),
            by 
              rw [←zpow_coe_nat,
                Int.nat_abs_of_nonneg (Int.mod_nonneg _ (Int.coe_nat_ne_zero_iff_pos.2 (order_of_pos _))),
                ←zpow_eq_mod_order_of, hi]
              exact fintypePerm⟩⟩

theorem same_cycle_apply {f : perm β} {x y : β} : same_cycle f x (f y) ↔ same_cycle f x y :=
  ⟨fun ⟨i, hi⟩ =>
      ⟨(-1)+i,
        by 
          rw [zpow_add, mul_apply, hi, zpow_neg_one, inv_apply_self]⟩,
    fun ⟨i, hi⟩ =>
      ⟨1+i,
        by 
          rw [zpow_add, mul_apply, hi, zpow_one]⟩⟩

theorem same_cycle_cycle {f : perm β} {x : β} (hx : f x ≠ x) : is_cycle f ↔ ∀ {y}, same_cycle f x y ↔ f y ≠ y :=
  ⟨fun hf y =>
      ⟨fun ⟨i, hi⟩ hy =>
          hx$
            by 
              rw [←zpow_apply_eq_self_of_apply_eq_self hy i, (f ^ i).Injective.eq_iff] at hi 
              rw [hi, hy],
        hf.exists_zpow_eq hx⟩,
    fun h => ⟨x, hx, fun y hy => h.2 hy⟩⟩

theorem same_cycle_inv (f : perm β) {x y : β} : same_cycle (f⁻¹) x y ↔ same_cycle f x y :=
  ⟨fun ⟨i, hi⟩ =>
      ⟨-i,
        by 
          rw [zpow_neg, ←inv_zpow, hi]⟩,
    fun ⟨i, hi⟩ =>
      ⟨-i,
        by 
          rw [zpow_neg, ←inv_zpow, inv_invₓ, hi]⟩⟩

theorem same_cycle_inv_apply {f : perm β} {x y : β} : same_cycle f x ((f⁻¹) y) ↔ same_cycle f x y :=
  by 
    rw [←same_cycle_inv, same_cycle_apply, same_cycle_inv]

@[simp]
theorem same_cycle_pow_left_iff {f : perm β} {x y : β} {n : ℕ} : same_cycle f ((f ^ n) x) y ↔ same_cycle f x y :=
  by 
    split 
    ·
      rintro ⟨k, rfl⟩
      use k+n 
      simp [zpow_add]
    ·
      rintro ⟨k, rfl⟩
      use k - n 
      rw [←zpow_coe_nat, ←mul_apply, ←zpow_add, Int.sub_add_cancel]

@[simp]
theorem same_cycle_zpow_left_iff {f : perm β} {x y : β} {n : ℤ} : same_cycle f ((f ^ n) x) y ↔ same_cycle f x y :=
  by 
    cases n
    ·
      exact same_cycle_pow_left_iff
    ·
      rw [zpow_neg_succ_of_nat, ←inv_pow, ←same_cycle_inv, same_cycle_pow_left_iff, same_cycle_inv]

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Unlike `support_congr`, which assumes that `∀ (x ∈ g.support), f x = g x)`, here
we have the weaker assumption that `∀ (x ∈ f.support), f x = g x`. -/
theorem is_cycle.support_congr
[fintype α]
{f g : perm α}
(hf : is_cycle f)
(hg : is_cycle g)
(h : «expr ⊆ »(f.support, g.support))
(h' : ∀ x «expr ∈ » f.support, «expr = »(f x, g x)) : «expr = »(f, g) :=
begin
  have [] [":", expr «expr = »(f.support, g.support)] [],
  { refine [expr le_antisymm h _],
    intros [ident z, ident hz],
    obtain ["⟨", ident x, ",", ident hx, ",", ident hf', "⟩", ":=", expr id hf],
    have [ident hx'] [":", expr «expr ≠ »(g x, x)] [],
    { rwa ["[", "<-", expr h' x (mem_support.mpr hx), "]"] [] },
    obtain ["⟨", ident m, ",", ident hm, "⟩", ":=", expr hg.exists_pow_eq hx' (mem_support.mp hz)],
    have [ident h''] [":", expr ∀ x «expr ∈ » «expr ∩ »(f.support, g.support), «expr = »(f x, g x)] [],
    { intros [ident x, ident hx],
      exact [expr h' x (mem_of_mem_inter_left hx)] },
    rwa ["[", "<-", expr hm, ",", "<-", expr pow_eq_on_of_mem_support h'' _ x (mem_inter_of_mem (mem_support.mpr hx) (mem_support.mpr hx')), ",", expr pow_apply_mem_support, ",", expr mem_support, "]"] [] },
  refine [expr support_congr h _],
  simpa [] [] [] ["[", "<-", expr this, "]"] [] ["using", expr h']
end

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If two cyclic permutations agree on all terms in their intersection,
and that intersection is not empty, then the two cyclic permutations must be equal. -/
theorem is_cycle.eq_on_support_inter_nonempty_congr
[fintype α]
{f g : perm α}
(hf : is_cycle f)
(hg : is_cycle g)
(h : ∀ x «expr ∈ » «expr ∩ »(f.support, g.support), «expr = »(f x, g x))
{x : α}
(hx : «expr = »(f x, g x))
(hx' : «expr ∈ »(x, f.support)) : «expr = »(f, g) :=
begin
  have [ident hx''] [":", expr «expr ∈ »(x, g.support)] [],
  { rwa ["[", expr mem_support, ",", "<-", expr hx, ",", "<-", expr mem_support, "]"] [] },
  have [] [":", expr «expr ⊆ »(f.support, g.support)] [],
  { intros [ident y, ident hy],
    obtain ["⟨", ident k, ",", ident rfl, "⟩", ":=", expr hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy)],
    rwa ["[", expr pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), ",", expr pow_apply_mem_support, "]"] [] },
  rw [expr (inter_eq_left_iff_subset _ _).mpr this] ["at", ident h],
  exact [expr hf.support_congr hg this h]
end

theorem is_cycle.support_pow_eq_iff [Fintype α] {f : perm α} (hf : is_cycle f) {n : ℕ} :
  support (f ^ n) = support f ↔ ¬orderOf f ∣ n :=
  by 
    rw [order_of_dvd_iff_pow_eq_one]
    split 
    ·
      intro h H 
      refine' hf.ne_one _ 
      rw [←support_eq_empty_iff, ←h, H, support_one]
    ·
      intro H 
      apply le_antisymmₓ (support_pow_le _ n) _ 
      intro x hx 
      contrapose! H 
      ext z 
      byCases' hz : f z = z
      ·
        rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply]
      ·
        obtain ⟨k, rfl⟩ := hf.exists_pow_eq hz (mem_support.mp hx)
        apply (f ^ k).Injective 
        rw [←mul_apply, (Commute.pow_pow_self _ _ _).Eq, mul_apply]
        simpa using H

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_cycle.pow_iff
[fintype β]
{f : perm β}
(hf : is_cycle f)
{n : exprℕ()} : «expr ↔ »(is_cycle «expr ^ »(f, n), n.coprime (order_of f)) :=
begin
  classical,
  split,
  { intro [ident h],
    have [ident hr] [":", expr «expr = »(support «expr ^ »(f, n), support f)] [],
    { rw [expr hf.support_pow_eq_iff] [],
      rintro ["⟨", ident k, ",", ident rfl, "⟩"],
      refine [expr h.ne_one _],
      simp [] [] [] ["[", expr pow_mul, ",", expr pow_order_of_eq_one, "]"] [] [] },
    have [] [":", expr «expr = »(order_of «expr ^ »(f, n), order_of f)] [],
    { rw ["[", expr order_of_is_cycle h, ",", expr hr, ",", expr order_of_is_cycle hf, "]"] [] },
    rw ["[", expr order_of_pow, ",", expr nat.div_eq_self, "]"] ["at", ident this],
    cases [expr this] [],
    { exact [expr absurd this (order_of_pos _).ne'] },
    { rwa ["[", expr nat.coprime_iff_gcd_eq_one, ",", expr nat.gcd_comm, "]"] [] } },
  { intro [ident h],
    obtain ["⟨", ident m, ",", ident hm, "⟩", ":=", expr exists_pow_eq_self_of_coprime h],
    have [ident hf'] [":", expr is_cycle «expr ^ »(«expr ^ »(f, n), m)] [":=", expr by rwa [expr hm] []],
    refine [expr is_cycle_of_is_cycle_pow hf' _],
    intros [ident x, ident hx],
    rw ["[", expr hm, "]"] [],
    exact [expr support_pow_le _ n hx] }
end

theorem is_cycle.pow_eq_one_iff [Fintype α] {f : perm α} (hf : is_cycle f) {n : ℕ} :
  f ^ n = 1 ↔ ∃ (x : _)(_ : x ∈ f.support), (f ^ n) x = x :=
  by 
    split 
    ·
      intro h 
      obtain ⟨x, hx, -⟩ := id hf 
      exact
        ⟨x, mem_support.mpr hx,
          by 
            simp [h]⟩
    ·
      rintro ⟨x, hx, hx'⟩
      byCases' h : support (f ^ n) = support f
      ·
        rw [←h, mem_support] at hx 
        contradiction
      ·
        rw [hf.support_pow_eq_iff, not_not] at h 
        obtain ⟨k, rfl⟩ := h 
        rw [pow_mulₓ, pow_order_of_eq_one, one_pow]

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_cycle.mem_support_pos_pow_iff_of_lt_order_of
[fintype α]
{f : perm α}
(hf : is_cycle f)
{n : exprℕ()}
(npos : «expr < »(0, n))
(hn : «expr < »(n, order_of f))
{x : α} : «expr ↔ »(«expr ∈ »(x, «expr ^ »(f, n).support), «expr ∈ »(x, f.support)) :=
begin
  have [] [":", expr «expr¬ »(«expr ∣ »(order_of f, n))] [":=", expr nat.not_dvd_of_pos_of_lt npos hn],
  rw ["<-", expr hf.support_pow_eq_iff] ["at", ident this],
  rw [expr this] []
end

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_cycle.is_cycle_pow_pos_of_lt_prime_order
[fintype β]
{f : perm β}
(hf : is_cycle f)
(hf' : (order_of f).prime)
(n : exprℕ())
(hn : «expr < »(0, n))
(hn' : «expr < »(n, order_of f)) : is_cycle «expr ^ »(f, n) :=
begin
  classical,
  have [] [":", expr n.coprime (order_of f)] [],
  { refine [expr nat.coprime.symm _],
    rw [expr nat.prime.coprime_iff_not_dvd hf'] [],
    exact [expr nat.not_dvd_of_pos_of_lt hn hn'] },
  obtain ["⟨", ident m, ",", ident hm, "⟩", ":=", expr exists_pow_eq_self_of_coprime this],
  have [ident hf''] [] [":=", expr hf],
  rw ["<-", expr hm] ["at", ident hf''],
  refine [expr is_cycle_of_is_cycle_pow hf'' _],
  rw ["[", expr hm, "]"] [],
  exact [expr support_pow_le f n]
end

/-!
### `cycle_of`
-/


/-- `f.cycle_of x` is the cycle of the permutation `f` to which `x` belongs. -/
def cycle_of [Fintype α] (f : perm α) (x : α) : perm α :=
  of_subtype (@subtype_perm _ f (same_cycle f x) fun _ => same_cycle_apply.symm)

theorem cycle_of_apply [Fintype α] (f : perm α) (x y : α) : cycle_of f x y = if same_cycle f x y then f y else y :=
  rfl

theorem cycle_of_inv [Fintype α] (f : perm α) (x : α) : cycle_of f x⁻¹ = cycle_of (f⁻¹) x :=
  Equiv.ext$
    fun y =>
      by 
        rw [inv_eq_iff_eq, cycle_of_apply, cycle_of_apply]
        splitIfs <;> simp_all [same_cycle_inv, same_cycle_inv_apply]

@[simp]
theorem cycle_of_pow_apply_self [Fintype α] (f : perm α) (x : α) : ∀ (n : ℕ), (cycle_of f x ^ n) x = (f ^ n) x
| 0 => rfl
| n+1 =>
  by 
    rw [pow_succₓ, mul_apply, cycle_of_apply, cycle_of_pow_apply_self, if_pos, pow_succₓ, mul_apply]
    exact ⟨n, rfl⟩

@[simp]
theorem cycle_of_zpow_apply_self [Fintype α] (f : perm α) (x : α) : ∀ (n : ℤ), (cycle_of f x ^ n) x = (f ^ n) x
| (n : ℕ) => cycle_of_pow_apply_self f x n
| -[1+ n] =>
  by 
    rw [zpow_neg_succ_of_nat, ←inv_pow, cycle_of_inv, zpow_neg_succ_of_nat, ←inv_pow, cycle_of_pow_apply_self]

theorem same_cycle.cycle_of_apply [Fintype α] {f : perm α} {x y : α} (h : same_cycle f x y) : cycle_of f x y = f y :=
  dif_pos h

theorem cycle_of_apply_of_not_same_cycle [Fintype α] {f : perm α} {x y : α} (h : ¬same_cycle f x y) :
  cycle_of f x y = y :=
  dif_neg h

theorem same_cycle.cycle_of_eq [Fintype α] {f : perm α} {x y : α} (h : same_cycle f x y) :
  cycle_of f x = cycle_of f y :=
  by 
    ext z 
    rw [cycle_of_apply]
    splitIfs with hz hz
    ·
      exact (h.symm.trans hz).cycle_of_apply.symm
    ·
      exact (cycle_of_apply_of_not_same_cycle (mt h.trans hz)).symm

@[simp]
theorem cycle_of_apply_apply_zpow_self [Fintype α] (f : perm α) (x : α) (k : ℤ) :
  cycle_of f x ((f ^ k) x) = (f ^ k+1) x :=
  by 
    rw [same_cycle.cycle_of_apply]
    ·
      rw [add_commₓ, zpow_add, zpow_one, mul_apply]
    ·
      exact ⟨k, rfl⟩

@[simp]
theorem cycle_of_apply_apply_pow_self [Fintype α] (f : perm α) (x : α) (k : ℕ) :
  cycle_of f x ((f ^ k) x) = (f ^ k+1) x :=
  by 
    convert cycle_of_apply_apply_zpow_self f x k using 1

@[simp]
theorem cycle_of_apply_apply_self [Fintype α] (f : perm α) (x : α) : cycle_of f x (f x) = f (f x) :=
  by 
    convert cycle_of_apply_apply_pow_self f x 1 using 1

@[simp]
theorem cycle_of_apply_self [Fintype α] (f : perm α) (x : α) : cycle_of f x x = f x :=
  (same_cycle.refl _ _).cycle_of_apply

theorem is_cycle.cycle_of_eq [Fintype α] {f : perm α} (hf : is_cycle f) {x : α} (hx : f x ≠ x) : cycle_of f x = f :=
  Equiv.ext$
    fun y =>
      if h : same_cycle f x y then
        by 
          rw [h.cycle_of_apply]
      else
        by 
          rw [cycle_of_apply_of_not_same_cycle h, not_not.1 (mt ((same_cycle_cycle hx).1 hf).2 h)]

@[simp]
theorem cycle_of_eq_one_iff [Fintype α] (f : perm α) {x : α} : cycle_of f x = 1 ↔ f x = x :=
  by 
    simpRw [ext_iff, cycle_of_apply, one_apply]
    refine' ⟨fun h => (if_pos (same_cycle.refl f x)).symm.trans (h x), fun h y => _⟩
    byCases' hy : f y = y
    ·
      rw [hy, if_t_t]
    ·
      exact
        if_neg
          (mt same_cycle.apply_eq_self_iff
            (by 
              tauto))

@[simp]
theorem cycle_of_self_apply [Fintype α] (f : perm α) (x : α) : cycle_of f (f x) = cycle_of f x :=
  (same_cycle_apply.mpr (same_cycle.refl _ _)).symm.cycle_of_eq

@[simp]
theorem cycle_of_self_apply_pow [Fintype α] (f : perm α) (n : ℕ) (x : α) : cycle_of f ((f ^ n) x) = cycle_of f x :=
  (same_cycle_pow_left_iff.mpr (same_cycle.refl _ _)).cycle_of_eq

@[simp]
theorem cycle_of_self_apply_zpow [Fintype α] (f : perm α) (n : ℤ) (x : α) : cycle_of f ((f ^ n) x) = cycle_of f x :=
  (same_cycle_zpow_left_iff.mpr (same_cycle.refl _ _)).cycle_of_eq

theorem is_cycle.cycle_of [Fintype α] {f : perm α} (hf : is_cycle f) {x : α} :
  cycle_of f x = if f x = x then 1 else f :=
  by 
    byCases' hx : f x = x
    ·
      rwa [if_pos hx, cycle_of_eq_one_iff]
    ·
      rwa [if_neg hx, hf.cycle_of_eq]

theorem cycle_of_one [Fintype α] (x : α) : cycle_of 1 x = 1 :=
  (cycle_of_eq_one_iff 1).mpr rfl

theorem is_cycle_cycle_of [Fintype α] (f : perm α) {x : α} (hx : f x ≠ x) : is_cycle (cycle_of f x) :=
  have  : cycle_of f x x ≠ x :=
    by 
      rwa [(same_cycle.refl _ _).cycle_of_apply]
  (same_cycle_cycle this).2$
    fun y =>
      ⟨fun h => mt h.apply_eq_self_iff.2 this,
        fun h =>
          if hxy : same_cycle f x y then
            let ⟨i, hi⟩ := hxy
            ⟨i,
              by 
                rw [cycle_of_zpow_apply_self, hi]⟩
          else
            by 
              rw [cycle_of_apply_of_not_same_cycle hxy] at h 
              exact (h rfl).elim⟩

@[simp]
theorem two_le_card_support_cycle_of_iff [Fintype α] {f : perm α} {x : α} : 2 ≤ card (cycle_of f x).support ↔ f x ≠ x :=
  by 
    refine'
      ⟨fun h => _,
        fun h =>
          by 
            simpa using (is_cycle_cycle_of _ h).two_le_card_support⟩
    contrapose! h 
    rw [←cycle_of_eq_one_iff] at h 
    simp [h]

@[simp]
theorem card_support_cycle_of_pos_iff [Fintype α] {f : perm α} {x : α} : 0 < card (cycle_of f x).support ↔ f x ≠ x :=
  by 
    rw [←two_le_card_support_cycle_of_iff, ←Nat.succ_le_iff]
    exact ⟨fun h => Or.resolve_left h.eq_or_lt (card_support_ne_one _).symm, zero_lt_two.trans_le⟩

theorem pow_apply_eq_pow_mod_order_of_cycle_of_apply [Fintype α] (f : perm α) (n : ℕ) (x : α) :
  (f ^ n) x = (f ^ (n % orderOf (cycle_of f x))) x :=
  by 
    rw [←cycle_of_pow_apply_self f, ←cycle_of_pow_apply_self f, pow_eq_mod_order_of]

theorem cycle_of_mul_of_apply_right_eq_self [Fintype α] {f g : perm α} (h : _root_.commute f g) (x : α) (hx : g x = x) :
  (f*g).cycleOf x = f.cycle_of x :=
  by 
    ext y 
    byCases' hxy : (f*g).SameCycle x y
    ·
      obtain ⟨z, rfl⟩ := hxy 
      rw [cycle_of_apply_apply_zpow_self]
      simp [h.mul_zpow, zpow_apply_eq_self_of_apply_eq_self hx]
    ·
      rw [cycle_of_apply_of_not_same_cycle hxy, cycle_of_apply_of_not_same_cycle]
      contrapose! hxy 
      obtain ⟨z, rfl⟩ := hxy 
      refine' ⟨z, _⟩
      simp [h.mul_zpow, zpow_apply_eq_self_of_apply_eq_self hx]

theorem disjoint.cycle_of_mul_distrib [Fintype α] {f g : perm α} (h : f.disjoint g) (x : α) :
  (f*g).cycleOf x = f.cycle_of x*g.cycle_of x :=
  by 
    cases' (disjoint_iff_eq_or_eq.mp h) x with hfx hgx
    ·
      simp [h.commute.eq, cycle_of_mul_of_apply_right_eq_self h.symm.commute, hfx]
    ·
      simp [cycle_of_mul_of_apply_right_eq_self h.commute, hgx]

theorem support_cycle_of_eq_nil_iff [Fintype α] {f : perm α} {x : α} : (f.cycle_of x).support = ∅ ↔ x ∉ f.support :=
  by 
    simp 

theorem support_cycle_of_le [Fintype α] (f : perm α) (x : α) : support (f.cycle_of x) ≤ support f :=
  by 
    intro y hy 
    rw [mem_support, cycle_of_apply] at hy 
    splitIfs  at hy
    ·
      exact mem_support.mpr hy
    ·
      exact absurd rfl hy

theorem mem_support_cycle_of_iff [Fintype α] {f : perm α} {x y : α} :
  y ∈ support (f.cycle_of x) ↔ same_cycle f x y ∧ x ∈ support f :=
  by 
    byCases' hx : f x = x
    ·
      rw [(cycle_of_eq_one_iff _).mpr hx]
      simp [hx]
    ·
      rw [mem_support, cycle_of_apply]
      splitIfs with hy
      ·
        simp only [hx, hy, iff_trueₓ, Ne.def, not_false_iff, and_selfₓ, mem_support]
        rcases hy with ⟨k, rfl⟩
        rw [←not_mem_support]
        simpa using hx
      ·
        simpa [hx] using hy

theorem same_cycle.mem_support_iff [Fintype α] {f : perm α} {x y : α} (h : same_cycle f x y) :
  x ∈ support f ↔ y ∈ support f :=
  ⟨fun hx => support_cycle_of_le f x (mem_support_cycle_of_iff.mpr ⟨h, hx⟩),
    fun hy => support_cycle_of_le f y (mem_support_cycle_of_iff.mpr ⟨h.symm, hy⟩)⟩

theorem pow_mod_card_support_cycle_of_self_apply [Fintype α] (f : perm α) (n : ℕ) (x : α) :
  (f ^ (n % (f.cycle_of x).support.card)) x = (f ^ n) x :=
  by 
    byCases' hx : f x = x
    ·
      rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx]
    ·
      rw [←cycle_of_pow_apply_self, ←cycle_of_pow_apply_self f, ←order_of_is_cycle (is_cycle_cycle_of f hx),
        ←pow_eq_mod_order_of]

/-!
### `cycle_factors`
-/


-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- Given a list `l : list α` and a permutation `f : perm α` whose nonfixed points are all in `l`,
  recursively factors `f` into cycles. -/
def cycle_factors_aux
[fintype α] : ∀
(l : list α)
(f : perm α), ∀
{x}, «expr ≠ »(f x, x) → «expr ∈ »(x, l) → {l : list (perm α) // «expr ∧ »(«expr = »(l.prod, f), «expr ∧ »(∀
  g «expr ∈ » l, is_cycle g, l.pairwise disjoint))}
| «expr[ , ]»([]), f, h := ⟨«expr[ , ]»([]), by { simp [] [] ["only"] ["[", expr imp_false, ",", expr list.pairwise.nil, ",", expr list.not_mem_nil, ",", expr forall_const, ",", expr and_true, ",", expr forall_prop_of_false, ",", expr not_not, ",", expr not_false_iff, ",", expr list.prod_nil, "]"] [] ["at", "*"],
   ext [] [] [],
   simp [] [] [] ["*"] [] [] }⟩
| [«expr :: »/«expr :: »/«expr :: »](x, l), f, h := if hx : «expr = »(f x, x) then cycle_factors_aux l f (λ
 y
 hy, list.mem_of_ne_of_mem (λ
  h, hy (by rwa [expr h] [])) (h hy)) else let ⟨m, hm₁, hm₂, hm₃⟩ := cycle_factors_aux l «expr * »(«expr ⁻¹»(cycle_of f x), f) (λ
     y
     hy, list.mem_of_ne_of_mem (λ
      h : «expr = »(y, x), by { rw ["[", expr h, ",", expr mul_apply, ",", expr ne.def, ",", expr inv_eq_iff_eq, ",", expr cycle_of_apply_self, "]"] ["at", ident hy],
        exact [expr hy rfl] }) (h (λ
       h : «expr = »(f y, y), by { rw ["[", expr mul_apply, ",", expr h, ",", expr ne.def, ",", expr inv_eq_iff_eq, ",", expr cycle_of_apply, "]"] ["at", ident hy],
         split_ifs ["at", ident hy] []; cc }))) in
⟨[«expr :: »/«expr :: »/«expr :: »](cycle_of f x, m), by { rw ["[", expr list.prod_cons, ",", expr hm₁, "]"] [],
   simp [] [] [] [] [] [] }, λ
 g
 hg, ((list.mem_cons_iff _ _ _).1 hg).elim (λ
  hg, «expr ▸ »(hg.symm, is_cycle_cycle_of _ hx)) (hm₂ g), list.pairwise_cons.2 ⟨λ
  g
  hg
  y, or_iff_not_imp_left.2 (λ hfy, have hxy : same_cycle f x y := not_not.1 (mt cycle_of_apply_of_not_same_cycle hfy),
   have hgm : «expr ~ »([«expr :: »/«expr :: »/«expr :: »](g, m.erase g), m) := list.cons_perm_iff_perm_erase.2 ⟨hg, list.perm.refl _⟩,
   have ∀
   h «expr ∈ » m.erase g, disjoint g h, from (list.pairwise_cons.1 ((hgm.pairwise_iff (λ
       (a b)
       (h : disjoint a b), h.symm)).2 hm₃)).1,
   «expr $ »(classical.by_cases id, λ
    hgy : «expr ≠ »(g y, y), «expr $ »((disjoint_prod_right _ this y).resolve_right, have hsc : same_cycle «expr ⁻¹»(f) x (f y), by rwa ["[", expr same_cycle_inv, ",", expr same_cycle_apply, "]"] [],
     by { rw ["[", expr disjoint_prod_perm hm₃ hgm.symm, ",", expr list.prod_cons, ",", "<-", expr eq_inv_mul_iff_mul_eq, "]"] ["at", ident hm₁],
       rwa ["[", expr hm₁, ",", expr mul_apply, ",", expr mul_apply, ",", expr cycle_of_inv, ",", expr hsc.cycle_of_apply, ",", expr inv_apply_self, ",", expr inv_eq_iff_eq, ",", expr eq_comm, "]"] [] }))), hm₃⟩⟩

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem mem_list_cycles_iff
{α : Type*}
[fintype α]
{l : list (perm α)}
(h1 : ∀ σ : perm α, «expr ∈ »(σ, l) → σ.is_cycle)
(h2 : l.pairwise disjoint)
{σ : perm α} : «expr ↔ »(«expr ∈ »(σ, l), «expr ∧ »(σ.is_cycle, ∀
  (a : α)
  (h4 : «expr ≠ »(σ a, a)), «expr = »(σ a, l.prod a))) :=
begin
  suffices [] [":", expr σ.is_cycle → «expr ↔ »(«expr ∈ »(σ, l), ∀
    (a : α)
    (h4 : «expr ≠ »(σ a, a)), «expr = »(σ a, l.prod a))],
  { exact [expr ⟨λ hσ, ⟨h1 σ hσ, (this (h1 σ hσ)).mp hσ⟩, λ hσ, (this hσ.1).mpr hσ.2⟩] },
  intro [ident h3],
  classical,
  split,
  { intros [ident h, ident a, ident ha],
    exact [expr eq_on_support_mem_disjoint h h2 _ (mem_support.mpr ha)] },
  { intros [ident h],
    have [ident hσl] [":", expr «expr ⊆ »(σ.support, l.prod.support)] [],
    { intros [ident x, ident hx],
      rw [expr mem_support] ["at", ident hx],
      rwa ["[", expr mem_support, ",", "<-", expr h _ hx, "]"] [] },
    obtain ["⟨", ident a, ",", ident ha, ",", "-", "⟩", ":=", expr id h3],
    rw ["<-", expr mem_support] ["at", ident ha],
    obtain ["⟨", ident τ, ",", ident hτ, ",", ident hτa, "⟩", ":=", expr exists_mem_support_of_mem_support_prod (hσl ha)],
    have [ident hτl] [":", expr ∀
     x «expr ∈ » τ.support, «expr = »(τ x, l.prod x)] [":=", expr eq_on_support_mem_disjoint hτ h2],
    have [ident key] [":", expr ∀ x «expr ∈ » «expr ∩ »(σ.support, τ.support), «expr = »(σ x, τ x)] [],
    { intros [ident x, ident hx],
      rw ["[", expr h x (mem_support.mp (mem_of_mem_inter_left hx)), ",", expr hτl x (mem_of_mem_inter_right hx), "]"] [] },
    convert [] [expr hτ] [],
    refine [expr h3.eq_on_support_inter_nonempty_congr (h1 _ hτ) key _ ha],
    exact [expr key a (mem_inter_of_mem ha hτa)] }
end

theorem list_cycles_perm_list_cycles {α : Type _} [Fintype α] {l₁ l₂ : List (perm α)} (h₀ : l₁.prod = l₂.prod)
  (h₁l₁ : ∀ (σ : perm α), σ ∈ l₁ → σ.is_cycle) (h₁l₂ : ∀ (σ : perm α), σ ∈ l₂ → σ.is_cycle)
  (h₂l₁ : l₁.pairwise Disjoint) (h₂l₂ : l₂.pairwise Disjoint) : l₁ ~ l₂ :=
  by 
    classical 
    refine'
      (List.perm_ext (nodup_of_pairwise_disjoint_cycles h₁l₁ h₂l₁) (nodup_of_pairwise_disjoint_cycles h₁l₂ h₂l₂)).mpr
        fun σ => _ 
    byCases' hσ : σ.is_cycle
    ·
      obtain ⟨a, ha⟩ := not_forall.mp (mt ext hσ.ne_one)
      rw [mem_list_cycles_iff h₁l₁ h₂l₁, mem_list_cycles_iff h₁l₂ h₂l₂, h₀]
    ·
      exact iff_of_false (mt (h₁l₁ σ) hσ) (mt (h₁l₂ σ) hσ)

/-- Factors a permutation `f` into a list of disjoint cyclic permutations that multiply to `f`. -/
def cycle_factors [Fintype α] [LinearOrderₓ α] (f : perm α) :
  { l : List (perm α) // l.prod = f ∧ (∀ g (_ : g ∈ l), is_cycle g) ∧ l.pairwise Disjoint } :=
  cycle_factors_aux (univ.sort (· ≤ ·)) f fun _ _ => (mem_sort _).2 (mem_univ _)

/-- Factors a permutation `f` into a list of disjoint cyclic permutations that multiply to `f`,
  without a linear order. -/
def trunc_cycle_factors [Fintype α] (f : perm α) :
  Trunc { l : List (perm α) // l.prod = f ∧ (∀ g (_ : g ∈ l), is_cycle g) ∧ l.pairwise Disjoint } :=
  Quotientₓ.recOnSubsingleton (@univ α _).1 (fun l h => Trunc.mk (cycle_factors_aux l f h))
    (show ∀ x, f x ≠ x → x ∈ (@univ α _).1 from fun _ _ => mem_univ _)

section CycleFactorsFinset

variable[Fintype α](f : perm α)

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- Factors a permutation `f` into a `finset` of disjoint cyclic permutations that multiply to `f`.
-/ def cycle_factors_finset : finset (perm α) :=
(trunc_cycle_factors f).lift (λ
 l : {l : list (perm α) // «expr ∧ »(«expr = »(l.prod, f), «expr ∧ »(∀
   g «expr ∈ » l, is_cycle g, l.pairwise disjoint))}, l.val.to_finset) (λ
 ⟨l, hl⟩
 ⟨l', hl'⟩, list.to_finset_eq_of_perm _ _ (list_cycles_perm_list_cycles «expr ▸ »(hl'.left.symm, hl.left) hl.right.left hl'.right.left hl.right.right hl'.right.right))

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem cycle_factors_finset_eq_list_to_finset
{σ : perm α}
{l : list (perm α)}
(hn : l.nodup) : «expr ↔ »(«expr = »(σ.cycle_factors_finset, l.to_finset), «expr ∧ »(∀
  f : perm α, «expr ∈ »(f, l) → f.is_cycle, «expr ∧ »(l.pairwise disjoint, «expr = »(l.prod, σ)))) :=
begin
  obtain ["⟨", "⟨", ident l', ",", ident hp', ",", ident hc', ",", ident hd', "⟩", ",", ident hl, "⟩", ":=", expr trunc.exists_rep σ.trunc_cycle_factors],
  have [ident ht] [":", expr «expr = »(cycle_factors_finset σ, l'.to_finset)] [],
  { rw ["[", expr cycle_factors_finset, ",", "<-", expr hl, ",", expr trunc.lift_mk, "]"] [] },
  rw [expr ht] [],
  split,
  { intro [ident h],
    have [ident hn'] [":", expr l'.nodup] [":=", expr nodup_of_pairwise_disjoint_cycles hc' hd'],
    have [ident hperm] [":", expr «expr ~ »(l, l')] [":=", expr list.perm_of_nodup_nodup_to_finset_eq hn hn' h.symm],
    refine [expr ⟨_, _, _⟩],
    { exact [expr λ _ h, hc' _ (hperm.subset h)] },
    { rwa [expr list.perm.pairwise_iff disjoint.symmetric hperm] [] },
    { rw ["[", "<-", expr hp', ",", expr hperm.symm.prod_eq', "]"] [],
      refine [expr hd'.imp _],
      exact [expr λ _ _, disjoint.commute] } },
  { rintro ["⟨", ident hc, ",", ident hd, ",", ident hp, "⟩"],
    refine [expr list.to_finset_eq_of_perm _ _ _],
    refine [expr list_cycles_perm_list_cycles _ hc' hc hd' hd],
    rw ["[", expr hp, ",", expr hp', "]"] [] }
end

theorem cycle_factors_finset_eq_finset {σ : perm α} {s : Finset (perm α)} :
  σ.cycle_factors_finset = s ↔
    (∀ (f : perm α), f ∈ s → f.is_cycle) ∧
      ∃ h : ∀ a (_ : a ∈ s) b (_ : b ∈ s), a ≠ b → Disjoint a b,
        (s.noncomm_prod id
            fun a ha b hb =>
              (em (a = b)).byCases (fun h => h ▸ Commute.refl a)
                (Set.Pairwise.mono' (fun _ _ => disjoint.commute) h a ha b hb)) =
          σ :=
  by 
    obtain ⟨l, hl, rfl⟩ := s.exists_list_nodup_eq 
    rw [cycle_factors_finset_eq_list_to_finset hl]
    simp only [noncomm_prod_to_finset, hl, exists_prop, List.mem_to_finset, And.congr_left_iff, And.congr_right_iff,
      List.map_id, Ne.def]
    intros 
    exact ⟨List.forall_of_pairwise disjoint.symmetric, hl.pairwise_of_forall_ne⟩

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem cycle_factors_finset_pairwise_disjoint
(p : perm α)
(hp : «expr ∈ »(p, cycle_factors_finset f))
(q : perm α)
(hq : «expr ∈ »(q, cycle_factors_finset f))
(h : «expr ≠ »(p, q)) : disjoint p q :=
begin
  have [] [":", expr «expr = »(f.cycle_factors_finset, f.cycle_factors_finset)] [":=", expr rfl],
  obtain ["⟨", "-", ",", ident hd, ",", "-", "⟩", ":=", expr cycle_factors_finset_eq_finset.mp this],
  exact [expr hd p hp q hq h]
end

theorem cycle_factors_finset_mem_commute (p : perm α) (hp : p ∈ cycle_factors_finset f) (q : perm α)
  (hq : q ∈ cycle_factors_finset f) : _root_.commute p q :=
  by 
    byCases' h : p = q
    ·
      exact h ▸ Commute.refl _
    ·
      exact (cycle_factors_finset_pairwise_disjoint _ _ hp _ hq h).Commute

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The product of cycle factors is equal to the original `f : perm α`. -/
theorem cycle_factors_finset_noncomm_prod
(comm : ∀
 (g «expr ∈ » f.cycle_factors_finset)
 (h «expr ∈ » f.cycle_factors_finset), commute (id g) (id h) := cycle_factors_finset_mem_commute f) : «expr = »(f.cycle_factors_finset.noncomm_prod id comm, f) :=
begin
  have [] [":", expr «expr = »(f.cycle_factors_finset, f.cycle_factors_finset)] [":=", expr rfl],
  obtain ["⟨", "-", ",", ident hd, ",", ident hp, "⟩", ":=", expr cycle_factors_finset_eq_finset.mp this],
  exact [expr hp]
end

theorem mem_cycle_factors_finset_iff {f p : perm α} :
  p ∈ cycle_factors_finset f ↔ p.is_cycle ∧ ∀ a (_ : a ∈ p.support), p a = f a :=
  by 
    obtain ⟨l, hl, hl'⟩ := f.cycle_factors_finset.exists_list_nodup_eq 
    rw [←hl']
    rw [eq_comm, cycle_factors_finset_eq_list_to_finset hl] at hl' 
    simpa [List.mem_to_finset, Ne.def, ←hl'.right.right] using mem_list_cycles_iff hl'.left hl'.right.left

theorem cycle_of_mem_cycle_factors_finset_iff {f : perm α} {x : α} :
  cycle_of f x ∈ cycle_factors_finset f ↔ x ∈ f.support :=
  by 
    rw [mem_cycle_factors_finset_iff]
    split 
    ·
      rintro ⟨hc, h⟩
      contrapose! hc 
      rw [not_mem_support, ←cycle_of_eq_one_iff] at hc 
      simp [hc]
    ·
      intro hx 
      refine' ⟨is_cycle_cycle_of _ (mem_support.mp hx), _⟩
      intro y hy 
      rw [mem_support] at hy 
      rw [cycle_of_apply]
      splitIfs with H
      ·
        rfl
      ·
        rw [cycle_of_apply_of_not_same_cycle H] at hy 
        contradiction

theorem mem_cycle_factors_finset_support_le {p f : perm α} (h : p ∈ cycle_factors_finset f) : p.support ≤ f.support :=
  by 
    rw [mem_cycle_factors_finset_iff] at h 
    intro x hx 
    rwa [mem_support, ←h.right x hx, ←mem_support]

theorem cycle_factors_finset_eq_empty_iff {f : perm α} : cycle_factors_finset f = ∅ ↔ f = 1 :=
  by 
    simpa [cycle_factors_finset_eq_finset] using eq_comm

@[simp]
theorem cycle_factors_finset_one : cycle_factors_finset (1 : perm α) = ∅ :=
  by 
    simp [cycle_factors_finset_eq_empty_iff]

@[simp]
theorem cycle_factors_finset_eq_singleton_self_iff {f : perm α} : f.cycle_factors_finset = {f} ↔ f.is_cycle :=
  by 
    simp [cycle_factors_finset_eq_finset]

theorem is_cycle.cycle_factors_finset_eq_singleton {f : perm α} (hf : is_cycle f) : f.cycle_factors_finset = {f} :=
  cycle_factors_finset_eq_singleton_self_iff.mpr hf

theorem cycle_factors_finset_eq_singleton_iff {f g : perm α} : f.cycle_factors_finset = {g} ↔ f.is_cycle ∧ f = g :=
  by 
    suffices  : f = g → (g.is_cycle ↔ f.is_cycle)
    ·
      simpa [cycle_factors_finset_eq_finset, eq_comm]
    rintro rfl 
    exact Iff.rfl

/-- Two permutations `f g : perm α` have the same cycle factors iff they are the same. -/
theorem cycle_factors_finset_injective : Function.Injective (@cycle_factors_finset α _ _) :=
  by 
    intro f g h 
    rw [←cycle_factors_finset_noncomm_prod f]
    simpa [h] using cycle_factors_finset_noncomm_prod g

theorem disjoint.disjoint_cycle_factors_finset {f g : perm α} (h : Disjoint f g) :
  _root_.disjoint (cycle_factors_finset f) (cycle_factors_finset g) :=
  by 
    rw [disjoint_iff_disjoint_support] at h 
    intro x hx 
    simp only [mem_cycle_factors_finset_iff, inf_eq_inter, mem_inter, mem_support] at hx 
    obtain ⟨⟨⟨a, ha, -⟩, hf⟩, -, hg⟩ := hx 
    refine' h (_ : a ∈ f.support ∩ g.support)
    simp [ha, ←hf a ha, ←hg a ha]

theorem disjoint.cycle_factors_finset_mul_eq_union {f g : perm α} (h : Disjoint f g) :
  cycle_factors_finset (f*g) = cycle_factors_finset f ∪ cycle_factors_finset g :=
  by 
    rw [cycle_factors_finset_eq_finset]
    split 
    ·
      simp only [mem_cycle_factors_finset_iff, mem_union]
      rintro _ (⟨h, -⟩ | ⟨h, -⟩) <;> exact h
    ·
      refine' ⟨_, _⟩
      ·
        simpRw [mem_union]
        rintro x (hx | hx) y (hy | hy) hxy
        ·
          exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy
        ·
          exact h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy)
        ·
          exact h.symm.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy)
        ·
          exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy
      ·
        rw [noncomm_prod_union_of_disjoint h.disjoint_cycle_factors_finset]
        rw [cycle_factors_finset_noncomm_prod, cycle_factors_finset_noncomm_prod]

theorem disjoint_mul_inv_of_mem_cycle_factors_finset {f g : perm α} (h : f ∈ cycle_factors_finset g) :
  Disjoint (g*f⁻¹) f :=
  by 
    rw [mem_cycle_factors_finset_iff] at h 
    intro x 
    byCases' hx : f x = x
    ·
      exact Or.inr hx
    ·
      refine' Or.inl _ 
      rw [mul_apply, ←h.right, apply_inv_self]
      rwa [←support_inv, apply_mem_support, support_inv, mem_support]

end CycleFactorsFinset

@[elab_as_eliminator]
theorem cycle_induction_on [Fintype β] (P : perm β → Prop) (σ : perm β) (base_one : P 1)
  (base_cycles : ∀ (σ : perm β), σ.is_cycle → P σ)
  (induction_disjoint : ∀ (σ τ : perm β), Disjoint σ τ → is_cycle σ → P σ → P τ → P (σ*τ)) : P σ :=
  by 
    suffices  : ∀ (l : List (perm β)), (∀ (τ : perm β), τ ∈ l → τ.is_cycle) → l.pairwise Disjoint → P l.prod
    ·
      classical 
      let x := σ.trunc_cycle_factors.out 
      exact (congr_argₓ P x.2.1).mp (this x.1 x.2.2.1 x.2.2.2)
    intro l 
    induction' l with σ l ih
    ·
      exact fun _ _ => base_one
    ·
      intro h1 h2 
      rw [List.prod_cons]
      exact
        induction_disjoint σ l.prod (disjoint_prod_right _ (list.pairwise_cons.mp h2).1)
          (h1 _ (List.mem_cons_selfₓ _ _)) (base_cycles σ (h1 σ (l.mem_cons_self σ)))
          (ih (fun τ hτ => h1 τ (List.mem_cons_of_memₓ σ hτ)) (List.pairwise_of_pairwise_cons h2))

theorem cycle_factors_finset_mul_inv_mem_eq_sdiff [Fintype α] {f g : perm α} (h : f ∈ cycle_factors_finset g) :
  cycle_factors_finset (g*f⁻¹) = cycle_factors_finset g \ {f} :=
  by 
    revert f 
    apply cycle_induction_on _ g
    ·
      simp 
    ·
      intro σ hσ f hf 
      simp only [cycle_factors_finset_eq_singleton_self_iff.mpr hσ, mem_singleton] at hf⊢
      simp [hf]
    ·
      intro σ τ hd hc hσ hτ f 
      simpRw [hd.cycle_factors_finset_mul_eq_union, mem_union]
      rintro (hf | hf)
      ·
        rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assocₓ,
          disjoint.cycle_factors_finset_mul_eq_union, hσ hf]
        ·
          rw [mem_cycle_factors_finset_iff] at hf 
          intro x 
          cases' hd.symm x with hx hx
          ·
            exact Or.inl hx
          ·
            refine' Or.inr _ 
            byCases' hfx : f x = x
            ·
              rw [←hfx]
              simpa [hx] using hfx.symm
            ·
              rw [mul_apply]
              rw [←hf.right _ (mem_support.mpr hfx)] at hx 
              contradiction
        ·
          exact fun H => hd.disjoint_cycle_factors_finset (mem_inter_of_mem hf H)
      ·
        rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assocₓ,
          disjoint.cycle_factors_finset_mul_eq_union, hτ hf]
        ·
          rw [mem_cycle_factors_finset_iff] at hf 
          intro x 
          cases' hd x with hx hx
          ·
            exact Or.inl hx
          ·
            refine' Or.inr _ 
            byCases' hfx : f x = x
            ·
              rw [←hfx]
              simpa [hx] using hfx.symm
            ·
              rw [mul_apply]
              rw [←hf.right _ (mem_support.mpr hfx)] at hx 
              contradiction
        ·
          exact fun H => hd.disjoint_cycle_factors_finset (mem_inter_of_mem H hf)

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem same_cycle.nat_of_mem_support
[fintype α]
(f : perm α)
{x y : α}
(h : same_cycle f x y)
(hx : «expr ∈ »(x, f.support)) : «expr∃ , »((i : exprℕ())
 (hi' : «expr < »(i, (f.cycle_of x).support.card)), «expr = »(«expr ^ »(f, i) x, y)) :=
begin
  revert [ident f],
  intro [ident f],
  apply [expr cycle_induction_on _ f],
  { simp [] [] [] [] [] [] },
  { intros [ident g, ident hg, ident H, ident hx],
    rw [expr mem_support] ["at", ident hx],
    rw ["[", expr hg.cycle_of_eq hx, ",", "<-", expr order_of_is_cycle hg, "]"] [],
    exact [expr H.nat'] },
  { rintros [ident g, ident h, ident hd, ident hg, ident IH, ident IH', "⟨", ident m, ",", ident rfl, "⟩", ident hx],
    cases [expr disjoint_iff_eq_or_eq.mp hd x] ["with", ident hgx, ident hhx],
    { have [ident hpow] [":", expr ∀ k : exprℤ(), «expr = »(«expr ^ »(«expr * »(g, h), k) x, «expr ^ »(h, k) x)] [],
      { intro [ident k],
        suffices [] [":", expr «expr = »(«expr ^ »(g, k) x, x)],
        { simpa [] [] [] ["[", expr hd.commute.eq, ",", expr hd.commute.symm.mul_zpow, "]"] [] [] },
        rw [expr zpow_apply_eq_self_of_apply_eq_self] [],
        simpa [] [] [] [] [] ["using", expr hgx] },
      obtain ["⟨", ident k, ",", ident hk, ",", ident hk', "⟩", ":=", expr IH' _ _],
      { refine [expr ⟨k, _, _⟩],
        { rw ["[", "<-", expr cycle_of_eq_one_iff, "]"] ["at", ident hgx],
          rwa ["[", expr hd.cycle_of_mul_distrib, ",", expr hgx, ",", expr one_mul, "]"] [] },
        { simpa [] [] [] ["[", "<-", expr zpow_coe_nat, ",", expr hpow, "]"] [] ["using", expr hk'] } },
      { use [expr m],
        simp [] [] [] ["[", expr hpow, "]"] [] [] },
      { rw ["[", expr mem_support, ",", expr hd.commute.eq, "]"] ["at", ident hx],
        simpa [] [] [] ["[", expr hgx, "]"] [] ["using", expr hx] } },
    { have [ident hpow] [":", expr ∀ k : exprℤ(), «expr = »(«expr ^ »(«expr * »(g, h), k) x, «expr ^ »(g, k) x)] [],
      { intro [ident k],
        suffices [] [":", expr «expr = »(«expr ^ »(h, k) x, x)],
        { simpa [] [] [] ["[", expr hd.commute.mul_zpow, "]"] [] [] },
        rw [expr zpow_apply_eq_self_of_apply_eq_self] [],
        simpa [] [] [] [] [] ["using", expr hhx] },
      obtain ["⟨", ident k, ",", ident hk, ",", ident hk', "⟩", ":=", expr IH _ _],
      { refine [expr ⟨k, _, _⟩],
        { rw ["[", "<-", expr cycle_of_eq_one_iff, "]"] ["at", ident hhx],
          rwa ["[", expr hd.cycle_of_mul_distrib, ",", expr hhx, ",", expr mul_one, "]"] [] },
        { simpa [] [] [] ["[", "<-", expr zpow_coe_nat, ",", expr hpow, "]"] [] ["using", expr hk'] } },
      { use [expr m],
        simp [] [] [] ["[", expr hpow, "]"] [] [] },
      { simpa [] [] [] ["[", expr hhx, "]"] [] ["using", expr hx] } } }
end

theorem same_cycle.nat [Fintype α] (f : perm α) {x y : α} (h : same_cycle f x y) :
  ∃ (i : ℕ)(hi : 0 < i)(hi' : i ≤ (f.cycle_of x).support.card+1), (f ^ i) x = y :=
  by 
    byCases' hx : x ∈ f.support
    ·
      obtain ⟨k, hk, hk'⟩ := same_cycle.nat_of_mem_support f h hx 
      cases k
      ·
        refine' ⟨(f.cycle_of x).support.card, _, self_le_add_right _ _, _⟩
        ·
          refine' zero_lt_one.trans (one_lt_card_support_of_ne_one _)
          simpa using hx
        ·
          simp only [perm.coe_one, id.def, pow_zeroₓ] at hk' 
          subst hk' 
          rw [←order_of_is_cycle (is_cycle_cycle_of _ (mem_support.mp hx)), ←cycle_of_pow_apply_self,
            pow_order_of_eq_one, one_apply]
      ·
        exact
          ⟨k+1,
            by 
              simp ,
            Nat.le_succ_of_leₓ hk.le, hk'⟩
    ·
      refine'
        ⟨1, zero_lt_one,
          by 
            simp ,
          _⟩
      obtain ⟨k, rfl⟩ := h 
      rw [not_mem_support] at hx 
      rw [pow_apply_eq_self_of_apply_eq_self hx, zpow_apply_eq_self_of_apply_eq_self hx]

section Generation

variable[Fintype α][Fintype β]

open Subgroup

theorem closure_is_cycle : closure { σ:perm β | is_cycle σ } = ⊤ :=
  by 
    classical 
    exact top_le_iff.mp (le_transₓ (ge_of_eq closure_is_swap) (closure_mono fun _ => is_swap.is_cycle))

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem closure_cycle_adjacent_swap
{σ : perm α}
(h1 : is_cycle σ)
(h2 : «expr = »(σ.support, «expr⊤»()))
(x : α) : «expr = »(closure ({σ, swap x (σ x)} : set (perm α)), «expr⊤»()) :=
begin
  let [ident H] [] [":=", expr closure ({σ, swap x (σ x)} : set (perm α))],
  have [ident h3] [":", expr «expr ∈ »(σ, H)] [":=", expr subset_closure (set.mem_insert σ _)],
  have [ident h4] [":", expr «expr ∈ »(swap x (σ x), H)] [":=", expr subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _))],
  have [ident step1] [":", expr ∀
   n : exprℕ(), «expr ∈ »(swap («expr ^ »(σ, n) x) («expr ^ »(σ, «expr + »(n, 1)) x), H)] [],
  { intro [ident n],
    induction [expr n] [] ["with", ident n, ident ih] [],
    { exact [expr subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _))] },
    { convert [] [expr H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3)] [],
      rw ["[", expr mul_swap_eq_swap_mul, ",", expr mul_inv_cancel_right, "]"] [],
      refl } },
  have [ident step2] [":", expr ∀ n : exprℕ(), «expr ∈ »(swap x («expr ^ »(σ, n) x), H)] [],
  { intro [ident n],
    induction [expr n] [] ["with", ident n, ident ih] [],
    { convert [] [expr H.one_mem] [],
      exact [expr swap_self x] },
    { by_cases [expr h5, ":", expr «expr = »(x, «expr ^ »(σ, n) x)],
      { rw ["[", expr pow_succ, ",", expr mul_apply, ",", "<-", expr h5, "]"] [],
        exact [expr h4] },
      by_cases [expr h6, ":", expr «expr = »(x, «expr ^ »(σ, «expr + »(n, 1)) x)],
      { rw ["[", "<-", expr h6, ",", expr swap_self, "]"] [],
        exact [expr H.one_mem] },
      rw ["[", expr swap_comm, ",", "<-", expr swap_mul_swap_mul_swap h5 h6, "]"] [],
      exact [expr H.mul_mem (H.mul_mem (step1 n) ih) (step1 n)] } },
  have [ident step3] [":", expr ∀ y : α, «expr ∈ »(swap x y, H)] [],
  { intro [ident y],
    have [ident hx] [":", expr «expr ∈ »(x, («expr⊤»() : finset α))] [":=", expr finset.mem_univ x],
    rw ["[", "<-", expr h2, ",", expr mem_support, "]"] ["at", ident hx],
    have [ident hy] [":", expr «expr ∈ »(y, («expr⊤»() : finset α))] [":=", expr finset.mem_univ y],
    rw ["[", "<-", expr h2, ",", expr mem_support, "]"] ["at", ident hy],
    cases [expr is_cycle.exists_pow_eq h1 hx hy] ["with", ident n, ident hn],
    rw ["<-", expr hn] [],
    exact [expr step2 n] },
  have [ident step4] [":", expr ∀ y z : α, «expr ∈ »(swap y z, H)] [],
  { intros [ident y, ident z],
    by_cases [expr h5, ":", expr «expr = »(z, x)],
    { rw ["[", expr h5, ",", expr swap_comm, "]"] [],
      exact [expr step3 y] },
    by_cases [expr h6, ":", expr «expr = »(z, y)],
    { rw ["[", expr h6, ",", expr swap_self, "]"] [],
      exact [expr H.one_mem] },
    rw ["[", "<-", expr swap_mul_swap_mul_swap h5 h6, ",", expr swap_comm z x, "]"] [],
    exact [expr H.mul_mem (H.mul_mem (step3 y) (step3 z)) (step3 y)] },
  rw ["[", expr eq_top_iff, ",", "<-", expr closure_is_swap, ",", expr closure_le, "]"] [],
  rintros [ident τ, "⟨", ident y, ",", ident z, ",", ident h5, ",", ident h6, "⟩"],
  rw [expr h6] [],
  exact [expr step4 y z]
end

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem closure_cycle_coprime_swap
{n : exprℕ()}
{σ : perm α}
(h0 : nat.coprime n (fintype.card α))
(h1 : is_cycle σ)
(h2 : «expr = »(σ.support, finset.univ))
(x : α) : «expr = »(closure ({σ, swap x («expr ^ »(σ, n) x)} : set (perm α)), «expr⊤»()) :=
begin
  rw ["[", "<-", expr finset.card_univ, ",", "<-", expr h2, ",", "<-", expr order_of_is_cycle h1, "]"] ["at", ident h0],
  cases [expr exists_pow_eq_self_of_coprime h0] ["with", ident m, ident hm],
  have [ident h2'] [":", expr «expr = »(«expr ^ »(σ, n).support, «expr⊤»())] [":=", expr eq.trans (support_pow_coprime h0) h2],
  have [ident h1'] [":", expr is_cycle «expr ^ »(«expr ^ »(σ, n), (m : exprℤ()))] [":=", expr by rwa ["<-", expr hm] ["at", ident h1]],
  replace [ident h1'] [":", expr is_cycle «expr ^ »(σ, n)] [":=", expr is_cycle_of_is_cycle_pow h1' (le_trans (support_pow_le σ n) (ge_of_eq (congr_arg support hm)))],
  rw ["[", expr eq_top_iff, ",", "<-", expr closure_cycle_adjacent_swap h1' h2' x, ",", expr closure_le, ",", expr set.insert_subset, "]"] [],
  exact [expr ⟨subgroup.pow_mem (closure _) (subset_closure (set.mem_insert σ _)) n, set.singleton_subset_iff.mpr (subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _)))⟩]
end

theorem closure_prime_cycle_swap {σ τ : perm α} (h0 : (Fintype.card α).Prime) (h1 : is_cycle σ)
  (h2 : σ.support = Finset.univ) (h3 : is_swap τ) : closure ({σ, τ} : Set (perm α)) = ⊤ :=
  by 
    obtain ⟨x, y, h4, h5⟩ := h3 
    obtain ⟨i, hi⟩ :=
      h1.exists_pow_eq (mem_support.mp ((finset.ext_iff.mp h2 x).mpr (Finset.mem_univ x)))
        (mem_support.mp ((finset.ext_iff.mp h2 y).mpr (Finset.mem_univ y)))
    rw [h5, ←hi]
    refine' closure_cycle_coprime_swap (Nat.Coprime.symm (h0.coprime_iff_not_dvd.mpr fun h => h4 _)) h1 h2 x 
    cases' h with m hm 
    rwa [hm, pow_mulₓ, ←Finset.card_univ, ←h2, ←order_of_is_cycle h1, pow_order_of_eq_one, one_pow, one_apply] at hi

end Generation

section 

variable[Fintype α]{σ τ : perm α}

noncomputable theory

theorem is_conj_of_support_equiv (f : { x // x ∈ (σ.support : Set α) } ≃ { x // x ∈ (τ.support : Set α) })
  (hf : ∀ (x : α) (hx : x ∈ (σ.support : Set α)), (f ⟨σ x, apply_mem_support.2 hx⟩ : α) = τ («expr↑ » (f ⟨x, hx⟩))) :
  IsConj σ τ :=
  by 
    refine' is_conj_iff.2 ⟨Equiv.extendSubtype f, _⟩
    rw [mul_inv_eq_iff_eq_mul]
    ext 
    simp only [perm.mul_apply]
    byCases' hx : x ∈ σ.support
    ·
      rw [Equiv.extend_subtype_apply_of_mem, Equiv.extend_subtype_apply_of_mem]
      ·
        exact hf x (Finset.mem_coe.2 hx)
    ·
      rwa [not_not.1 ((not_congr mem_support).1 (Equiv.extend_subtype_not_mem f _ _)),
        not_not.1 ((not_congr mem_support).mp hx)]

theorem is_cycle.is_conj (hσ : is_cycle σ) (hτ : is_cycle τ) (h : σ.support.card = τ.support.card) : IsConj σ τ :=
  by 
    refine'
      is_conj_of_support_equiv
        (hσ.zpowers_equiv_support.symm.trans
          ((zpowersEquivZpowers
                (by 
                  rw [order_of_is_cycle hσ, h, order_of_is_cycle hτ])).trans
            hτ.zpowers_equiv_support))
        _ 
    intro x hx 
    simp only [perm.mul_apply, Equiv.trans_apply, Equiv.sum_congr_apply]
    obtain ⟨n, rfl⟩ := hσ.exists_pow_eq (Classical.some_spec hσ).1 (mem_support.1 hx)
    apply Eq.trans _ (congr rfl (congr rfl (congr rfl (congr rfl (hσ.zpowers_equiv_support_symm_apply n).symm))))
    apply (congr rfl (congr rfl (congr rfl (hσ.zpowers_equiv_support_symm_apply (n+1))))).trans _ 
    simp only [Ne.def, is_cycle.zpowers_equiv_support_apply, Subtype.coe_mk, zpowers_equiv_zpowers_apply]
    rw [pow_succₓ, perm.mul_apply]

theorem is_cycle.is_conj_iff (hσ : is_cycle σ) (hτ : is_cycle τ) : IsConj σ τ ↔ σ.support.card = τ.support.card :=
  ⟨by 
      intro h 
      obtain ⟨π, rfl⟩ := is_conj_iff.1 h 
      apply Finset.card_congr (fun a ha => π a) (fun _ ha => _) (fun _ _ _ _ ab => π.injective ab) fun b hb => _
      ·
        simp [mem_support.1 ha]
      ·
        refine' ⟨(π⁻¹) b, ⟨_, π.apply_inv_self b⟩⟩
        contrapose! hb 
        rw [mem_support, not_not] at hb 
        rw [mem_support, not_not, perm.mul_apply, perm.mul_apply, hb, perm.apply_inv_self],
    hσ.is_conj hτ⟩

@[simp]
theorem support_conj : ((σ*τ)*σ⁻¹).support = τ.support.map σ.to_embedding :=
  by 
    ext 
    simp only [mem_map_equiv, perm.coe_mul, comp_app, Ne.def, perm.mem_support, Equiv.eq_symm_apply]
    rfl

theorem card_support_conj : ((σ*τ)*σ⁻¹).support.card = τ.support.card :=
  by 
    simp 

end 

-- error in GroupTheory.Perm.Cycles: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem disjoint.is_conj_mul
{α : Type*}
[fintype α]
{σ τ π ρ : perm α}
(hc1 : is_conj σ π)
(hc2 : is_conj τ ρ)
(hd1 : disjoint σ τ)
(hd2 : disjoint π ρ) : is_conj «expr * »(σ, τ) «expr * »(π, ρ) :=
begin
  classical,
  obtain ["⟨", ident f, ",", ident rfl, "⟩", ":=", expr is_conj_iff.1 hc1],
  obtain ["⟨", ident g, ",", ident rfl, "⟩", ":=", expr is_conj_iff.1 hc2],
  have [ident hd1'] [] [":=", expr coe_inj.2 hd1.support_mul],
  have [ident hd2'] [] [":=", expr coe_inj.2 hd2.support_mul],
  rw ["[", expr coe_union, "]"] ["at", "*"],
  have [ident hd1''] [] [":=", expr disjoint_iff_disjoint_coe.1 (disjoint_iff_disjoint_support.1 hd1)],
  have [ident hd2''] [] [":=", expr disjoint_iff_disjoint_coe.1 (disjoint_iff_disjoint_support.1 hd2)],
  refine [expr is_conj_of_support_equiv _ _],
  { refine [expr ((equiv.set.of_eq hd1').trans (equiv.set.union hd1'')).trans ((equiv.sum_congr (subtype_equiv f (λ
         a, _)) (subtype_equiv g (λ
         a, _))).trans ((equiv.set.of_eq hd2').trans (equiv.set.union hd2'')).symm)]; { simp [] [] ["only"] ["[", expr set.mem_image, ",", expr to_embedding_apply, ",", expr exists_eq_right, ",", expr support_conj, ",", expr coe_map, ",", expr apply_eq_iff_eq, "]"] [] [] } },
  { intros [ident x, ident hx],
    simp [] [] ["only"] ["[", expr trans_apply, ",", expr symm_trans_apply, ",", expr set.of_eq_apply, ",", expr set.of_eq_symm_apply, ",", expr equiv.sum_congr_apply, "]"] [] [],
    rw ["[", expr hd1', ",", expr set.mem_union, "]"] ["at", ident hx],
    cases [expr hx] ["with", ident hxσ, ident hxτ],
    { rw ["[", expr mem_coe, ",", expr mem_support, "]"] ["at", ident hxσ],
      rw ["[", expr set.union_apply_left hd1'' _, ",", expr set.union_apply_left hd1'' _, "]"] [],
      simp [] [] ["only"] ["[", expr subtype_equiv_apply, ",", expr perm.coe_mul, ",", expr sum.map_inl, ",", expr comp_app, ",", expr set.union_symm_apply_left, ",", expr subtype.coe_mk, ",", expr apply_eq_iff_eq, "]"] [] [],
      { have [ident h] [] [":=", expr (hd2 (f x)).resolve_left _],
        { rw ["[", expr mul_apply, ",", expr mul_apply, "]"] ["at", ident h],
          rw ["[", expr h, ",", expr inv_apply_self, ",", expr (hd1 x).resolve_left hxσ, "]"] [] },
        { rwa ["[", expr mul_apply, ",", expr mul_apply, ",", expr inv_apply_self, ",", expr apply_eq_iff_eq, "]"] [] } },
      { rwa ["[", expr subtype.coe_mk, ",", expr subtype.coe_mk, ",", expr mem_coe, ",", expr mem_support, "]"] [] },
      { rwa ["[", expr subtype.coe_mk, ",", expr subtype.coe_mk, ",", expr perm.mul_apply, ",", expr (hd1 x).resolve_left hxσ, ",", expr mem_coe, ",", expr apply_mem_support, ",", expr mem_support, "]"] [] } },
    { rw ["[", expr mem_coe, ",", "<-", expr apply_mem_support, ",", expr mem_support, "]"] ["at", ident hxτ],
      rw ["[", expr set.union_apply_right hd1'' _, ",", expr set.union_apply_right hd1'' _, "]"] [],
      simp [] [] ["only"] ["[", expr subtype_equiv_apply, ",", expr perm.coe_mul, ",", expr sum.map_inr, ",", expr comp_app, ",", expr set.union_symm_apply_right, ",", expr subtype.coe_mk, ",", expr apply_eq_iff_eq, "]"] [] [],
      { have [ident h] [] [":=", expr (hd2 (g (τ x))).resolve_right _],
        { rw ["[", expr mul_apply, ",", expr mul_apply, "]"] ["at", ident h],
          rw ["[", expr inv_apply_self, ",", expr h, ",", expr (hd1 (τ x)).resolve_right hxτ, "]"] [] },
        { rwa ["[", expr mul_apply, ",", expr mul_apply, ",", expr inv_apply_self, ",", expr apply_eq_iff_eq, "]"] [] } },
      { rwa ["[", expr subtype.coe_mk, ",", expr subtype.coe_mk, ",", expr mem_coe, ",", "<-", expr apply_mem_support, ",", expr mem_support, "]"] [] },
      { rwa ["[", expr subtype.coe_mk, ",", expr subtype.coe_mk, ",", expr perm.mul_apply, ",", expr (hd1 (τ x)).resolve_right hxτ, ",", expr mem_coe, ",", expr mem_support, "]"] [] } } }
end

section FixedPoints

/-!
### Fixed points
-/


theorem fixed_point_card_lt_of_ne_one [Fintype α] {σ : perm α} (h : σ ≠ 1) :
  (filter (fun x => σ x = x) univ).card < Fintype.card α - 1 :=
  by 
    rw [lt_tsub_iff_left, ←lt_tsub_iff_right, ←Finset.card_compl, Finset.compl_filter]
    exact one_lt_card_support_of_ne_one h

end FixedPoints

end Equiv.Perm

