/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser

! This file was ported from Lean 3 source module group_theory.perm.fin
! leanprover-community/mathlib commit 19cb3751e5e9b3d97adb51023949c50c13b5fdfd
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.GroupTheory.Perm.Cycle.Type
import Mathbin.GroupTheory.Perm.Option
import Mathbin.Logic.Equiv.Fin
import Mathbin.Logic.Equiv.Fintype

/-!
# Permutations of `fin n`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/


open Equiv

#print Equiv.Perm.decomposeFin /-
/-- Permutations of `fin (n + 1)` are equivalent to fixing a single
`fin (n + 1)` and permuting the remaining with a `perm (fin n)`.
The fixed `fin (n + 1)` is swapped with `0`. -/
def Equiv.Perm.decomposeFin {n : ℕ} : Perm (Fin n.succ) ≃ Fin n.succ × Perm (Fin n) :=
  ((Equiv.permCongr <| finSuccEquiv n).trans Equiv.Perm.decomposeOption).trans
    (Equiv.prodCongr (finSuccEquiv n).symm (Equiv.refl _))
#align equiv.perm.decompose_fin Equiv.Perm.decomposeFin
-/

#print Equiv.Perm.decomposeFin_symm_of_refl /-
@[simp]
theorem Equiv.Perm.decomposeFin_symm_of_refl {n : ℕ} (p : Fin (n + 1)) :
    Equiv.Perm.decomposeFin.symm (p, Equiv.refl _) = swap 0 p := by
  simp [Equiv.Perm.decomposeFin, Equiv.permCongr_def]
#align equiv.perm.decompose_fin_symm_of_refl Equiv.Perm.decomposeFin_symm_of_refl
-/

#print Equiv.Perm.decomposeFin_symm_of_one /-
@[simp]
theorem Equiv.Perm.decomposeFin_symm_of_one {n : ℕ} (p : Fin (n + 1)) :
    Equiv.Perm.decomposeFin.symm (p, 1) = swap 0 p :=
  Equiv.Perm.decomposeFin_symm_of_refl p
#align equiv.perm.decompose_fin_symm_of_one Equiv.Perm.decomposeFin_symm_of_one
-/

#print Equiv.Perm.decomposeFin_symm_apply_zero /-
@[simp]
theorem Equiv.Perm.decomposeFin_symm_apply_zero {n : ℕ} (p : Fin (n + 1)) (e : Perm (Fin n)) :
    Equiv.Perm.decomposeFin.symm (p, e) 0 = p := by simp [Equiv.Perm.decomposeFin]
#align equiv.perm.decompose_fin_symm_apply_zero Equiv.Perm.decomposeFin_symm_apply_zero
-/

#print Equiv.Perm.decomposeFin_symm_apply_succ /-
@[simp]
theorem Equiv.Perm.decomposeFin_symm_apply_succ {n : ℕ} (e : Perm (Fin n)) (p : Fin (n + 1))
    (x : Fin n) : Equiv.Perm.decomposeFin.symm (p, e) x.succ = swap 0 p (e x).succ :=
  by
  refine' Fin.cases _ _ p
  · simp [Equiv.Perm.decomposeFin, EquivFunctor.map]
  · intro i
    by_cases h : i = e x
    · simp [h, Equiv.Perm.decomposeFin, EquivFunctor.map]
    · have h' : some (e x) ≠ some i := fun H => h (Option.some_injective _ H).symm
      have h'' : (e x).succ ≠ i.succ := fun H => h (Fin.succ_injective _ H).symm
      simp [h, h'', Fin.succ_ne_zero, Equiv.Perm.decomposeFin, EquivFunctor.map,
        swap_apply_of_ne_of_ne, swap_apply_of_ne_of_ne (Option.some_ne_none (e x)) h']
#align equiv.perm.decompose_fin_symm_apply_succ Equiv.Perm.decomposeFin_symm_apply_succ
-/

#print Equiv.Perm.decomposeFin_symm_apply_one /-
@[simp]
theorem Equiv.Perm.decomposeFin_symm_apply_one {n : ℕ} (e : Perm (Fin (n + 1))) (p : Fin (n + 2)) :
    Equiv.Perm.decomposeFin.symm (p, e) 1 = swap 0 p (e 0).succ := by
  rw [← Fin.succ_zero_eq_one, Equiv.Perm.decomposeFin_symm_apply_succ e p 0]
#align equiv.perm.decompose_fin_symm_apply_one Equiv.Perm.decomposeFin_symm_apply_one
-/

/- warning: equiv.perm.decompose_fin.symm_sign -> Equiv.Perm.decomposeFin.symm_sign is a dubious translation:
lean 3 declaration is
  forall {n : Nat} (p : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (e : Equiv.Perm.{1} (Fin n)), Eq.{1} (Units.{0} Int Int.monoid) (coeFn.{1, 1} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n)))))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n)))))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{1} (Fin (Nat.succ n))) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n)))))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{0} (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => Fin.decidableEq (Nat.succ n) a b) (Fin.fintype (Nat.succ n))) (coeFn.{1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (fun (_x : Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) => (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) -> (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.hasCoeToFun.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (HMul.hMul.{0, 0, 0} (Units.{0} Int Int.monoid) (Units.{0} Int Int.monoid) (Units.{0} Int Int.monoid) (instHMul.{0} (Units.{0} Int Int.monoid) (MulOneClass.toHasMul.{0} (Units.{0} Int Int.monoid) (Units.mulOneClass.{0} Int Int.monoid))) (ite.{1} (Units.{0} Int Int.monoid) (Eq.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) p (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (Fin.decidableEq (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) p (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (OfNat.ofNat.{0} (Units.{0} Int Int.monoid) 1 (OfNat.mk.{0} (Units.{0} Int Int.monoid) 1 (One.one.{0} (Units.{0} Int Int.monoid) (MulOneClass.toHasOne.{0} (Units.{0} Int Int.monoid) (Units.mulOneClass.{0} Int Int.monoid))))) (Neg.neg.{0} (Units.{0} Int Int.monoid) (Units.hasNeg.{0} Int Int.monoid (NonUnitalNonAssocRing.toHasDistribNeg.{0} Int (NonAssocRing.toNonUnitalNonAssocRing.{0} Int (Ring.toNonAssocRing.{0} Int Int.ring)))) (OfNat.ofNat.{0} (Units.{0} Int Int.monoid) 1 (OfNat.mk.{0} (Units.{0} Int Int.monoid) 1 (One.one.{0} (Units.{0} Int Int.monoid) (MulOneClass.toHasOne.{0} (Units.{0} Int Int.monoid) (Units.mulOneClass.{0} Int Int.monoid))))))) (coeFn.{1, 1} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{1} (Fin n)) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{0} (Fin n) (fun (a : Fin n) (b : Fin n) => Fin.decidableEq n a b) (Fin.fintype n)) e))
but is expected to have type
  forall {n : Nat} (p : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (e : Equiv.Perm.{1} (Fin n)), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n)))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin (Nat.succ n))) (fun (_x : Equiv.Perm.{1} (Fin (Nat.succ n))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n)))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin (Nat.succ n))) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n))))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n)))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin (Nat.succ n))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n)))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{0, 0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n)))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{0} (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => instDecidableEqFin (Nat.succ n) a b) (Fin.fintype (Nat.succ n))) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (_x : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) _x) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) e) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (instHMul.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (MulOneClass.toMul.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt))) (ite.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (Eq.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) p (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (NeZero.succ n)))) (instDecidableEqFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) p (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (NeZero.succ n)))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (InvOneClass.toOne.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (DivInvOneMonoid.toInvOneClass.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (DivisionMonoid.toDivInvOneMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (DivisionCommMonoid.toDivisionMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (CommGroup.toDivisionCommMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (Units.instCommGroupUnitsToMonoid.{0} Int Int.instCommMonoidInt)))))))) (Neg.neg.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (Units.instNegUnits.{0} Int Int.instMonoidInt (NonUnitalNonAssocRing.toHasDistribNeg.{0} Int (NonAssocRing.toNonUnitalNonAssocRing.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt)))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (InvOneClass.toOne.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (DivInvOneMonoid.toInvOneClass.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (DivisionMonoid.toDivInvOneMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (DivisionCommMonoid.toDivisionMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (CommGroup.toDivisionCommMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (Nat.succ n))) => Units.{0} Int Int.instMonoidInt) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (fun (a : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) => Equiv.Perm.{1} (Fin (Nat.succ n))) a) (Equiv.instFunLikeEquiv.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n)) (Prod.mk.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) p e))) (Units.instCommGroupUnitsToMonoid.{0} Int Int.instCommMonoidInt)))))))))) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin n)) (fun (_x : Equiv.Perm.{1} (Fin n)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{0} (Equiv.Perm.{1} (Fin n)) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n)))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{0} (Fin n) (fun (a : Fin n) (b : Fin n) => instDecidableEqFin n a b) (Fin.fintype n)) e))
Case conversion may be inaccurate. Consider using '#align equiv.perm.decompose_fin.symm_sign Equiv.Perm.decomposeFin.symm_signₓ'. -/
@[simp]
theorem Equiv.Perm.decomposeFin.symm_sign {n : ℕ} (p : Fin (n + 1)) (e : Perm (Fin n)) :
    Perm.sign (Equiv.Perm.decomposeFin.symm (p, e)) = ite (p = 0) 1 (-1) * Perm.sign e := by
  refine' Fin.cases _ _ p <;> simp [Equiv.Perm.decomposeFin, Fin.succ_ne_zero]
#align equiv.perm.decompose_fin.symm_sign Equiv.Perm.decomposeFin.symm_sign

/- warning: finset.univ_perm_fin_succ -> Finset.univ_perm_fin_succ is a dubious translation:
lean 3 declaration is
  forall {n : Nat}, Eq.{1} (Finset.{0} (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Finset.univ.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.fintype.{0, 0} (Fin (Nat.succ n)) (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => Fin.decidableEq (Nat.succ n) a b) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => Fin.decidableEq (Nat.succ n) a b) (Fin.fintype (Nat.succ n)) (Fin.fintype (Nat.succ n)))) (Finset.map.{0, 0} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.toEmbedding.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n))) (Finset.univ.{0} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Prod.fintype.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) (Fin.fintype (Nat.succ n)) (Equiv.fintype.{0, 0} (Fin n) (Fin n) (fun (a : Fin n) (b : Fin n) => Fin.decidableEq n a b) (fun (a : Fin n) (b : Fin n) => Fin.decidableEq n a b) (Fin.fintype n) (Fin.fintype n)))))
but is expected to have type
  forall {n : Nat}, Eq.{1} (Finset.{0} (Equiv.Perm.{1} (Fin (Nat.succ n)))) (Finset.univ.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (equivFintype.{0, 0} (Fin (Nat.succ n)) (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => instDecidableEqFin (Nat.succ n) a b) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => instDecidableEqFin (Nat.succ n) a b) (Fin.fintype (Nat.succ n)) (Fin.fintype (Nat.succ n)))) (Finset.map.{0, 0} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.toEmbedding.{1, 1} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.symm.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (Equiv.Perm.decomposeFin n))) (Finset.univ.{0} (Prod.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n))) (instFintypeProd.{0, 0} (Fin (Nat.succ n)) (Equiv.Perm.{1} (Fin n)) (Fin.fintype (Nat.succ n)) (equivFintype.{0, 0} (Fin n) (Fin n) (fun (a : Fin n) (b : Fin n) => instDecidableEqFin n a b) (fun (a : Fin n) (b : Fin n) => instDecidableEqFin n a b) (Fin.fintype n) (Fin.fintype n)))))
Case conversion may be inaccurate. Consider using '#align finset.univ_perm_fin_succ Finset.univ_perm_fin_succₓ'. -/
/-- The set of all permutations of `fin (n + 1)` can be constructed by augmenting the set of
permutations of `fin n` by each element of `fin (n + 1)` in turn. -/
theorem Finset.univ_perm_fin_succ {n : ℕ} :
    @Finset.univ (Perm <| Fin n.succ) _ =
      (Finset.univ : Finset <| Fin n.succ × Perm (Fin n)).map
        Equiv.Perm.decomposeFin.symm.toEmbedding :=
  (Finset.univ_map_equiv_to_embedding _).symm
#align finset.univ_perm_fin_succ Finset.univ_perm_fin_succ

section CycleRange

/-! ### `cycle_range` section

Define the permutations `fin.cycle_range i`, the cycle `(0 1 2 ... i)`.
-/


open Equiv.Perm

#print finRotate_succ_eq_decomposeFin /-
theorem finRotate_succ_eq_decomposeFin {n : ℕ} :
    finRotate n.succ = decomposeFin.symm (1, finRotate n) :=
  by
  ext i
  cases n; · simp
  refine' Fin.cases _ (fun i => _) i
  · simp
  rw [coe_finRotate, decompose_fin_symm_apply_succ, if_congr i.succ_eq_last_succ rfl rfl]
  split_ifs with h
  · simp [h]
  ·
    rw [Fin.val_succ, Function.Injective.map_swap Fin.val_injective, Fin.val_succ, coe_finRotate,
      if_neg h, Fin.val_zero, Fin.val_one,
      swap_apply_of_ne_of_ne (Nat.succ_ne_zero _) (Nat.succ_succ_ne_one _)]
#align fin_rotate_succ finRotate_succ_eq_decomposeFin
-/

/- warning: sign_fin_rotate -> sign_finRotate is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} (Units.{0} Int Int.monoid) (coeFn.{1, 1} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Equiv.Perm.permGroup.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Equiv.Perm.permGroup.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Equiv.Perm.permGroup.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => Fin.decidableEq (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HPow.hPow.{0, 0, 0} (Units.{0} Int Int.monoid) Nat (Units.{0} Int Int.monoid) (instHPow.{0, 0} (Units.{0} Int Int.monoid) Nat (Monoid.Pow.{0} (Units.{0} Int Int.monoid) (DivInvMonoid.toMonoid.{0} (Units.{0} Int Int.monoid) (Group.toDivInvMonoid.{0} (Units.{0} Int Int.monoid) (Units.group.{0} Int Int.monoid))))) (Neg.neg.{0} (Units.{0} Int Int.monoid) (Units.hasNeg.{0} Int Int.monoid (NonUnitalNonAssocRing.toHasDistribNeg.{0} Int (NonAssocRing.toNonUnitalNonAssocRing.{0} Int (Ring.toNonAssocRing.{0} Int Int.ring)))) (OfNat.ofNat.{0} (Units.{0} Int Int.monoid) 1 (OfNat.mk.{0} (Units.{0} Int Int.monoid) 1 (One.one.{0} (Units.{0} Int Int.monoid) (MulOneClass.toHasOne.{0} (Units.{0} Int Int.monoid) (Units.mulOneClass.{0} Int Int.monoid)))))) n)
but is expected to have type
  forall (n : Nat), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Equiv.Perm.permGroup.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (fun (_x : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Equiv.Perm.permGroup.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Equiv.Perm.permGroup.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Equiv.Perm.permGroup.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Equiv.Perm.permGroup.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{0, 0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Equiv.Perm.permGroup.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => instDecidableEqFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) Nat (Monoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivInvMonoid.toMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Group.toDivInvMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Units.instGroupUnits.{0} Int Int.instMonoidInt))))) (Neg.neg.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Units.instNegUnits.{0} Int Int.instMonoidInt (NonUnitalNonAssocRing.toHasDistribNeg.{0} Int (NonAssocRing.toNonUnitalNonAssocRing.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt)))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (InvOneClass.toOne.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivInvOneMonoid.toInvOneClass.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivisionMonoid.toDivInvOneMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (DivisionCommMonoid.toDivisionMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (CommGroup.toDivisionCommMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) => Units.{0} Int Int.instMonoidInt) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Units.instCommGroupUnitsToMonoid.{0} Int Int.instCommMonoidInt))))))))) n)
Case conversion may be inaccurate. Consider using '#align sign_fin_rotate sign_finRotateₓ'. -/
@[simp]
theorem sign_finRotate (n : ℕ) : Perm.sign (finRotate (n + 1)) = (-1) ^ n :=
  by
  induction' n with n ih
  · simp
  · rw [finRotate_succ_eq_decomposeFin]
    simp [ih, pow_succ]
#align sign_fin_rotate sign_finRotate

/- warning: support_fin_rotate -> support_finRotate is a dubious translation:
lean 3 declaration is
  forall {n : Nat}, Eq.{1} (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Equiv.Perm.support.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) => Fin.decidableEq (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))
but is expected to have type
  forall {n : Nat}, Eq.{1} (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (Equiv.Perm.support.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) => instDecidableEqFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (finRotate (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))
Case conversion may be inaccurate. Consider using '#align support_fin_rotate support_finRotateₓ'. -/
@[simp]
theorem support_finRotate {n : ℕ} : support (finRotate (n + 2)) = Finset.univ :=
  by
  ext
  simp
#align support_fin_rotate support_finRotate

/- warning: support_fin_rotate_of_le -> support_finRotate_of_le is a dubious translation:
lean 3 declaration is
  forall {n : Nat}, (LE.le.{0} Nat Nat.hasLe (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) n) -> (Eq.{1} (Finset.{0} (Fin n)) (Equiv.Perm.support.{0} (Fin n) (fun (a : Fin n) (b : Fin n) => Fin.decidableEq n a b) (Fin.fintype n) (finRotate n)) (Finset.univ.{0} (Fin n) (Fin.fintype n)))
but is expected to have type
  forall {n : Nat}, (LE.le.{0} Nat instLENat (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) n) -> (Eq.{1} (Finset.{0} (Fin n)) (Equiv.Perm.support.{0} (Fin n) (fun (a : Fin n) (b : Fin n) => instDecidableEqFin n a b) (Fin.fintype n) (finRotate n)) (Finset.univ.{0} (Fin n) (Fin.fintype n)))
Case conversion may be inaccurate. Consider using '#align support_fin_rotate_of_le support_finRotate_of_leₓ'. -/
theorem support_finRotate_of_le {n : ℕ} (h : 2 ≤ n) : support (finRotate n) = Finset.univ :=
  by
  obtain ⟨m, rfl⟩ := exists_add_of_le h
  rw [add_comm, support_finRotate]
#align support_fin_rotate_of_le support_finRotate_of_le

#print isCycle_finRotate /-
theorem isCycle_finRotate {n : ℕ} : IsCycle (finRotate (n + 2)) :=
  by
  refine' ⟨0, by decide, fun x hx' => ⟨x, _⟩⟩
  clear hx'
  cases' x with x hx
  rw [coe_coe, zpow_ofNat, Fin.ext_iff, Fin.val_mk]
  induction' x with x ih; · rfl
  rw [pow_succ, perm.mul_apply, coe_finRotate_of_ne_last, ih (lt_trans x.lt_succ_self hx)]
  rw [Ne.def, Fin.ext_iff, ih (lt_trans x.lt_succ_self hx), Fin.val_last]
  exact ne_of_lt (Nat.lt_of_succ_lt_succ hx)
#align is_cycle_fin_rotate isCycle_finRotate
-/

#print isCycle_finRotate_of_le /-
theorem isCycle_finRotate_of_le {n : ℕ} (h : 2 ≤ n) : IsCycle (finRotate n) :=
  by
  obtain ⟨m, rfl⟩ := exists_add_of_le h
  rw [add_comm]
  exact isCycle_finRotate
#align is_cycle_fin_rotate_of_le isCycle_finRotate_of_le
-/

#print cycleType_finRotate /-
@[simp]
theorem cycleType_finRotate {n : ℕ} : cycleType (finRotate (n + 2)) = {n + 2} :=
  by
  rw [is_cycle_fin_rotate.cycle_type, support_finRotate, ← Fintype.card, Fintype.card_fin]
  rfl
#align cycle_type_fin_rotate cycleType_finRotate
-/

#print cycleType_finRotate_of_le /-
theorem cycleType_finRotate_of_le {n : ℕ} (h : 2 ≤ n) : cycleType (finRotate n) = {n} :=
  by
  obtain ⟨m, rfl⟩ := exists_add_of_le h
  rw [add_comm, cycleType_finRotate]
#align cycle_type_fin_rotate_of_le cycleType_finRotate_of_le
-/

namespace Fin

#print Fin.cycleRange /-
/-- `fin.cycle_range i` is the cycle `(0 1 2 ... i)` leaving `(i+1 ... (n-1))` unchanged. -/
def cycleRange {n : ℕ} (i : Fin n) : Perm (Fin n) :=
  (finRotate (i + 1)).extendDomain
    (Equiv.ofLeftInverse' (Fin.castLe (Nat.succ_le_of_lt i.is_lt)).toEmbedding coe
      (by
        intro x
        ext
        simp))
#align fin.cycle_range Fin.cycleRange
-/

#print Fin.cycleRange_of_gt /-
theorem cycleRange_of_gt {n : ℕ} {i j : Fin n.succ} (h : i < j) : cycleRange i j = j :=
  by
  rw [cycle_range, of_left_inverse'_eq_of_injective, ←
    Function.Embedding.toEquivRange_eq_ofInjective, ← via_fintype_embedding,
    via_fintype_embedding_apply_not_mem_range]
  simpa
#align fin.cycle_range_of_gt Fin.cycleRange_of_gt
-/

#print Fin.cycleRange_of_le /-
theorem cycleRange_of_le {n : ℕ} {i j : Fin n.succ} (h : j ≤ i) :
    cycleRange i j = if j = i then 0 else j + 1 :=
  by
  cases n
  · simp
  have :
    j =
      (Fin.castLe (Nat.succ_le_of_lt i.is_lt)).toEmbedding
        ⟨j, lt_of_le_of_lt h (Nat.lt_succ_self i)⟩ :=
    by simp
  ext
  rw [this, cycle_range, of_left_inverse'_eq_of_injective, ←
    Function.Embedding.toEquivRange_eq_ofInjective, ← via_fintype_embedding,
    via_fintype_embedding_apply_image, RelEmbedding.coeFn_toEmbedding, coe_cast_le, coe_finRotate]
  simp only [Fin.ext_iff, coe_last, coe_mk, coe_zero, Fin.eta, apply_ite coe, cast_le_mk]
  split_ifs with heq
  · rfl
  · rw [Fin.val_add_one_of_lt]
    exact lt_of_lt_of_le (lt_of_le_of_ne h (mt (congr_arg coe) HEq)) (le_last i)
#align fin.cycle_range_of_le Fin.cycleRange_of_le
-/

#print Fin.coe_cycleRange_of_le /-
theorem coe_cycleRange_of_le {n : ℕ} {i j : Fin n.succ} (h : j ≤ i) :
    (cycleRange i j : ℕ) = if j = i then 0 else j + 1 :=
  by
  rw [cycle_range_of_le h]
  split_ifs with h'
  · rfl
  exact
    coe_add_one_of_lt
      (calc
        (j : ℕ) < i := fin.lt_iff_coe_lt_coe.mp (lt_of_le_of_ne h h')
        _ ≤ n := nat.lt_succ_iff.mp i.2
        )
#align fin.coe_cycle_range_of_le Fin.coe_cycleRange_of_le
-/

#print Fin.cycleRange_of_lt /-
theorem cycleRange_of_lt {n : ℕ} {i j : Fin n.succ} (h : j < i) : cycleRange i j = j + 1 := by
  rw [cycle_range_of_le h.le, if_neg h.ne]
#align fin.cycle_range_of_lt Fin.cycleRange_of_lt
-/

#print Fin.coe_cycleRange_of_lt /-
theorem coe_cycleRange_of_lt {n : ℕ} {i j : Fin n.succ} (h : j < i) :
    (cycleRange i j : ℕ) = j + 1 := by rw [coe_cycle_range_of_le h.le, if_neg h.ne]
#align fin.coe_cycle_range_of_lt Fin.coe_cycleRange_of_lt
-/

#print Fin.cycleRange_of_eq /-
theorem cycleRange_of_eq {n : ℕ} {i j : Fin n.succ} (h : j = i) : cycleRange i j = 0 := by
  rw [cycle_range_of_le h.le, if_pos h]
#align fin.cycle_range_of_eq Fin.cycleRange_of_eq
-/

#print Fin.cycleRange_self /-
@[simp]
theorem cycleRange_self {n : ℕ} (i : Fin n.succ) : cycleRange i i = 0 :=
  cycleRange_of_eq rfl
#align fin.cycle_range_self Fin.cycleRange_self
-/

#print Fin.cycleRange_apply /-
theorem cycleRange_apply {n : ℕ} (i j : Fin n.succ) :
    cycleRange i j = if j < i then j + 1 else if j = i then 0 else j :=
  by
  split_ifs with h₁ h₂
  · exact cycle_range_of_lt h₁
  · exact cycle_range_of_eq h₂
  · exact cycle_range_of_gt (lt_of_le_of_ne (le_of_not_gt h₁) (Ne.symm h₂))
#align fin.cycle_range_apply Fin.cycleRange_apply
-/

/- warning: fin.cycle_range_zero -> Fin.cycleRange_zero is a dubious translation:
lean 3 declaration is
  forall (n : Nat), Eq.{1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Fin.cycleRange (Nat.succ n) (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (OfNat.mk.{0} (Fin (Nat.succ n)) 0 (Zero.zero.{0} (Fin (Nat.succ n)) (Fin.hasZeroOfNeZero (Nat.succ n) (NeZero.succ n)))))) (OfNat.ofNat.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) 1 (OfNat.mk.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) 1 (One.one.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (MulOneClass.toHasOne.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n))))))))))
but is expected to have type
  forall (n : Nat), Eq.{1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Fin.cycleRange (Nat.succ n) (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (OfNat.ofNat.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) 1 (One.toOfNat1.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (InvOneClass.toOne.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivInvOneMonoid.toInvOneClass.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (DivisionMonoid.toDivInvOneMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Group.toDivisionMonoid.{0} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Equiv.Perm.permGroup.{0} (Fin (Nat.succ n)))))))))
Case conversion may be inaccurate. Consider using '#align fin.cycle_range_zero Fin.cycleRange_zeroₓ'. -/
@[simp]
theorem cycleRange_zero (n : ℕ) : cycleRange (0 : Fin n.succ) = 1 :=
  by
  ext j
  refine' Fin.cases _ (fun j => _) j
  · simp
  · rw [cycle_range_of_gt (Fin.succ_pos j), one_apply]
#align fin.cycle_range_zero Fin.cycleRange_zero

#print Fin.cycleRange_last /-
@[simp]
theorem cycleRange_last (n : ℕ) : cycleRange (last n) = finRotate (n + 1) :=
  by
  ext i
  rw [coe_cycle_range_of_le (le_last _), coe_finRotate]
#align fin.cycle_range_last Fin.cycleRange_last
-/

/- warning: fin.cycle_range_zero' -> Fin.cycleRange_zero' is a dubious translation:
lean 3 declaration is
  forall {n : Nat} (h : LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) n), Eq.{1} (Equiv.Perm.{1} (Fin n)) (Fin.cycleRange n (Fin.mk n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) h)) (OfNat.ofNat.{0} (Equiv.Perm.{1} (Fin n)) 1 (OfNat.mk.{0} (Equiv.Perm.{1} (Fin n)) 1 (One.one.{0} (Equiv.Perm.{1} (Fin n)) (MulOneClass.toHasOne.{0} (Equiv.Perm.{1} (Fin n)) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n)))))))))
but is expected to have type
  forall {n : Nat} (h : LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) n), Eq.{1} (Equiv.Perm.{1} (Fin n)) (Fin.cycleRange n (Fin.mk n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) h)) (OfNat.ofNat.{0} (Equiv.Perm.{1} (Fin n)) 1 (One.toOfNat1.{0} (Equiv.Perm.{1} (Fin n)) (InvOneClass.toOne.{0} (Equiv.Perm.{1} (Fin n)) (DivInvOneMonoid.toInvOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivisionMonoid.toDivInvOneMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivisionMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))))))
Case conversion may be inaccurate. Consider using '#align fin.cycle_range_zero' Fin.cycleRange_zero'ₓ'. -/
@[simp]
theorem cycleRange_zero' {n : ℕ} (h : 0 < n) : cycleRange ⟨0, h⟩ = 1 :=
  by
  cases' n with n
  · cases h
  exact cycle_range_zero n
#align fin.cycle_range_zero' Fin.cycleRange_zero'

/- warning: fin.sign_cycle_range -> Fin.sign_cycleRange is a dubious translation:
lean 3 declaration is
  forall {n : Nat} (i : Fin n), Eq.{1} (Units.{0} Int Int.monoid) (coeFn.{1, 1} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{1} (Fin n)) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{0} (Fin n) (fun (a : Fin n) (b : Fin n) => Fin.decidableEq n a b) (Fin.fintype n)) (Fin.cycleRange n i)) (HPow.hPow.{0, 0, 0} (Units.{0} Int Int.monoid) Nat (Units.{0} Int Int.monoid) (instHPow.{0, 0} (Units.{0} Int Int.monoid) Nat (Monoid.Pow.{0} (Units.{0} Int Int.monoid) (DivInvMonoid.toMonoid.{0} (Units.{0} Int Int.monoid) (Group.toDivInvMonoid.{0} (Units.{0} Int Int.monoid) (Units.group.{0} Int Int.monoid))))) (Neg.neg.{0} (Units.{0} Int Int.monoid) (Units.hasNeg.{0} Int Int.monoid (NonUnitalNonAssocRing.toHasDistribNeg.{0} Int (NonAssocRing.toNonUnitalNonAssocRing.{0} Int (Ring.toNonAssocRing.{0} Int Int.ring)))) (OfNat.ofNat.{0} (Units.{0} Int Int.monoid) 1 (OfNat.mk.{0} (Units.{0} Int Int.monoid) 1 (One.one.{0} (Units.{0} Int Int.monoid) (MulOneClass.toHasOne.{0} (Units.{0} Int Int.monoid) (Units.mulOneClass.{0} Int Int.monoid)))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin n) Nat (HasLiftT.mk.{1, 1} (Fin n) Nat (CoeTCₓ.coe.{1, 1} (Fin n) Nat (coeBase.{1, 1} (Fin n) Nat (Fin.coeToNat n)))) i))
but is expected to have type
  forall {n : Nat} (i : Fin n), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (FunLike.coe.{1, 1, 1} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin n)) (fun (_x : Equiv.Perm.{1} (Fin n)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) _x) (MulHomClass.toFunLike.{0, 0, 0} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{0} (Equiv.Perm.{1} (Fin n)) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n)))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{0, 0, 0} (MonoidHom.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{0, 0} (Equiv.Perm.{1} (Fin n)) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{0} (Equiv.Perm.{1} (Fin n)) (DivInvMonoid.toMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Group.toDivInvMonoid.{0} (Equiv.Perm.{1} (Fin n)) (Equiv.Perm.permGroup.{0} (Fin n))))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{0} (Fin n) (fun (a : Fin n) (b : Fin n) => instDecidableEqFin n a b) (Fin.fintype n)) (Fin.cycleRange n i)) (HPow.hPow.{0, 0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (instHPow.{0, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) Nat (Monoid.Pow.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (DivInvMonoid.toMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (Group.toDivInvMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (Units.instGroupUnits.{0} Int Int.instMonoidInt))))) (Neg.neg.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (Units.instNegUnits.{0} Int Int.instMonoidInt (NonUnitalNonAssocRing.toHasDistribNeg.{0} Int (NonAssocRing.toNonUnitalNonAssocRing.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt)))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (InvOneClass.toOne.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (DivInvOneMonoid.toInvOneClass.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (DivisionMonoid.toDivInvOneMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (DivisionCommMonoid.toDivisionMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (CommGroup.toDivisionCommMonoid.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{1} (Fin n)) => Units.{0} Int Int.instMonoidInt) (Fin.cycleRange n i)) (Units.instCommGroupUnitsToMonoid.{0} Int Int.instCommMonoidInt))))))))) (Fin.val n i))
Case conversion may be inaccurate. Consider using '#align fin.sign_cycle_range Fin.sign_cycleRangeₓ'. -/
@[simp]
theorem sign_cycleRange {n : ℕ} (i : Fin n) : Perm.sign (cycleRange i) = (-1) ^ (i : ℕ) := by
  simp [cycle_range]
#align fin.sign_cycle_range Fin.sign_cycleRange

/- warning: fin.succ_above_cycle_range -> Fin.succAbove_cycleRange is a dubious translation:
lean 3 declaration is
  forall {n : Nat} (i : Fin n) (j : Fin n), Eq.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (coeFn.{1, 1} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe n) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.partialOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))) (fun (_x : RelEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin n) (Fin.hasLe n)) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.partialOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))))) => (Fin n) -> (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (RelEmbedding.hasCoeToFun.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin n) (Fin.hasLe n)) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.partialOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))))) (Fin.succAbove n (Fin.succ n i)) (coeFn.{1, 1} (Equiv.Perm.{1} (Fin n)) (fun (_x : Equiv.{1, 1} (Fin n) (Fin n)) => (Fin n) -> (Fin n)) (Equiv.hasCoeToFun.{1, 1} (Fin n) (Fin n)) (Fin.cycleRange n i) j)) (coeFn.{1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (fun (_x : Equiv.{1, 1} (Fin (Nat.succ n)) (Fin (Nat.succ n))) => (Fin (Nat.succ n)) -> (Fin (Nat.succ n))) (Equiv.hasCoeToFun.{1, 1} (Fin (Nat.succ n)) (Fin (Nat.succ n))) (Equiv.swap.{1} (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => Fin.decidableEq (Nat.succ n) a b) (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (OfNat.mk.{0} (Fin (Nat.succ n)) 0 (Zero.zero.{0} (Fin (Nat.succ n)) (Fin.hasZeroOfNeZero (Nat.succ n) (NeZero.succ n))))) (Fin.succ n i)) (Fin.succ n j))
but is expected to have type
  forall {n : Nat} (i : Fin n) (j : Fin n), Eq.{1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin n) => Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (FunLike.coe.{1, 1, 1} (Equiv.Perm.{1} (Fin n)) (Fin n) (fun (a : Fin n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Fin n) => Fin n) a) (Equiv.instFunLikeEquiv.{1, 1} (Fin n) (Fin n)) (Fin.cycleRange n i) j)) (FunLike.coe.{1, 1, 1} (Function.Embedding.{1, 1} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (fun (_x : Fin n) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Fin n) => Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Function.Embedding.{1, 1} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Function.instEmbeddingLikeEmbedding.{1, 1} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (RelEmbedding.toEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Fin n) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Fin n) => LE.le.{0} (Fin n) (instLEFin n) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (Fin.succAbove n (Fin.succ n i))) (FunLike.coe.{1, 1, 1} (Equiv.Perm.{1} (Fin n)) (Fin n) (fun (_x : Fin n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Fin n) => Fin n) _x) (Equiv.instFunLikeEquiv.{1, 1} (Fin n) (Fin n)) (Fin.cycleRange n i) j)) (FunLike.coe.{1, 1, 1} (Equiv.Perm.{1} (Fin (Nat.succ n))) (Fin (Nat.succ n)) (fun (_x : Fin (Nat.succ n)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Fin (Nat.succ n)) => Fin (Nat.succ n)) _x) (Equiv.instFunLikeEquiv.{1, 1} (Fin (Nat.succ n)) (Fin (Nat.succ n))) (Equiv.swap.{1} (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => instDecidableEqFin (Nat.succ n) a b) (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n))) (Fin.succ n i)) (Fin.succ n j))
Case conversion may be inaccurate. Consider using '#align fin.succ_above_cycle_range Fin.succAbove_cycleRangeₓ'. -/
@[simp]
theorem succAbove_cycleRange {n : ℕ} (i j : Fin n) :
    i.succ.succAbove (i.cycleRange j) = swap 0 i.succ j.succ :=
  by
  cases n
  · rcases j with ⟨_, ⟨⟩⟩
  rcases lt_trichotomy j i with (hlt | heq | hgt)
  · have : (j + 1).cast_succ = j.succ := by
      ext
      rw [coe_cast_succ, coe_succ, Fin.val_add_one_of_lt (lt_of_lt_of_le hlt i.le_last)]
    rw [Fin.cycleRange_of_lt hlt, Fin.succAbove_below, this, swap_apply_of_ne_of_ne]
    · apply Fin.succ_ne_zero
    · exact (Fin.succ_injective _).Ne hlt.ne
    · rw [Fin.lt_iff_val_lt_val]
      simpa [this] using hlt
  · rw [HEq, Fin.cycleRange_self, Fin.succAbove_below, swap_apply_right, Fin.castSucc_zero]
    · rw [Fin.castSucc_zero]
      apply Fin.succ_pos
  · rw [Fin.cycleRange_of_gt hgt, Fin.succAbove_above, swap_apply_of_ne_of_ne]
    · apply Fin.succ_ne_zero
    · apply (Fin.succ_injective _).Ne hgt.ne.symm
    · simpa [Fin.le_iff_val_le_val] using hgt
#align fin.succ_above_cycle_range Fin.succAbove_cycleRange

#print Fin.cycleRange_succAbove /-
@[simp]
theorem cycleRange_succAbove {n : ℕ} (i : Fin (n + 1)) (j : Fin n) :
    i.cycleRange (i.succAbove j) = j.succ :=
  by
  cases' lt_or_ge j.cast_succ i with h h
  · rw [Fin.succAbove_below _ _ h, Fin.cycleRange_of_lt h, Fin.coeSucc_eq_succ]
  · rw [Fin.succAbove_above _ _ h, Fin.cycleRange_of_gt (fin.le_cast_succ_iff.mp h)]
#align fin.cycle_range_succ_above Fin.cycleRange_succAbove
-/

#print Fin.cycleRange_symm_zero /-
@[simp]
theorem cycleRange_symm_zero {n : ℕ} (i : Fin (n + 1)) : i.cycleRange.symm 0 = i :=
  i.cycleRange.Injective (by simp)
#align fin.cycle_range_symm_zero Fin.cycleRange_symm_zero
-/

#print Fin.cycleRange_symm_succ /-
@[simp]
theorem cycleRange_symm_succ {n : ℕ} (i : Fin (n + 1)) (j : Fin n) :
    i.cycleRange.symm j.succ = i.succAbove j :=
  i.cycleRange.Injective (by simp)
#align fin.cycle_range_symm_succ Fin.cycleRange_symm_succ
-/

/- warning: fin.is_cycle_cycle_range -> Fin.isCycle_cycleRange is a dubious translation:
lean 3 declaration is
  forall {n : Nat} {i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))}, (Ne.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) -> (Equiv.Perm.IsCycle.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.cycleRange (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) i))
but is expected to have type
  forall {n : Nat} {i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))}, (Ne.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (NeZero.succ n)))) -> (Equiv.Perm.IsCycle.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.cycleRange (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) i))
Case conversion may be inaccurate. Consider using '#align fin.is_cycle_cycle_range Fin.isCycle_cycleRangeₓ'. -/
theorem isCycle_cycleRange {n : ℕ} {i : Fin (n + 1)} (h0 : i ≠ 0) : IsCycle (cycleRange i) :=
  by
  cases' i with i hi
  cases i
  · exact (h0 rfl).elim
  exact is_cycle_fin_rotate.extend_domain _
#align fin.is_cycle_cycle_range Fin.isCycle_cycleRange

/- warning: fin.cycle_type_cycle_range -> Fin.cycleType_cycleRange is a dubious translation:
lean 3 declaration is
  forall {n : Nat} {i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))}, (Ne.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) -> (Eq.{1} (Multiset.{0} Nat) (Equiv.Perm.cycleType.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => Fin.decidableEq (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) a b) (Fin.cycleRange (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) i)) (Singleton.singleton.{0, 0} Nat (Multiset.{0} Nat) (Multiset.hasSingleton.{0} Nat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) Nat (HasLiftT.mk.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) Nat (CoeTCₓ.coe.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) Nat (coeBase.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) Nat (Fin.coeToNat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))) i) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {n : Nat} {i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))}, (Ne.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (NeZero.succ n)))) -> (Eq.{1} (Multiset.{0} Nat) (Equiv.Perm.cycleType.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => instDecidableEqFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) a b) (Fin.cycleRange (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) i)) (Singleton.singleton.{0, 0} Nat (Multiset.{0} Nat) (Multiset.instSingletonMultiset.{0} Nat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (Fin.val (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) i) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))
Case conversion may be inaccurate. Consider using '#align fin.cycle_type_cycle_range Fin.cycleType_cycleRangeₓ'. -/
@[simp]
theorem cycleType_cycleRange {n : ℕ} {i : Fin (n + 1)} (h0 : i ≠ 0) :
    cycleType (cycleRange i) = {i + 1} :=
  by
  cases' i with i hi
  cases i
  · exact (h0 rfl).elim
  rw [cycle_range, cycle_type_extend_domain]
  exact cycleType_finRotate
#align fin.cycle_type_cycle_range Fin.cycleType_cycleRange

#print Fin.isThreeCycle_cycleRange_two /-
theorem isThreeCycle_cycleRange_two {n : ℕ} : IsThreeCycle (cycleRange 2 : Perm (Fin (n + 3))) := by
  rw [is_three_cycle, cycle_type_cycle_range] <;> decide
#align fin.is_three_cycle_cycle_range_two Fin.isThreeCycle_cycleRange_two
-/

end Fin

end CycleRange

